Index: libitm/configure
===================================================================
diff --git a/libitm/configure b/libitm/configure
--- a/libitm/configure	(revision 262353)
+++ b/libitm/configure	(revision 262353)
@@ -17647,7 +17647,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
Index: libitm/ChangeLog
===================================================================
diff --git a/libitm/ChangeLog b/libitm/ChangeLog
--- a/libitm/ChangeLog	(revision 262353)
+++ b/libitm/ChangeLog	(revision 262353)
@@ -1,3 +1,11 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
Index: libgomp/ChangeLog
===================================================================
diff --git a/libgomp/ChangeLog b/libgomp/ChangeLog
--- a/libgomp/ChangeLog	(revision 262353)
+++ b/libgomp/ChangeLog	(revision 262353)
@@ -1,3 +1,49 @@
+2018-06-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/86291
+	* testsuite/libgomp.c++/pr86291.C: New test.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
+2018-05-01  Tom de Vries  <tom@codesourcery.com>
+
+	backport from trunk:
+	2018-04-16  Cesar Philippidis  <cesar@codesourcery.com>
+		    Tom de Vries  <tom@codesourcery.com>
+
+	PR middle-end/84955
+	* testsuite/libgomp.oacc-c-c++-common/pr84955.c: New test.
+	* testsuite/libgomp.oacc-fortran/pr84955.f90: New test.
+
+2018-03-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-02-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/84418
+	* libgomp.fortran/pr84418-1.f90: New test.
+	* libgomp.fortran/pr84418-2.f90: New test.
+
+	2018-01-29  Christoph Spiel  <cspiel@freenet.de>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR libgomp/84096
+	* omp.h.in (omp_init_nest_lock_with_hint): Use omp_nest_lock_t
+	instead of omp_lock_t.
+
+2018-02-09  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2018-02-08  Martin Jambor  <mjambor@suse.cz>
+
+	* testsuite/libgomp.hsa.c/staticvar.c: New test.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
Index: libgomp/testsuite/libgomp.c++/pr86291.C
===================================================================
diff --git a/libgomp/testsuite/libgomp.c++/pr86291.C b/libgomp/testsuite/libgomp.c++/pr86291.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libgomp/testsuite/libgomp.c++/pr86291.C	(revision 262353)
@@ -0,0 +1,51 @@
+// PR c++/86291
+// { dg-do run }
+// { dg-additional-options "-std=c++11" }
+
+extern "C" void abort ();
+
+struct I
+{
+  using size_type = __SIZE_TYPE__;
+  using difference_type = __PTRDIFF_TYPE__;
+  using value_type = int;
+  using reference = int &;
+  using pointer = int *;
+  static I begin () { return I{}; }
+  static I end () { I res; res.pos = res.num; return res; }
+  I &operator++ () { ++pos; return *this; }
+  reference operator* () const { return val; }
+  I &operator+= (size_type diff) { pos += diff; return *this; }
+  friend bool operator< (const I &a, const I &b) { return a.pos < b.pos; }
+  friend difference_type operator- (const I &a, const I &b) { return a.pos - b.pos; }
+  size_type pos = 0;
+  size_type num = 1;
+  mutable int val = 0;
+};
+
+int c;
+
+int
+main ()
+{
+#pragma omp parallel for collapse(10)
+  for (auto i = I::begin (); i < I::end (); ++i)
+    for (auto j = I::begin (); j < I::end (); ++j)
+      for (auto k = I::begin (); k < I::end (); ++k)
+	for (auto l = I::begin (); l < I::end (); ++l)
+	  for (auto m = I::begin (); m < I::end (); ++m)
+	    for (auto n = I::begin (); n < I::end (); ++n)
+	      for (auto o = I::begin (); o < I::end (); ++o)
+		for (auto p = I::begin (); p < I::end (); ++p)
+		  for (auto q = I::begin (); q < I::end (); ++q)
+		    for (auto r = I::begin (); r < I::end (); ++r)
+		      {
+			if (*i != 0 || *j != 0 || *k != 0 || *l != 0 || *m != 0
+			    || *n != 0 || *o != 0 || *p != 0 || *q != 0 || *r != 0)
+			  abort ();
+			#pragma omp atomic
+			  c++;
+		      }
+  if (c != 1)
+    abort ();
+}
Index: libgomp/testsuite/libgomp.fortran/pr84418-2.f90
===================================================================
diff --git a/libgomp/testsuite/libgomp.fortran/pr84418-2.f90 b/libgomp/testsuite/libgomp.fortran/pr84418-2.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libgomp/testsuite/libgomp.fortran/pr84418-2.f90	(revision 262353)
@@ -0,0 +1,35 @@
+! PR fortran/84418
+! { dg-do run { target vect_simd_clones } }
+! { dg-options "-fno-inline" }
+! { dg-additional-options "-msse2" { target sse2_runtime } }
+! { dg-additional-options "-mavx" { target avx_runtime } }
+
+  type p
+    integer :: i, j
+  end type
+  type(p) :: a(1024)
+  integer :: b(4,1024), c(1024)
+  integer :: i
+  do i = 1, 1024
+    a(i)%i = 2 * i
+    a(i)%j = 3 * i
+    b(1,i) = 4 * i
+    b(2,i) = 5 * i
+    b(3,i) = 6 * i
+    b(4,i) = 7 * i
+  end do
+  !$omp simd
+  do i = 1, 1024
+    c(i) = foo (a(i), b(:,i))
+  end do
+  do i = 1, 1024
+    if (c(i).ne.(6 * i)) call abort
+  end do
+contains  
+  function foo (x, y)
+    type (p) :: x
+    integer :: y(4), foo
+    !$omp declare simd linear (ref (x, y))
+    foo = x%i + y(1)
+  end function
+end
Index: libgomp/testsuite/libgomp.fortran/pr84418-1.f90
===================================================================
diff --git a/libgomp/testsuite/libgomp.fortran/pr84418-1.f90 b/libgomp/testsuite/libgomp.fortran/pr84418-1.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libgomp/testsuite/libgomp.fortran/pr84418-1.f90	(revision 262353)
@@ -0,0 +1,26 @@
+! PR fortran/84418
+! { dg-do run { target vect_simd_clones } }
+! { dg-options "-fno-inline" }
+! { dg-additional-options "-msse2" { target sse2_runtime } }
+! { dg-additional-options "-mavx" { target avx_runtime } }
+
+  real :: a(1024), b(1024), c(1024)
+  integer :: i
+  do i = 1, 1024
+    a(i) = 0.5 * i
+    b(i) = 1.5 * i
+  end do
+  !$omp simd
+  do i = 1, 1024
+    c(i) = foo (a(i), b(i))
+  end do
+  do i = 1, 1024
+    if (c(i).ne.(2 * i)) call abort
+  end do
+contains
+  real function foo (x, y)
+    real :: x, y
+    !$omp declare simd linear (ref (x, y))
+    foo = x + y
+  end function
+end
Index: libgomp/testsuite/libgomp.hsa.c/staticvar.c
===================================================================
diff --git a/libgomp/testsuite/libgomp.hsa.c/staticvar.c b/libgomp/testsuite/libgomp.hsa.c/staticvar.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libgomp/testsuite/libgomp.hsa.c/staticvar.c	(revision 262353)
@@ -0,0 +1,23 @@
+extern void abort (void);
+
+#pragma omp declare target
+int
+foo (void)
+{
+  static int s;
+  return ++s;
+}
+#pragma omp end declare target
+
+int
+main ()
+{
+  int r;
+  #pragma omp target map(from:r)
+  {
+    r = foo ();
+  }
+  if (r != 1)
+    abort ();
+  return 0;
+}
Index: libgomp/testsuite/libgomp.oacc-fortran/pr84955.f90
===================================================================
diff --git a/libgomp/testsuite/libgomp.oacc-fortran/pr84955.f90 b/libgomp/testsuite/libgomp.oacc-fortran/pr84955.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libgomp/testsuite/libgomp.oacc-fortran/pr84955.f90	(revision 262353)
@@ -0,0 +1,13 @@
+! { dg-do compile }
+
+subroutine s
+   integer :: i, j
+   !$acc parallel loop tile(2,3)
+   do i = 1, 10
+      do j = 1, 10
+         do
+         end do
+      end do
+   end do
+  !$acc end parallel loop
+end subroutine s
Index: libgomp/testsuite/libgomp.oacc-c-c++-common/pr84955.c
===================================================================
diff --git a/libgomp/testsuite/libgomp.oacc-c-c++-common/pr84955.c b/libgomp/testsuite/libgomp.oacc-c-c++-common/pr84955.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libgomp/testsuite/libgomp.oacc-c-c++-common/pr84955.c	(revision 262353)
@@ -0,0 +1,15 @@
+/* { dg-do compile }  */
+
+int
+main (void)
+{
+  int i, j;
+
+#pragma acc parallel loop tile(2,3)
+  for (i = 1; i < 10; i++)
+    for (j = 1; j < 10; j++)
+      for (;;)
+	;
+
+  return i + j;
+}
Index: libgomp/configure
===================================================================
diff --git a/libgomp/configure b/libgomp/configure
--- a/libgomp/configure	(revision 262353)
+++ b/libgomp/configure	(revision 262353)
@@ -16823,7 +16823,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
Index: libgomp/omp.h.in
===================================================================
diff --git a/libgomp/omp.h.in b/libgomp/omp.h.in
--- a/libgomp/omp.h.in	(revision 262353)
+++ b/libgomp/omp.h.in	(revision 262353)
@@ -101,7 +101,7 @@
 extern int omp_test_lock (omp_lock_t *) __GOMP_NOTHROW;
 
 extern void omp_init_nest_lock (omp_nest_lock_t *) __GOMP_NOTHROW;
-extern void omp_init_nest_lock_with_hint (omp_lock_t *, omp_lock_hint_t)
+extern void omp_init_nest_lock_with_hint (omp_nest_lock_t *, omp_lock_hint_t)
   __GOMP_NOTHROW;
 extern void omp_destroy_nest_lock (omp_nest_lock_t *) __GOMP_NOTHROW;
 extern void omp_set_nest_lock (omp_nest_lock_t *) __GOMP_NOTHROW;
Index: liboffloadmic/configure
===================================================================
diff --git a/liboffloadmic/configure b/liboffloadmic/configure
--- a/liboffloadmic/configure	(revision 262353)
+++ b/liboffloadmic/configure	(revision 262353)
@@ -14492,7 +14492,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
Index: liboffloadmic/ChangeLog
===================================================================
diff --git a/liboffloadmic/ChangeLog b/liboffloadmic/ChangeLog
--- a/liboffloadmic/ChangeLog	(revision 262353)
+++ b/liboffloadmic/ChangeLog	(revision 262353)
@@ -1,3 +1,12 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+	* plugin/confugure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
Index: liboffloadmic/plugin/configure
===================================================================
diff --git a/liboffloadmic/plugin/configure b/liboffloadmic/plugin/configure
--- a/liboffloadmic/plugin/configure	(revision 262353)
+++ b/liboffloadmic/plugin/configure	(revision 262353)
@@ -14187,7 +14187,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
Index: libmpx/configure
===================================================================
diff --git a/libmpx/configure b/libmpx/configure
--- a/libmpx/configure	(revision 262353)
+++ b/libmpx/configure	(revision 262353)
@@ -11596,7 +11596,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
Index: libmpx/ChangeLog
===================================================================
diff --git a/libmpx/ChangeLog b/libmpx/ChangeLog
--- a/libmpx/ChangeLog	(revision 262353)
+++ b/libmpx/ChangeLog	(revision 262353)
@@ -1,3 +1,11 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
Index: libquadmath/configure
===================================================================
diff --git a/libquadmath/configure b/libquadmath/configure
--- a/libquadmath/configure	(revision 262353)
+++ b/libquadmath/configure	(revision 262353)
@@ -12929,7 +12929,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
Index: libquadmath/ChangeLog
===================================================================
diff --git a/libquadmath/ChangeLog b/libquadmath/ChangeLog
--- a/libquadmath/ChangeLog	(revision 262353)
+++ b/libquadmath/ChangeLog	(revision 262353)
@@ -1,3 +1,11 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
Index: libcc1/configure
===================================================================
diff --git a/libcc1/configure b/libcc1/configure
--- a/libcc1/configure	(revision 262353)
+++ b/libcc1/configure	(revision 262353)
@@ -14315,7 +14315,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
Index: libcc1/ChangeLog
===================================================================
diff --git a/libcc1/ChangeLog b/libcc1/ChangeLog
--- a/libcc1/ChangeLog	(revision 262353)
+++ b/libcc1/ChangeLog	(revision 262353)
@@ -1,3 +1,11 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
Index: libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc
===================================================================
diff --git a/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc b/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc
--- a/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc	(revision 262353)
+++ b/libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc	(revision 262353)
@@ -154,7 +154,6 @@
 # include <sys/procfs.h>
 #endif
 #include <sys/user.h>
-#include <sys/ustat.h>
 #include <linux/cyclades.h>
 #include <linux/if_eql.h>
 #include <linux/if_plip.h>
@@ -247,7 +246,19 @@
 #endif // SANITIZER_LINUX || SANITIZER_FREEBSD
 
 #if SANITIZER_LINUX && !SANITIZER_ANDROID
-  unsigned struct_ustat_sz = sizeof(struct ustat);
+  // Use pre-computed size of struct ustat to avoid <sys/ustat.h> which
+  // has been removed from glibc 2.28.
+#if defined(__aarch64__) || defined(__s390x__) || defined (__mips64) \
+  || defined(__powerpc64__) || defined(__arch64__) || defined(__sparcv9) \
+  || defined(__x86_64__)
+#define SIZEOF_STRUCT_USTAT 32
+#elif defined(__arm__) || defined(__i386__) || defined(__mips__) \
+  || defined(__powerpc__) || defined(__s390__) || defined(__sparc__)
+#define SIZEOF_STRUCT_USTAT 20
+#else
+#error Unknown size of struct ustat
+#endif
+  unsigned struct_ustat_sz = SIZEOF_STRUCT_USTAT;
   unsigned struct_rlimit64_sz = sizeof(struct rlimit64);
   unsigned struct_statvfs64_sz = sizeof(struct statvfs64);
 #endif // SANITIZER_LINUX && !SANITIZER_ANDROID
Index: libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc
===================================================================
diff --git a/libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc b/libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc
--- a/libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc	(revision 262353)
+++ b/libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc	(revision 262353)
@@ -153,28 +153,43 @@
 #endif
 }
 
+#ifndef __GLIBC_PREREQ
+#define __GLIBC_PREREQ(x, y) 0
+#endif
+
 #if !SANITIZER_FREEBSD && !SANITIZER_ANDROID && !SANITIZER_GO
 static uptr g_tls_size;
 
-#ifdef __i386__
-# define DL_INTERNAL_FUNCTION __attribute__((regparm(3), stdcall))
-#else
-# define DL_INTERNAL_FUNCTION
-#endif
-
 void InitTlsSize() {
 // all current supported platforms have 16 bytes stack alignment
   const size_t kStackAlign = 16;
-  typedef void (*get_tls_func)(size_t*, size_t*) DL_INTERNAL_FUNCTION;
-  get_tls_func get_tls;
-  void *get_tls_static_info_ptr = dlsym(RTLD_NEXT, "_dl_get_tls_static_info");
-  CHECK_EQ(sizeof(get_tls), sizeof(get_tls_static_info_ptr));
-  internal_memcpy(&get_tls, &get_tls_static_info_ptr,
-                  sizeof(get_tls_static_info_ptr));
-  CHECK_NE(get_tls, 0);
   size_t tls_size = 0;
   size_t tls_align = 0;
-  get_tls(&tls_size, &tls_align);
+  void *get_tls_static_info_ptr = dlsym(RTLD_NEXT, "_dl_get_tls_static_info");
+#if defined(__i386__) && !__GLIBC_PREREQ(2, 27)
+  /* On i?86, _dl_get_tls_static_info used to be internal_function, i.e.
+     __attribute__((regparm(3), stdcall)) before glibc 2.27 and is normal
+     function in 2.27 and later.  */
+  if (!dlvsym(RTLD_NEXT, "glob", "GLIBC_2.27")) {
+    typedef void (*get_tls_func)(size_t*, size_t*)
+      __attribute__((regparm(3), stdcall));
+    get_tls_func get_tls;
+    CHECK_EQ(sizeof(get_tls), sizeof(get_tls_static_info_ptr));
+    internal_memcpy(&get_tls, &get_tls_static_info_ptr,
+                    sizeof(get_tls_static_info_ptr));
+    CHECK_NE(get_tls, 0);
+    get_tls(&tls_size, &tls_align);
+  } else
+#endif
+  {
+    typedef void (*get_tls_func)(size_t*, size_t*);
+    get_tls_func get_tls;
+    CHECK_EQ(sizeof(get_tls), sizeof(get_tls_static_info_ptr));
+    internal_memcpy(&get_tls, &get_tls_static_info_ptr,
+                    sizeof(get_tls_static_info_ptr));
+    CHECK_NE(get_tls, 0);
+    get_tls(&tls_size, &tls_align);
+  }
   if (tls_align < kStackAlign)
     tls_align = kStackAlign;
   g_tls_size = RoundUpTo(tls_size, tls_align);
Index: libsanitizer/configure
===================================================================
diff --git a/libsanitizer/configure b/libsanitizer/configure
--- a/libsanitizer/configure	(revision 262353)
+++ b/libsanitizer/configure	(revision 262353)
@@ -16511,7 +16511,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
Index: libsanitizer/asan/asan_allocator.h
===================================================================
diff --git a/libsanitizer/asan/asan_allocator.h b/libsanitizer/asan/asan_allocator.h
--- a/libsanitizer/asan/asan_allocator.h	(revision 262353)
+++ b/libsanitizer/asan/asan_allocator.h	(revision 262353)
@@ -115,7 +115,7 @@
 
 #if SANITIZER_CAN_USE_ALLOCATOR64
 # if defined(__powerpc64__)
-const uptr kAllocatorSpace =  0xa0000000000ULL;
+const uptr kAllocatorSpace = ~(uptr)0;
 const uptr kAllocatorSize  =  0x20000000000ULL;  // 2T.
 typedef DefaultSizeClassMap SizeClassMap;
 # elif defined(__aarch64__) && SANITIZER_ANDROID
Index: libsanitizer/ChangeLog
===================================================================
diff --git a/libsanitizer/ChangeLog b/libsanitizer/ChangeLog
--- a/libsanitizer/ChangeLog	(revision 262353)
+++ b/libsanitizer/ChangeLog	(revision 262353)
@@ -1,3 +1,48 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
+2018-06-07  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-03-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/84761
+	* sanitizer_common/sanitizer_linux_libcdep.cc (__GLIBC_PREREQ):
+	Define if not defined.
+	(DL_INTERNAL_FUNCTION): Don't define.
+	(InitTlsSize): For __i386__ if not compiled against glibc 2.27+
+	determine at runtime whether to use regparm(3), stdcall calling
+	convention for older glibcs or normal calling convention for
+	newer glibcs for call to _dl_get_tls_static_info.
+
+2018-05-31  Matthias Klose  <doko@ubuntu.com>
+
+	PR sanitizer/86012
+	* sanitizer_common/sanitizer_platform_limits_posix.cc: Define
+	SIZEOF_STRUCT_USTAT for 32bit sparc.
+
+2018-05-24  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR sanitizer/85835
+	* sanitizer_common/sanitizer_platform_limits_posix.cc: Don't
+	include <sys/ustat.h> for Linux.
+	(SIZEOF_STRUCT_USTAT): New.
+	(struct_ustat_sz): Use SIZEOF_STRUCT_USTAT for Linux.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-04-18  Bill Seurer  <seurer@linux.vnet.ibm.com>
+
+	PR sanitizer/85389
+	* asan/asan_allocator.h (kAllocatorSpace): For __powerpc64__ change
+	from 0xa0000000000ULL to ~(uptr)0.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
Index: libstdc++-v3/configure
===================================================================
diff --git a/libstdc++-v3/configure b/libstdc++-v3/configure
--- a/libstdc++-v3/configure	(revision 262353)
+++ b/libstdc++-v3/configure	(revision 262353)
@@ -620,6 +620,8 @@
 ATOMIC_FLAGS
 ATOMIC_WORD_SRCDIR
 ATOMICITY_SRCDIR
+INCLUDE_DIR_NOTPARALLEL_FALSE
+INCLUDE_DIR_NOTPARALLEL_TRUE
 BUILD_PDF_FALSE
 BUILD_PDF_TRUE
 PDFLATEX
@@ -11601,7 +11603,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11604 "configure"
+#line 11606 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -11707,7 +11709,7 @@
   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
   lt_status=$lt_dlunknown
   cat > conftest.$ac_ext <<_LT_EOF
-#line 11710 "configure"
+#line 11712 "configure"
 #include "confdefs.h"
 
 #if HAVE_DLFCN_H
@@ -15393,7 +15395,7 @@
   # Fake what AC_TRY_COMPILE does.
 
     cat > conftest.$ac_ext << EOF
-#line 15396 "configure"
+#line 15398 "configure"
 int main()
 {
   typedef bool atomic_type;
@@ -15428,7 +15430,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15431 "configure"
+#line 15433 "configure"
 int main()
 {
   typedef short atomic_type;
@@ -15463,7 +15465,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15466 "configure"
+#line 15468 "configure"
 int main()
 {
   // NB: _Atomic_word not necessarily int.
@@ -15499,7 +15501,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15502 "configure"
+#line 15504 "configure"
 int main()
 {
   typedef long long atomic_type;
@@ -15580,7 +15582,7 @@
   # unnecessary for this test.
 
     cat > conftest.$ac_ext << EOF
-#line 15583 "configure"
+#line 15585 "configure"
 int main()
 {
   _Decimal32 d1;
@@ -15622,7 +15624,7 @@
   # unnecessary for this test.
 
     cat > conftest.$ac_ext << EOF
-#line 15625 "configure"
+#line 15627 "configure"
 template<typename T1, typename T2>
   struct same
   { typedef T2 type; };
@@ -15656,7 +15658,7 @@
     rm -f conftest*
 
     cat > conftest.$ac_ext << EOF
-#line 15659 "configure"
+#line 15661 "configure"
 template<typename T1, typename T2>
   struct same
   { typedef T2 type; };
@@ -53327,6 +53329,19 @@
 fi
 done
 
+    for ac_func in aligned_alloc posix_memalign memalign _aligned_malloc
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+eval as_val=\$$as_ac_var
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
     ;;
 
   *-fuchsia*)
@@ -66077,6 +66092,19 @@
 
   CXXFLAGS="$ac_save_CXXFLAGS"
 
+    for ac_func in aligned_alloc posix_memalign memalign _aligned_malloc
+do :
+  as_ac_var=`$as_echo "ac_cv_func_$ac_func" | $as_tr_sh`
+ac_fn_c_check_func "$LINENO" "$ac_func" "$as_ac_var"
+eval as_val=\$$as_ac_var
+   if test "x$as_val" = x""yes; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
     ;;
   *-netbsd*)
     SECTION_FLAGS='-ffunction-sections -fdata-sections'
@@ -81219,7 +81247,19 @@
 fi
 
 
+case "$build" in
+ *-*-darwin* ) glibcxx_include_dir_notparallel=yes ;;
+ * ) glibcxx_include_dir_notparallel=no ;;
+esac
+ if test $glibcxx_include_dir_notparallel = "yes"; then
+  INCLUDE_DIR_NOTPARALLEL_TRUE=
+  INCLUDE_DIR_NOTPARALLEL_FALSE='#'
+else
+  INCLUDE_DIR_NOTPARALLEL_TRUE='#'
+  INCLUDE_DIR_NOTPARALLEL_FALSE=
+fi
 
+
 # Propagate the target-specific source directories through the build chain.
 ATOMICITY_SRCDIR=config/${atomicity_dir}
 ATOMIC_WORD_SRCDIR=config/${atomic_word_dir}
@@ -81657,7 +81697,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
@@ -81913,6 +81953,10 @@
   as_fn_error "conditional \"BUILD_PDF\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+if test -z "${INCLUDE_DIR_NOTPARALLEL_TRUE}" && test -z "${INCLUDE_DIR_NOTPARALLEL_FALSE}"; then
+  as_fn_error "conditional \"INCLUDE_DIR_NOTPARALLEL\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
 
 : ${CONFIG_STATUS=./config.status}
 ac_write_fail=0
Index: libstdc++-v3/src/filesystem/ops.cc
===================================================================
diff --git a/libstdc++-v3/src/filesystem/ops.cc b/libstdc++-v3/src/filesystem/ops.cc
--- a/libstdc++-v3/src/filesystem/ops.cc	(revision 262353)
+++ b/libstdc++-v3/src/filesystem/ops.cc	(revision 262353)
@@ -1391,10 +1391,11 @@
       ec.assign(errno, std::generic_category());
   else
     {
+      uintmax_t fragment_size = f.f_frsize;
       info = space_info{
-	f.f_blocks * f.f_frsize,
-	f.f_bfree * f.f_frsize,
-	f.f_bavail * f.f_frsize
+	f.f_blocks * fragment_size,
+	f.f_bfree * fragment_size,
+	f.f_bavail * fragment_size
       };
       ec.clear();
     }
Index: libstdc++-v3/src/c++98/ios_failure.cc
===================================================================
diff --git a/libstdc++-v3/src/c++98/ios_failure.cc b/libstdc++-v3/src/c++98/ios_failure.cc
--- a/libstdc++-v3/src/c++98/ios_failure.cc	(revision 262353)
+++ b/libstdc++-v3/src/c++98/ios_failure.cc	(revision 262353)
@@ -29,6 +29,18 @@
 #define _GLIBCXX_USE_CXX11_ABI 0
 #include <ios>
 
+#if _GLIBCXX_USE_DUAL_ABI && __cpp_rtti
+#include <cxxabi.h>
+#include <typeinfo>
+#endif
+
+#ifdef _GLIBCXX_USE_NLS
+# include <libintl.h>
+# define _(msgid)   gettext (msgid)
+#else
+# define _(msgid)   (msgid)
+#endif
+
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
@@ -43,5 +55,40 @@
   ios_base::failure::what() const throw()
   { return _M_msg.c_str(); }
 
+#if _GLIBCXX_USE_DUAL_ABI
+  // When the dual ABI is enabled __throw_ios_failure() is defined in
+  // src/c++11/cxx11-ios_failure.cc
+#if __cpp_rtti
+  // If RTTI is enabled the exception type thrown will use these functions to
+  // construct/destroy a gcc4-compatible ios::failure object in a buffer,
+  // and to catch that object via a handler of the gcc4-compatible type.
+  void
+  __construct_ios_failure(void* buf, const char* msg)
+  { ::new(buf) ios_base::failure(msg); }
+
+  void
+  __destroy_ios_failure(void* buf)
+  { static_cast<ios_base::failure*>(buf)->~failure(); }
+
+  bool
+  __is_ios_failure_handler(const __cxxabiv1::__class_type_info* type)
+  { return *type == typeid(ios::failure); }
+
+  namespace {
+  // C++98-style static assertions to ensure ios::failure fits in a buffer
+  // with the same size and alignment as runtime_error:
+  typedef char S[1 / (sizeof(ios::failure) <= sizeof(runtime_error))];
+  typedef char A[1 / (__alignof(ios::failure) <= __alignof(runtime_error))];
+  }
+#endif // __cpp_rtti
+
+#else // ! _GLIBCXX_USE_DUAL_ABI
+
+  void
+  __throw_ios_failure(const char* __s __attribute__((unused)))
+  { _GLIBCXX_THROW_OR_ABORT(ios::failure(_(__s))); }
+
+#endif
+
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
Index: libstdc++-v3/src/c++11/Makefile.in
===================================================================
diff --git a/libstdc++-v3/src/c++11/Makefile.in b/libstdc++-v3/src/c++11/Makefile.in
--- a/libstdc++-v3/src/c++11/Makefile.in	(revision 262353)
+++ b/libstdc++-v3/src/c++11/Makefile.in	(revision 262353)
@@ -433,6 +433,9 @@
 
 libc__11convenience_la_SOURCES = $(sources)  $(inst_sources)
 
+# Rewrite the type info for __ios_failure.
+@ENABLE_DUAL_ABI_TRUE@rewrite_ios_failure_typeinfo = sed -e '/^_*_ZTISt13__ios_failure:/,/_ZTVN10__cxxabiv120__si_class_type_infoE/s/_ZTVN10__cxxabiv120__si_class_type_infoE/_ZTVSt19__iosfail_type_info/'
+
 # AM_CXXFLAGS needs to be in each subdirectory so that it can be
 # modified in a per-library or per-sub-library way.  Need to manually
 # set this option because CONFIG_CXXFLAGS has to be after
@@ -748,6 +751,21 @@
 hashtable_c++0x.o: hashtable_c++0x.cc
 	$(CXXCOMPILE) -fimplicit-templates -c $<
 
+@ENABLE_DUAL_ABI_TRUE@cxx11-ios_failure-lt.s: cxx11-ios_failure.cc
+@ENABLE_DUAL_ABI_TRUE@	$(LTCXXCOMPILE) -S $< -o tmp-cxx11-ios_failure-lt.s
+@ENABLE_DUAL_ABI_TRUE@	-test -f tmp-cxx11-ios_failure-lt.o && mv -f tmp-cxx11-ios_failure-lt.o tmp-cxx11-ios_failure-lt.s
+@ENABLE_DUAL_ABI_TRUE@	$(rewrite_ios_failure_typeinfo) tmp-$@ > $@
+@ENABLE_DUAL_ABI_TRUE@	-rm -f tmp-$@
+@ENABLE_DUAL_ABI_TRUE@cxx11-ios_failure.s: cxx11-ios_failure.cc
+@ENABLE_DUAL_ABI_TRUE@	$(CXXCOMPILE) -S $< -o tmp-$@
+@ENABLE_DUAL_ABI_TRUE@	$(rewrite_ios_failure_typeinfo) tmp-$@ > $@
+@ENABLE_DUAL_ABI_TRUE@	-rm -f tmp-$@
+
+@ENABLE_DUAL_ABI_TRUE@cxx11-ios_failure.lo: cxx11-ios_failure-lt.s
+@ENABLE_DUAL_ABI_TRUE@	$(LTCXXCOMPILE) -g0 -c $< -o $@
+@ENABLE_DUAL_ABI_TRUE@cxx11-ios_failure.o: cxx11-ios_failure.s
+@ENABLE_DUAL_ABI_TRUE@	$(CXXCOMPILE) -g0 -c $<
+
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
 .NOEXPORT:
Index: libstdc++-v3/src/c++11/ios.cc
===================================================================
diff --git a/libstdc++-v3/src/c++11/ios.cc b/libstdc++-v3/src/c++11/ios.cc
--- a/libstdc++-v3/src/c++11/ios.cc	(revision 262353)
+++ b/libstdc++-v3/src/c++11/ios.cc	(revision 262353)
@@ -26,29 +26,13 @@
 // ISO C++ 14882: 27.4  Iostreams base classes
 //
 
-// Determines the version of ios_base::failure thrown by __throw_ios_failure.
-// If !_GLIBCXX_USE_DUAL_ABI this will get undefined automatically.
-#define _GLIBCXX_USE_CXX11_ABI 1
-
 #include <ios>
 #include <limits>
-#include <bits/functexcept.h>
 
-#ifdef _GLIBCXX_USE_NLS
-# include <libintl.h>
-# define _(msgid)   gettext (msgid)
-#else
-# define _(msgid)   (msgid)
-#endif
-
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
-  void
-  __throw_ios_failure(const char* __s __attribute__((unused)))
-  { _GLIBCXX_THROW_OR_ABORT(ios_base::failure(_(__s))); }
-
   // Definitions for static const members of ios_base.
   const ios_base::fmtflags ios_base::boolalpha;
   const ios_base::fmtflags ios_base::dec;
Index: libstdc++-v3/src/c++11/cxx11-ios_failure.cc
===================================================================
diff --git a/libstdc++-v3/src/c++11/cxx11-ios_failure.cc b/libstdc++-v3/src/c++11/cxx11-ios_failure.cc
--- a/libstdc++-v3/src/c++11/cxx11-ios_failure.cc	(revision 262353)
+++ b/libstdc++-v3/src/c++11/cxx11-ios_failure.cc	(revision 262353)
@@ -28,7 +28,16 @@
 
 #define _GLIBCXX_USE_CXX11_ABI 1
 #include <ios>
+#include <bits/functexcept.h>
+#include <cxxabi.h>
 
+#ifdef _GLIBCXX_USE_NLS
+# include <libintl.h>
+# define _(msgid)   gettext (msgid)
+#else
+# define _(msgid)   (msgid)
+#endif
+
 #if ! _GLIBCXX_USE_DUAL_ABI
 # error This file should not be compiled for this configuration.
 #endif
@@ -91,5 +100,66 @@
   ios_base::failure::what() const throw()
   { return runtime_error::what(); }
 
+#if __cpp_rtti
+  // These functions are defined in src/c++98/ios_failure.cc
+  extern void __construct_ios_failure(void*, const char*);
+  extern void __destroy_ios_failure(void*);
+  extern bool __is_ios_failure_handler(const __cxxabiv1::__class_type_info*);
+
+  // The type thrown to report errors during stream buffer operations.
+  // In addition to the ios::failure[abi:cxx11] base class it also has a
+  // member of the gcc4-compatible ios::failure type (in an opaque buffer).
+  struct __ios_failure : std::ios::failure
+  {
+    __ios_failure(const char* s) : failure(s)
+    { __construct_ios_failure(buf, runtime_error::what()); }
+
+    ~__ios_failure()
+    { __destroy_ios_failure(buf); }
+
+    // Use std::runtime_error as a proxy for the gcc4-compatible ios::failure
+    // (which can't be declared here because _GLIBCXX_USE_CXX11_ABI == 1).
+    // There are assertions in src/c++98/ios_failure.cc to ensure the size
+    // and alignment assumptions are valid.
+    alignas(runtime_error) unsigned char buf[sizeof(runtime_error)];
+  };
+
+  // Custom type info for __ios_failure.
+  class __iosfail_type_info : __cxxabiv1::__si_class_type_info
+  {
+    ~__iosfail_type_info();
+
+    bool
+    __do_upcast (const __class_type_info *dst_type,
+		 void **obj_ptr) const override;
+  };
+
+  __iosfail_type_info::~__iosfail_type_info() = default;
+
+  // This function gets called to see if an exception of type
+  // __ios_failure can be upcast to the type in a catch handler.
+  bool
+  __iosfail_type_info::__do_upcast(const __class_type_info *dst_type,
+				   void **obj_ptr) const
+  {
+    // If the handler is for the gcc4-compatible ios::failure type then
+    // catch the object stored in __ios_failure::buf instead of
+    // the __ios_failure exception object itself.
+    if (__is_ios_failure_handler(dst_type))
+      {
+	*obj_ptr = static_cast<__ios_failure*>(*obj_ptr)->buf;
+	return true;
+      }
+    // Otherwise proceed as normal to see if the handler matches.
+    return __class_type_info::__do_upcast(dst_type, obj_ptr);
+  }
+#else // ! __cpp_rtti
+  using __ios_failure = ios::failure;
+#endif
+
+  void
+  __throw_ios_failure(const char* __s __attribute__((unused)))
+  { _GLIBCXX_THROW_OR_ABORT(__ios_failure(_(__s))); }
+
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace
Index: libstdc++-v3/src/c++11/Makefile.am
===================================================================
diff --git a/libstdc++-v3/src/c++11/Makefile.am b/libstdc++-v3/src/c++11/Makefile.am
--- a/libstdc++-v3/src/c++11/Makefile.am	(revision 262353)
+++ b/libstdc++-v3/src/c++11/Makefile.am	(revision 262353)
@@ -126,6 +126,26 @@
 hashtable_c++0x.o: hashtable_c++0x.cc
 	$(CXXCOMPILE) -fimplicit-templates -c $<
 
+if ENABLE_DUAL_ABI
+# Rewrite the type info for __ios_failure.
+rewrite_ios_failure_typeinfo = sed -e '/^_*_ZTISt13__ios_failure:/,/_ZTVN10__cxxabiv120__si_class_type_infoE/s/_ZTVN10__cxxabiv120__si_class_type_infoE/_ZTVSt19__iosfail_type_info/'
+
+cxx11-ios_failure-lt.s: cxx11-ios_failure.cc
+	$(LTCXXCOMPILE) -S $< -o tmp-cxx11-ios_failure-lt.s
+	-test -f tmp-cxx11-ios_failure-lt.o && mv -f tmp-cxx11-ios_failure-lt.o tmp-cxx11-ios_failure-lt.s
+	$(rewrite_ios_failure_typeinfo) tmp-$@ > $@
+	-rm -f tmp-$@
+cxx11-ios_failure.s: cxx11-ios_failure.cc
+	$(CXXCOMPILE) -S $< -o tmp-$@
+	$(rewrite_ios_failure_typeinfo) tmp-$@ > $@
+	-rm -f tmp-$@
+
+cxx11-ios_failure.lo: cxx11-ios_failure-lt.s
+	$(LTCXXCOMPILE) -g0 -c $< -o $@
+cxx11-ios_failure.o: cxx11-ios_failure.s
+	$(CXXCOMPILE) -g0 -c $<
+endif
+
 # AM_CXXFLAGS needs to be in each subdirectory so that it can be
 # modified in a per-library or per-sub-library way.  Need to manually
 # set this option because CONFIG_CXXFLAGS has to be after
Index: libstdc++-v3/configure.ac
===================================================================
diff --git a/libstdc++-v3/configure.ac b/libstdc++-v3/configure.ac
--- a/libstdc++-v3/configure.ac	(revision 262353)
+++ b/libstdc++-v3/configure.ac	(revision 262353)
@@ -467,6 +467,12 @@
 	       test $ac_cv_prog_DBLATEX = "yes" &&
 	       test $ac_cv_prog_PDFLATEX = "yes")
 
+case "$build" in
+ *-*-darwin* ) glibcxx_include_dir_notparallel=yes ;;
+ * ) glibcxx_include_dir_notparallel=no ;;
+esac
+AM_CONDITIONAL(INCLUDE_DIR_NOTPARALLEL,
+               test $glibcxx_include_dir_notparallel = "yes")
 
 # Propagate the target-specific source directories through the build chain.
 ATOMICITY_SRCDIR=config/${atomicity_dir}
Index: libstdc++-v3/doc/xml/faq.xml
===================================================================
diff --git a/libstdc++-v3/doc/xml/faq.xml b/libstdc++-v3/doc/xml/faq.xml
--- a/libstdc++-v3/doc/xml/faq.xml	(revision 262353)
+++ b/libstdc++-v3/doc/xml/faq.xml	(revision 262353)
@@ -734,15 +734,16 @@
     except for some corner cases.  Support for localization
     in <classname>locale</classname> may be incomplete on some non-GNU
     platforms. Also dependent on the underlying platform is support
-    for <type>wchar_t</type> and <type>long
-    long</type> specializations, and details of thread support.
+    for <type>wchar_t</type> and <type>long long</type> specializations,
+    and details of thread support.
     </para>
     <para>    
     Long answer: See the implementation status pages for 
     <link linkend="status.iso.1998">C++98</link>,
-    <link linkend="status.iso.tr1">TR1</link>, and 
-    <link linkend="status.iso.2011">C++11</link>.
-    <link linkend="status.iso.2014">C++14</link>.
+    <link linkend="status.iso.tr1">TR1</link>,
+    <link linkend="status.iso.2011">C++11</link>,
+    <link linkend="status.iso.2014">C++14</link>, and
+    <link linkend="status.iso.2017">C++17</link>.
     </para> 
   </answer>
 </qandaentry>
@@ -875,6 +876,9 @@
     </para>
   </question>
   <answer xml:id="a-ambiguous_overloads">
+    <note>
+      <para>This answer is old and probably no longer be relevant.</para>
+    </note>
     <para>
     Another problem is the <literal>rel_ops</literal> namespace and the template
     comparison operator functions contained therein.  If they become
Index: libstdc++-v3/doc/xml/manual/using.xml
===================================================================
diff --git a/libstdc++-v3/doc/xml/manual/using.xml b/libstdc++-v3/doc/xml/manual/using.xml
--- a/libstdc++-v3/doc/xml/manual/using.xml	(revision 262353)
+++ b/libstdc++-v3/doc/xml/manual/using.xml	(revision 262353)
@@ -1016,7 +1016,7 @@
 </para>
 
 <para> The <symbol>_GLIBCXX_USE_CXX11_ABI</symbol> macro (see
-<xref linkend="manual.intro.using.macros"/>) controls whether
+  <xref linkend="manual.intro.using.macros"/>) controls whether
   the declarations in the library headers use the old or new ABI.
   So the decision of which ABI to use can be made separately for each
   source file being compiled.
@@ -1051,12 +1051,39 @@
 </para>
 
 <para> Although the standard exception types defined in
-  <filename class="headerfile">&lt;stdexcept&gt;</filename> use strings, they
+  <filename class="headerfile">&lt;stdexcept&gt;</filename> use strings, most
   are not defined twice, so that a <classname>std::out_of_range</classname>
   exception thrown in one file can always be caught by a suitable handler in
   another file, even if the two files are compiled with different ABIs.
 </para>
 
+<para> One exception type does change when using the new ABI, namely
+  <classname>std::ios_base::failure</classname>.
+  This is necessary because the 2011 standard changed its base class from
+  <classname>std::exception</classname> to
+  <classname>std::system_error</classname>, which causes its layout to change.
+  Exceptions due to iostream errors are thrown by a function inside
+  <filename class="libraryfile">libstdc++.so</filename>, so whether the thrown
+  exception uses the old <classname>std::ios_base::failure</classname> type
+  or the new one depends on the ABI that was active when
+  <filename class="libraryfile">libstdc++.so</filename> was built,
+  <emphasis>not</emphasis> the ABI active in the user code that is using
+  iostreams.
+  This means that for a given build of GCC the type thrown is fixed.
+  In current releases the library throws a special type that can be caught
+  by handlers for either the old or new type,
+  but for GCC 7.1, 7.2 and 7.3 the library throws the new
+  <classname>std::ios_base::failure</classname> type,
+  and for GCC 5.x and 6.x the library throws the old type.
+  Catch handlers of type <classname>std::ios_base::failure</classname>
+  will only catch the exceptions if using a newer release,
+  or if the handler is compiled with the same ABI as the type thrown by
+  the library.
+  Handlers for <classname>std::exception</classname> will always catch
+  iostreams exceptions, because the old and new type both inherit from
+  <classname>std::exception</classname>.
+</para>
+
 <section xml:id="manual.intro.using.abi.trouble" xreflabel="Dual ABI Troubleshooting"><info><title>Troubleshooting</title></info>
 
 <para> If you get linker errors about undefined references to symbols
Index: libstdc++-v3/doc/xml/manual/debug_mode.xml
===================================================================
diff --git a/libstdc++-v3/doc/xml/manual/debug_mode.xml b/libstdc++-v3/doc/xml/manual/debug_mode.xml
--- a/libstdc++-v3/doc/xml/manual/debug_mode.xml	(revision 262353)
+++ b/libstdc++-v3/doc/xml/manual/debug_mode.xml	(revision 262353)
@@ -285,7 +285,19 @@
   </row>
 </thead>
 <tbody>
-    <row>
+  <row>
+    <entry><classname>std::array</classname></entry>
+    <entry><filename class="headerfile">array</filename></entry>
+    <entry><classname>__gnu_debug::array</classname></entry>
+    <entry><filename class="headerfile">&lt;debug/array&gt;</filename></entry>
+  </row>
+  <row>
+    <entry><classname>std::forward_list</classname></entry>
+    <entry><filename class="headerfile">forward_list</filename></entry>
+    <entry><classname>__gnu_debug::forward_list</classname></entry>
+    <entry><filename class="headerfile">&lt;debug/forward_list&gt;</filename></entry>
+  </row>
+  <row>
     <entry><classname>std::unordered_map</classname></entry>
     <entry><filename class="headerfile">unordered_map</filename></entry>
     <entry><classname>__gnu_debug::unordered_map</classname></entry>
Index: libstdc++-v3/doc/html/faq.html
===================================================================
diff --git a/libstdc++-v3/doc/html/faq.html b/libstdc++-v3/doc/html/faq.html
--- a/libstdc++-v3/doc/html/faq.html	(revision 262353)
+++ b/libstdc++-v3/doc/html/faq.html	(revision 262353)
@@ -534,14 +534,15 @@
     except for some corner cases.  Support for localization
     in <code class="classname">locale</code> may be incomplete on some non-GNU
     platforms. Also dependent on the underlying platform is support
-    for <span class="type">wchar_t</span> and <span class="type">long
-    long</span> specializations, and details of thread support.
+    for <span class="type">wchar_t</span> and <span class="type">long long</span> specializations,
+    and details of thread support.
     </p><p>    
     Long answer: See the implementation status pages for 
     <a class="link" href="manual/status.html#status.iso.1998" title="C++ 1998/2003">C++98</a>,
-    <a class="link" href="manual/status.html#status.iso.tr1" title="C++ TR1">TR1</a>, and 
-    <a class="link" href="manual/status.html#status.iso.2011" title="C++ 2011">C++11</a>.
-    <a class="link" href="manual/status.html#status.iso.2014" title="C++ 2014">C++14</a>.
+    <a class="link" href="manual/status.html#status.iso.tr1" title="C++ TR1">TR1</a>,
+    <a class="link" href="manual/status.html#status.iso.2011" title="C++ 2011">C++11</a>,
+    <a class="link" href="manual/status.html#status.iso.2014" title="C++ 2014">C++14</a>, and
+    <a class="link" href="manual/status.html#status.iso.2017" title="C++ 2017">C++17</a>.
     </p></td></tr><tr class="question"><td align="left" valign="top"><a id="faq.standard_bugs"></a><a id="q-standard_bugs"></a><p><strong>5.2.</strong></p></td><td align="left" valign="top"><p>
       Bugs in the ISO C++ language or library specification
     </p></td></tr><tr class="answer"><td align="left" valign="top"><a id="a-standard_bugs"></a></td><td align="left" valign="top"><p>
@@ -633,7 +634,7 @@
     without other drawbacks, send us a patch.
     </p></td></tr><tr class="question"><td align="left" valign="top"><a id="faq.ambiguous_overloads"></a><a id="q-ambiguous_overloads"></a><p><strong>6.3.</strong></p></td><td align="left" valign="top"><p>
       Ambiguous overloads after including an old-style header
-    </p></td></tr><tr class="answer"><td align="left" valign="top"><a id="a-ambiguous_overloads"></a></td><td align="left" valign="top"><p>
+    </p></td></tr><tr class="answer"><td align="left" valign="top"><a id="a-ambiguous_overloads"></a></td><td align="left" valign="top"><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>This answer is old and probably no longer be relevant.</p></div><p>
     Another problem is the <code class="literal">rel_ops</code> namespace and the template
     comparison operator functions contained therein.  If they become
     visible in the same namespace as other comparison functions
Index: libstdc++-v3/doc/html/manual/debug_mode_using.html
===================================================================
diff --git a/libstdc++-v3/doc/html/manual/debug_mode_using.html b/libstdc++-v3/doc/html/manual/debug_mode_using.html
--- a/libstdc++-v3/doc/html/manual/debug_mode_using.html	(revision 262353)
+++ b/libstdc++-v3/doc/html/manual/debug_mode_using.html	(revision 262353)
@@ -20,4 +20,4 @@
   containers:
 </p><div class="table"><a id="table.debug_mode_containers"></a><p class="title"><strong>Table 17.1. Debugging Containers</strong></p><div class="table-contents"><table class="table" summary="Debugging Containers" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Container</th><th align="left">Header</th><th align="left">Debug container</th><th align="left">Debug header</th></tr></thead><tbody><tr><td align="left"><code class="classname">std::bitset</code></td><td align="left"><code class="filename">bitset</code></td><td align="left"><code class="classname">__gnu_debug::bitset</code></td><td align="left"><code class="filename">&lt;debug/bitset&gt;</code></td></tr><tr><td align="left"><code class="classname">std::deque</code></td><td align="left"><code class="filename">deque</code></td><td align="left"><code class="classname">__gnu_debug::deque</code></td><td align="left"><code class="filename">&lt;debug/deque&gt;</code></td></tr><tr><td align="left"><code class="classname">std::list</code></td><td align="left"><code class="filename">list</code></td><td align="left"><code class="classname">__gnu_debug::list</code></td><td align="left"><code class="filename">&lt;debug/list&gt;</code></td></tr><tr><td align="left"><code class="classname">std::map</code></td><td align="left"><code class="filename">map</code></td><td align="left"><code class="classname">__gnu_debug::map</code></td><td align="left"><code class="filename">&lt;debug/map&gt;</code></td></tr><tr><td align="left"><code class="classname">std::multimap</code></td><td align="left"><code class="filename">map</code></td><td align="left"><code class="classname">__gnu_debug::multimap</code></td><td align="left"><code class="filename">&lt;debug/map&gt;</code></td></tr><tr><td align="left"><code class="classname">std::multiset</code></td><td align="left"><code class="filename">set</code></td><td align="left"><code class="classname">__gnu_debug::multiset</code></td><td align="left"><code class="filename">&lt;debug/set&gt;</code></td></tr><tr><td align="left"><code class="classname">std::set</code></td><td align="left"><code class="filename">set</code></td><td align="left"><code class="classname">__gnu_debug::set</code></td><td align="left"><code class="filename">&lt;debug/set&gt;</code></td></tr><tr><td align="left"><code class="classname">std::string</code></td><td align="left"><code class="filename">string</code></td><td align="left"><code class="classname">__gnu_debug::string</code></td><td align="left"><code class="filename">&lt;debug/string&gt;</code></td></tr><tr><td align="left"><code class="classname">std::wstring</code></td><td align="left"><code class="filename">string</code></td><td align="left"><code class="classname">__gnu_debug::wstring</code></td><td align="left"><code class="filename">&lt;debug/string&gt;</code></td></tr><tr><td align="left"><code class="classname">std::basic_string</code></td><td align="left"><code class="filename">string</code></td><td align="left"><code class="classname">__gnu_debug::basic_string</code></td><td align="left"><code class="filename">&lt;debug/string&gt;</code></td></tr><tr><td align="left"><code class="classname">std::vector</code></td><td align="left"><code class="filename">vector</code></td><td align="left"><code class="classname">__gnu_debug::vector</code></td><td align="left"><code class="filename">&lt;debug/vector&gt;</code></td></tr></tbody></table></div></div><br class="table-break" /><p>In addition, when compiling in C++11 mode, these additional
 containers have additional debug capability.
-</p><div class="table"><a id="table.debug_mode_containers_cxx11"></a><p class="title"><strong>Table 17.2. Debugging Containers C++11</strong></p><div class="table-contents"><table class="table" summary="Debugging Containers C++11" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Container</th><th align="left">Header</th><th align="left">Debug container</th><th align="left">Debug header</th></tr></thead><tbody><tr><td align="left"><code class="classname">std::unordered_map</code></td><td align="left"><code class="filename">unordered_map</code></td><td align="left"><code class="classname">__gnu_debug::unordered_map</code></td><td align="left"><code class="filename">&lt;debug/unordered_map&gt;</code></td></tr><tr><td align="left"><code class="classname">std::unordered_multimap</code></td><td align="left"><code class="filename">unordered_map</code></td><td align="left"><code class="classname">__gnu_debug::unordered_multimap</code></td><td align="left"><code class="filename">&lt;debug/unordered_map&gt;</code></td></tr><tr><td align="left"><code class="classname">std::unordered_set</code></td><td align="left"><code class="filename">unordered_set</code></td><td align="left"><code class="classname">__gnu_debug::unordered_set</code></td><td align="left"><code class="filename">&lt;debug/unordered_set&gt;</code></td></tr><tr><td align="left"><code class="classname">std::unordered_multiset</code></td><td align="left"><code class="filename">unordered_set</code></td><td align="left"><code class="classname">__gnu_debug::unordered_multiset</code></td><td align="left"><code class="filename">&lt;debug/unordered_set&gt;</code></td></tr></tbody></table></div></div><br class="table-break" /></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="debug_mode_semantics.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="debug_mode.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="debug_mode_design.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Semantics </td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"> Design</td></tr></table></div></body></html>
\ No newline at end of file
+</p><div class="table"><a id="table.debug_mode_containers_cxx11"></a><p class="title"><strong>Table 17.2. Debugging Containers C++11</strong></p><div class="table-contents"><table class="table" summary="Debugging Containers C++11" border="1"><colgroup><col align="left" class="c1" /><col align="left" class="c2" /><col align="left" class="c3" /><col align="left" class="c4" /></colgroup><thead><tr><th align="left">Container</th><th align="left">Header</th><th align="left">Debug container</th><th align="left">Debug header</th></tr></thead><tbody><tr><td align="left"><code class="classname">std::array</code></td><td align="left"><code class="filename">array</code></td><td align="left"><code class="classname">__gnu_debug::array</code></td><td align="left"><code class="filename">&lt;debug/array&gt;</code></td></tr><tr><td align="left"><code class="classname">std::forward_list</code></td><td align="left"><code class="filename">forward_list</code></td><td align="left"><code class="classname">__gnu_debug::forward_list</code></td><td align="left"><code class="filename">&lt;debug/forward_list&gt;</code></td></tr><tr><td align="left"><code class="classname">std::unordered_map</code></td><td align="left"><code class="filename">unordered_map</code></td><td align="left"><code class="classname">__gnu_debug::unordered_map</code></td><td align="left"><code class="filename">&lt;debug/unordered_map&gt;</code></td></tr><tr><td align="left"><code class="classname">std::unordered_multimap</code></td><td align="left"><code class="filename">unordered_map</code></td><td align="left"><code class="classname">__gnu_debug::unordered_multimap</code></td><td align="left"><code class="filename">&lt;debug/unordered_map&gt;</code></td></tr><tr><td align="left"><code class="classname">std::unordered_set</code></td><td align="left"><code class="filename">unordered_set</code></td><td align="left"><code class="classname">__gnu_debug::unordered_set</code></td><td align="left"><code class="filename">&lt;debug/unordered_set&gt;</code></td></tr><tr><td align="left"><code class="classname">std::unordered_multiset</code></td><td align="left"><code class="filename">unordered_set</code></td><td align="left"><code class="classname">__gnu_debug::unordered_multiset</code></td><td align="left"><code class="filename">&lt;debug/unordered_set&gt;</code></td></tr></tbody></table></div></div><br class="table-break" /></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="debug_mode_semantics.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="debug_mode.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="debug_mode_design.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Semantics </td><td width="20%" align="center"><a accesskey="h" href="../index.html">Home</a></td><td width="40%" align="right" valign="top"> Design</td></tr></table></div></body></html>
\ No newline at end of file
Index: libstdc++-v3/doc/html/manual/using_dual_abi.html
===================================================================
diff --git a/libstdc++-v3/doc/html/manual/using_dual_abi.html b/libstdc++-v3/doc/html/manual/using_dual_abi.html
--- a/libstdc++-v3/doc/html/manual/using_dual_abi.html	(revision 262353)
+++ b/libstdc++-v3/doc/html/manual/using_dual_abi.html	(revision 262353)
@@ -14,7 +14,7 @@
   for the new implementations have different names the definitions for both
   versions can be present in the same library.
 </p><p> The <span class="symbol">_GLIBCXX_USE_CXX11_ABI</span> macro (see
-<a class="xref" href="using_macros.html" title="Macros">Macros</a>) controls whether
+  <a class="xref" href="using_macros.html" title="Macros">Macros</a>) controls whether
   the declarations in the library headers use the old or new ABI.
   So the decision of which ABI to use can be made separately for each
   source file being compiled.
@@ -43,10 +43,35 @@
   facet that derives from one or other version of
   <code class="classname">time_get</code> is installed in the locale).
 </p><p> Although the standard exception types defined in
-  <code class="filename">&lt;stdexcept&gt;</code> use strings, they
+  <code class="filename">&lt;stdexcept&gt;</code> use strings, most
   are not defined twice, so that a <code class="classname">std::out_of_range</code>
   exception thrown in one file can always be caught by a suitable handler in
   another file, even if the two files are compiled with different ABIs.
+</p><p> One exception type does change when using the new ABI, namely
+  <code class="classname">std::ios_base::failure</code>.
+  This is necessary because the 2011 standard changed its base class from
+  <code class="classname">std::exception</code> to
+  <code class="classname">std::system_error</code>, which causes its layout to change.
+  Exceptions due to iostream errors are thrown by a function inside
+  <code class="filename">libstdc++.so</code>, so whether the thrown
+  exception uses the old <code class="classname">std::ios_base::failure</code> type
+  or the new one depends on the ABI that was active when
+  <code class="filename">libstdc++.so</code> was built,
+  <span class="emphasis"><em>not</em></span> the ABI active in the user code that is using
+  iostreams.
+  This means that for a given build of GCC the type thrown is fixed.
+  In current releases the library throws a special type that can be caught
+  by handlers for either the old or new type,
+  but for GCC 7.1, 7.2 and 7.3 the library throws the new
+  <code class="classname">std::ios_base::failure</code> type,
+  and for GCC 5.x and 6.x the library throws the old type.
+  Catch handlers of type <code class="classname">std::ios_base::failure</code>
+  will only catch the exceptions if using a newer release,
+  or if the handler is compiled with the same ABI as the type thrown by
+  the library.
+  Handlers for <code class="classname">std::exception</code> will always catch
+  iostreams exceptions, because the old and new type both inherit from
+  <code class="classname">std::exception</code>.
 </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="manual.intro.using.abi.trouble"></a>Troubleshooting</h3></div></div></div><p> If you get linker errors about undefined references to symbols
   that involve types in the <code class="code">std::__cxx11</code> namespace or the tag
   <code class="code">[abi:cxx11]</code> then it probably indicates that you are trying to
Index: libstdc++-v3/include/Makefile.in
===================================================================
diff --git a/libstdc++-v3/include/Makefile.in b/libstdc++-v3/include/Makefile.in
--- a/libstdc++-v3/include/Makefile.in	(revision 262353)
+++ b/libstdc++-v3/include/Makefile.in	(revision 262353)
@@ -1897,6 +1897,9 @@
 $(experimental_headers): ; @:
 $(experimental_bits_headers): ; @:
 
+# See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=81797
+@INCLUDE_DIR_NOTPARALLEL_TRUE@.NOTPARALLEL:
+
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
 .NOEXPORT:
Index: libstdc++-v3/include/std/any
===================================================================
diff --git a/libstdc++-v3/include/std/any b/libstdc++-v3/include/std/any
--- a/libstdc++-v3/include/std/any	(revision 262353)
+++ b/libstdc++-v3/include/std/any	(revision 262353)
@@ -70,7 +70,7 @@
 
   /**
    *  @brief A type-safe container of any type.
-   * 
+   *
    *  An @c any object's state is either empty or it stores a contained object
    *  of CopyConstructible type.
    */
@@ -114,8 +114,8 @@
       void __do_emplace(_Args&&... __args)
       {
 	reset();
+        _Mgr::_S_create(_M_storage, std::forward<_Args>(__args)...);
 	_M_manager = &_Mgr::_S_manage;
-        _Mgr::_S_create(_M_storage, std::forward<_Args>(__args)...);
       }
 
     /// Emplace with an object created from @p __il and @p __args as
@@ -125,8 +125,8 @@
       void __do_emplace(initializer_list<_Up> __il, _Args&&... __args)
       {
 	reset();
+        _Mgr::_S_create(_M_storage, __il, std::forward<_Args>(__args)...);
 	_M_manager = &_Mgr::_S_manage;
-        _Mgr::_S_create(_M_storage, __il, std::forward<_Args>(__args)...);
       }
 
   public:
@@ -272,8 +272,7 @@
 				   _Decay<_ValueType>, _Args&&...>::type
       emplace(_Args&&... __args)
       {
-	__do_emplace<_Decay<_ValueType>>
-	  (std::forward<_Args>(__args)...);
+	__do_emplace<_Decay<_ValueType>>(std::forward<_Args>(__args)...);
 	any::_Arg __arg;
 	this->_M_manager(any::_Op_access, this, &__arg);
 	return *static_cast<_Decay<_ValueType>*>(__arg._M_obj);
@@ -288,8 +287,8 @@
 				   _Args&&...>::type
       emplace(initializer_list<_Up> __il, _Args&&... __args)
       {
-	__do_emplace<_Decay<_ValueType>, _Up>
-	  (__il, std::forward<_Args>(__args)...);
+	__do_emplace<_Decay<_ValueType>, _Up>(__il,
+					      std::forward<_Args>(__args)...);
 	any::_Arg __arg;
 	this->_M_manager(any::_Op_access, this, &__arg);
 	return *static_cast<_Decay<_ValueType>*>(__arg._M_obj);
@@ -624,7 +623,7 @@
     }
 
   /// @}
-  
+
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
 
Index: libstdc++-v3/include/std/utility
===================================================================
diff --git a/libstdc++-v3/include/std/utility b/libstdc++-v3/include/std/utility
--- a/libstdc++-v3/include/std/utility	(revision 262353)
+++ b/libstdc++-v3/include/std/utility	(revision 262353)
@@ -75,10 +75,6 @@
 #include <bits/move.h>
 #include <initializer_list>
 
-#if __cplusplus > 201402L
-#include <exception>
-#endif
-
 namespace std _GLIBCXX_VISIBILITY(default)
 {
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
Index: libstdc++-v3/include/std/type_traits
===================================================================
diff --git a/libstdc++-v3/include/std/type_traits b/libstdc++-v3/include/std/type_traits
--- a/libstdc++-v3/include/std/type_traits	(revision 262353)
+++ b/libstdc++-v3/include/std/type_traits	(revision 262353)
@@ -3069,6 +3069,10 @@
       remove_cv_t<remove_all_extents_t<_Tp>>
       )>
     { };
+
+  template<typename _Tp>
+    inline constexpr bool has_unique_object_representations_v
+      = has_unique_object_representations<_Tp>::value;
 #endif
 #undef _GLIBCXX_HAVE_BUILTIN_HAS_UNIQ_OBJ_REP
 
Index: libstdc++-v3/include/std/thread
===================================================================
diff --git a/libstdc++-v3/include/std/thread b/libstdc++-v3/include/std/thread
--- a/libstdc++-v3/include/std/thread	(revision 262353)
+++ b/libstdc++-v3/include/std/thread	(revision 262353)
@@ -243,21 +243,18 @@
 	{ return _M_invoke(_Indices()); }
       };
 
-    // Alias for _Invoker<tuple<DECAY_COPY(_Tp)...>>
     template<typename... _Tp>
-      using __invoker_type
-	= _Invoker<decltype(std::make_tuple(std::declval<_Tp>()...))>;
+      using __decayed_tuple = tuple<typename std::decay<_Tp>::type...>;
 
   public:
-    // Returns a call wrapper that does
-    // INVOKE(DECAY_COPY(__callable), DECAY_COPY(__args)).
+    // Returns a call wrapper that stores
+    // tuple{DECAY_COPY(__callable), DECAY_COPY(__args)...}.
     template<typename _Callable, typename... _Args>
-      static __invoker_type<_Callable, _Args...>
+      static _Invoker<__decayed_tuple<_Callable, _Args...>>
       __make_invoker(_Callable&& __callable, _Args&&... __args)
       {
-	return { {
-	    std::make_tuple(std::forward<_Callable>(__callable),
-			    std::forward<_Args>(__args)...)
+	return { __decayed_tuple<_Callable, _Args...>{
+	    std::forward<_Callable>(__callable), std::forward<_Args>(__args)...
 	} };
       }
   };
Index: libstdc++-v3/include/std/variant
===================================================================
diff --git a/libstdc++-v3/include/std/variant b/libstdc++-v3/include/std/variant
--- a/libstdc++-v3/include/std/variant	(revision 262353)
+++ b/libstdc++-v3/include/std/variant	(revision 262353)
@@ -741,7 +741,7 @@
       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
 		    "T should occur for exactly once in alternatives");
       static_assert(!is_void_v<_Tp>, "_Tp should not be void");
-      return get<__detail::__variant::__index_of_v<_Tp, _Types...>>(__v);
+      return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(__v);
     }
 
   template<typename _Tp, typename... _Types>
@@ -750,7 +750,7 @@
       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
 		    "T should occur for exactly once in alternatives");
       static_assert(!is_void_v<_Tp>, "_Tp should not be void");
-      return get<__detail::__variant::__index_of_v<_Tp, _Types...>>(
+      return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(
 	std::move(__v));
     }
 
@@ -760,7 +760,7 @@
       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
 		    "T should occur for exactly once in alternatives");
       static_assert(!is_void_v<_Tp>, "_Tp should not be void");
-      return get<__detail::__variant::__index_of_v<_Tp, _Types...>>(__v);
+      return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(__v);
     }
 
   template<typename _Tp, typename... _Types>
@@ -769,7 +769,7 @@
       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
 		    "T should occur for exactly once in alternatives");
       static_assert(!is_void_v<_Tp>, "_Tp should not be void");
-      return get<__detail::__variant::__index_of_v<_Tp, _Types...>>(
+      return std::get<__detail::__variant::__index_of_v<_Tp, _Types...>>(
 	std::move(__v));
     }
 
@@ -808,7 +808,8 @@
       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
 		    "T should occur for exactly once in alternatives");
       static_assert(!is_void_v<_Tp>, "_Tp should not be void");
-      return get_if<__detail::__variant::__index_of_v<_Tp, _Types...>>(__ptr);
+      return std::get_if<__detail::__variant::__index_of_v<_Tp, _Types...>>(
+	  __ptr);
     }
 
   template<typename _Tp, typename... _Types>
@@ -819,7 +820,8 @@
       static_assert(__detail::__variant::__exactly_once<_Tp, _Types...>,
 		    "T should occur for exactly once in alternatives");
       static_assert(!is_void_v<_Tp>, "_Tp should not be void");
-      return get_if<__detail::__variant::__index_of_v<_Tp, _Types...>>(__ptr);
+      return std::get_if<__detail::__variant::__index_of_v<_Tp, _Types...>>(
+	  __ptr);
     }
 
   struct monostate { };
@@ -1240,7 +1242,7 @@
 
       using _Result_type =
 	decltype(std::forward<_Visitor>(__visitor)(
-	    get<0>(std::forward<_Variants>(__variants))...));
+	    std::get<0>(std::forward<_Variants>(__variants))...));
 
       constexpr auto& __vtable = __detail::__variant::__gen_vtable<
 	_Result_type, _Visitor&&, _Variants&&...>::_S_vtable;
Index: libstdc++-v3/include/bits/parse_numbers.h
===================================================================
diff --git a/libstdc++-v3/include/bits/parse_numbers.h b/libstdc++-v3/include/bits/parse_numbers.h
--- a/libstdc++-v3/include/bits/parse_numbers.h	(revision 262353)
+++ b/libstdc++-v3/include/bits/parse_numbers.h	(revision 262353)
@@ -197,6 +197,13 @@
 		    "integer literal does not fit in unsigned long long");
     };
 
+  // Skip past digit separators:
+  template<unsigned _Base, unsigned long long _Pow, char _Dig, char..._Digs>
+    struct _Number_help<_Base, _Pow, '\'', _Dig, _Digs...>
+    : _Number_help<_Base, _Pow, _Dig, _Digs...>
+    { };
+
+  // Terminating case for recursion:
   template<unsigned _Base, unsigned long long _Pow, char _Dig>
     struct _Number_help<_Base, _Pow, _Dig>
     {
Index: libstdc++-v3/include/bits/basic_string.h
===================================================================
diff --git a/libstdc++-v3/include/bits/basic_string.h b/libstdc++-v3/include/bits/basic_string.h
--- a/libstdc++-v3/include/bits/basic_string.h	(revision 262353)
+++ b/libstdc++-v3/include/bits/basic_string.h	(revision 262353)
@@ -5130,7 +5130,10 @@
       */
       _CharT*
       data() noexcept
-      { return _M_data(); }
+      {
+	_M_leak();
+	return _M_data();
+      }
 #endif
 
       /**
Index: libstdc++-v3/include/bits/node_handle.h
===================================================================
diff --git a/libstdc++-v3/include/bits/node_handle.h b/libstdc++-v3/include/bits/node_handle.h
--- a/libstdc++-v3/include/bits/node_handle.h	(revision 262353)
+++ b/libstdc++-v3/include/bits/node_handle.h	(revision 262353)
@@ -105,7 +105,7 @@
       {
 	using std::swap;
 	swap(_M_ptr, __nh._M_ptr);
-	if (_AllocTraits::propagate_on_container_swap
+	if (_AllocTraits::propagate_on_container_swap::value
 	    || !_M_alloc || !__nh._M_alloc)
 	  _M_alloc.swap(__nh._M_alloc);
 	else
Index: libstdc++-v3/include/bits/char_traits.h
===================================================================
diff --git a/libstdc++-v3/include/bits/char_traits.h b/libstdc++-v3/include/bits/char_traits.h
--- a/libstdc++-v3/include/bits/char_traits.h	(revision 262353)
+++ b/libstdc++-v3/include/bits/char_traits.h	(revision 262353)
@@ -143,8 +143,6 @@
       { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
     };
 
-#define __cpp_lib_constexpr_char_traits 201611
-
   template<typename _CharT>
     _GLIBCXX14_CONSTEXPR int
     char_traits<_CharT>::
@@ -217,6 +215,8 @@
 _GLIBCXX_BEGIN_NAMESPACE_VERSION
 
 #if __cplusplus > 201402
+#define __cpp_lib_constexpr_char_traits 201611
+
   /**
    *  @brief Determine whether the characters of a NULL-terminated
    *  string are known at compile time.
Index: libstdc++-v3/include/bits/valarray_array.h
===================================================================
diff --git a/libstdc++-v3/include/bits/valarray_array.h b/libstdc++-v3/include/bits/valarray_array.h
--- a/libstdc++-v3/include/bits/valarray_array.h	(revision 262353)
+++ b/libstdc++-v3/include/bits/valarray_array.h	(revision 262353)
@@ -152,7 +152,10 @@
     {
       inline static void
       _S_do_it(const _Tp* __b, const _Tp* __e, _Tp* __restrict__ __o)
-      { __builtin_memcpy(__o, __b, (__e - __b) * sizeof(_Tp)); }
+      {
+	if (__b)
+	  __builtin_memcpy(__o, __b, (__e - __b) * sizeof(_Tp));
+      }
     };
 
   template<typename _Tp>
@@ -258,7 +261,10 @@
     {
       inline static void
       _S_do_it(const _Tp* __restrict__ __a, size_t __n, _Tp* __restrict__ __b)
-      { __builtin_memcpy(__b, __a, __n * sizeof (_Tp)); }
+      {
+	if (__n != 0)
+	  __builtin_memcpy(__b, __a, __n * sizeof (_Tp));
+      }
     };
 
   // Copy a plain array __a[<__n>] into a play array __b[<>]
Index: libstdc++-v3/include/bits/basic_string.tcc
===================================================================
diff --git a/libstdc++-v3/include/bits/basic_string.tcc b/libstdc++-v3/include/bits/basic_string.tcc
--- a/libstdc++-v3/include/bits/basic_string.tcc	(revision 262353)
+++ b/libstdc++-v3/include/bits/basic_string.tcc	(revision 262353)
@@ -1597,8 +1597,21 @@
 
   // Inhibit implicit instantiations for required instantiations,
   // which are defined via explicit instantiations elsewhere.
-#if _GLIBCXX_EXTERN_TEMPLATE > 0 && __cplusplus <= 201402L
+#if _GLIBCXX_EXTERN_TEMPLATE > 0
+  // The explicit instantiations definitions in src/c++11/string-inst.cc
+  // are compiled as C++14, so the new C++17 members aren't instantiated.
+  // Until those definitions are compiled as C++17 suppress the declaration,
+  // so C++17 code will implicitly instantiate std::string and std::wstring
+  // as needed.
+# if __cplusplus <= 201402L
   extern template class basic_string<char>;
+# elif ! _GLIBCXX_USE_CXX11_ABI
+  // Still need to prevent implicit instantiation of the COW empty rep,
+  // to ensure the definition in libstdc++.so is unique (PR 86138).
+  extern template basic_string<char>::size_type
+    basic_string<char>::_Rep::_S_empty_rep_storage[];
+# endif
+
   extern template
     basic_istream<char>&
     operator>>(basic_istream<char>&, string&);
@@ -1613,7 +1626,13 @@
     getline(basic_istream<char>&, string&);
 
 #ifdef _GLIBCXX_USE_WCHAR_T
+# if __cplusplus <= 201402L
   extern template class basic_string<wchar_t>;
+# elif ! _GLIBCXX_USE_CXX11_ABI
+  extern template basic_string<wchar_t>::size_type
+    basic_string<wchar_t>::_Rep::_S_empty_rep_storage[];
+# endif
+
   extern template
     basic_istream<wchar_t>&
     operator>>(basic_istream<wchar_t>&, wstring&);
@@ -1626,8 +1645,8 @@
   extern template
     basic_istream<wchar_t>&
     getline(basic_istream<wchar_t>&, wstring&);
-#endif
-#endif
+#endif // _GLIBCXX_USE_WCHAR_T
+#endif // _GLIBCXX_EXTERN_TEMPLATE > 0
 
 _GLIBCXX_END_NAMESPACE_VERSION
 } // namespace std
Index: libstdc++-v3/include/bits/random.tcc
===================================================================
diff --git a/libstdc++-v3/include/bits/random.tcc b/libstdc++-v3/include/bits/random.tcc
--- a/libstdc++-v3/include/bits/random.tcc	(revision 262353)
+++ b/libstdc++-v3/include/bits/random.tcc	(revision 262353)
@@ -2356,7 +2356,7 @@
 	    __v = __v * __v * __v;
 	    __u = __aurng();
 	  }
-	while (__u > result_type(1.0) - 0.331 * __n * __n * __n * __n
+	while (__u > result_type(1.0) - 0.0331 * __n * __n * __n * __n
 	       && (std::log(__u) > (0.5 * __n * __n + __a1
 				    * (1.0 - __v + std::log(__v)))));
 
@@ -2405,7 +2405,7 @@
 		  __v = __v * __v * __v;
 		  __u = __aurng();
 		}
-	      while (__u > result_type(1.0) - 0.331 * __n * __n * __n * __n
+	      while (__u > result_type(1.0) - 0.0331 * __n * __n * __n * __n
 		     && (std::log(__u) > (0.5 * __n * __n + __a1
 					  * (1.0 - __v + std::log(__v)))));
 
@@ -2426,7 +2426,7 @@
 		  __v = __v * __v * __v;
 		  __u = __aurng();
 		}
-	      while (__u > result_type(1.0) - 0.331 * __n * __n * __n * __n
+	      while (__u > result_type(1.0) - 0.0331 * __n * __n * __n * __n
 		     && (std::log(__u) > (0.5 * __n * __n + __a1
 					  * (1.0 - __v + std::log(__v)))));
 
Index: libstdc++-v3/include/bits/random.h
===================================================================
diff --git a/libstdc++-v3/include/bits/random.h b/libstdc++-v3/include/bits/random.h
--- a/libstdc++-v3/include/bits/random.h	(revision 262353)
+++ b/libstdc++-v3/include/bits/random.h	(revision 262353)
@@ -2643,7 +2643,12 @@
        */
       void
       param(const param_type& __param)
-      { _M_param = __param; }
+      {
+	_M_param = __param;
+	typedef typename std::gamma_distribution<result_type>::param_type
+	  param_type;
+	_M_gd.param(param_type{__param.n() / 2});
+      }
 
       /**
        * @brief Returns the greatest lower bound value of the distribution.
Index: libstdc++-v3/include/c_global/cstdlib
===================================================================
diff --git a/libstdc++-v3/include/c_global/cstdlib b/libstdc++-v3/include/c_global/cstdlib
--- a/libstdc++-v3/include/c_global/cstdlib	(revision 262353)
+++ b/libstdc++-v3/include/c_global/cstdlib	(revision 262353)
@@ -78,6 +78,9 @@
 
 // Get rid of those macros defined in <stdlib.h> in lieu of real functions.
 #undef abort
+#if __cplusplus >= 201703L && defined(_GLIBCXX_HAVE_ALIGNED_ALLOC)
+# undef aligned_alloc
+#endif
 #undef atexit
 #if __cplusplus >= 201103L
 # ifdef _GLIBCXX_HAVE_AT_QUICK_EXIT
@@ -125,6 +128,9 @@
   using ::ldiv_t;
 
   using ::abort;
+#if __cplusplus >= 201703L && defined(_GLIBCXX_HAVE_ALIGNED_ALLOC)
+  using ::aligned_alloc;
+#endif
   using ::atexit;
 #if __cplusplus >= 201103L
 # ifdef _GLIBCXX_HAVE_AT_QUICK_EXIT
Index: libstdc++-v3/include/c_global/cstddef
===================================================================
diff --git a/libstdc++-v3/include/c_global/cstddef b/libstdc++-v3/include/c_global/cstddef
--- a/libstdc++-v3/include/c_global/cstddef	(revision 262353)
+++ b/libstdc++-v3/include/c_global/cstddef	(revision 262353)
@@ -65,7 +65,7 @@
   /// std::byte
   enum class byte : unsigned char {};
 
-  template<typename _IntegerType> struct __byte_operand;
+  template<typename _IntegerType> struct __byte_operand { };
   template<> struct __byte_operand<bool> { using __type = byte; };
   template<> struct __byte_operand<char> { using __type = byte; };
   template<> struct __byte_operand<signed char> { using __type = byte; };
Index: libstdc++-v3/include/tr1/exp_integral.tcc
===================================================================
diff --git a/libstdc++-v3/include/tr1/exp_integral.tcc b/libstdc++-v3/include/tr1/exp_integral.tcc
--- a/libstdc++-v3/include/tr1/exp_integral.tcc	(revision 262353)
+++ b/libstdc++-v3/include/tr1/exp_integral.tcc	(revision 262353)
@@ -86,7 +86,7 @@
       _Tp __term = _Tp(1);
       _Tp __esum = _Tp(0);
       _Tp __osum = _Tp(0);
-      const unsigned int __max_iter = 100;
+      const unsigned int __max_iter = 1000;
       for (unsigned int __i = 1; __i < __max_iter; ++__i)
         {
           __term *= - __x / __i;
@@ -156,7 +156,7 @@
     _Tp
     __expint_En_series(unsigned int __n, _Tp __x)
     {
-      const unsigned int __max_iter = 100;
+      const unsigned int __max_iter = 1000;
       const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
       const int __nm1 = __n - 1;
       _Tp __ans = (__nm1 != 0
@@ -202,7 +202,7 @@
     _Tp
     __expint_En_cont_frac(unsigned int __n, _Tp __x)
     {
-      const unsigned int __max_iter = 100;
+      const unsigned int __max_iter = 1000;
       const _Tp __eps = std::numeric_limits<_Tp>::epsilon();
       const _Tp __fp_min = std::numeric_limits<_Tp>::min();
       const int __nm1 = __n - 1;
Index: libstdc++-v3/include/tr1/ell_integral.tcc
===================================================================
diff --git a/libstdc++-v3/include/tr1/ell_integral.tcc b/libstdc++-v3/include/tr1/ell_integral.tcc
--- a/libstdc++-v3/include/tr1/ell_integral.tcc	(revision 262353)
+++ b/libstdc++-v3/include/tr1/ell_integral.tcc	(revision 262353)
@@ -685,8 +685,8 @@
           const _Tp __kk = __k * __k;
 
           return __ellint_rf(_Tp(0), _Tp(1) - __kk, _Tp(1))
-               - __nu
-               * __ellint_rj(_Tp(0), _Tp(1) - __kk, _Tp(1), _Tp(1) + __nu)
+               + __nu
+               * __ellint_rj(_Tp(0), _Tp(1) - __kk, _Tp(1), _Tp(1) - __nu)
                / _Tp(3);
         }
     }
@@ -735,9 +735,9 @@
 
           const _Tp __Pi = __s
                          * __ellint_rf(__cc, _Tp(1) - __kk * __ss, _Tp(1))
-                         - __nu * __sss
+                         + __nu * __sss
                          * __ellint_rj(__cc, _Tp(1) - __kk * __ss, _Tp(1),
-                                       _Tp(1) + __nu * __ss) / _Tp(3);
+                                       _Tp(1) - __nu * __ss) / _Tp(3);
 
           if (__n == 0)
             return __Pi;
Index: libstdc++-v3/include/Makefile.am
===================================================================
diff --git a/libstdc++-v3/include/Makefile.am b/libstdc++-v3/include/Makefile.am
--- a/libstdc++-v3/include/Makefile.am	(revision 262353)
+++ b/libstdc++-v3/include/Makefile.am	(revision 262353)
@@ -1474,3 +1474,8 @@
 $(ext_headers): ; @:
 $(experimental_headers): ; @:
 $(experimental_bits_headers): ; @:
+
+if INCLUDE_DIR_NOTPARALLEL
+# See https://gcc.gnu.org/bugzilla/show_bug.cgi?id=81797
+.NOTPARALLEL:
+endif
Index: libstdc++-v3/libsupc++/cxxabi_init_exception.h
===================================================================
diff --git a/libstdc++-v3/libsupc++/cxxabi_init_exception.h b/libstdc++-v3/libsupc++/cxxabi_init_exception.h
--- a/libstdc++-v3/libsupc++/cxxabi_init_exception.h	(revision 262353)
+++ b/libstdc++-v3/libsupc++/cxxabi_init_exception.h	(revision 262353)
@@ -62,6 +62,9 @@
       void*
       __cxa_allocate_exception(size_t) _GLIBCXX_NOTHROW;
 
+      void
+      __cxa_free_exception(void*) _GLIBCXX_NOTHROW;
+
       // Initialize exception (this is a GNU extension)
       __cxa_refcounted_exception*
       __cxa_init_primary_exception(void *object, std::type_info *tinfo,
Index: libstdc++-v3/libsupc++/exception_ptr.h
===================================================================
diff --git a/libstdc++-v3/libsupc++/exception_ptr.h b/libstdc++-v3/libsupc++/exception_ptr.h
--- a/libstdc++-v3/libsupc++/exception_ptr.h	(revision 262353)
+++ b/libstdc++-v3/libsupc++/exception_ptr.h	(revision 262353)
@@ -178,25 +178,31 @@
     exception_ptr 
     make_exception_ptr(_Ex __ex) _GLIBCXX_USE_NOEXCEPT
     {
-#if __cpp_exceptions
+#if __cpp_exceptions && __cpp_rtti && !_GLIBCXX_HAVE_CDTOR_CALLABI
+      void* __e = __cxxabiv1::__cxa_allocate_exception(sizeof(_Ex));
+      (void) __cxxabiv1::__cxa_init_primary_exception(
+	  __e, const_cast<std::type_info*>(&typeid(__ex)),
+	  __exception_ptr::__dest_thunk<_Ex>);
       try
 	{
-#if __cpp_rtti && !_GLIBCXX_HAVE_CDTOR_CALLABI
-          void *__e = __cxxabiv1::__cxa_allocate_exception(sizeof(_Ex));
-          (void)__cxxabiv1::__cxa_init_primary_exception(
-	      __e, const_cast<std::type_info*>(&typeid(__ex)),
-	      __exception_ptr::__dest_thunk<_Ex>);
           ::new (__e) _Ex(__ex);
           return exception_ptr(__e);
-#else
+	}
+      catch(...)
+	{
+	  __cxxabiv1::__cxa_free_exception(__e);
+	  return current_exception();
+	}
+#elif __cpp_exceptions
+      try
+	{
           throw __ex;
-#endif
 	}
       catch(...)
 	{
 	  return current_exception();
 	}
-#else
+#else // no RTTI and no exceptions
       return exception_ptr();
 #endif
     }
Index: libstdc++-v3/ChangeLog
===================================================================
diff --git a/libstdc++-v3/ChangeLog b/libstdc++-v3/ChangeLog
--- a/libstdc++-v3/ChangeLog	(revision 262353)
+++ b/libstdc++-v3/ChangeLog	(revision 262353)
@@ -1,3 +1,277 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
+2018-06-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-06-22  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/86138
+	* include/bits/basic_string.tcc:
+	[__cplusplus > 201402 && !_GLIBCXX_USE_CXX11_ABI]
+	(basic_string<char>::_Rep::_S_empty_rep_storage)
+	(basic_string<wchar_t>::_Rep::_S_empty_rep_storage): Add explicit
+	instantiation declarations.
+	[__cplusplus > 201402] (operator>>, operator<<, getline): Re-enable
+	explicit instantiation declarations.
+	* testsuite/21_strings/basic_string/cons/char/86138.cc: New.
+	* testsuite/21_strings/basic_string/cons/wchar_t/86138.cc: New.
+
+2018-06-21  Jonathan Wakely  <jwakely@redhat.com>
+
+	* config/abi/post/x86_64-linux-gnu/baseline_symbols.txt: Update.
+
+2018-06-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/std/utility: Remove unused <exception> header.
+
+2018-06-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/86169
+	* include/bits/basic_string.h [!_GLIBCXX_USE_CXX11_ABI]
+	(basic_string::data()): Unshare string.
+	* testsuite/21_strings/basic_string/operations/data/char/86169.cc:
+	New.
+
+2018-06-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	* include/bits/char_traits.h (__cpp_lib_constexpr_char_traits): Only
+	define for C++17 and above.
+
+2018-05-17  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/85812
+	* libsupc++/cxxabi_init_exception.h (__cxa_free_exception): Declare.
+	* libsupc++/exception_ptr.h (make_exception_ptr) [__cpp_exceptions]:
+	Refactor to separate non-throwing and throwing implementations.
+	[__cpp_rtti && !_GLIBCXX_HAVE_CDTOR_CALLABI]: Deallocate the memory
+	if constructing the object throws.
+
+2018-05-14  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/67554
+	* include/bits/valarray_array.h (_Array_copy_ctor<_Tp, true>)
+	(_Array_copier<_Tp, true>): Do not pass null pointers to memcpy.
+
+	PR libstdc++/82966
+	* include/bits/node_handle.h (_Node_handle_common::_M_swap): Use value
+	instead of type.
+	* testsuite/23_containers/set/modifiers/node_swap.cc: New.
+
+2018-05-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/xml/faq.xml: Link to C++17 status. Add note to outdated answer.
+	* doc/xml/manual/debug_mode.xml: Add array and forward_list to list
+	of C++11 containers with Debug Mode support.
+	* doc/xml/manual/using.xml: Document Dual ABI for ios_base::failure.
+	* doc/html/*: Regenerate.
+
+2018-05-07  Edward Smith-Rowland  <3dw4rd@verizon.net>
+	    Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-05-07  Edward Smith-Rowland  <3dw4rd@verizon.net>
+
+	PR libstdc++/80506
+	* include/bits/random.tcc (gamma_distribution::operator()): Fix magic
+	number used in loop condition.
+	(gamma_distribution::__generate_impl()): Ditto.
+
+2018-05-03  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/84769
+	* include/std/variant (visit): Qualify std::get call.
+
+	PR libstdc++/85632 use uintmax_t for arithmetic
+	* src/filesystem/ops.cc (experimental::filesystem::space): Perform
+	arithmetic in result type.
+	* testsuite/experimental/filesystem/operations/space.cc: New.
+
+2018-04-30  Edward Smith-Rowland  <3dw4rd@verizon.net>
+
+	PR libstdc++/pr66689 - comp_ellint_3 and ellint_3 return garbage values
+	* include/tr1/ell_integral.tcc: Correct the nu sign convention
+	in ellint_3 and comp_ellint_3.
+	* testsuite/tr1/5_numerical_facilities/special_functions/
+	06_comp_ellint_3/check_value.cc: Regen with correct values.
+	* testsuite/tr1/5_numerical_facilities/special_functions/
+	14_ellint_3/check_value.cc: Ditto.
+	* testsuite/special_functions/06_comp_ellint_3/check_value.cc: Ditto.
+	* testsuite/special_functions/13_ellint_3/check_value.cc: Ditto.
+	* testsuite/special_functions/06_comp_ellint_3/pr66689.cc: New.
+	* testsuite/special_functions/13_ellint_3/pr66689.cc: New.
+	* testsuite/tr1/5_numerical_facilities/special_functions/
+	06_comp_ellint_3/pr66689.cc: New.
+	* testsuite/tr1/5_numerical_facilities/special_functions/
+	14_ellint_3/pr66689.cc: New.
+
+2018-04-30  Edward Smith-Rowland  <3dw4rd@verizon.net>
+
+	PR libstdc++/68397 std::tr1::expint fails ... long double arguments.
+	* include/tr1/exp_integral.tcc: Increase iteration limits.
+	* testsuite/tr1/5_numerical_facilities/special_functions/15_expint/
+	pr68397.cc: New test.
+	* testsuite/special_functions/14_expint/pr68397.cc: New test.
+
+2018-04-18  Jonathan Wakely  <jwakely@redhat.com>
+	    Jakub Jelinek  <jakub@redhat.com>
+
+	PR libstdc++/85442
+	* src/c++11/Makefile.am: Don't generate debuginfo again for
+	cxx11-ios_failure-lt.s and cxx11-ios_failure.s files.
+	* src/c++11/Makefile.in: Regenerate.
+
+2018-04-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/c++11/Makefile.am: Fix sed command.
+	* src/c++11/Makefile.in: Regenerate.
+
+	* src/c++11/Makefile.am: Rewrite sed rule to be less fragile and to
+	handle mangled names starting with double underscores on darwin.
+	* src/c++11/Makefile.in: Regenerate.
+
+2018-04-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	* src/c++11/Makefile.am: Fix comment.
+	* src/c++11/Makefile.in: Regenerate.
+	* src/c++11/cxx11-ios_failure.cc: Fix comment.
+	* src/c++98/ios_failure.cc: Likewise.
+
+	Backport from mainline
+	2018-04-10  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/85222
+	* src/c++11/Makefile.am [ENABLE_DUAL_ABI]: Add special rules for
+	cxx11-ios_failure.cc to rewrite type info for __ios_failure.
+	* src/c++11/Makefile.in: Regenerate.
+	* src/c++11/cxx11-ios_failure.cc (__ios_failure, __iosfail_type_info):
+	New types.
+	[_GLIBCXX_USE_DUAL_ABI] (__throw_ios_failure): Define here.
+	* src/c++11/ios.cc (__throw_ios_failure): Remove definition.
+	(_GLIBCXX_USE_CXX11_ABI): Don't define here.
+	* src/c++98/ios_failure.cc (__construct_ios_failure)
+	(__destroy_ios_failure, is_ios_failure_handler): New functions.
+	[!_GLIBCXX_USE_DUAL_ABI] (__throw_ios_failure): Define here.
+	* testsuite/27_io/ios_base/failure/dual_abi.cc: New.
+	* testsuite/27_io/basic_ios/copyfmt/char/1.cc: Revert changes to
+	handler types, to always catch std::ios_base::failure.
+	* testsuite/27_io/basic_ios/exceptions/char/1.cc: Likewise.
+	* testsuite/27_io/basic_istream/extractors_arithmetic/char/
+	exceptions_failbit.cc: Likewise.
+	* testsuite/27_io/basic_istream/extractors_arithmetic/wchar_t/
+	exceptions_failbit.cc: Likewise.
+	* testsuite/27_io/basic_istream/extractors_other/char/
+	exceptions_null.cc: Likewise.
+	* testsuite/27_io/basic_istream/extractors_other/wchar_t/
+	exceptions_null.cc: Likewise.
+	* testsuite/27_io/basic_istream/sentry/char/12297.cc: Likewise.
+	* testsuite/27_io/basic_istream/sentry/wchar_t/12297.cc: Likewise.
+	* testsuite/27_io/basic_ostream/inserters_other/char/
+	exceptions_null.cc: Likewise.
+	* testsuite/27_io/basic_ostream/inserters_other/wchar_t/
+	exceptions_null.cc: Likewise.
+	* testsuite/27_io/ios_base/storage/2.cc: Likewise.
+
+2018-03-22  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR libstdc++/77691
+	* testsuite/experimental/memory_resource/resource_adaptor.cc:
+	xfail execution on 32-bit Solaris/x86.
+
+2018-03-13  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-03-09  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/84769
+	* include/std/variant (get<_Tp, _Types...>, get_if<_Tp, _Types...>):
+	Qualify calls to get<_Np, Types...> and get_if<_Np, _Types...>.
+
+2018-03-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/84773
+	PR libstdc++/83662
+	* crossconfig.m4: Check for aligned_alloc etc. on freebsd and mingw32.
+	* configure: Regenerate.
+	* include/c_global/cstdlib [_GLIBCXX_HAVE_ALIGNED_ALLOC]
+	(aligned_alloc): Add using-declaration.
+	* testsuite/18_support/aligned_alloc/aligned_alloc.cc: New test.
+
+2018-03-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-03-02  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/84671
+	* include/bits/parse_numbers.h (_Number_help): Add partial
+	specialization to handle digit separators. Adjust partial
+	specialization for recursion temrination to require _Pow == 1ULL.
+	* testsuite/20_util/duration/literals/84671.cc: New
+
+2018-02-26  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-02-23  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/84532
+	* include/std/thread (thread::__make_invoker): Construct tuple
+	directly instead of using make_tuple.
+	* testsuite/30_threads/async/84532.cc: New.
+	* testsuite/30_threads/thread/84532.cc: New.
+
+2018-02-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-02-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/81797
+	* configure.ac (INCLUDE_DIR_NOTPARALLEL): Define.
+	* configure: Regenerate.
+	* include/Makefile.am (INCLUDE_DIR_NOTPARALLEL): Add .NOTPARALLEL when
+	defined.
+	* include/Makefile.in: Regenerate.
+
+2018-01-29  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/83833
+	* testsuite/26_numerics/random/chi_squared_distribution/83833.cc:
+	Add -ffloat-store to options for m68k and ia32.
+
+	PR libstdc++/83658
+	* include/std/any (any::__do_emplace): Only set _M_manager after
+	constructing the contained object.
+	* testsuite/20_util/any/misc/any_cast_neg.cc: Adjust dg-error line.
+	* testsuite/20_util/any/modifiers/83658.cc: New test.
+
+	Backport from mainline
+	2018-01-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/83833
+	* include/bits/random.h (chi_squared_distribution::param): Update
+	gamma distribution parameter.
+	* testsuite/26_numerics/random/chi_squared_distribution/83833.cc: New
+	test.
+
+2018-01-25  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/81076
+	* include/c_global/cstddef (__byte_operand): Define primary template.
+	* testsuite/18_support/byte/81076.cc: New test.
+
+	Backport from mainline
+	2018-01-15  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR libstdc++/83830
+	* include/std/type_traits (has_unique_object_representations_v): Add
+	variable template.
+	* testsuite/20_util/has_unique_object_representations/value.cc: Check
+	variable template.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
Index: libstdc++-v3/testsuite/18_support/byte/81076.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/18_support/byte/81076.cc b/libstdc++-v3/testsuite/18_support/byte/81076.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/18_support/byte/81076.cc	(revision 262353)
@@ -0,0 +1,26 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do compile { target c++1z } }
+
+#include <cstddef>
+
+template<class> void to_integer(...);
+
+using T = decltype(to_integer<void* const>(std::byte{}));
+using T = void;
Index: libstdc++-v3/testsuite/18_support/aligned_alloc/aligned_alloc.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/18_support/aligned_alloc/aligned_alloc.cc b/libstdc++-v3/testsuite/18_support/aligned_alloc/aligned_alloc.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/18_support/aligned_alloc/aligned_alloc.cc	(revision 262353)
@@ -0,0 +1,42 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++1z } }
+
+#include <cstdlib>
+#include <cstdint>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+#ifdef _GLIBCXX_HAVE_ALIGNED_ALLOC
+  void* p = std::aligned_alloc(256, 1);
+  if (p)
+  {
+    VERIFY( (reinterpret_cast<std::uintptr_t>(p) % 256) == 0 );
+    std::free(p);
+  }
+#endif
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/30_threads/thread/84532.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/30_threads/thread/84532.cc b/libstdc++-v3/testsuite/30_threads/thread/84532.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/30_threads/thread/84532.cc	(revision 262353)
@@ -0,0 +1,38 @@
+// { dg-do compile { target c++11 } }
+// { dg-require-cstdint "" }
+// { dg-require-gthreads "" }
+
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <thread>
+
+// PR libstdc++/84532
+
+struct F
+{
+  template<typename T, typename U>
+    void operator()(T, U, int&)
+    {
+      using std::is_same;
+      using std::reference_wrapper;
+      static_assert(is_same<T, reference_wrapper<int>>::value, "");
+      static_assert(is_same<U, reference_wrapper<const int>>::value, "");
+    }
+};
+int i = 0;
+std::thread t(F{}, std::ref(i), std::cref(i), std::ref(i));
Index: libstdc++-v3/testsuite/30_threads/async/84532.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/30_threads/async/84532.cc b/libstdc++-v3/testsuite/30_threads/async/84532.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/30_threads/async/84532.cc	(revision 262353)
@@ -0,0 +1,38 @@
+// { dg-do compile { target c++11 } }
+// { dg-require-cstdint "" }
+// { dg-require-gthreads "" }
+
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+#include <future>
+
+// PR libstdc++/84532
+
+struct F
+{
+  template<typename T, typename U>
+    void operator()(T, U, int&)
+    {
+      using std::is_same;
+      using std::reference_wrapper;
+      static_assert(is_same<T, reference_wrapper<int>>::value, "");
+      static_assert(is_same<U, reference_wrapper<const int>>::value, "");
+    }
+};
+int i = 0;
+auto fut = std::async(F{}, std::ref(i), std::cref(i), std::ref(i));
Index: libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/06_comp_ellint_3/pr66689.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/06_comp_ellint_3/pr66689.cc b/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/06_comp_ellint_3/pr66689.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/06_comp_ellint_3/pr66689.cc	(revision 262353)
@@ -0,0 +1,20 @@
+
+#include <tr1/cmath>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  double Pi1 = std::tr1::comp_ellint_3(0.75, 0.0);
+  VERIFY(std::abs(Pi1 - 1.91099) < 0.00001);
+
+  double Pi2 = std::tr1::comp_ellint_3(0.75, 0.5);
+  VERIFY(std::abs(Pi2 - 2.80011) < 0.00001);
+}
+
+int
+main()
+{
+  test01();
+  return 0;
+}
Index: libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/06_comp_ellint_3/check_value.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/06_comp_ellint_3/check_value.cc b/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/06_comp_ellint_3/check_value.cc
--- a/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/06_comp_ellint_3/check_value.cc	(revision 262353)
+++ b/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/06_comp_ellint_3/check_value.cc	(revision 262353)
@@ -1,6 +1,7 @@
-// 2007-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>
+// { dg-do run { target c++11 } }
+// { dg-options "-D__STDCPP_WANT_MATH_SPEC_FUNCS__" }
 //
-// Copyright (C) 2007-2017 Free Software Foundation, Inc.
+// Copyright (C) 2016-2018 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -18,826 +19,490 @@
 // <http://www.gnu.org/licenses/>.
 
 //  comp_ellint_3
-
-
 //  Compare against values generated by the GNU Scientific Library.
 //  The GSL can be found on the web: http://www.gnu.org/software/gsl/
-
+#include <limits>
 #include <tr1/cmath>
 #if defined(__TEST_DEBUG)
-#include <iostream>
-#define VERIFY(A) \
-if (!(A)) \
-  { \
-    std::cout << "line " << __LINE__ \
-      << "  max_abs_frac = " << max_abs_frac \
-      << std::endl; \
-  }
+#  include <iostream>
+#  define VERIFY(A) \
+  if (!(A)) \
+    { \
+      std::cout << "line " << __LINE__ \
+	<< "  max_abs_frac = " << max_abs_frac \
+	<< std::endl; \
+    }
 #else
-#include <testsuite_hooks.h>
+#  include <testsuite_hooks.h>
 #endif
-#include "../testcase.h"
+#include <specfun_testcase.h>
 
-
 // Test data for k=-0.90000000000000002.
-testcase_comp_ellint_3<double> data001[] = {
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 1.2838262090802751e-16
+// mean(f - f_Boost): 4.4408920985006264e-17
+// variance(f - f_Boost): 2.4347558803117648e-34
+// stddev(f - f_Boost): 1.5603704304785339e-17
+const testcase_comp_ellint_3<double>
+data001[10] =
+{
   { 2.2805491384227703, -0.90000000000000002, 0.0000000000000000 },
-  { 2.1537868513875287, -0.90000000000000002, 0.10000000000000001 },
-  { 2.0443194576468890, -0.90000000000000002, 0.20000000000000001 },
-  { 1.9486280260314426, -0.90000000000000002, 0.29999999999999999 },
-  { 1.8641114227238349, -0.90000000000000002, 0.40000000000000002 },
-  { 1.7888013241937861, -0.90000000000000002, 0.50000000000000000 },
-  { 1.7211781128919523, -0.90000000000000002, 0.59999999999999998 },
-  { 1.6600480747670938, -0.90000000000000002, 0.69999999999999996 },
-  { 1.6044591960982204, -0.90000000000000002, 0.80000000000000004 },
-  { 1.5536420236310946, -0.90000000000000002, 0.90000000000000002 },
+  { 2.4295011187834885, -0.90000000000000002, 0.10000000000000001 },
+  { 2.6076835743348412, -0.90000000000000002, 0.20000000000000001 },
+  { 2.8256506968858512, -0.90000000000000002, 0.30000000000000004 },
+  { 3.1000689868578619, -0.90000000000000002, 0.40000000000000002 },
+  { 3.4591069002104677, -0.90000000000000002, 0.50000000000000000 },
+  { 3.9549939883570229, -0.90000000000000002, 0.60000000000000009 },
+  { 4.6985482312992435, -0.90000000000000002, 0.70000000000000007 },
+  { 5.9820740813645710, -0.90000000000000002, 0.80000000000000004 },
+  { 8.9942562031858699, -0.90000000000000002, 0.90000000000000002 },
 };
+const double toler001 = 2.5000000000000020e-13;
 
-// Test function for k=-0.90000000000000002.
-template <typename Tp>
-void test001()
+// Test data for k=-0.80000000000000004.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.1949393471095187e-16
+// mean(f - f_Boost): 9.5479180117763459e-16
+// variance(f - f_Boost): 5.4782007307014711e-34
+// stddev(f - f_Boost): 2.3405556457178006e-17
+const testcase_comp_ellint_3<double>
+data002[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data001)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data001[i].k), Tp(data001[i].nu));
-      const Tp f0 = data001[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.80000000000000004.
-testcase_comp_ellint_3<double> data002[] = {
-  { 1.9953027776647296, -0.80000000000000004, 0.0000000000000000 },
-  { 1.8910755418379521, -0.80000000000000004, 0.10000000000000001 },
-  { 1.8007226661734588, -0.80000000000000004, 0.20000000000000001 },
-  { 1.7214611048717301, -0.80000000000000004, 0.29999999999999999 },
-  { 1.6512267838651289, -0.80000000000000004, 0.40000000000000002 },
-  { 1.5884528947755532, -0.80000000000000004, 0.50000000000000000 },
-  { 1.5319262547427865, -0.80000000000000004, 0.59999999999999998 },
-  { 1.4806912324625332, -0.80000000000000004, 0.69999999999999996 },
-  { 1.4339837018309474, -0.80000000000000004, 0.80000000000000004 },
-  { 1.3911845406776222, -0.80000000000000004, 0.90000000000000002 },
+  { 1.9953027776647294, -0.80000000000000004, 0.0000000000000000 },
+  { 2.1172616484005085, -0.80000000000000004, 0.10000000000000001 },
+  { 2.2624789434186798, -0.80000000000000004, 0.20000000000000001 },
+  { 2.4392042002725698, -0.80000000000000004, 0.30000000000000004 },
+  { 2.6604037035529728, -0.80000000000000004, 0.40000000000000002 },
+  { 2.9478781158239751, -0.80000000000000004, 0.50000000000000000 },
+  { 3.3418121892288055, -0.80000000000000004, 0.60000000000000009 },
+  { 3.9268876980046397, -0.80000000000000004, 0.70000000000000007 },
+  { 4.9246422058196071, -0.80000000000000004, 0.80000000000000004 },
+  { 7.2263259298637132, -0.80000000000000004, 0.90000000000000002 },
 };
+const double toler002 = 2.5000000000000020e-13;
 
-// Test function for k=-0.80000000000000004.
-template <typename Tp>
-void test002()
+// Test data for k=-0.69999999999999996.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 3
+// max(|f - f_Boost| / |f_Boost|): 1.9832236886714888e-16
+// mean(f - f_Boost): -1.5543122344752191e-16
+// variance(f - f_Boost): 2.9825759533819119e-33
+// stddev(f - f_Boost): 5.4612965066748680e-17
+const testcase_comp_ellint_3<double>
+data003[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data002)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data002[i].k), Tp(data002[i].nu));
-      const Tp f0 = data002[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.69999999999999996.
-testcase_comp_ellint_3<double> data003[] = {
-  { 1.8456939983747236, -0.69999999999999996, 0.0000000000000000 },
-  { 1.7528050171757608, -0.69999999999999996, 0.10000000000000001 },
-  { 1.6721098780092147, -0.69999999999999996, 0.20000000000000001 },
-  { 1.6011813647733213, -0.69999999999999996, 0.29999999999999999 },
-  { 1.5382162002954762, -0.69999999999999996, 0.40000000000000002 },
-  { 1.4818433192178544, -0.69999999999999996, 0.50000000000000000 },
-  { 1.4309994736080540, -0.69999999999999996, 0.59999999999999998 },
-  { 1.3848459188329196, -0.69999999999999996, 0.69999999999999996 },
-  { 1.3427110650397533, -0.69999999999999996, 0.80000000000000004 },
-  { 1.3040500499695911, -0.69999999999999996, 0.90000000000000002 },
+  { 1.8456939983747234, -0.69999999999999996, 0.0000000000000000 },
+  { 1.9541347343119564, -0.69999999999999996, 0.10000000000000001 },
+  { 2.0829290325820202, -0.69999999999999996, 0.20000000000000001 },
+  { 2.2392290510988535, -0.69999999999999996, 0.30000000000000004 },
+  { 2.4342502915307880, -0.69999999999999996, 0.40000000000000002 },
+  { 2.6868019968236996, -0.69999999999999996, 0.50000000000000000 },
+  { 3.0314573496746742, -0.69999999999999996, 0.60000000000000009 },
+  { 3.5408408771788564, -0.69999999999999996, 0.70000000000000007 },
+  { 4.4042405729076961, -0.69999999999999996, 0.80000000000000004 },
+  { 6.3796094177887754, -0.69999999999999996, 0.90000000000000002 },
 };
+const double toler003 = 2.5000000000000020e-13;
 
-// Test function for k=-0.69999999999999996.
-template <typename Tp>
-void test003()
+// Test data for k=-0.59999999999999998.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 2
+// max(|f - f_Boost| / |f_Boost|): 2.2547200163366559e-16
+// mean(f - f_Boost): -1.9984014443252818e-16
+// variance(f - f_Boost): 4.9303806576313241e-33
+// stddev(f - f_Boost): 7.0216669371534022e-17
+const testcase_comp_ellint_3<double>
+data004[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data003)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data003[i].k), Tp(data003[i].nu));
-      const Tp f0 = data003[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.59999999999999998.
-testcase_comp_ellint_3<double> data004[] = {
   { 1.7507538029157526, -0.59999999999999998, 0.0000000000000000 },
-  { 1.6648615773343014, -0.59999999999999998, 0.10000000000000001 },
-  { 1.5901418016279374, -0.59999999999999998, 0.20000000000000001 },
-  { 1.5243814243493585, -0.59999999999999998, 0.29999999999999999 },
-  { 1.4659345278069984, -0.59999999999999998, 0.40000000000000002 },
-  { 1.4135484285693078, -0.59999999999999998, 0.50000000000000000 },
-  { 1.3662507535812816, -0.59999999999999998, 0.59999999999999998 },
-  { 1.3232737468822811, -0.59999999999999998, 0.69999999999999996 },
-  { 1.2840021261752192, -0.59999999999999998, 0.80000000000000004 },
-  { 1.2479362973851875, -0.59999999999999998, 0.90000000000000002 },
+  { 1.8508766487100685, -0.59999999999999998, 0.10000000000000001 },
+  { 1.9695980282802217, -0.59999999999999998, 0.20000000000000001 },
+  { 2.1134154405060599, -0.59999999999999998, 0.30000000000000004 },
+  { 2.2925036420985130, -0.59999999999999998, 0.40000000000000002 },
+  { 2.5239007084492711, -0.59999999999999998, 0.50000000000000000 },
+  { 2.8388723099514972, -0.59999999999999998, 0.60000000000000009 },
+  { 3.3029735898397159, -0.59999999999999998, 0.70000000000000007 },
+  { 4.0867036409261832, -0.59999999999999998, 0.80000000000000004 },
+  { 5.8709993116265604, -0.59999999999999998, 0.90000000000000002 },
 };
+const double toler004 = 2.5000000000000020e-13;
 
-// Test function for k=-0.59999999999999998.
-template <typename Tp>
-void test004()
+// Test data for k=-0.50000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 3
+// max(|f - f_Boost| / |f_Boost|): 2.1900131385114407e-16
+// mean(f - f_Boost): 2.4424906541753446e-16
+// variance(f - f_Boost): 7.3651365379430888e-33
+// stddev(f - f_Boost): 8.5820373676319358e-17
+const testcase_comp_ellint_3<double>
+data005[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data004)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data004[i].k), Tp(data004[i].nu));
-      const Tp f0 = data004[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.50000000000000000.
-testcase_comp_ellint_3<double> data005[] = {
-  { 1.6857503548125963, -0.50000000000000000, 0.0000000000000000 },
-  { 1.6045524936084892, -0.50000000000000000, 0.10000000000000001 },
-  { 1.5338490483665983, -0.50000000000000000, 0.20000000000000001 },
-  { 1.4715681939859637, -0.50000000000000000, 0.29999999999999999 },
-  { 1.4161679518465340, -0.50000000000000000, 0.40000000000000002 },
-  { 1.3664739530045971, -0.50000000000000000, 0.50000000000000000 },
-  { 1.3215740290190876, -0.50000000000000000, 0.59999999999999998 },
-  { 1.2807475181182502, -0.50000000000000000, 0.69999999999999996 },
-  { 1.2434165408189539, -0.50000000000000000, 0.80000000000000004 },
-  { 1.2091116095504744, -0.50000000000000000, 0.90000000000000002 },
+  { 1.6857503548125961, -0.50000000000000000, 0.0000000000000000 },
+  { 1.7803034946545482, -0.50000000000000000, 0.10000000000000001 },
+  { 1.8922947612264021, -0.50000000000000000, 0.20000000000000001 },
+  { 2.0277924458111314, -0.50000000000000000, 0.30000000000000004 },
+  { 2.1962905366178065, -0.50000000000000000, 0.40000000000000002 },
+  { 2.4136715042011945, -0.50000000000000000, 0.50000000000000000 },
+  { 2.7090491861753558, -0.50000000000000000, 0.60000000000000009 },
+  { 3.1433945297859229, -0.50000000000000000, 0.70000000000000007 },
+  { 3.8750701888108070, -0.50000000000000000, 0.80000000000000004 },
+  { 5.5355132096026463, -0.50000000000000000, 0.90000000000000002 },
 };
+const double toler005 = 2.5000000000000020e-13;
 
-// Test function for k=-0.50000000000000000.
-template <typename Tp>
-void test005()
+// Test data for k=-0.39999999999999991.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1718164615986397e-16
+// mean(f - f_Boost): 6.2172489379008762e-16
+// variance(f - f_Boost): 1.6458949750907531e-31
+// stddev(f - f_Boost): 4.0569631192441877e-16
+const testcase_comp_ellint_3<double>
+data006[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data005)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data005[i].k), Tp(data005[i].nu));
-      const Tp f0 = data005[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002.
-testcase_comp_ellint_3<double> data006[] = {
-  { 1.6399998658645112, -0.40000000000000002, 0.0000000000000000 },
-  { 1.5620566886683604, -0.40000000000000002, 0.10000000000000001 },
-  { 1.4941414344266770, -0.40000000000000002, 0.20000000000000001 },
-  { 1.4342789859950078, -0.40000000000000002, 0.29999999999999999 },
-  { 1.3809986210732901, -0.40000000000000002, 0.40000000000000002 },
-  { 1.3331797176377398, -0.40000000000000002, 0.50000000000000000 },
-  { 1.2899514672527024, -0.40000000000000002, 0.59999999999999998 },
-  { 1.2506255923253344, -0.40000000000000002, 0.69999999999999996 },
-  { 1.2146499565727209, -0.40000000000000002, 0.80000000000000004 },
-  { 1.1815758115929846, -0.40000000000000002, 0.90000000000000002 },
+  { 1.6399998658645112, -0.39999999999999991, 0.0000000000000000 },
+  { 1.7306968836847190, -0.39999999999999991, 0.10000000000000001 },
+  { 1.8380358826317627, -0.39999999999999991, 0.20000000000000001 },
+  { 1.9677924132520139, -0.39999999999999991, 0.30000000000000004 },
+  { 2.1289968719280026, -0.39999999999999991, 0.40000000000000002 },
+  { 2.3367461373176512, -0.39999999999999991, 0.50000000000000000 },
+  { 2.6186940209850191, -0.39999999999999991, 0.60000000000000009 },
+  { 3.0327078743873246, -0.39999999999999991, 0.70000000000000007 },
+  { 3.7289548002199902, -0.39999999999999991, 0.80000000000000004 },
+  { 5.3055535102872513, -0.39999999999999991, 0.90000000000000002 },
 };
+const double toler006 = 2.5000000000000020e-13;
 
-// Test function for k=-0.40000000000000002.
-template <typename Tp>
-void test006()
+// Test data for k=-0.29999999999999993.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.9274792319434433e-16
+// mean(f - f_Boost): 6.2172489379008762e-16
+// variance(f - f_Boost): 8.7651211691223537e-33
+// stddev(f - f_Boost): 9.3622225828712025e-17
+const testcase_comp_ellint_3<double>
+data007[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data006)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data006[i].k), Tp(data006[i].nu));
-      const Tp f0 = data006[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004.
-testcase_comp_ellint_3<double> data007[] = {
-  { 1.6080486199305126, -0.30000000000000004, 0.0000000000000000 },
-  { 1.5323534693557526, -0.30000000000000004, 0.10000000000000001 },
-  { 1.4663658145259875, -0.30000000000000004, 0.20000000000000001 },
-  { 1.4081767433479089, -0.30000000000000004, 0.29999999999999999 },
-  { 1.3563643538969761, -0.30000000000000004, 0.40000000000000002 },
-  { 1.3098448759814960, -0.30000000000000004, 0.50000000000000000 },
-  { 1.2677758800420666, -0.30000000000000004, 0.59999999999999998 },
-  { 1.2294913236274980, -0.30000000000000004, 0.69999999999999996 },
-  { 1.1944567571590046, -0.30000000000000004, 0.80000000000000004 },
-  { 1.1622376896064912, -0.30000000000000004, 0.90000000000000002 },
+  { 1.6080486199305128, -0.29999999999999993, 0.0000000000000000 },
+  { 1.6960848815118226, -0.29999999999999993, 0.10000000000000001 },
+  { 1.8002173372290500, -0.29999999999999993, 0.20000000000000001 },
+  { 1.9260216862473254, -0.29999999999999993, 0.30000000000000004 },
+  { 2.0822121773175533, -0.29999999999999993, 0.40000000000000002 },
+  { 2.2833505881933971, -0.29999999999999993, 0.50000000000000000 },
+  { 2.5560975528589065, -0.29999999999999993, 0.60000000000000009 },
+  { 2.9562123549913877, -0.29999999999999993, 0.70000000000000007 },
+  { 3.6283050484567170, -0.29999999999999993, 0.80000000000000004 },
+  { 5.1479514944016795, -0.29999999999999993, 0.90000000000000002 },
 };
+const double toler007 = 2.5000000000000020e-13;
 
-// Test function for k=-0.30000000000000004.
-template <typename Tp>
-void test007()
+// Test data for k=-0.19999999999999996.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.9753938705764407e-16
+// mean(f - f_Boost): 3.1086244689504381e-16
+// variance(f - f_Boost): 4.1147374377268827e-32
+// stddev(f - f_Boost): 2.0284815596220939e-16
+const testcase_comp_ellint_3<double>
+data008[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data007)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data007[i].k), Tp(data007[i].nu));
-      const Tp f0 = data007[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.19999999999999996.
-testcase_comp_ellint_3<double> data008[] = {
-  { 1.5868678474541664, -0.19999999999999996, 0.0000000000000000 },
-  { 1.5126513474261092, -0.19999999999999996, 0.10000000000000001 },
-  { 1.4479323932249568, -0.19999999999999996, 0.20000000000000001 },
-  { 1.3908453514752481, -0.19999999999999996, 0.29999999999999999 },
-  { 1.3400002519661010, -0.19999999999999996, 0.40000000000000002 },
-  { 1.2943374404397376, -0.19999999999999996, 0.50000000000000000 },
-  { 1.2530330675914561, -0.19999999999999996, 0.59999999999999998 },
-  { 1.2154356555075867, -0.19999999999999996, 0.69999999999999996 },
-  { 1.1810223448909913, -0.19999999999999996, 0.80000000000000004 },
-  { 1.1493679916141863, -0.19999999999999996, 0.90000000000000002 },
+  { 1.5868678474541662, -0.19999999999999996, 0.0000000000000000 },
+  { 1.6731552050562593, -0.19999999999999996, 0.10000000000000001 },
+  { 1.7751816279738935, -0.19999999999999996, 0.20000000000000001 },
+  { 1.8983924169967101, -0.19999999999999996, 0.30000000000000004 },
+  { 2.0512956926676806, -0.19999999999999996, 0.40000000000000002 },
+  { 2.2481046259421302, -0.19999999999999996, 0.50000000000000000 },
+  { 2.5148333891629315, -0.19999999999999996, 0.60000000000000009 },
+  { 2.9058704854500967, -0.19999999999999996, 0.70000000000000007 },
+  { 3.5622166386422633, -0.19999999999999996, 0.80000000000000004 },
+  { 5.0448269356200370, -0.19999999999999996, 0.90000000000000002 },
 };
+const double toler008 = 2.5000000000000020e-13;
 
-// Test function for k=-0.19999999999999996.
-template <typename Tp>
-void test008()
+// Test data for k=-0.099999999999999978.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 1.9932308021417639e-16
+// mean(f - f_Boost): 0.0000000000000000
+// variance(f - f_Boost): 6.8368087769470551e-64
+// stddev(f - f_Boost): 2.6147291976315738e-32
+const testcase_comp_ellint_3<double>
+data009[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data008)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data008[i].k), Tp(data008[i].nu));
-      const Tp f0 = data008[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.099999999999999978.
-testcase_comp_ellint_3<double> data009[] = {
-  { 1.5747455615173562, -0.099999999999999978, 0.0000000000000000 },
-  { 1.5013711111199950, -0.099999999999999978, 0.10000000000000001 },
-  { 1.4373749386463430, -0.099999999999999978, 0.20000000000000001 },
-  { 1.3809159606704959, -0.099999999999999978, 0.29999999999999999 },
-  { 1.3306223265207477, -0.099999999999999978, 0.40000000000000002 },
-  { 1.2854480708580160, -0.099999999999999978, 0.50000000000000000 },
-  { 1.2445798942989255, -0.099999999999999978, 0.59999999999999998 },
-  { 1.2073745911083187, -0.099999999999999978, 0.69999999999999996 },
-  { 1.1733158866987732, -0.099999999999999978, 0.80000000000000004 },
-  { 1.1419839485283374, -0.099999999999999978, 0.90000000000000002 },
+  { 1.5747455615173560, -0.099999999999999978, 0.0000000000000000 },
+  { 1.6600374067558428, -0.099999999999999978, 0.10000000000000001 },
+  { 1.7608656115083421, -0.099999999999999978, 0.20000000000000001 },
+  { 1.8826015946315438, -0.099999999999999978, 0.30000000000000004 },
+  { 2.0336367403076760, -0.099999999999999978, 0.40000000000000002 },
+  { 2.2279868912966849, -0.099999999999999978, 0.50000000000000000 },
+  { 2.4913004919173827, -0.099999999999999978, 0.60000000000000009 },
+  { 2.8771910188009744, -0.099999999999999978, 0.70000000000000007 },
+  { 3.5246199613295617, -0.099999999999999978, 0.80000000000000004 },
+  { 4.9862890417305508, -0.099999999999999978, 0.90000000000000002 },
 };
+const double toler009 = 2.5000000000000020e-13;
 
-// Test function for k=-0.099999999999999978.
-template <typename Tp>
-void test009()
+// Test data for k=0.0000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.1899085000907084e-16
+// mean(f - f_Boost): -2.2204460492503131e-16
+// variance(f - f_Boost): 5.4782007307014711e-32
+// stddev(f - f_Boost): 2.3405556457178008e-16
+const testcase_comp_ellint_3<double>
+data010[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data009)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data009[i].k), Tp(data009[i].nu));
-      const Tp f0 = data009[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.0000000000000000.
-testcase_comp_ellint_3<double> data010[] = {
   { 1.5707963267948966, 0.0000000000000000, 0.0000000000000000 },
-  { 1.4976955329233277, 0.0000000000000000, 0.10000000000000001 },
-  { 1.4339343023863691, 0.0000000000000000, 0.20000000000000001 },
-  { 1.3776795151134889, 0.0000000000000000, 0.29999999999999999 },
-  { 1.3275651989026322, 0.0000000000000000, 0.40000000000000002 },
-  { 1.2825498301618641, 0.0000000000000000, 0.50000000000000000 },
-  { 1.2418235332245127, 0.0000000000000000, 0.59999999999999998 },
-  { 1.2047457872617382, 0.0000000000000000, 0.69999999999999996 },
-  { 1.1708024551734544, 0.0000000000000000, 0.80000000000000004 },
-  { 1.1395754288497419, 0.0000000000000000, 0.90000000000000002 },
+  { 1.6557647109660170, 0.0000000000000000, 0.10000000000000001 },
+  { 1.7562036827601817, 0.0000000000000000, 0.20000000000000001 },
+  { 1.8774607092226381, 0.0000000000000000, 0.30000000000000004 },
+  { 2.0278893379868062, 0.0000000000000000, 0.40000000000000002 },
+  { 2.2214414690791831, 0.0000000000000000, 0.50000000000000000 },
+  { 2.4836470664490258, 0.0000000000000000, 0.60000000000000009 },
+  { 2.8678686047727386, 0.0000000000000000, 0.70000000000000007 },
+  { 3.5124073655203634, 0.0000000000000000, 0.80000000000000004 },
+  { 4.9672941328980516, 0.0000000000000000, 0.90000000000000002 },
 };
+const double toler010 = 2.5000000000000020e-13;
 
-// Test function for k=0.0000000000000000.
-template <typename Tp>
-void test010()
+// Test data for k=0.10000000000000009.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 1.9932308021417639e-16
+// mean(f - f_Boost): -2.2204460492503132e-17
+// variance(f - f_Boost): 6.0868897007794120e-35
+// stddev(f - f_Boost): 7.8018521523926693e-18
+const testcase_comp_ellint_3<double>
+data011[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data010)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data010[i].k), Tp(data010[i].nu));
-      const Tp f0 = data010[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.10000000000000009.
-testcase_comp_ellint_3<double> data011[] = {
-  { 1.5747455615173562, 0.10000000000000009, 0.0000000000000000 },
-  { 1.5013711111199950, 0.10000000000000009, 0.10000000000000001 },
-  { 1.4373749386463430, 0.10000000000000009, 0.20000000000000001 },
-  { 1.3809159606704959, 0.10000000000000009, 0.29999999999999999 },
-  { 1.3306223265207477, 0.10000000000000009, 0.40000000000000002 },
-  { 1.2854480708580160, 0.10000000000000009, 0.50000000000000000 },
-  { 1.2445798942989255, 0.10000000000000009, 0.59999999999999998 },
-  { 1.2073745911083187, 0.10000000000000009, 0.69999999999999996 },
-  { 1.1733158866987732, 0.10000000000000009, 0.80000000000000004 },
-  { 1.1419839485283374, 0.10000000000000009, 0.90000000000000002 },
+  { 1.5747455615173560, 0.10000000000000009, 0.0000000000000000 },
+  { 1.6600374067558428, 0.10000000000000009, 0.10000000000000001 },
+  { 1.7608656115083421, 0.10000000000000009, 0.20000000000000001 },
+  { 1.8826015946315440, 0.10000000000000009, 0.30000000000000004 },
+  { 2.0336367403076760, 0.10000000000000009, 0.40000000000000002 },
+  { 2.2279868912966849, 0.10000000000000009, 0.50000000000000000 },
+  { 2.4913004919173827, 0.10000000000000009, 0.60000000000000009 },
+  { 2.8771910188009744, 0.10000000000000009, 0.70000000000000007 },
+  { 3.5246199613295617, 0.10000000000000009, 0.80000000000000004 },
+  { 4.9862890417305508, 0.10000000000000009, 0.90000000000000002 },
 };
+const double toler011 = 2.5000000000000020e-13;
 
-// Test function for k=0.10000000000000009.
-template <typename Tp>
-void test011()
+// Test data for k=0.20000000000000018.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.9753938705764407e-16
+// mean(f - f_Boost): 3.1086244689504381e-16
+// variance(f - f_Boost): 4.1147374377268827e-32
+// stddev(f - f_Boost): 2.0284815596220939e-16
+const testcase_comp_ellint_3<double>
+data012[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data011)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data011[i].k), Tp(data011[i].nu));
-      const Tp f0 = data011[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996.
-testcase_comp_ellint_3<double> data012[] = {
-  { 1.5868678474541664, 0.19999999999999996, 0.0000000000000000 },
-  { 1.5126513474261092, 0.19999999999999996, 0.10000000000000001 },
-  { 1.4479323932249568, 0.19999999999999996, 0.20000000000000001 },
-  { 1.3908453514752481, 0.19999999999999996, 0.29999999999999999 },
-  { 1.3400002519661010, 0.19999999999999996, 0.40000000000000002 },
-  { 1.2943374404397376, 0.19999999999999996, 0.50000000000000000 },
-  { 1.2530330675914561, 0.19999999999999996, 0.59999999999999998 },
-  { 1.2154356555075867, 0.19999999999999996, 0.69999999999999996 },
-  { 1.1810223448909913, 0.19999999999999996, 0.80000000000000004 },
-  { 1.1493679916141863, 0.19999999999999996, 0.90000000000000002 },
+  { 1.5868678474541662, 0.20000000000000018, 0.0000000000000000 },
+  { 1.6731552050562593, 0.20000000000000018, 0.10000000000000001 },
+  { 1.7751816279738935, 0.20000000000000018, 0.20000000000000001 },
+  { 1.8983924169967101, 0.20000000000000018, 0.30000000000000004 },
+  { 2.0512956926676806, 0.20000000000000018, 0.40000000000000002 },
+  { 2.2481046259421302, 0.20000000000000018, 0.50000000000000000 },
+  { 2.5148333891629315, 0.20000000000000018, 0.60000000000000009 },
+  { 2.9058704854500967, 0.20000000000000018, 0.70000000000000007 },
+  { 3.5622166386422633, 0.20000000000000018, 0.80000000000000004 },
+  { 5.0448269356200370, 0.20000000000000018, 0.90000000000000002 },
 };
+const double toler012 = 2.5000000000000020e-13;
 
-// Test function for k=0.19999999999999996.
-template <typename Tp>
-void test012()
+// Test data for k=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.4585997630846713e-16
+// mean(f - f_Boost): 5.1070259132757197e-16
+// variance(f - f_Boost): 1.7591111235252501e-32
+// stddev(f - f_Boost): 1.3263148659067538e-16
+const testcase_comp_ellint_3<double>
+data013[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data012)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data012[i].k), Tp(data012[i].nu));
-      const Tp f0 = data012[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.30000000000000004.
-testcase_comp_ellint_3<double> data013[] = {
-  { 1.6080486199305126, 0.30000000000000004, 0.0000000000000000 },
-  { 1.5323534693557526, 0.30000000000000004, 0.10000000000000001 },
-  { 1.4663658145259875, 0.30000000000000004, 0.20000000000000001 },
-  { 1.4081767433479089, 0.30000000000000004, 0.29999999999999999 },
-  { 1.3563643538969761, 0.30000000000000004, 0.40000000000000002 },
-  { 1.3098448759814960, 0.30000000000000004, 0.50000000000000000 },
-  { 1.2677758800420666, 0.30000000000000004, 0.59999999999999998 },
-  { 1.2294913236274980, 0.30000000000000004, 0.69999999999999996 },
-  { 1.1944567571590046, 0.30000000000000004, 0.80000000000000004 },
-  { 1.1622376896064912, 0.30000000000000004, 0.90000000000000002 },
+  { 1.6080486199305128, 0.30000000000000004, 0.0000000000000000 },
+  { 1.6960848815118228, 0.30000000000000004, 0.10000000000000001 },
+  { 1.8002173372290500, 0.30000000000000004, 0.20000000000000001 },
+  { 1.9260216862473254, 0.30000000000000004, 0.30000000000000004 },
+  { 2.0822121773175533, 0.30000000000000004, 0.40000000000000002 },
+  { 2.2833505881933975, 0.30000000000000004, 0.50000000000000000 },
+  { 2.5560975528589065, 0.30000000000000004, 0.60000000000000009 },
+  { 2.9562123549913877, 0.30000000000000004, 0.70000000000000007 },
+  { 3.6283050484567174, 0.30000000000000004, 0.80000000000000004 },
+  { 5.1479514944016795, 0.30000000000000004, 0.90000000000000002 },
 };
+const double toler013 = 2.5000000000000020e-13;
 
-// Test function for k=0.30000000000000004.
-template <typename Tp>
-void test013()
+// Test data for k=0.40000000000000013.
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.7696531428672557e-16
+// mean(f - f_Boost): 1.1990408665951691e-15
+// variance(f - f_Boost): 2.6514491536595121e-31
+// stddev(f - f_Boost): 5.1492224205791612e-16
+const testcase_comp_ellint_3<double>
+data014[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data013)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data013[i].k), Tp(data013[i].nu));
-      const Tp f0 = data013[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991.
-testcase_comp_ellint_3<double> data014[] = {
-  { 1.6399998658645112, 0.39999999999999991, 0.0000000000000000 },
-  { 1.5620566886683604, 0.39999999999999991, 0.10000000000000001 },
-  { 1.4941414344266770, 0.39999999999999991, 0.20000000000000001 },
-  { 1.4342789859950078, 0.39999999999999991, 0.29999999999999999 },
-  { 1.3809986210732901, 0.39999999999999991, 0.40000000000000002 },
-  { 1.3331797176377398, 0.39999999999999991, 0.50000000000000000 },
-  { 1.2899514672527024, 0.39999999999999991, 0.59999999999999998 },
-  { 1.2506255923253344, 0.39999999999999991, 0.69999999999999996 },
-  { 1.2146499565727209, 0.39999999999999991, 0.80000000000000004 },
-  { 1.1815758115929846, 0.39999999999999991, 0.90000000000000002 },
+  { 1.6399998658645112, 0.40000000000000013, 0.0000000000000000 },
+  { 1.7306968836847190, 0.40000000000000013, 0.10000000000000001 },
+  { 1.8380358826317629, 0.40000000000000013, 0.20000000000000001 },
+  { 1.9677924132520141, 0.40000000000000013, 0.30000000000000004 },
+  { 2.1289968719280030, 0.40000000000000013, 0.40000000000000002 },
+  { 2.3367461373176512, 0.40000000000000013, 0.50000000000000000 },
+  { 2.6186940209850196, 0.40000000000000013, 0.60000000000000009 },
+  { 3.0327078743873246, 0.40000000000000013, 0.70000000000000007 },
+  { 3.7289548002199906, 0.40000000000000013, 0.80000000000000004 },
+  { 5.3055535102872522, 0.40000000000000013, 0.90000000000000002 },
 };
+const double toler014 = 2.5000000000000020e-13;
 
-// Test function for k=0.39999999999999991.
-template <typename Tp>
-void test014()
+// Test data for k=0.50000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 3
+// max(|f - f_Boost| / |f_Boost|): 2.1900131385114407e-16
+// mean(f - f_Boost): 2.4424906541753446e-16
+// variance(f - f_Boost): 7.3651365379430888e-33
+// stddev(f - f_Boost): 8.5820373676319358e-17
+const testcase_comp_ellint_3<double>
+data015[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data014)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data014[i].k), Tp(data014[i].nu));
-      const Tp f0 = data014[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.50000000000000000.
-testcase_comp_ellint_3<double> data015[] = {
-  { 1.6857503548125963, 0.50000000000000000, 0.0000000000000000 },
-  { 1.6045524936084892, 0.50000000000000000, 0.10000000000000001 },
-  { 1.5338490483665983, 0.50000000000000000, 0.20000000000000001 },
-  { 1.4715681939859637, 0.50000000000000000, 0.29999999999999999 },
-  { 1.4161679518465340, 0.50000000000000000, 0.40000000000000002 },
-  { 1.3664739530045971, 0.50000000000000000, 0.50000000000000000 },
-  { 1.3215740290190876, 0.50000000000000000, 0.59999999999999998 },
-  { 1.2807475181182502, 0.50000000000000000, 0.69999999999999996 },
-  { 1.2434165408189539, 0.50000000000000000, 0.80000000000000004 },
-  { 1.2091116095504744, 0.50000000000000000, 0.90000000000000002 },
+  { 1.6857503548125961, 0.50000000000000000, 0.0000000000000000 },
+  { 1.7803034946545482, 0.50000000000000000, 0.10000000000000001 },
+  { 1.8922947612264021, 0.50000000000000000, 0.20000000000000001 },
+  { 2.0277924458111314, 0.50000000000000000, 0.30000000000000004 },
+  { 2.1962905366178065, 0.50000000000000000, 0.40000000000000002 },
+  { 2.4136715042011945, 0.50000000000000000, 0.50000000000000000 },
+  { 2.7090491861753558, 0.50000000000000000, 0.60000000000000009 },
+  { 3.1433945297859229, 0.50000000000000000, 0.70000000000000007 },
+  { 3.8750701888108070, 0.50000000000000000, 0.80000000000000004 },
+  { 5.5355132096026463, 0.50000000000000000, 0.90000000000000002 },
 };
+const double toler015 = 2.5000000000000020e-13;
 
-// Test function for k=0.50000000000000000.
-template <typename Tp>
-void test015()
+// Test data for k=0.60000000000000009.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 2
+// max(|f - f_Boost| / |f_Boost|): 2.2547200163366559e-16
+// mean(f - f_Boost): -2.2204460492503131e-16
+// variance(f - f_Boost): 6.0868897007794117e-33
+// stddev(f - f_Boost): 7.8018521523926690e-17
+const testcase_comp_ellint_3<double>
+data016[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data015)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data015[i].k), Tp(data015[i].nu));
-      const Tp f0 = data015[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.60000000000000009.
-testcase_comp_ellint_3<double> data016[] = {
   { 1.7507538029157526, 0.60000000000000009, 0.0000000000000000 },
-  { 1.6648615773343014, 0.60000000000000009, 0.10000000000000001 },
-  { 1.5901418016279374, 0.60000000000000009, 0.20000000000000001 },
-  { 1.5243814243493585, 0.60000000000000009, 0.29999999999999999 },
-  { 1.4659345278069984, 0.60000000000000009, 0.40000000000000002 },
-  { 1.4135484285693078, 0.60000000000000009, 0.50000000000000000 },
-  { 1.3662507535812816, 0.60000000000000009, 0.59999999999999998 },
-  { 1.3232737468822811, 0.60000000000000009, 0.69999999999999996 },
-  { 1.2840021261752192, 0.60000000000000009, 0.80000000000000004 },
-  { 1.2479362973851875, 0.60000000000000009, 0.90000000000000002 },
+  { 1.8508766487100687, 0.60000000000000009, 0.10000000000000001 },
+  { 1.9695980282802217, 0.60000000000000009, 0.20000000000000001 },
+  { 2.1134154405060599, 0.60000000000000009, 0.30000000000000004 },
+  { 2.2925036420985130, 0.60000000000000009, 0.40000000000000002 },
+  { 2.5239007084492711, 0.60000000000000009, 0.50000000000000000 },
+  { 2.8388723099514976, 0.60000000000000009, 0.60000000000000009 },
+  { 3.3029735898397159, 0.60000000000000009, 0.70000000000000007 },
+  { 4.0867036409261832, 0.60000000000000009, 0.80000000000000004 },
+  { 5.8709993116265613, 0.60000000000000009, 0.90000000000000002 },
 };
+const double toler016 = 2.5000000000000020e-13;
 
-// Test function for k=0.60000000000000009.
-template <typename Tp>
-void test016()
+// Test data for k=0.70000000000000018.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.9298727220933567e-16
+// mean(f - f_Boost): 4.8849813083506892e-16
+// variance(f - f_Boost): 2.0476296953421943e-31
+// stddev(f - f_Boost): 4.5250742483877478e-16
+const testcase_comp_ellint_3<double>
+data017[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data016)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data016[i].k), Tp(data016[i].nu));
-      const Tp f0 = data016[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996.
-testcase_comp_ellint_3<double> data017[] = {
-  { 1.8456939983747236, 0.69999999999999996, 0.0000000000000000 },
-  { 1.7528050171757608, 0.69999999999999996, 0.10000000000000001 },
-  { 1.6721098780092147, 0.69999999999999996, 0.20000000000000001 },
-  { 1.6011813647733213, 0.69999999999999996, 0.29999999999999999 },
-  { 1.5382162002954762, 0.69999999999999996, 0.40000000000000002 },
-  { 1.4818433192178544, 0.69999999999999996, 0.50000000000000000 },
-  { 1.4309994736080540, 0.69999999999999996, 0.59999999999999998 },
-  { 1.3848459188329196, 0.69999999999999996, 0.69999999999999996 },
-  { 1.3427110650397533, 0.69999999999999996, 0.80000000000000004 },
-  { 1.3040500499695911, 0.69999999999999996, 0.90000000000000002 },
+  { 1.8456939983747238, 0.70000000000000018, 0.0000000000000000 },
+  { 1.9541347343119566, 0.70000000000000018, 0.10000000000000001 },
+  { 2.0829290325820207, 0.70000000000000018, 0.20000000000000001 },
+  { 2.2392290510988540, 0.70000000000000018, 0.30000000000000004 },
+  { 2.4342502915307880, 0.70000000000000018, 0.40000000000000002 },
+  { 2.6868019968237000, 0.70000000000000018, 0.50000000000000000 },
+  { 3.0314573496746746, 0.70000000000000018, 0.60000000000000009 },
+  { 3.5408408771788569, 0.70000000000000018, 0.70000000000000007 },
+  { 4.4042405729076970, 0.70000000000000018, 0.80000000000000004 },
+  { 6.3796094177887763, 0.70000000000000018, 0.90000000000000002 },
 };
+const double toler017 = 2.5000000000000020e-13;
 
-// Test function for k=0.69999999999999996.
-template <typename Tp>
-void test017()
+// Test data for k=0.80000000000000004.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.1949393471095187e-16
+// mean(f - f_Boost): 9.5479180117763459e-16
+// variance(f - f_Boost): 5.4782007307014711e-34
+// stddev(f - f_Boost): 2.3405556457178006e-17
+const testcase_comp_ellint_3<double>
+data018[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data017)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data017[i].k), Tp(data017[i].nu));
-      const Tp f0 = data017[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.80000000000000004.
-testcase_comp_ellint_3<double> data018[] = {
-  { 1.9953027776647296, 0.80000000000000004, 0.0000000000000000 },
-  { 1.8910755418379521, 0.80000000000000004, 0.10000000000000001 },
-  { 1.8007226661734588, 0.80000000000000004, 0.20000000000000001 },
-  { 1.7214611048717301, 0.80000000000000004, 0.29999999999999999 },
-  { 1.6512267838651289, 0.80000000000000004, 0.40000000000000002 },
-  { 1.5884528947755532, 0.80000000000000004, 0.50000000000000000 },
-  { 1.5319262547427865, 0.80000000000000004, 0.59999999999999998 },
-  { 1.4806912324625332, 0.80000000000000004, 0.69999999999999996 },
-  { 1.4339837018309474, 0.80000000000000004, 0.80000000000000004 },
-  { 1.3911845406776222, 0.80000000000000004, 0.90000000000000002 },
+  { 1.9953027776647294, 0.80000000000000004, 0.0000000000000000 },
+  { 2.1172616484005085, 0.80000000000000004, 0.10000000000000001 },
+  { 2.2624789434186798, 0.80000000000000004, 0.20000000000000001 },
+  { 2.4392042002725698, 0.80000000000000004, 0.30000000000000004 },
+  { 2.6604037035529728, 0.80000000000000004, 0.40000000000000002 },
+  { 2.9478781158239751, 0.80000000000000004, 0.50000000000000000 },
+  { 3.3418121892288055, 0.80000000000000004, 0.60000000000000009 },
+  { 3.9268876980046397, 0.80000000000000004, 0.70000000000000007 },
+  { 4.9246422058196071, 0.80000000000000004, 0.80000000000000004 },
+  { 7.2263259298637132, 0.80000000000000004, 0.90000000000000002 },
 };
+const double toler018 = 2.5000000000000020e-13;
 
-// Test function for k=0.80000000000000004.
-template <typename Tp>
-void test018()
+// Test data for k=0.90000000000000013.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 3
+// max(|f - f_Boost| / |f_Boost|): 1.5716352001310461e-16
+// mean(f - f_Boost): 4.4408920985006264e-17
+// variance(f - f_Boost): 2.4347558803117648e-34
+// stddev(f - f_Boost): 1.5603704304785339e-17
+const testcase_comp_ellint_3<double>
+data019[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data018)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data018[i].k), Tp(data018[i].nu));
-      const Tp f0 = data018[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991.
-testcase_comp_ellint_3<double> data019[] = {
-  { 2.2805491384227699, 0.89999999999999991, 0.0000000000000000 },
-  { 2.1537868513875282, 0.89999999999999991, 0.10000000000000001 },
-  { 2.0443194576468890, 0.89999999999999991, 0.20000000000000001 },
-  { 1.9486280260314424, 0.89999999999999991, 0.29999999999999999 },
-  { 1.8641114227238347, 0.89999999999999991, 0.40000000000000002 },
-  { 1.7888013241937859, 0.89999999999999991, 0.50000000000000000 },
-  { 1.7211781128919521, 0.89999999999999991, 0.59999999999999998 },
-  { 1.6600480747670936, 0.89999999999999991, 0.69999999999999996 },
-  { 1.6044591960982200, 0.89999999999999991, 0.80000000000000004 },
-  { 1.5536420236310944, 0.89999999999999991, 0.90000000000000002 },
+  { 2.2805491384227707, 0.90000000000000013, 0.0000000000000000 },
+  { 2.4295011187834890, 0.90000000000000013, 0.10000000000000001 },
+  { 2.6076835743348421, 0.90000000000000013, 0.20000000000000001 },
+  { 2.8256506968858521, 0.90000000000000013, 0.30000000000000004 },
+  { 3.1000689868578628, 0.90000000000000013, 0.40000000000000002 },
+  { 3.4591069002104686, 0.90000000000000013, 0.50000000000000000 },
+  { 3.9549939883570242, 0.90000000000000013, 0.60000000000000009 },
+  { 4.6985482312992453, 0.90000000000000013, 0.70000000000000007 },
+  { 5.9820740813645727, 0.90000000000000013, 0.80000000000000004 },
+  { 8.9942562031858735, 0.90000000000000013, 0.90000000000000002 },
 };
+const double toler019 = 2.5000000000000020e-13;
 
-// Test function for k=0.89999999999999991.
-template <typename Tp>
-void test019()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data019)
-                         / sizeof(testcase_comp_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::comp_ellint_3(Tp(data019[i].k), Tp(data019[i].nu));
-      const Tp f0 = data019[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+template<typename Ret, unsigned int Num>
+  void
+  test(const testcase_comp_ellint_3<Ret> (&data)[Num], Ret toler)
+  {
+    bool test __attribute__((unused)) = true;
+    const Ret eps = std::numeric_limits<Ret>::epsilon();
+    Ret max_abs_diff = -Ret(1);
+    Ret max_abs_frac = -Ret(1);
+    unsigned int num_datum = Num;
+    for (unsigned int i = 0; i < num_datum; ++i)
+      {
+	const Ret f = std::tr1::comp_ellint_3(data[i].k, data[i].nu);
+	const Ret f0 = data[i].f0;
+	const Ret diff = f - f0;
+	if (std::abs(diff) > max_abs_diff)
+	  max_abs_diff = std::abs(diff);
+	if (std::abs(f0) > Ret(10) * eps
+	 && std::abs(f) > Ret(10) * eps)
+	  {
+	    const Ret frac = diff / f0;
+	    if (std::abs(frac) > max_abs_frac)
+	      max_abs_frac = std::abs(frac);
+	  }
+      }
+    VERIFY(max_abs_frac < toler);
+  }
 
-int main(int, char**)
+int
+main()
 {
-  test001<double>();
-  test002<double>();
-  test003<double>();
-  test004<double>();
-  test005<double>();
-  test006<double>();
-  test007<double>();
-  test008<double>();
-  test009<double>();
-  test010<double>();
-  test011<double>();
-  test012<double>();
-  test013<double>();
-  test014<double>();
-  test015<double>();
-  test016<double>();
-  test017<double>();
-  test018<double>();
-  test019<double>();
+  test(data001, toler001);
+  test(data002, toler002);
+  test(data003, toler003);
+  test(data004, toler004);
+  test(data005, toler005);
+  test(data006, toler006);
+  test(data007, toler007);
+  test(data008, toler008);
+  test(data009, toler009);
+  test(data010, toler010);
+  test(data011, toler011);
+  test(data012, toler012);
+  test(data013, toler013);
+  test(data014, toler014);
+  test(data015, toler015);
+  test(data016, toler016);
+  test(data017, toler017);
+  test(data018, toler018);
+  test(data019, toler019);
   return 0;
 }
Index: libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/15_expint/pr68397.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/15_expint/pr68397.cc b/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/15_expint/pr68397.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/15_expint/pr68397.cc	(revision 262353)
@@ -0,0 +1,46 @@
+// Copyright (C) 2017 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// PR libstdc++/68397 -  std::tr1::expint fails in __expint_En_cont_frac
+// for some long double arguments due to low __max_iter value
+
+#include <tr1/cmath>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  // Answers from Wolfram Alpha.
+  long double ans_ok = -0.10001943365331651406888645149537315243646135979573L;
+  long double ans_bomb = -0.10777727809650077516264612749163100483995270163783L;
+
+  long double Ei_ok = std::tr1::expint(-1.500001L);
+  long double diff_ok = std::abs(Ei_ok - ans_ok);
+  VERIFY(diff_ok < 1.0e-15L);
+
+  long double Ei_bomb = std::tr1::expint(-1.450001L);
+  long double diff_bomb = std::abs(Ei_bomb - ans_bomb);
+  VERIFY(diff_bomb < 1.0e-15L);
+}
+
+int
+main()
+{
+  test01();
+  return 0;
+}
+
Index: libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/pr66689.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/pr66689.cc b/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/pr66689.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/pr66689.cc	(revision 262353)
@@ -0,0 +1,22 @@
+
+#include <tr1/cmath>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  const double pi = 3.141592654;
+
+  double Pi1 = std::tr1::ellint_3(0.75, 0.0, pi / 2.0);
+  VERIFY(std::abs(Pi1 - 1.91099) < 0.00001);
+
+  double Pi2 = std::tr1::ellint_3(0.75, 0.5, pi / 2.0);
+  VERIFY(std::abs(Pi2 - 2.80011) < 0.00001);
+}
+
+int
+main()
+{
+  test01();
+  return 0;
+}
Index: libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/check_value.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/check_value.cc b/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/check_value.cc
--- a/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/check_value.cc	(revision 262353)
+++ b/libstdc++-v3/testsuite/tr1/5_numerical_facilities/special_functions/14_ellint_3/check_value.cc	(revision 262353)
@@ -1,6 +1,7 @@
-// 2007-02-04  Edward Smith-Rowland <3dw4rd@verizon.net>
+// { dg-do run { target c++11 } }
+// { dg-options "-D__STDCPP_WANT_MATH_SPEC_FUNCS__" }
 //
-// Copyright (C) 2007-2017 Free Software Foundation, Inc.
+// Copyright (C) 2016-2018 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -18,10098 +19,6324 @@
 // <http://www.gnu.org/licenses/>.
 
 //  ellint_3
-
-
 //  Compare against values generated by the GNU Scientific Library.
 //  The GSL can be found on the web: http://www.gnu.org/software/gsl/
-
+#include <limits>
 #include <tr1/cmath>
 #if defined(__TEST_DEBUG)
-#include <iostream>
-#define VERIFY(A) \
-if (!(A)) \
-  { \
-    std::cout << "line " << __LINE__ \
-      << "  max_abs_frac = " << max_abs_frac \
-      << std::endl; \
-  }
+#  include <iostream>
+#  define VERIFY(A) \
+  if (!(A)) \
+    { \
+      std::cout << "line " << __LINE__ \
+	<< "  max_abs_frac = " << max_abs_frac \
+	<< std::endl; \
+    }
 #else
-#include <testsuite_hooks.h>
+#  include <testsuite_hooks.h>
 #endif
-#include "../testcase.h"
+#include <specfun_testcase.h>
 
-
 // Test data for k=-0.90000000000000002, nu=0.0000000000000000.
-testcase_ellint_3<double> data001[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17525427376115027, -0.90000000000000002, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35492464591297446, -0.90000000000000002, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.54388221416157134, -0.90000000000000002, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.74797400423532523, -0.90000000000000002, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.97463898451966458, -0.90000000000000002, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.2334463254523440, -0.90000000000000002, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.5355247765594910, -0.90000000000000002, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.8882928567775124, -0.90000000000000002, 0.0000000000000000,
-          1.3962634015954636 },
-  { 2.2805491384227703, -0.90000000000000002, 0.0000000000000000,
-          1.5707963267948966 },
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 5.7842011620951154e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 4.1942474344433133e-34
+// stddev(f - f_Boost): 2.0479861900030756e-17
+const testcase_ellint_3<double>
+data001[10] =
+{
+  { 0.0000000000000000, -0.90000000000000002, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17525427376115027, -0.90000000000000002, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35492464591297446, -0.90000000000000002, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.54388221416157123, -0.90000000000000002, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.74797400423532512, -0.90000000000000002, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.97463898451966446, -0.90000000000000002, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.2334463254523438, -0.90000000000000002, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.5355247765594913, -0.90000000000000002, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.8882928567775126, -0.90000000000000002, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 2.2805491384227703, -0.90000000000000002, 0.0000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler001 = 2.5000000000000020e-13;
 
-// Test function for k=-0.90000000000000002, nu=0.0000000000000000.
-template <typename Tp>
-void test001()
+// Test data for k=-0.90000000000000002, nu=0.10000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.1500594295134815e-16
+// mean(f - f_Boost): 1.0269562977782698e-16
+// variance(f - f_Boost): 1.4388836606733082e-32
+// stddev(f - f_Boost): 1.1995347684303728e-16
+const testcase_ellint_3<double>
+data002[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data001)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data001[i].k), Tp(data001[i].nu),
-                   Tp(data001[i].phi));
-      const Tp f0 = data001[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.90000000000000002, nu=0.10000000000000001.
-testcase_ellint_3<double> data002[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17507714233254659, -0.90000000000000002, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.35350932904326521, -0.90000000000000002, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.53911129989870998, -0.90000000000000002, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.73666644254508429, -0.90000000000000002, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.95250736612100184, -0.90000000000000002, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.1950199550905594, -0.90000000000000002, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.4741687286340848, -0.90000000000000002, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.7968678183506059, -0.90000000000000002, 0.10000000000000001,
-          1.3962634015954636 },
-  { 2.1537868513875287, -0.90000000000000002, 0.10000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.90000000000000002, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17543204932716244, -0.90000000000000002, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35636022898551184, -0.90000000000000002, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.54880278898382584, -0.90000000000000002, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.75988834774529268, -0.90000000000000002, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.99853303003568117, -0.90000000000000002, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.2759958823999022, -0.90000000000000002, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.6051187364639401, -0.90000000000000002, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.9941406879519472, -0.90000000000000002, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 2.4295011187834881, -0.90000000000000002, 0.10000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler002 = 2.5000000000000020e-13;
 
-// Test function for k=-0.90000000000000002, nu=0.10000000000000001.
-template <typename Tp>
-void test002()
+// Test data for k=-0.90000000000000002, nu=0.20000000000000001.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 5.2711357908578066e-16
+// mean(f - f_Boost): 8.0491169285323847e-17
+// variance(f - f_Boost): 7.9985534974304465e-34
+// stddev(f - f_Boost): 2.8281714052423424e-17
+const testcase_ellint_3<double>
+data003[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data002)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data002[i].k), Tp(data002[i].nu),
-                   Tp(data002[i].phi));
-      const Tp f0 = data002[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.90000000000000002, nu=0.20000000000000001.
-testcase_ellint_3<double> data003[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17490065089140930, -0.90000000000000002, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.35211377590661436, -0.90000000000000002, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.53448220334204122, -0.90000000000000002, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.72591368943179613, -0.90000000000000002, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.93192539780038763, -0.90000000000000002, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.1600809679692683, -0.90000000000000002, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.4195407225882508, -0.90000000000000002, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.7168966476424528, -0.90000000000000002, 0.20000000000000001,
-          1.3962634015954636 },
-  { 2.0443194576468890, -0.90000000000000002, 0.20000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.90000000000000002, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17561047321968409, -0.90000000000000002, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35781659944356109, -0.90000000000000002, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.55388150905215283, -0.90000000000000002, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.77246874123251441, -0.90000000000000002, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 1.0244466254771925, -0.90000000000000002, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.3234824077640801, -0.90000000000000002, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.6849848968804237, -0.90000000000000002, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 2.1185749045502273, -0.90000000000000002, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 2.6076835743348412, -0.90000000000000002, 0.20000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler003 = 2.5000000000000020e-13;
 
-// Test function for k=-0.90000000000000002, nu=0.20000000000000001.
-template <typename Tp>
-void test003()
+// Test data for k=-0.90000000000000002, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.9955372494296814e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 4.1942474344433133e-34
+// stddev(f - f_Boost): 2.0479861900030756e-17
+const testcase_ellint_3<double>
+data004[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data003)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data003[i].k), Tp(data003[i].nu),
-                   Tp(data003[i].phi));
-      const Tp f0 = data003[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.90000000000000002, nu=0.29999999999999999.
-testcase_ellint_3<double> data004[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17472479532647534, -0.90000000000000002, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.35073750187374114, -0.90000000000000002, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.52998766129466979, -0.90000000000000002, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.71566993548699587, -0.90000000000000002, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.91271517762560195, -0.90000000000000002, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.1281241199843370, -0.90000000000000002, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.3704929576917448, -0.90000000000000002, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.6461981511487715, -0.90000000000000002, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.9486280260314426, -0.90000000000000002, 0.29999999999999999,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.90000000000000002, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17578954966746221, -0.90000000000000002, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35929429810867447, -0.90000000000000002, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.55912757154240811, -0.90000000000000002, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.78578314722025389, -0.90000000000000002, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 1.0526941001131365, -0.90000000000000002, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.3769682234538601, -0.90000000000000002, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.7779437432911238, -0.90000000000000002, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 2.2676509341813631, -0.90000000000000002, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.8256506968858512, -0.90000000000000002, 0.30000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler004 = 2.5000000000000020e-13;
 
-// Test function for k=-0.90000000000000002, nu=0.29999999999999999.
-template <typename Tp>
-void test004()
+// Test data for k=-0.90000000000000002, nu=0.40000000000000002.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.7042235432234642e-16
+// mean(f - f_Boost): 2.0261570199409106e-16
+// variance(f - f_Boost): 5.8024227149195491e-32
+// stddev(f - f_Boost): 2.4088218520512364e-16
+const testcase_ellint_3<double>
+data005[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data004)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data004[i].k), Tp(data004[i].nu),
-                   Tp(data004[i].phi));
-      const Tp f0 = data004[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.90000000000000002, nu=0.40000000000000002.
-testcase_ellint_3<double> data005[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17454957156468839, -0.90000000000000002, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34938003933330430, -0.90000000000000002, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.52562093533067455, -0.90000000000000002, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.70589461324915703, -0.90000000000000002, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.89472658511942849, -0.90000000000000002, 0.40000000000000002,
-          0.87266462599716477 },
-  { 1.0987419542323440, -0.90000000000000002, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.3261349565496301, -0.90000000000000002, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.5831293909853767, -0.90000000000000002, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.8641114227238349, -0.90000000000000002, 0.40000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.90000000000000002, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17596928293938452, -0.90000000000000002, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.36079388642472821, -0.90000000000000002, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.56455096667115612, -0.90000000000000002, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.79990996997869435, -0.90000000000000002, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 1.0836647913872215, -0.90000000000000002, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.4378726836091849, -0.90000000000000002, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.8880446720682853, -0.90000000000000002, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 2.4505848932025227, -0.90000000000000002, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 3.1000689868578615, -0.90000000000000002, 0.40000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler005 = 2.5000000000000020e-13;
 
-// Test function for k=-0.90000000000000002, nu=0.40000000000000002.
-template <typename Tp>
-void test005()
+// Test data for k=-0.90000000000000002, nu=0.50000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 3.8944086593755267e-16
+// mean(f - f_Boost): 6.9388939039072284e-17
+// variance(f - f_Boost): 1.7333369499485123e-32
+// stddev(f - f_Boost): 1.3165625507162629e-16
+const testcase_ellint_3<double>
+data006[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data005)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data005[i].k), Tp(data005[i].nu),
-                   Tp(data005[i].phi));
-      const Tp f0 = data005[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.90000000000000002, nu=0.50000000000000000.
-testcase_ellint_3<double> data006[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17437497557073336, -0.90000000000000002, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34804093691586013, -0.90000000000000002, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.52137576320372914, -0.90000000000000002, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.69655163996912284, -0.90000000000000002, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.87783188683054236, -0.90000000000000002, 0.50000000000000000,
-          0.87266462599716477 },
-  { 1.0716015959755185, -0.90000000000000002, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.2857636916026747, -0.90000000000000002, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.5264263913252365, -0.90000000000000002, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.7888013241937861, -0.90000000000000002, 0.50000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.90000000000000002, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17614967734498183, -0.90000000000000002, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.36231594750319435, -0.90000000000000002, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.57016256984349567, -0.90000000000000002, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.81494025918293422, -0.90000000000000002, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.1178482279283477, -0.90000000000000002, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.5081455873012106, -0.90000000000000002, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 2.0213599730863998, -0.90000000000000002, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.6822467012926827, -0.90000000000000002, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 3.4591069002104677, -0.90000000000000002, 0.50000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler006 = 2.5000000000000020e-13;
 
-// Test function for k=-0.90000000000000002, nu=0.50000000000000000.
-template <typename Tp>
-void test006()
+// Test data for k=-0.90000000000000002, nu=0.60000000000000009.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.0602096790645418e-16
+// mean(f - f_Boost): 1.0269562977782698e-16
+// variance(f - f_Boost): 1.4388836606733082e-32
+// stddev(f - f_Boost): 1.1995347684303728e-16
+const testcase_ellint_3<double>
+data007[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data006)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data006[i].k), Tp(data006[i].nu),
-                   Tp(data006[i].phi));
-      const Tp f0 = data006[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.90000000000000002, nu=0.59999999999999998.
-testcase_ellint_3<double> data007[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17420100334657815, -0.90000000000000002, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34671975876122157, -0.90000000000000002, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.51724631570707968, -0.90000000000000002, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.68760879113743056, -0.90000000000000002, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.86192157779698364, -0.90000000000000002, 0.59999999999999998,
-          0.87266462599716477 },
-  { 1.0464279696166354, -0.90000000000000002, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.2488156247094004, -0.90000000000000002, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.4750988777188474, -0.90000000000000002, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.7211781128919523, -0.90000000000000002, 0.59999999999999998,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.90000000000000002, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17633073723493825, -0.90000000000000002, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.36386108723492810, -0.90000000000000002, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.57597424744716241, -0.90000000000000002, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.83098051948501150, -0.90000000000000002, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.1558706545698916, -0.90000000000000002, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.5905576379415669, -0.90000000000000002, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 2.1875186010215080, -0.90000000000000002, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.9885767771316849, -0.90000000000000002, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 3.9549939883570224, -0.90000000000000002, 0.60000000000000009, 
+	  1.5707963267948966 },
 };
+const double toler007 = 2.5000000000000020e-13;
 
-// Test function for k=-0.90000000000000002, nu=0.59999999999999998.
-template <typename Tp>
-void test007()
+// Test data for k=-0.90000000000000002, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.1938610791060186e-16
+// mean(f - f_Boost): 3.0253577421035517e-16
+// variance(f - f_Boost): 4.2342877557562532e-32
+// stddev(f - f_Boost): 2.0577385051935665e-16
+const testcase_ellint_3<double>
+data008[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data007)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data007[i].k), Tp(data007[i].nu),
-                   Tp(data007[i].phi));
-      const Tp f0 = data007[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.90000000000000002, nu=0.69999999999999996.
-testcase_ellint_3<double> data008[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17402765093102210, -0.90000000000000002, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34541608382635131, -0.90000000000000002, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.51322715827061705, -0.90000000000000002, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.67903717872440306, -0.90000000000000002, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.84690113601682671, -0.90000000000000002, 0.69999999999999996,
-          0.87266462599716477 },
-  { 1.0229914311548418, -0.90000000000000002, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.2148329639709381, -0.90000000000000002, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.4283586501307806, -0.90000000000000002, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.6600480747670938, -0.90000000000000002, 0.69999999999999996,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.90000000000000002, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17651246700160939, -0.90000000000000002, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36542993547358982, -0.90000000000000002, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.58199897877674867, -0.90000000000000002, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.84815633587352857, -0.90000000000000002, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.1985495623872375, -0.90000000000000002, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.6892158134027688, -0.90000000000000002, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 2.4029722191094236, -0.90000000000000002, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 3.4201084941340052, -0.90000000000000002, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 4.6985482312992435, -0.90000000000000002, 0.70000000000000007, 
+	  1.5707963267948966 },
 };
+const double toler008 = 2.5000000000000020e-13;
 
-// Test function for k=-0.90000000000000002, nu=0.69999999999999996.
-template <typename Tp>
-void test008()
+// Test data for k=-0.90000000000000002, nu=0.80000000000000004.
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.5091520146032660e-16
+// mean(f - f_Boost): 2.8310687127941490e-16
+// variance(f - f_Boost): 9.8950000698295322e-33
+// stddev(f - f_Boost): 9.9473614943006532e-17
+const testcase_ellint_3<double>
+data009[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data008)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data008[i].k), Tp(data008[i].nu),
-                   Tp(data008[i].phi));
-      const Tp f0 = data008[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.90000000000000002, nu=0.80000000000000004.
-testcase_ellint_3<double> data009[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17385491439925149, -0.90000000000000002, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34412950523113928, -0.90000000000000002, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.50931321668729612, -0.90000000000000002, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.67081081392296349, -0.90000000000000002, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.83268846097293259, -0.90000000000000002, 0.80000000000000004,
-          0.87266462599716477 },
-  { 1.0010985015814027, -0.90000000000000002, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.1834394045489678, -0.90000000000000002, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.3855695891683188, -0.90000000000000002, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.6044591960982204, -0.90000000000000002, 0.80000000000000004,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.90000000000000002, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17669487107954862, -0.90000000000000002, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36702314729628421, -0.90000000000000002, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.58825099711365492, -0.90000000000000002, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.86661711422209031, -0.90000000000000002, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.2469779109884802, -0.90000000000000002, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.8105469760531578, -0.90000000000000002, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.6989505165893752, -0.90000000000000002, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 4.0935213267757424, -0.90000000000000002, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 5.9820740813645710, -0.90000000000000002, 0.80000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler009 = 2.5000000000000020e-13;
 
-// Test function for k=-0.90000000000000002, nu=0.80000000000000004.
-template <typename Tp>
-void test009()
+// Test data for k=-0.90000000000000002, nu=0.90000000000000002.
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 8.2628580104449673e-16
+// mean(f - f_Boost): 8.5764728652293339e-16
+// variance(f - f_Boost): 8.9671393318321280e-31
+// stddev(f - f_Boost): 9.4694980499666013e-16
+const testcase_ellint_3<double>
+data010[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data009)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data009[i].k), Tp(data009[i].nu),
-                   Tp(data009[i].phi));
-      const Tp f0 = data009[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.90000000000000002, nu=0.90000000000000002.
-testcase_ellint_3<double> data010[] = {
-  { -0.0000000000000000, -0.90000000000000002, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17368278986240138, -0.90000000000000002, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.34285962963961397, -0.90000000000000002, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.50549974644993323, -0.90000000000000002, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.66290623857720898, -0.90000000000000002, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.81921183128847164, -0.90000000000000002, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.98058481956066390, -0.90000000000000002, 0.90000000000000002,
-          1.0471975511965976 },
-  { 1.1543223520473567, -0.90000000000000002, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.3462119782292938, -0.90000000000000002, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.5536420236310946, -0.90000000000000002, 0.90000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.90000000000000002, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17687795394604169, -0.90000000000000002, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36864140434751286, -0.90000000000000002, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.59474595366817051, -0.90000000000000002, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.88654237226056665, -0.90000000000000002, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.3026595810616726, -0.90000000000000002, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.9653635459278078, -0.90000000000000002, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 3.1451407527189463, -0.90000000000000002, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 5.3745230680316114, -0.90000000000000002, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 8.9942562031858682, -0.90000000000000002, 0.90000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler010 = 2.5000000000000020e-13;
 
-// Test function for k=-0.90000000000000002, nu=0.90000000000000002.
-template <typename Tp>
-void test010()
+// Test data for k=-0.80000000000000004, nu=0.0000000000000000.
+// max(|f - f_Boost|): 1.5543122344752192e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.7898565163847540e-16
+// mean(f - f_Boost): 2.3869795029440865e-16
+// variance(f - f_Boost): 2.1368406725192426e-31
+// stddev(f - f_Boost): 4.6225974002926564e-16
+const testcase_ellint_3<double>
+data011[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data010)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data010[i].k), Tp(data010[i].nu),
-                   Tp(data010[i].phi));
-      const Tp f0 = data010[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.80000000000000004, nu=0.0000000000000000.
-testcase_ellint_3<double> data011[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17510154241338902, -0.80000000000000004, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35365068839779390, -0.80000000000000004, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.53926804409084561, -0.80000000000000004, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.73587926028070383, -0.80000000000000004, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.94770942970071170, -0.80000000000000004, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.1789022995388239, -0.80000000000000004, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.4323027881876009, -0.80000000000000004, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.7069629739121674, -0.80000000000000004, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.9953027776647296, -0.80000000000000004, 0.0000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.80000000000000004, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17510154241338899, -0.80000000000000004, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35365068839779396, -0.80000000000000004, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.53926804409084550, -0.80000000000000004, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.73587926028070372, -0.80000000000000004, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.94770942970071170, -0.80000000000000004, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.1789022995388236, -0.80000000000000004, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.4323027881876012, -0.80000000000000004, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.7069629739121677, -0.80000000000000004, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.9953027776647294, -0.80000000000000004, 0.0000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler011 = 2.5000000000000020e-13;
 
-// Test function for k=-0.80000000000000004, nu=0.0000000000000000.
-template <typename Tp>
-void test011()
+// Test data for k=-0.80000000000000004, nu=0.10000000000000001.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3898786942190374e-16
+// mean(f - f_Boost): 2.3869795029440865e-16
+// variance(f - f_Boost): 2.9190059990693968e-31
+// stddev(f - f_Boost): 5.4027826155319237e-16
+const testcase_ellint_3<double>
+data012[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data011)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data011[i].k), Tp(data011[i].nu),
-                   Tp(data011[i].phi));
-      const Tp f0 = data011[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.80000000000000004, nu=0.10000000000000001.
-testcase_ellint_3<double> data012[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17492468824017166, -0.80000000000000004, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.35224443521476911, -0.80000000000000004, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.53456851853226961, -0.80000000000000004, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.72488875602364944, -0.80000000000000004, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.92661354274638952, -0.80000000000000004, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.1432651144499077, -0.80000000000000004, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.3774479927211429, -0.80000000000000004, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.6287092337196041, -0.80000000000000004, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.8910755418379521, -0.80000000000000004, 0.10000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.80000000000000004, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17527903952342144, -0.80000000000000004, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35507705313548549, -0.80000000000000004, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.54411455987643553, -0.80000000000000004, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.74745625666804383, -0.80000000000000004, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.97046953684238557, -0.80000000000000004, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.2183080025184605, -0.80000000000000004, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.4943711151994405, -0.80000000000000004, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.7972401309544201, -0.80000000000000004, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 2.1172616484005085, -0.80000000000000004, 0.10000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler012 = 2.5000000000000020e-13;
 
-// Test function for k=-0.80000000000000004, nu=0.10000000000000001.
-template <typename Tp>
-void test012()
+// Test data for k=-0.80000000000000004, nu=0.20000000000000001.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.8513740186068518e-16
+// mean(f - f_Boost): 2.8310687127941490e-16
+// variance(f - f_Boost): 2.7528339102381189e-31
+// stddev(f - f_Boost): 5.2467455724840699e-16
+const testcase_ellint_3<double>
+data013[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data012)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data012[i].k), Tp(data012[i].nu),
-                   Tp(data012[i].phi));
-      const Tp f0 = data012[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.80000000000000004, nu=0.20000000000000001.
-testcase_ellint_3<double> data013[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17474847286224943, -0.80000000000000004, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.35085779529084682, -0.80000000000000004, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.53000829263059157, -0.80000000000000004, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.71443466027453406, -0.80000000000000004, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.90698196872715420, -0.80000000000000004, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.1108198200558581, -0.80000000000000004, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.3284988909963957, -0.80000000000000004, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.5600369318140328, -0.80000000000000004, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.8007226661734588, -0.80000000000000004, 0.20000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.80000000000000004, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17545718375086419, -0.80000000000000004, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35652404627248163, -0.80000000000000004, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.54911638512920913, -0.80000000000000004, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.75967684282131176, -0.80000000000000004, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.99513526893543769, -0.80000000000000004, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.2622192109995993, -0.80000000000000004, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.5654106676347741, -0.80000000000000004, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.9029531718534984, -0.80000000000000004, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 2.2624789434186798, -0.80000000000000004, 0.20000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler013 = 2.5000000000000020e-13;
 
-// Test function for k=-0.80000000000000004, nu=0.20000000000000001.
-template <typename Tp>
-void test013()
+// Test data for k=-0.80000000000000004, nu=0.30000000000000004.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.2825261583337354e-16
+// mean(f - f_Boost): 2.6367796834847468e-16
+// variance(f - f_Boost): 2.8249350208968825e-31
+// stddev(f - f_Boost): 5.3150117788175054e-16
+const testcase_ellint_3<double>
+data014[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data013)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data013[i].k), Tp(data013[i].nu),
-                   Tp(data013[i].phi));
-      const Tp f0 = data013[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.80000000000000004, nu=0.29999999999999999.
-testcase_ellint_3<double> data014[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17457289217669891, -0.80000000000000004, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34949028801501258, -0.80000000000000004, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.52558024362769318, -0.80000000000000004, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.70447281740094914, -0.80000000000000004, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.88864745641528986, -0.80000000000000004, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.0811075819341465, -0.80000000000000004, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.2844589654082377, -0.80000000000000004, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.4991461361277849, -0.80000000000000004, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.7214611048717301, -0.80000000000000004, 0.29999999999999999,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.80000000000000004, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17563597931587369, -0.80000000000000004, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35799220412005128, -0.80000000000000004, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.55428253691111318, -0.80000000000000004, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.77260647376977365, -0.80000000000000004, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 1.0220015271210958, -0.80000000000000004, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.3115965312302671, -0.80000000000000004, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.6478518468813512, -0.80000000000000004, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 2.0290458414203481, -0.80000000000000004, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.4392042002725693, -0.80000000000000004, 0.30000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler014 = 2.5000000000000020e-13;
 
-// Test function for k=-0.80000000000000004, nu=0.29999999999999999.
-template <typename Tp>
-void test014()
+// Test data for k=-0.80000000000000004, nu=0.40000000000000002.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3462748389836647e-16
+// mean(f - f_Boost): 3.3861802251067273e-16
+// variance(f - f_Boost): 4.3719465706454422e-31
+// stddev(f - f_Boost): 6.6120696991527871e-16
+const testcase_ellint_3<double>
+data015[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data014)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data014[i].k), Tp(data014[i].nu),
-                   Tp(data014[i].phi));
-      const Tp f0 = data014[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.80000000000000004, nu=0.40000000000000002.
-testcase_ellint_3<double> data015[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17439794211872178, -0.80000000000000004, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34814144964568972, -0.80000000000000004, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.52127776285273075, -0.80000000000000004, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.69496411438966599, -0.80000000000000004, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.87146878427509589, -0.80000000000000004, 0.40000000000000002,
-          0.87266462599716477 },
-  { 1.0537579024937762, -0.80000000000000004, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.2445534387922637, -0.80000000000000004, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.4446769766361993, -0.80000000000000004, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.6512267838651289, -0.80000000000000004, 0.40000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.80000000000000004, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17581543047866136, -0.80000000000000004, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35948208343061633, -0.80000000000000004, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.55962280893702021, -0.80000000000000004, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.78632063889234116, -0.80000000000000004, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 1.0514333069550323, -0.80000000000000004, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.3677213138838757, -0.80000000000000004, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.7451736773665165, -0.80000000000000004, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 2.1830100424586831, -0.80000000000000004, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.6604037035529724, -0.80000000000000004, 0.40000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler015 = 2.5000000000000020e-13;
 
-// Test function for k=-0.80000000000000004, nu=0.40000000000000002.
-template <typename Tp>
-void test015()
+// Test data for k=-0.80000000000000004, nu=0.50000000000000000.
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0388243828581744e-16
+// mean(f - f_Boost): 3.8580250105724191e-16
+// variance(f - f_Boost): 6.4106456575047741e-31
+// stddev(f - f_Boost): 8.0066507713929764e-16
+const testcase_ellint_3<double>
+data016[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data015)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data015[i].k), Tp(data015[i].nu),
-                   Tp(data015[i].phi));
-      const Tp f0 = data015[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.80000000000000004, nu=0.50000000000000000.
-testcase_ellint_3<double> data016[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17422361866118047, -0.80000000000000004, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34681083254170475, -0.80000000000000004, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.51709470815494440, -0.80000000000000004, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.68587375344080259, -0.80000000000000004, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.85532571852810624, -0.80000000000000004, 0.50000000000000000,
-          0.87266462599716477 },
-  { 1.0284677391874906, -0.80000000000000004, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.2081693942686225, -0.80000000000000004, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.3955803006426311, -0.80000000000000004, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.5884528947755532, -0.80000000000000004, 0.50000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.80000000000000004, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17599554153999472, -0.80000000000000004, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.36099426243351540, -0.80000000000000004, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.56514786174780673, -0.80000000000000004, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.80090697622371010, -0.80000000000000004, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0838891627679339, -0.80000000000000004, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.4323506654466280, -0.80000000000000004, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.8625761085390575, -0.80000000000000004, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.3768757305654766, -0.80000000000000004, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.9478781158239746, -0.80000000000000004, 0.50000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler016 = 2.5000000000000020e-13;
 
-// Test function for k=-0.80000000000000004, nu=0.50000000000000000.
-template <typename Tp>
-void test016()
+// Test data for k=-0.80000000000000004, nu=0.60000000000000009.
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.0631099169042069e-15
+// mean(f - f_Boost): 4.8294701571194306e-16
+// variance(f - f_Boost): 1.1633910328160319e-30
+// stddev(f - f_Boost): 1.0786060600682865e-15
+const testcase_ellint_3<double>
+data017[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data016)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data016[i].k), Tp(data016[i].nu),
-                   Tp(data016[i].phi));
-      const Tp f0 = data016[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.80000000000000004, nu=0.59999999999999998.
-testcase_ellint_3<double> data017[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17404991781414092, -0.80000000000000004, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34549800443625167, -0.80000000000000004, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.51302536167001556, -0.80000000000000004, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.67717065003912258, -0.80000000000000004, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.84011512421134416, -0.80000000000000004, 0.59999999999999998,
-          0.87266462599716477 },
-  { 1.0049863847088742, -0.80000000000000004, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.1748145941898918, -0.80000000000000004, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.3510319699755071, -0.80000000000000004, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.5319262547427865, -0.80000000000000004, 0.59999999999999998,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.80000000000000004, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17617631684170665, -0.80000000000000004, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.36252934193666231, -0.80000000000000004, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.57086932622945163, -0.80000000000000004, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.81646796740150973, -0.80000000000000004, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.1199552158519064, -0.80000000000000004, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.5079766673336394, -0.80000000000000004, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 2.0082747447038165, -0.80000000000000004, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.6315146066775523, -0.80000000000000004, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 3.3418121892288051, -0.80000000000000004, 0.60000000000000009, 
+	  1.5707963267948966 },
 };
+const double toler017 = 2.5000000000000020e-13;
 
-// Test function for k=-0.80000000000000004, nu=0.59999999999999998.
-template <typename Tp>
-void test017()
+// Test data for k=-0.80000000000000004, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.6544679145741375e-16
+// mean(f - f_Boost): 3.2751579226442120e-16
+// variance(f - f_Boost): 4.4236851331020672e-31
+// stddev(f - f_Boost): 6.6510789599147505e-16
+const testcase_ellint_3<double>
+data018[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data017)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data017[i].k), Tp(data017[i].nu),
-                   Tp(data017[i].phi));
-      const Tp f0 = data017[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.80000000000000004, nu=0.69999999999999996.
-testcase_ellint_3<double> data018[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17387683562442202, -0.80000000000000004, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34420254775101611, -0.80000000000000004, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.50906439222143685, -0.80000000000000004, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.66882693152688433, -0.80000000000000004, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.82574792844091316, -0.80000000000000004, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.98310431309490953, -0.80000000000000004, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.1440884535113258, -0.80000000000000004, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.3103743938952537, -0.80000000000000004, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.4806912324625332, -0.80000000000000004, 0.69999999999999996,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.80000000000000004, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17635776076721221, -0.80000000000000004, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36408794649916976, -0.80000000000000004, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.57679992290624138, -0.80000000000000004, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.83312441418142813, -0.80000000000000004, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.1603958891464856, -0.80000000000000004, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.5982855143796213, -0.80000000000000004, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 2.1962484408371821, -0.80000000000000004, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.9873281786111869, -0.80000000000000004, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.9268876980046397, -0.80000000000000004, 0.70000000000000007, 
+	  1.5707963267948966 },
 };
+const double toler018 = 2.5000000000000020e-13;
 
-// Test function for k=-0.80000000000000004, nu=0.69999999999999996.
-template <typename Tp>
-void test018()
+// Test data for k=-0.80000000000000004, nu=0.80000000000000004.
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0176949165011079e-16
+// mean(f - f_Boost): 7.0499162063697436e-16
+// variance(f - f_Boost): 1.7230805408026989e-30
+// stddev(f - f_Boost): 1.3126616246400665e-15
+const testcase_ellint_3<double>
+data019[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data018)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data018[i].k), Tp(data018[i].nu),
-                   Tp(data018[i].phi));
-      const Tp f0 = data018[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.80000000000000004, nu=0.80000000000000004.
-testcase_ellint_3<double> data019[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17370436817515206, -0.80000000000000004, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34292405894783395, -0.80000000000000004, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.50520682176250087, -0.80000000000000004, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.66081751679736189, -0.80000000000000004, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.81214672249355102, -0.80000000000000004, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.96264481387685574, -0.80000000000000004, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.1156611352656258, -0.80000000000000004, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.2730756225143889, -0.80000000000000004, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.4339837018309474, -0.80000000000000004, 0.80000000000000004,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.80000000000000004, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17653987774203392, -0.80000000000000004, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36567072568046877, -0.80000000000000004, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.58295359996558616, -0.80000000000000004, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.85101998309176108, -0.80000000000000004, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.2062322059736537, -0.80000000000000004, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.7090321420917429, -0.80000000000000004, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.4529058049405066, -0.80000000000000004, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 3.5368893360106948, -0.80000000000000004, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 4.9246422058196062, -0.80000000000000004, 0.80000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler019 = 2.5000000000000020e-13;
 
-// Test function for k=-0.80000000000000004, nu=0.80000000000000004.
-template <typename Tp>
-void test019()
+// Test data for k=-0.80000000000000004, nu=0.90000000000000002.
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.7782721357365268e-16
+// mean(f - f_Boost): 8.9928064994637676e-16
+// variance(f - f_Boost): 1.5485199571025344e-30
+// stddev(f - f_Boost): 1.2443954183066307e-15
+const testcase_ellint_3<double>
+data020[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data019)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data019[i].k), Tp(data019[i].nu),
-                   Tp(data019[i].phi));
-      const Tp f0 = data019[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.80000000000000004, nu=0.90000000000000002.
-testcase_ellint_3<double> data020[] = {
-  { -0.0000000000000000, -0.80000000000000004, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17353251158533153, -0.80000000000000004, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.34166214791545768, -0.80000000000000004, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.50144799535130580, -0.80000000000000004, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.65311976193814447, -0.80000000000000004, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.79924384892320866, -0.80000000000000004, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.94345762353365625, -0.80000000000000004, 0.90000000000000002,
-          1.0471975511965976 },
-  { 1.0892582069219159, -0.80000000000000004, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.2387000876610268, -0.80000000000000004, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.3911845406776222, -0.80000000000000004, 0.90000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.80000000000000004, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17672267223433513, -0.80000000000000004, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36727835537196063, -0.80000000000000004, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.58934569363716649, -0.80000000000000004, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.87032723471138851, -0.80000000000000004, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.2588676111323349, -0.80000000000000004, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.8498731900660019, -0.80000000000000004, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.8368381299300420, -0.80000000000000004, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 4.5674844191654058, -0.80000000000000004, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 7.2263259298637115, -0.80000000000000004, 0.90000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler020 = 2.5000000000000020e-13;
 
-// Test function for k=-0.80000000000000004, nu=0.90000000000000002.
-template <typename Tp>
-void test020()
+// Test data for k=-0.69999999999999996, nu=0.0000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.5425633303580569e-16
+// mean(f - f_Boost): 7.7715611723760953e-17
+// variance(f - f_Boost): 7.4564398834547797e-34
+// stddev(f - f_Boost): 2.7306482533374340e-17
+const testcase_ellint_3<double>
+data021[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data020)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data020[i].k), Tp(data020[i].nu),
-                   Tp(data020[i].phi));
-      const Tp f0 = data020[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.69999999999999996, nu=0.0000000000000000.
-testcase_ellint_3<double> data021[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17496737466916720, -0.69999999999999996, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35254687535677925, -0.69999999999999996, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.53536740275997130, -0.69999999999999996, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.72603797651684465, -0.69999999999999996, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.92698296348313458, -0.69999999999999996, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.1400447527693316, -0.69999999999999996, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.3657668117194071, -0.69999999999999996, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.6024686895959159, -0.69999999999999996, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.8456939983747236, -0.69999999999999996, 0.0000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.69999999999999996, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17496737466916723, -0.69999999999999996, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35254687535677931, -0.69999999999999996, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.53536740275997130, -0.69999999999999996, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.72603797651684454, -0.69999999999999996, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.92698296348313447, -0.69999999999999996, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.1400447527693316, -0.69999999999999996, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.3657668117194071, -0.69999999999999996, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.6024686895959162, -0.69999999999999996, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.8456939983747234, -0.69999999999999996, 0.0000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler021 = 2.5000000000000020e-13;
 
-// Test function for k=-0.69999999999999996, nu=0.0000000000000000.
-template <typename Tp>
-void test021()
+// Test data for k=-0.69999999999999996, nu=0.10000000000000001.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.2736371663370261e-16
+// mean(f - f_Boost): 8.8817841970012528e-17
+// variance(f - f_Boost): 9.7390235212470591e-34
+// stddev(f - f_Boost): 3.1207408609570677e-17
+const testcase_ellint_3<double>
+data022[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data021)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data021[i].k), Tp(data021[i].nu),
-                   Tp(data021[i].phi));
-      const Tp f0 = data021[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.69999999999999996, nu=0.10000000000000001.
-testcase_ellint_3<double> data022[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17479076384884681, -0.69999999999999996, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.35114844900396364, -0.69999999999999996, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.53072776947527012, -0.69999999999999996, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.71530198262386246, -0.69999999999999996, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.90666760677828306, -0.69999999999999996, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.1063366517438080, -0.69999999999999996, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.3149477243092147, -0.69999999999999996, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.5314886725038925, -0.69999999999999996, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.7528050171757608, -0.69999999999999996, 0.10000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.69999999999999996, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17514462737300920, -0.69999999999999996, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35396527997470451, -0.69999999999999996, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.54015179589433981, -0.69999999999999996, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.73734430854477728, -0.69999999999999996, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.94888950796697047, -0.69999999999999996, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.1772807959736322, -0.69999999999999996, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.4231796401075831, -0.69999999999999996, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.6841856799887469, -0.69999999999999996, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.9541347343119562, -0.69999999999999996, 0.10000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler022 = 2.5000000000000020e-13;
 
-// Test function for k=-0.69999999999999996, nu=0.10000000000000001.
-template <typename Tp>
-void test022()
+// Test data for k=-0.69999999999999996, nu=0.20000000000000001.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.9907249355047774e-16
+// mean(f - f_Boost): 3.3306690738754695e-17
+// variance(f - f_Boost): 1.3695501826753678e-34
+// stddev(f - f_Boost): 1.1702778228589003e-17
+const testcase_ellint_3<double>
+data023[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data022)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data022[i].k), Tp(data022[i].nu),
-                   Tp(data022[i].phi));
-      const Tp f0 = data022[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.69999999999999996, nu=0.20000000000000001.
-testcase_ellint_3<double> data023[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17461479077791472, -0.69999999999999996, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34976950621407538, -0.69999999999999996, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.52622533231350188, -0.69999999999999996, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.70508774017895226, -0.69999999999999996, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.88775302531730294, -0.69999999999999996, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0756195476149006, -0.69999999999999996, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.2695349716654372, -0.69999999999999996, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.4690814617070540, -0.69999999999999996, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.6721098780092147, -0.69999999999999996, 0.20000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.69999999999999996, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17532252613350796, -0.69999999999999996, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35540417596807522, -0.69999999999999996, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.54508913033361928, -0.69999999999999996, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.74927635777718415, -0.69999999999999996, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.97261706337936338, -0.69999999999999996, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.2187303976209327, -0.69999999999999996, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.4887796709222487, -0.69999999999999996, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.7796581281839212, -0.69999999999999996, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 2.0829290325820202, -0.69999999999999996, 0.20000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler023 = 2.5000000000000020e-13;
 
-// Test function for k=-0.69999999999999996, nu=0.20000000000000001.
-template <typename Tp>
-void test023()
+// Test data for k=-0.69999999999999996, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.6912897610535316e-16
+// mean(f - f_Boost): 1.6653345369377347e-17
+// variance(f - f_Boost): 2.6207864467918357e-32
+// stddev(f - f_Boost): 1.6188843216214787e-16
+const testcase_ellint_3<double>
+data024[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data023)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data023[i].k), Tp(data023[i].nu),
-                   Tp(data023[i].phi));
-      const Tp f0 = data023[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.69999999999999996, nu=0.29999999999999999.
-testcase_ellint_3<double> data024[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17443945136076172, -0.69999999999999996, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34840956983535287, -0.69999999999999996, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.52185308551329179, -0.69999999999999996, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.69535240431168266, -0.69999999999999996, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.87007983473964923, -0.69999999999999996, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.0474657975577066, -0.69999999999999996, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.2286225419931889, -0.69999999999999996, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.4136490671013271, -0.69999999999999996, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.6011813647733213, -0.69999999999999996, 0.29999999999999999,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.69999999999999996, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17550107516328570, -0.69999999999999996, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35686409576571959, -0.69999999999999996, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.55018827316513352, -0.69999999999999996, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.76189759494390275, -0.69999999999999996, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.99844623430885615, -0.69999999999999996, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.2652862989039833, -0.69999999999999996, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.5647666808691361, -0.69999999999999996, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.8932499694938163, -0.69999999999999996, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.2392290510988535, -0.69999999999999996, 0.30000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler024 = 2.5000000000000020e-13;
 
-// Test function for k=-0.69999999999999996, nu=0.29999999999999999.
-template <typename Tp>
-void test024()
+// Test data for k=-0.69999999999999996, nu=0.40000000000000002.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.5578567644745380e-16
+// mean(f - f_Boost): 1.4710455076283324e-16
+// variance(f - f_Boost): 2.6715739327327140e-33
+// stddev(f - f_Boost): 5.1687270509601433e-17
+const testcase_ellint_3<double>
+data025[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data024)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data024[i].k), Tp(data024[i].nu),
-                   Tp(data024[i].phi));
-      const Tp f0 = data024[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.69999999999999996, nu=0.40000000000000002.
-testcase_ellint_3<double> data025[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17426474153983226, -0.69999999999999996, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34706817945773732, -0.69999999999999996, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.51760452851738159, -0.69999999999999996, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.68605801534722766, -0.69999999999999996, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.85351339387296532, -0.69999999999999996, 0.40000000000000002,
-          0.87266462599716477 },
-  { 1.0215297967969537, -0.69999999999999996, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.1915051074460528, -0.69999999999999996, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.3639821911744707, -0.69999999999999996, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.5382162002954762, -0.69999999999999996, 0.40000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.69999999999999996, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17568027871494424, -0.69999999999999996, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35834559208180261, -0.69999999999999996, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.55545885451190613, -0.69999999999999996, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.77528120402568101, -0.69999999999999996, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 1.0267241287600319, -0.69999999999999996, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.3181380338980246, -0.69999999999999996, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.6542840785132085, -0.69999999999999996, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 2.0315595131131818, -0.69999999999999996, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.4342502915307875, -0.69999999999999996, 0.40000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler025 = 2.5000000000000020e-13;
 
-// Test function for k=-0.69999999999999996, nu=0.40000000000000002.
-template <typename Tp>
-void test025()
+// Test data for k=-0.69999999999999996, nu=0.50000000000000000.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.0416041815443256e-16
+// mean(f - f_Boost): 1.9151347174783951e-16
+// variance(f - f_Boost): 7.8758646268991113e-33
+// stddev(f - f_Boost): 8.8746068233466605e-17
+const testcase_ellint_3<double>
+data026[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data025)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data025[i].k), Tp(data025[i].nu),
-                   Tp(data025[i].phi));
-      const Tp f0 = data025[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.69999999999999996, nu=0.50000000000000000.
-testcase_ellint_3<double> data026[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17409065729516093, -0.69999999999999996, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34574489064986091, -0.69999999999999996, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.51347361925579793, -0.69999999999999996, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.67717079489579290, -0.69999999999999996, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.83793902055292280, -0.69999999999999996, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.99752863545289705, -0.69999999999999996, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.1576240080401499, -0.69999999999999996, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.3191464023923762, -0.69999999999999996, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.4818433192178544, -0.69999999999999996, 0.50000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.69999999999999996, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17586014108156545, -0.69999999999999996, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35984923894341653, -0.69999999999999996, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.56091135606739995, -0.69999999999999996, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.78951212635197054, -0.69999999999999996, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0578865732938729, -0.69999999999999996, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.3789149005151722, -0.69999999999999996, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.7620212286086225, -0.69999999999999996, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.2051554347435585, -0.69999999999999996, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.6868019968236991, -0.69999999999999996, 0.50000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler026 = 2.5000000000000020e-13;
 
-// Test function for k=-0.69999999999999996, nu=0.50000000000000000.
-template <typename Tp>
-void test026()
+// Test data for k=-0.69999999999999996, nu=0.60000000000000009.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.6515644573247170e-16
+// mean(f - f_Boost): 9.9920072216264091e-17
+// variance(f - f_Boost): 1.2325951644078310e-33
+// stddev(f - f_Boost): 3.5108334685767011e-17
+const testcase_ellint_3<double>
+data027[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data026)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data026[i].k), Tp(data026[i].nu),
-                   Tp(data026[i].phi));
-      const Tp f0 = data026[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.69999999999999996, nu=0.59999999999999998.
-testcase_ellint_3<double> data027[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17391719464391611, -0.69999999999999996, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34443927423869031, -0.69999999999999996, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50945473266486074, -0.69999999999999996, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.66866056326513823, -0.69999999999999996, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.82325830002337352, -0.69999999999999996, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.97522808245669357, -0.69999999999999996, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.1265300613705282, -0.69999999999999996, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.2784066076152003, -0.69999999999999996, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.4309994736080540, -0.69999999999999996, 0.59999999999999998,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.69999999999999996, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17604066659721918, -0.69999999999999996, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.36137563278353424, -0.69999999999999996, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.56655721272747606, -0.69999999999999996, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.80468966552978305, -0.69999999999999996, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0924902943683852, -0.69999999999999996, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.4499247992499797, -0.69999999999999996, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.8953714382113815, -0.69999999999999996, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.4323229949248670, -0.69999999999999996, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 3.0314573496746742, -0.69999999999999996, 0.60000000000000009, 
+	  1.5707963267948966 },
 };
+const double toler027 = 2.5000000000000020e-13;
 
-// Test function for k=-0.69999999999999996, nu=0.59999999999999998.
-template <typename Tp>
-void test027()
+// Test data for k=-0.69999999999999996, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.8475278552871384e-16
+// mean(f - f_Boost): 9.9920072216264091e-17
+// variance(f - f_Boost): 1.2325951644078310e-33
+// stddev(f - f_Boost): 3.5108334685767011e-17
+const testcase_ellint_3<double>
+data028[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data027)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data027[i].k), Tp(data027[i].nu),
-                   Tp(data027[i].phi));
-      const Tp f0 = data027[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.69999999999999996, nu=0.69999999999999996.
-testcase_ellint_3<double> data028[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17374434963995028, -0.69999999999999996, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34315091562900674, -0.69999999999999996, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.50554262375653358, -0.69999999999999996, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.66050025406305812, -0.69999999999999996, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.80938620118847404, -0.69999999999999996, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.95443223855852144, -0.69999999999999996, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0978573207128302, -0.69999999999999996, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.2411754575007123, -0.69999999999999996, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.3848459188329196, -0.69999999999999996, 0.69999999999999996,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.69999999999999996, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17622185963747933, -0.69999999999999996, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36292539360435261, -0.69999999999999996, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.57240892970150015, -0.69999999999999996, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.82093084713182629, -0.69999999999999996, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.1312609022179871, -0.69999999999999996, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.5345768067715795, -0.69999999999999996, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 2.0668847445934420, -0.69999999999999996, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.7483444537551240, -0.69999999999999996, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.5408408771788560, -0.69999999999999996, 0.70000000000000007, 
+	  1.5707963267948966 },
 };
+const double toler028 = 2.5000000000000020e-13;
 
-// Test function for k=-0.69999999999999996, nu=0.69999999999999996.
-template <typename Tp>
-void test028()
+// Test data for k=-0.69999999999999996, nu=0.80000000000000004.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.8664526853112274e-16
+// mean(f - f_Boost): 1.6930901125533636e-16
+// variance(f - f_Boost): 3.5389557150937801e-33
+// stddev(f - f_Boost): 5.9489122661994095e-17
+const testcase_ellint_3<double>
+data029[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data028)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data028[i].k), Tp(data028[i].nu),
-                   Tp(data028[i].phi));
-      const Tp f0 = data028[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.69999999999999996, nu=0.80000000000000004.
-testcase_ellint_3<double> data029[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17357211837335737, -0.69999999999999996, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34187941416012108, -0.69999999999999996, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.50173239465478270, -0.69999999999999996, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.65266550725988315, -0.69999999999999996, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.79624879865249298, -0.69999999999999996, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.93497577043296920, -0.69999999999999996, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.0713041566930748, -0.69999999999999996, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.2069772023255652, -0.69999999999999996, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.3427110650397533, -0.69999999999999996, 0.80000000000000004,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.69999999999999996, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17640372461994805, -0.69999999999999996, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36449916621651091, -0.69999999999999996, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.57848021800372573, -0.69999999999999996, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.83837480968392586, -0.69999999999999996, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1751669030061143, -0.69999999999999996, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.6381851899173601, -0.69999999999999996, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.3002065924302197, -0.69999999999999996, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 3.2337600665337862, -0.69999999999999996, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 4.4042405729076961, -0.69999999999999996, 0.80000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler029 = 2.5000000000000020e-13;
 
-// Test function for k=-0.69999999999999996, nu=0.80000000000000004.
-template <typename Tp>
-void test029()
+// Test data for k=-0.69999999999999996, nu=0.90000000000000002.
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 8.5869439826269878e-16
+// mean(f - f_Boost): 6.7723604502134545e-16
+// variance(f - f_Boost): 4.8757508225668289e-31
+// stddev(f - f_Boost): 6.9826576763914390e-16
+const testcase_ellint_3<double>
+data030[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data029)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data029[i].k), Tp(data029[i].nu),
-                   Tp(data029[i].phi));
-      const Tp f0 = data029[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.69999999999999996, nu=0.90000000000000002.
-testcase_ellint_3<double> data030[] = {
-  { -0.0000000000000000, -0.69999999999999996, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17340049697003634, -0.69999999999999996, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.34062438249741556, -0.69999999999999996, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.49801946510076878, -0.69999999999999996, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.64513432604750487, -0.69999999999999996, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.78378145487573758, -0.69999999999999996, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.91671799500854634, -0.69999999999999996, 0.90000000000000002,
-          1.0471975511965976 },
-  { 1.0466193579463123, -0.69999999999999996, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.1754218079199146, -0.69999999999999996, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.3040500499695911, -0.69999999999999996, 0.90000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.69999999999999996, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17658626600478800, -0.69999999999999996, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36609762156017206, -0.69999999999999996, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.58478615187842409, -0.69999999999999996, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.85718862878291846, -0.69999999999999996, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.2255385617397643, -0.69999999999999996, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.7696521899992939, -0.69999999999999996, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.6476314987883502, -0.69999999999999996, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 4.1373434902898083, -0.69999999999999996, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 6.3796094177887746, -0.69999999999999996, 0.90000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler030 = 2.5000000000000020e-13;
 
-// Test function for k=-0.69999999999999996, nu=0.90000000000000002.
-template <typename Tp>
-void test030()
+// Test data for k=-0.59999999999999998, nu=0.0000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.3664899092028927e-16
+// mean(f - f_Boost): 5.2735593669694933e-17
+// variance(f - f_Boost): 3.4333862218458872e-34
+// stddev(f - f_Boost): 1.8529398861932589e-17
+const testcase_ellint_3<double>
+data031[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data030)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data030[i].k), Tp(data030[i].nu),
-                   Tp(data030[i].phi));
-      const Tp f0 = data030[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.59999999999999998, nu=0.0000000000000000.
-testcase_ellint_3<double> data031[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17485154362988362, -0.59999999999999998, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35160509865544326, -0.59999999999999998, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.53210652578446160, -0.59999999999999998, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.71805304664485670, -0.59999999999999998, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.91082759030195970, -0.59999999999999998, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.1112333229323361, -0.59999999999999998, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.3191461190365270, -0.59999999999999998, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.5332022105084773, -0.59999999999999998, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.7507538029157526, -0.59999999999999998, 0.0000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.59999999999999998, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17485154362988359, -0.59999999999999998, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35160509865544320, -0.59999999999999998, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.53210652578446138, -0.59999999999999998, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.71805304664485659, -0.59999999999999998, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.91082759030195981, -0.59999999999999998, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.1112333229323361, -0.59999999999999998, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.3191461190365270, -0.59999999999999998, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.5332022105084779, -0.59999999999999998, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.7507538029157523, -0.59999999999999998, 0.0000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler031 = 2.5000000000000020e-13;
 
-// Test function for k=-0.59999999999999998, nu=0.0000000000000000.
-template <typename Tp>
-void test031()
+// Test data for k=-0.59999999999999998, nu=0.10000000000000001.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.2335247010355137e-16
+// mean(f - f_Boost): 8.6042284408449634e-17
+// variance(f - f_Boost): 2.2835347143080263e-33
+// stddev(f - f_Boost): 4.7786344433405099e-17
+const testcase_ellint_3<double>
+data032[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data031)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data031[i].k), Tp(data031[i].nu),
-                   Tp(data031[i].phi));
-      const Tp f0 = data031[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.59999999999999998, nu=0.10000000000000001.
-testcase_ellint_3<double> data032[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17467514275022014, -0.59999999999999998, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.35021333086258255, -0.59999999999999998, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52751664092962713, -0.59999999999999998, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.70752126971957885, -0.59999999999999998, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.89111058756112871, -0.59999999999999998, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0789241202877768, -0.59999999999999998, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.2710800210399946, -0.59999999999999998, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.4669060574440276, -0.59999999999999998, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.6648615773343014, -0.59999999999999998, 0.10000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.59999999999999998, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17502858548476194, -0.59999999999999998, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35301673150537388, -0.59999999999999998, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.53683932476326812, -0.59999999999999998, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.72914228589586771, -0.59999999999999998, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.93208036718354692, -0.59999999999999998, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.1468984688863377, -0.59999999999999998, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.3733904977062528, -0.59999999999999998, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.6094225663372157, -0.59999999999999998, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.8508766487100685, -0.59999999999999998, 0.10000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler032 = 2.5000000000000020e-13;
 
-// Test function for k=-0.59999999999999998, nu=0.10000000000000001.
-template <typename Tp>
-void test032()
+// Test data for k=-0.59999999999999998, nu=0.20000000000000001.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0940560416437693e-16
+// mean(f - f_Boost): 4.1633363423443370e-17
+// variance(f - f_Boost): 8.5834655546147173e-33
+// stddev(f - f_Boost): 9.2646994309662939e-17
+const testcase_ellint_3<double>
+data033[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data032)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data032[i].k), Tp(data032[i].nu),
-                   Tp(data032[i].phi));
-      const Tp f0 = data032[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.59999999999999998, nu=0.20000000000000001.
-testcase_ellint_3<double> data033[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17449937871800653, -0.59999999999999998, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34884093647346553, -0.59999999999999998, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.52306221119844110, -0.59999999999999998, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.69749955678982223, -0.59999999999999998, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.87274610682416853, -0.59999999999999998, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0494620540750792, -0.59999999999999998, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.2280847305507339, -0.59999999999999998, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.4085436279696886, -0.59999999999999998, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.5901418016279374, -0.59999999999999998, 0.20000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.59999999999999998, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17520627248155893, -0.59999999999999998, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35444873935437748, -0.59999999999999998, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.54172310557682524, -0.59999999999999998, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.74084300280734672, -0.59999999999999998, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.95509001527006121, -0.59999999999999998, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1865688084431796, -0.59999999999999998, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.4352978868932598, -0.59999999999999998, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.6983400371331816, -0.59999999999999998, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.9695980282802215, -0.59999999999999998, 0.20000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler033 = 2.5000000000000020e-13;
 
-// Test function for k=-0.59999999999999998, nu=0.20000000000000001.
-template <typename Tp>
-void test033()
+// Test data for k=-0.59999999999999998, nu=0.30000000000000004.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.9470074709717020e-16
+// mean(f - f_Boost): 7.4940054162198071e-17
+// variance(f - f_Boost): 1.6823592487044846e-32
+// stddev(f - f_Boost): 1.2970579203352812e-16
+const testcase_ellint_3<double>
+data034[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data033)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data033[i].k), Tp(data033[i].nu),
-                   Tp(data033[i].phi));
-      const Tp f0 = data033[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.59999999999999998, nu=0.29999999999999999.
-testcase_ellint_3<double> data034[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17432424744393935, -0.59999999999999998, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34748744127146447, -0.59999999999999998, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51873632743924847, -0.59999999999999998, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.68794610396313127, -0.59999999999999998, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.85558070175468726, -0.59999999999999998, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.0224416343605653, -0.59999999999999998, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1893144457936788, -0.59999999999999998, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.3566435377982575, -0.59999999999999998, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.5243814243493585, -0.59999999999999998, 0.29999999999999999,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.59999999999999998, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17538460882640122, -0.59999999999999998, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35590165133735557, -0.59999999999999998, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.54676661152254535, -0.59999999999999998, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.75321709418305305, -0.59999999999999998, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.98012637808992920, -0.59999999999999998, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.2310891277158875, -0.59999999999999998, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.5069157924585623, -0.59999999999999998, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.8039583598337940, -0.59999999999999998, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.1134154405060599, -0.59999999999999998, 0.30000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler034 = 2.5000000000000020e-13;
 
-// Test function for k=-0.59999999999999998, nu=0.29999999999999999.
-template <typename Tp>
-void test034()
+// Test data for k=-0.59999999999999998, nu=0.40000000000000002.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.7909659715991921e-16
+// mean(f - f_Boost): -2.7755575615628915e-18
+// variance(f - f_Boost): 2.4044165394594425e-32
+// stddev(f - f_Boost): 1.5506181152880429e-16
+const testcase_ellint_3<double>
+data035[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data034)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data034[i].k), Tp(data034[i].nu),
-                   Tp(data034[i].phi));
-      const Tp f0 = data034[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.59999999999999998, nu=0.40000000000000002.
-testcase_ellint_3<double> data035[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17414974487670720, -0.59999999999999998, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34615238767335027, -0.59999999999999998, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.51453257838108579, -0.59999999999999998, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.67882386787534410, -0.59999999999999998, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.83948470233173578, -0.59999999999999998, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.99753496200073977, -0.59999999999999998, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.1541101404388487, -0.59999999999999998, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.3100911323398814, -0.59999999999999998, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.4659345278069984, -0.59999999999999998, 0.40000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.59999999999999998, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17556359876533037, -0.59999999999999998, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35737601674244679, -0.59999999999999998, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.55197933771320218, -0.59999999999999998, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.76633591620002894, -0.59999999999999998, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 1.0075231136019616, -0.59999999999999998, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2815842073813450, -0.59999999999999998, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.5911666941449827, -0.59999999999999998, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.9323227566025762, -0.59999999999999998, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.2925036420985130, -0.59999999999999998, 0.40000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler035 = 2.5000000000000020e-13;
 
-// Test function for k=-0.59999999999999998, nu=0.40000000000000002.
-template <typename Tp>
-void test035()
+// Test data for k=-0.59999999999999998, nu=0.50000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.6240126899196213e-16
+// mean(f - f_Boost): 9.1593399531575410e-17
+// variance(f - f_Boost): 1.0357223256482469e-33
+// stddev(f - f_Boost): 3.2182640128619758e-17
+const testcase_ellint_3<double>
+data036[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data035)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data035[i].k), Tp(data035[i].nu),
-                   Tp(data035[i].phi));
-      const Tp f0 = data035[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.59999999999999998, nu=0.50000000000000000.
-testcase_ellint_3<double> data036[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17397586700252810, -0.59999999999999998, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34483533397138516, -0.59999999999999998, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.51044500461706499, -0.59999999999999998, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.67009988034712675, -0.59999999999999998, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.82434762375735193, -0.59999999999999998, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.97447346702798998, -0.59999999999999998, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.1219494000522143, -0.59999999999999998, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.2680242605954486, -0.59999999999999998, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.4135484285693078, -0.59999999999999998, 0.50000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.59999999999999998, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17574324658480217, -0.59999999999999998, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35887240603169313, -0.59999999999999998, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.55737161826345261, -0.59999999999999998, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.78028227313077458, -0.59999999999999998, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0376989776486290, -0.59999999999999998, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.3395933991042925, -0.59999999999999998, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.6924049626591782, -0.59999999999999998, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.0931011856518920, -0.59999999999999998, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.5239007084492706, -0.59999999999999998, 0.50000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler036 = 2.5000000000000020e-13;
 
-// Test function for k=-0.59999999999999998, nu=0.50000000000000000.
-template <typename Tp>
-void test036()
+// Test data for k=-0.59999999999999998, nu=0.60000000000000009.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.6651378277398083e-16
+// mean(f - f_Boost): 1.1934897514720432e-16
+// variance(f - f_Boost): 1.7585404776158019e-33
+// stddev(f - f_Boost): 4.1934955319110598e-17
+const testcase_ellint_3<double>
+data037[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data036)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data036[i].k), Tp(data036[i].nu),
-                   Tp(data036[i].phi));
-      const Tp f0 = data036[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.59999999999999998, nu=0.59999999999999998.
-testcase_ellint_3<double> data037[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17380260984469356, -0.59999999999999998, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34353585361777839, -0.59999999999999998, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50646805774321402, -0.59999999999999998, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.66174468108625517, -0.59999999999999998, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.81007462280278408, -0.59999999999999998, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.95303466945718729, -0.59999999999999998, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0924118588677503, -0.59999999999999998, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.2297640574847937, -0.59999999999999998, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.3662507535812816, -0.59999999999999998, 0.59999999999999998,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.59999999999999998, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17592355661219386, -0.59999999999999998, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.36039141192661606, -0.59999999999999998, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.56295472636903854, -0.59999999999999998, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.79515295130165986, -0.59999999999999998, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0711886441942242, -0.59999999999999998, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.4072952835139891, -0.59999999999999998, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.8174863977376825, -0.59999999999999998, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.3029921578542232, -0.59999999999999998, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.8388723099514972, -0.59999999999999998, 0.60000000000000009, 
+	  1.5707963267948966 },
 };
+const double toler037 = 2.5000000000000020e-13;
 
-// Test function for k=-0.59999999999999998, nu=0.59999999999999998.
-template <typename Tp>
-void test037()
+// Test data for k=-0.59999999999999998, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.2451074234797436e-16
+// mean(f - f_Boost): 5.2735593669694933e-17
+// variance(f - f_Boost): 3.4333862218458872e-34
+// stddev(f - f_Boost): 1.8529398861932589e-17
+const testcase_ellint_3<double>
+data038[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data037)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data037[i].k), Tp(data037[i].nu),
-                   Tp(data037[i].phi));
-      const Tp f0 = data037[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.59999999999999998, nu=0.69999999999999996.
-testcase_ellint_3<double> data038[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17362996946312009, -0.59999999999999998, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34225353454870588, -0.59999999999999998, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.50259656397799546, -0.59999999999999998, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.65373184496628944, -0.59999999999999998, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.79658372884056439, -0.59999999999999998, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.93303240100245421, -0.59999999999999998, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0651547944716557, -0.59999999999999998, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1947676204853441, -0.59999999999999998, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.3232737468822811, -0.59999999999999998, 0.69999999999999996,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.59999999999999998, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17610453321631936, -0.59999999999999998, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36193365056369764, -0.59999999999999998, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56874098962268527, -0.59999999999999998, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.81106198671477181, -0.59999999999999998, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.1086886419010082, -0.59999999999999998, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.4879048567239257, -0.59999999999999998, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.9780310073615923, -0.59999999999999998, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.5941545586772712, -0.59999999999999998, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.3029735898397155, -0.59999999999999998, 0.70000000000000007, 
+	  1.5707963267948966 },
 };
+const double toler038 = 2.5000000000000020e-13;
 
-// Test function for k=-0.59999999999999998, nu=0.69999999999999996.
-template <typename Tp>
-void test038()
+// Test data for k=-0.59999999999999998, nu=0.80000000000000004.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.3826960061025914e-16
+// mean(f - f_Boost): 2.7478019859472625e-16
+// variance(f - f_Boost): 4.6451528105588637e-32
+// stddev(f - f_Boost): 2.1552616570984749e-16
+const testcase_ellint_3<double>
+data039[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data038)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data038[i].k), Tp(data038[i].nu),
-                   Tp(data038[i].phi));
-      const Tp f0 = data038[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.59999999999999998, nu=0.80000000000000004.
-testcase_ellint_3<double> data039[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17345794195390687, -0.59999999999999998, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34098797854531027, -0.59999999999999998, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49882569168826230, -0.59999999999999998, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.64603758566475511, -0.59999999999999998, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.78380365594769730, -0.59999999999999998, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.91430946255611190, -0.59999999999999998, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.0398955217270607, -0.59999999999999998, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.1625948314277676, -0.59999999999999998, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.2840021261752192, -0.59999999999999998, 0.80000000000000004,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.59999999999999998, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17628618080795252, -0.59999999999999998, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36349976272521012, -0.59999999999999998, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.57474392342151914, -0.59999999999999998, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.82814493499158159, -0.59999999999999998, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1511281795998280, -0.59999999999999998, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.5864286332503075, -0.59999999999999998, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.1958944866494527, -0.59999999999999998, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 3.0398358172574604, -0.59999999999999998, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 4.0867036409261832, -0.59999999999999998, 0.80000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler039 = 2.5000000000000020e-13;
 
-// Test function for k=-0.59999999999999998, nu=0.80000000000000004.
-template <typename Tp>
-void test039()
+// Test data for k=-0.59999999999999998, nu=0.90000000000000002.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.7440178400898422e-16
+// mean(f - f_Boost): 5.0792703376600914e-16
+// variance(f - f_Boost): 1.9863137923719990e-31
+// stddev(f - f_Boost): 4.4568080420543122e-16
+const testcase_ellint_3<double>
+data040[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data039)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data039[i].k), Tp(data039[i].nu),
-                   Tp(data039[i].phi));
-      const Tp f0 = data039[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.59999999999999998, nu=0.90000000000000002.
-testcase_ellint_3<double> data040[] = {
-  { -0.0000000000000000, -0.59999999999999998, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17328652344890033, -0.59999999999999998, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33973880062929018, -0.59999999999999998, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.49515092233122765, -0.59999999999999998, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.63864042139737043, -0.59999999999999998, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.77167205646538850, -0.59999999999999998, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.89673202848034383, -0.59999999999999998, 0.90000000000000002,
-          1.0471975511965976 },
-  { 1.0163984492661304, -0.59999999999999998, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.1328845785162431, -0.59999999999999998, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.2479362973851875, -0.59999999999999998, 0.90000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.59999999999999998, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17646850384035848, -0.59999999999999998, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36509041515134105, -0.59999999999999998, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.58097838596260631, -0.59999999999999998, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.84656453396163722, -0.59999999999999998, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1997828426963724, -0.59999999999999998, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.7112436789225605, -0.59999999999999998, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.5193168553672312, -0.59999999999999998, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.8656670488606686, -0.59999999999999998, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.8709993116265595, -0.59999999999999998, 0.90000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler040 = 2.5000000000000020e-13;
 
-// Test function for k=-0.59999999999999998, nu=0.90000000000000002.
-template <typename Tp>
-void test040()
+// Test data for k=-0.50000000000000000, nu=0.0000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.4551389361831220e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 2.5893058141206173e-32
+// stddev(f - f_Boost): 1.6091320064309879e-16
+const testcase_ellint_3<double>
+data041[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data040)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data040[i].k), Tp(data040[i].nu),
-                   Tp(data040[i].phi));
-      const Tp f0 = data040[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.50000000000000000, nu=0.0000000000000000.
-testcase_ellint_3<double> data041[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17475385514035785, -0.50000000000000000, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35081868470101585, -0.50000000000000000, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52942862705190585, -0.50000000000000000, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.71164727562630326, -0.50000000000000000, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.89824523594227768, -0.50000000000000000, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0895506700518851, -0.50000000000000000, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2853005857432933, -0.50000000000000000, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.4845545520549484, -0.50000000000000000, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.6857503548125963, -0.50000000000000000, 0.0000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.50000000000000000, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17475385514035785, -0.50000000000000000, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35081868470101579, -0.50000000000000000, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52942862705190574, -0.50000000000000000, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.71164727562630326, -0.50000000000000000, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.89824523594227768, -0.50000000000000000, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0895506700518853, -0.50000000000000000, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2853005857432933, -0.50000000000000000, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.4845545520549488, -0.50000000000000000, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.6857503548125961, -0.50000000000000000, 0.0000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler041 = 2.5000000000000020e-13;
 
-// Test function for k=-0.50000000000000000, nu=0.0000000000000000.
-template <typename Tp>
-void test041()
+// Test data for k=-0.50000000000000000, nu=0.10000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.7416868347177582e-16
+// mean(f - f_Boost): 2.7755575615628915e-18
+// variance(f - f_Boost): 5.4326441655972001e-32
+// stddev(f - f_Boost): 2.3308033305273100e-16
+const testcase_ellint_3<double>
+data042[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data041)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data041[i].k), Tp(data041[i].nu),
-                   Tp(data041[i].phi));
-      const Tp f0 = data041[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.50000000000000000, nu=0.10000000000000001.
-testcase_ellint_3<double> data042[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17457763120814676, -0.50000000000000000, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34943246340849154, -0.50000000000000000, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52487937869610801, -0.50000000000000000, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.70127785096388395, -0.50000000000000000, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.87898815988624479, -0.50000000000000000, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0582764576094172, -0.50000000000000000, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.2391936844060207, -0.50000000000000000, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.4214793542995841, -0.50000000000000000, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.6045524936084892, -0.50000000000000000, 0.10000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.50000000000000000, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17493071928248824, -0.50000000000000000, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35222467688034798, -0.50000000000000000, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.53411928652008112, -0.50000000000000000, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.72256398117177589, -0.50000000000000000, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.91899583232771009, -0.50000000000000000, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.1240549163055360, -0.50000000000000000, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.3372938086286021, -0.50000000000000000, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.5570024469132429, -0.50000000000000000, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.7803034946545480, -0.50000000000000000, 0.10000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler042 = 2.5000000000000020e-13;
 
-// Test function for k=-0.50000000000000000, nu=0.10000000000000001.
-template <typename Tp>
-void test042()
+// Test data for k=-0.50000000000000000, nu=0.20000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1198767993730867e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 5.0311947683004831e-32
+// stddev(f - f_Boost): 2.2430324938128922e-16
+const testcase_ellint_3<double>
+data043[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data042)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data042[i].k), Tp(data042[i].nu),
-                   Tp(data042[i].phi));
-      const Tp f0 = data042[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.50000000000000000, nu=0.20000000000000001.
-testcase_ellint_3<double> data043[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17440204336345433, -0.50000000000000000, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34806552388338824, -0.50000000000000000, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.52046416757129821, -0.50000000000000000, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.69140924550993876, -0.50000000000000000, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.86104678636125520, -0.50000000000000000, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0297439459053981, -0.50000000000000000, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1979214112912036, -0.50000000000000000, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.3659033858648930, -0.50000000000000000, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.5338490483665983, -0.50000000000000000, 0.20000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.50000000000000000, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17510822779582402, -0.50000000000000000, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35365094725531487, -0.50000000000000000, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53895933237328697, -0.50000000000000000, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.73408090840070794, -0.50000000000000000, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.94145442818535396, -0.50000000000000000, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1624120186296487, -0.50000000000000000, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3965823372867114, -0.50000000000000000, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.6414308440430099, -0.50000000000000000, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.8922947612264018, -0.50000000000000000, 0.20000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler043 = 2.5000000000000020e-13;
 
-// Test function for k=-0.50000000000000000, nu=0.20000000000000001.
-template <typename Tp>
-void test043()
+// Test data for k=-0.50000000000000000, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3800262770228813e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 8.5027191584278157e-32
+// stddev(f - f_Boost): 2.9159422419567599e-16
+const testcase_ellint_3<double>
+data044[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data043)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data043[i].k), Tp(data043[i].nu),
-                   Tp(data043[i].phi));
-      const Tp f0 = data043[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.50000000000000000, nu=0.29999999999999999.
-testcase_ellint_3<double> data044[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17422708752228896, -0.50000000000000000, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34671739434855858, -0.50000000000000000, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51617616305641889, -0.50000000000000000, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.68200047612545178, -0.50000000000000000, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.84427217869498372, -0.50000000000000000, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.0035637821389782, -0.50000000000000000, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1606800483933113, -0.50000000000000000, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.3164407134643459, -0.50000000000000000, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.4715681939859637, -0.50000000000000000, 0.29999999999999999,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.50000000000000000, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17528638488102041, -0.50000000000000000, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35509802222332720, -0.50000000000000000, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.54395740731866193, -0.50000000000000000, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.74625871438752667, -0.50000000000000000, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.96588271186092023, -0.50000000000000000, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.2054319584357329, -0.50000000000000000, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.4651077994832871, -0.50000000000000000, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.7416018368052644, -0.50000000000000000, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.0277924458111314, -0.50000000000000000, 0.30000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler044 = 2.5000000000000020e-13;
 
-// Test function for k=-0.50000000000000000, nu=0.29999999999999999.
-template <typename Tp>
-void test044()
+// Test data for k=-0.50000000000000000, nu=0.40000000000000002.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.0439932918341581e-16
+// mean(f - f_Boost): 3.0531133177191807e-17
+// variance(f - f_Boost): 9.0809736800018602e-32
+// stddev(f - f_Boost): 3.0134653938616686e-16
+const testcase_ellint_3<double>
+data045[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data044)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data044[i].k), Tp(data044[i].nu),
-                   Tp(data044[i].phi));
-      const Tp f0 = data044[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.50000000000000000, nu=0.40000000000000002.
-testcase_ellint_3<double> data045[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17405275963859917, -0.50000000000000000, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34538761957029329, -0.50000000000000000, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.51200902646603919, -0.50000000000000000, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.67301522212868792, -0.50000000000000000, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.82853844466313320, -0.50000000000000000, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.97942097862681488, -0.50000000000000000, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.1268429801220616, -0.50000000000000000, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2720406704533922, -0.50000000000000000, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.4161679518465340, -0.50000000000000000, 0.40000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.50000000000000000, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17546519477859268, -0.50000000000000000, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35656644822531680, -0.50000000000000000, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54912289677411319, -0.50000000000000000, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.75916731611690047, -0.50000000000000000, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.99260415631328214, -0.50000000000000000, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2541925856918670, -0.50000000000000000, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.5456393705347609, -0.50000000000000000, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.8631904972952076, -0.50000000000000000, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.1962905366178065, -0.50000000000000000, 0.40000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler045 = 2.5000000000000020e-13;
 
-// Test function for k=-0.50000000000000000, nu=0.40000000000000002.
-template <typename Tp>
-void test045()
+// Test data for k=-0.50000000000000000, nu=0.50000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.6797816859260978e-16
+// mean(f - f_Boost): 9.4368957093138303e-17
+// variance(f - f_Boost): 7.7794254682023874e-32
+// stddev(f - f_Boost): 2.7891621444803792e-16
+const testcase_ellint_3<double>
+data046[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data045)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data045[i].k), Tp(data045[i].nu),
-                   Tp(data045[i].phi));
-      const Tp f0 = data045[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.50000000000000000, nu=0.50000000000000000.
-testcase_ellint_3<double> data046[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17387905570381157, -0.50000000000000000, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34407576010465207, -0.50000000000000000, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50795686560160835, -0.50000000000000000, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.66442115453330175, -0.50000000000000000, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.81373829119355345, -0.50000000000000000, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.95705743313235825, -0.50000000000000000, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0959131991362556, -0.50000000000000000, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.2318900529754597, -0.50000000000000000, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.3664739530045971, -0.50000000000000000, 0.50000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.50000000000000000, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17564466176941509, -0.50000000000000000, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35805679276065394, -0.50000000000000000, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.55446601496200032, -0.50000000000000000, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.77288783578259013, -0.50000000000000000, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0220246013918972, -0.50000000000000000, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.3101681612463965, -0.50000000000000000, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.6422994881851025, -0.50000000000000000, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.0152636030998816, -0.50000000000000000, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.4136715042011945, -0.50000000000000000, 0.50000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler046 = 2.5000000000000020e-13;
 
-// Test function for k=-0.50000000000000000, nu=0.50000000000000000.
-template <typename Tp>
-void test046()
+// Test data for k=-0.50000000000000000, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.9178421578645735e-16
+// mean(f - f_Boost): 1.3322676295501878e-16
+// variance(f - f_Boost): 1.7749370367472766e-31
+// stddev(f - f_Boost): 4.2130001622920411e-16
+const testcase_ellint_3<double>
+data047[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data046)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data046[i].k), Tp(data046[i].nu),
-                   Tp(data046[i].phi));
-      const Tp f0 = data046[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.50000000000000000, nu=0.59999999999999998.
-testcase_ellint_3<double> data047[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17370597174637581, -0.50000000000000000, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34278139158591414, -0.50000000000000000, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50401419439302719, -0.50000000000000000, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.65618938076167221, -0.50000000000000000, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.79977959248855424, -0.50000000000000000, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.93625925190753545, -0.50000000000000000, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0674905658379710, -0.50000000000000000, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1953481298023048, -0.50000000000000000, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.3215740290190876, -0.50000000000000000, 0.59999999999999998,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.50000000000000000, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17582479017522740, -0.50000000000000000, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35956964546660036, -0.50000000000000000, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55999790372984193, -0.50000000000000000, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.78751507911209895, -0.50000000000000000, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0546620505035220, -0.50000000000000000, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3754438357425935, -0.50000000000000000, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.7615727400820127, -0.50000000000000000, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.2134638067565242, -0.50000000000000000, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.7090491861753558, -0.50000000000000000, 0.60000000000000009, 
+	  1.5707963267948966 },
 };
+const double toler047 = 2.5000000000000020e-13;
 
-// Test function for k=-0.50000000000000000, nu=0.59999999999999998.
-template <typename Tp>
-void test047()
+// Test data for k=-0.50000000000000000, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0745105182189226e-16
+// mean(f - f_Boost): 4.1633363423443370e-17
+// variance(f - f_Boost): 1.9996383743576116e-32
+// stddev(f - f_Boost): 1.4140857026211713e-16
+const testcase_ellint_3<double>
+data048[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data047)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data047[i].k), Tp(data047[i].nu),
-                   Tp(data047[i].phi));
-      const Tp f0 = data047[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.50000000000000000, nu=0.69999999999999996.
-testcase_ellint_3<double> data048[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17353350383131641, -0.50000000000000000, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34150410405436771, -0.50000000000000000, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.50017589696443487, -0.50000000000000000, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.64829398188419962, -0.50000000000000000, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.78658270782402073, -0.50000000000000000, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.91684738336675053, -0.50000000000000000, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0412486789555937, -0.50000000000000000, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1619021847612001, -0.50000000000000000, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2807475181182502, -0.50000000000000000, 0.69999999999999996,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.50000000000000000, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17600558435914915, -0.50000000000000000, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36110561926726259, -0.50000000000000000, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56573074641137111, -0.50000000000000000, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.80316073084237205, -0.50000000000000000, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0911910688131461, -0.50000000000000000, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.4530946406380640, -0.50000000000000000, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.9144386536785372, -0.50000000000000000, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.4878788958234970, -0.50000000000000000, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.1433945297859225, -0.50000000000000000, 0.70000000000000007, 
+	  1.5707963267948966 },
 };
+const double toler048 = 2.5000000000000020e-13;
 
-// Test function for k=-0.50000000000000000, nu=0.69999999999999996.
-template <typename Tp>
-void test048()
+// Test data for k=-0.50000000000000000, nu=0.80000000000000004.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.4380477375534667e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 1.4989821857033475e-31
+// stddev(f - f_Boost): 3.8716691306248618e-16
+const testcase_ellint_3<double>
+data049[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data048)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data048[i].k), Tp(data048[i].nu),
-                   Tp(data048[i].phi));
-      const Tp f0 = data048[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.50000000000000000, nu=0.80000000000000004.
-testcase_ellint_3<double> data049[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17336164805979126, -0.50000000000000000, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34024350132086773, -0.50000000000000000, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49643719555734084, -0.50000000000000000, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.64071162456976150, -0.50000000000000000, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.77407836177211908, -0.50000000000000000, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.89867058251905652, -0.50000000000000000, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.0169181822134912, -0.50000000000000000, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.1311363312779448, -0.50000000000000000, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.2434165408189539, -0.50000000000000000, 0.80000000000000004,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.50000000000000000, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17618704872620228, -0.50000000000000000, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36266535159745827, -0.50000000000000000, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.57167789954529158, -0.50000000000000000, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.81995752984315018, -0.50000000000000000, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1325112162158122, -0.50000000000000000, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.5479055930718042, -0.50000000000000000, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.1215243941010486, -0.50000000000000000, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.9069405767650132, -0.50000000000000000, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.8750701888108066, -0.50000000000000000, 0.80000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler049 = 2.5000000000000020e-13;
 
-// Test function for k=-0.50000000000000000, nu=0.80000000000000004.
-template <typename Tp>
-void test049()
+// Test data for k=-0.50000000000000000, nu=0.90000000000000002.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.6192315188521289e-16
+// mean(f - f_Boost): 3.5249581031848718e-16
+// variance(f - f_Boost): 2.5029385557256515e-31
+// stddev(f - f_Boost): 5.0029376927217987e-16
+const testcase_ellint_3<double>
+data050[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data049)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data049[i].k), Tp(data049[i].nu),
-                   Tp(data049[i].phi));
-      const Tp f0 = data049[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.50000000000000000, nu=0.90000000000000002.
-testcase_ellint_3<double> data050[] = {
-  { -0.0000000000000000, -0.50000000000000000, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17319040056865681, -0.50000000000000000, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33899920036578557, -0.50000000000000000, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.49279362182695186, -0.50000000000000000, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.63342123379746151, -0.50000000000000000, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.76220595179550321, -0.50000000000000000, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.88160004743532294, -0.50000000000000000, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.99427448642310134, -0.50000000000000000, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.1027091512470093, -0.50000000000000000, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.2091116095504744, -0.50000000000000000, 0.90000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.50000000000000000, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17636918772384180, -0.50000000000000000, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36424950570740700, -0.50000000000000000, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57785404590231426, -0.50000000000000000, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.83806480521716531, -0.50000000000000000, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1798568683069752, -0.50000000000000000, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.6678766243739607, -0.50000000000000000, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.4282976450693483, -0.50000000000000000, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.6810787666126656, -0.50000000000000000, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.5355132096026454, -0.50000000000000000, 0.90000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler050 = 2.5000000000000020e-13;
 
-// Test function for k=-0.50000000000000000, nu=0.90000000000000002.
-template <typename Tp>
-void test050()
+// Test data for k=-0.39999999999999991, nu=0.0000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.1423314994346225e-16
+// mean(f - f_Boost): 1.9428902930940238e-17
+// variance(f - f_Boost): 2.2263750157116445e-32
+// stddev(f - f_Boost): 1.4921042241450980e-16
+const testcase_ellint_3<double>
+data051[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data050)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data050[i].k), Tp(data050[i].nu),
-                   Tp(data050[i].phi));
-      const Tp f0 = data050[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.0000000000000000.
-testcase_ellint_3<double> data051[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17467414669441531, -0.40000000000000002, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35018222772483443, -0.40000000000000002, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52729015917508748, -0.40000000000000002, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.70662374407341255, -0.40000000000000002, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.88859210497602170, -0.40000000000000002, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0733136290471379, -0.40000000000000002, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2605612170157061, -0.40000000000000002, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.4497513956433437, -0.40000000000000002, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.6399998658645112, -0.40000000000000002, 0.0000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.39999999999999991, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17467414669441528, -0.39999999999999991, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35018222772483443, -0.39999999999999991, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52729015917508748, -0.39999999999999991, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.70662374407341244, -0.39999999999999991, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.88859210497602159, -0.39999999999999991, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0733136290471381, -0.39999999999999991, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2605612170157066, -0.39999999999999991, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.4497513956433439, -0.39999999999999991, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.6399998658645112, -0.39999999999999991, 0.0000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler051 = 2.5000000000000020e-13;
 
-// Test function for k=-0.40000000000000002, nu=0.0000000000000000.
-template <typename Tp>
-void test051()
+// Test data for k=-0.39999999999999991, nu=0.10000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.8489340395463703e-16
+// mean(f - f_Boost): 6.3837823915946496e-17
+// variance(f - f_Boost): 4.4785242050000272e-32
+// stddev(f - f_Boost): 2.1162523963365114e-16
+const testcase_ellint_3<double>
+data052[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data051)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data051[i].k), Tp(data051[i].nu),
-                   Tp(data051[i].phi));
-      const Tp f0 = data051[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.10000000000000001.
-testcase_ellint_3<double> data052[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17449806706684673, -0.40000000000000002, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34880048623856075, -0.40000000000000002, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52277322065757403, -0.40000000000000002, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.69638072056918376, -0.40000000000000002, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.86968426619831540, -0.40000000000000002, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0428044206578095, -0.40000000000000002, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.2158651158274378, -0.40000000000000002, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.3889447129893322, -0.40000000000000002, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.5620566886683604, -0.40000000000000002, 0.10000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.39999999999999991, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17485086590796767, -0.39999999999999991, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35158366412506992, -0.39999999999999991, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.53194731675711726, -0.39999999999999991, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.71740615528010931, -0.39999999999999991, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.90896157773487030, -0.39999999999999991, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.1069605483834348, -0.39999999999999991, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.3109353428823001, -0.39999999999999991, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.5195460789903448, -0.39999999999999991, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.7306968836847187, -0.39999999999999991, 0.10000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler052 = 2.5000000000000020e-13;
 
-// Test function for k=-0.40000000000000002, nu=0.10000000000000001.
-template <typename Tp>
-void test052()
+// Test data for k=-0.39999999999999991, nu=0.20000000000000001.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.0467985583872730e-16
+// mean(f - f_Boost): 8.6042284408449634e-17
+// variance(f - f_Boost): 1.5826864298542218e-32
+// stddev(f - f_Boost): 1.2580486595733180e-16
+const testcase_ellint_3<double>
+data053[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data052)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data052[i].k), Tp(data052[i].nu),
-                   Tp(data052[i].phi));
-      const Tp f0 = data052[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.20000000000000001.
-testcase_ellint_3<double> data053[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17432262290723399, -0.40000000000000002, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34743795258968596, -0.40000000000000002, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.51838919472805123, -0.40000000000000002, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.68663134739057918, -0.40000000000000002, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.85206432981833979, -0.40000000000000002, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0149595349004430, -0.40000000000000002, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1758349405464676, -0.40000000000000002, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.3353337673882635, -0.40000000000000002, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.4941414344266770, -0.40000000000000002, 0.20000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.39999999999999991, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17502822886437389, -0.39999999999999991, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35300530062530805, -0.39999999999999991, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53675259548210896, -0.39999999999999991, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.72878006428676934, -0.39999999999999991, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.93100219010583563, -0.39999999999999991, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1443487271187609, -0.39999999999999991, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3683427764108813, -0.39999999999999991, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.6008221459300933, -0.39999999999999991, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.8380358826317627, -0.39999999999999991, 0.20000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler053 = 2.5000000000000020e-13;
 
-// Test function for k=-0.40000000000000002, nu=0.20000000000000001.
-template <typename Tp>
-void test053()
+// Test data for k=-0.39999999999999991, nu=0.30000000000000004.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.9973414591826100e-16
+// mean(f - f_Boost): 8.6042284408449634e-17
+// variance(f - f_Boost): 1.5826864298542218e-32
+// stddev(f - f_Boost): 1.2580486595733180e-16
+const testcase_ellint_3<double>
+data054[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data053)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data053[i].k), Tp(data053[i].nu),
-                   Tp(data053[i].phi));
-      const Tp f0 = data053[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.29999999999999999.
-testcase_ellint_3<double> data054[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17414781013591543, -0.40000000000000002, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34609415696777285, -0.40000000000000002, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51413131295862546, -0.40000000000000002, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.67733527622935630, -0.40000000000000002, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.83558675182733266, -0.40000000000000002, 0.29999999999999999,
-          0.87266462599716477 },
-  { 0.98940140808865906, -0.40000000000000002, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1396968797728058, -0.40000000000000002, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.2875920037865087, -0.40000000000000002, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.4342789859950078, -0.40000000000000002, 0.29999999999999999,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.39999999999999991, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17520623975982899, -0.39999999999999991, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35444766141612105, -0.39999999999999991, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.54171455841536009, -0.39999999999999991, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.74080517001084012, -0.39999999999999991, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.95496950509296563, -0.39999999999999991, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.1862627879844718, -0.39999999999999991, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.4346501803799458, -0.39999999999999991, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.6971744798077697, -0.39999999999999991, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 1.9677924132520139, -0.39999999999999991, 0.30000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler054 = 2.5000000000000020e-13;
 
-// Test function for k=-0.40000000000000002, nu=0.29999999999999999.
-template <typename Tp>
-void test054()
+// Test data for k=-0.39999999999999991, nu=0.40000000000000002.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.2577246923979600e-16
+// mean(f - f_Boost): 1.8596235662471373e-16
+// variance(f - f_Boost): 1.6222417021441306e-31
+// stddev(f - f_Boost): 4.0277061736727151e-16
+const testcase_ellint_3<double>
+data055[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data054)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data054[i].k), Tp(data054[i].nu),
-                   Tp(data054[i].phi));
-      const Tp f0 = data054[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.40000000000000002.
-testcase_ellint_3<double> data055[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17397362471112710, -0.40000000000000002, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34476864603333196, -0.40000000000000002, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.50999329415379357, -0.40000000000000002, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.66845674551396017, -0.40000000000000002, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.82012848346231748, -0.40000000000000002, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.96582449258349057, -0.40000000000000002, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.1068473749476286, -0.40000000000000002, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2447132729159986, -0.40000000000000002, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.3809986210732901, -0.40000000000000002, 0.40000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.39999999999999991, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17538490283034375, -0.39999999999999991, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35591129064319948, -0.39999999999999991, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54684250413264535, -0.39999999999999991, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.75355027742668290, -0.39999999999999991, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.98117935026780634, -0.39999999999999991, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2337464222030734, -0.39999999999999991, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.5125183419289221, -0.39999999999999991, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.8140224451130311, -0.39999999999999991, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.1289968719280026, -0.39999999999999991, 0.40000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler055 = 2.5000000000000020e-13;
 
-// Test function for k=-0.40000000000000002, nu=0.40000000000000002.
-template <typename Tp>
-void test055()
+// Test data for k=-0.39999999999999991, nu=0.50000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.8009196014748294e-16
+// mean(f - f_Boost): 1.6375789613221060e-16
+// variance(f - f_Boost): 6.4788283329186610e-32
+// stddev(f - f_Boost): 2.5453542647181080e-16
+const testcase_ellint_3<double>
+data056[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data055)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data055[i].k), Tp(data055[i].nu),
-                   Tp(data055[i].phi));
-      const Tp f0 = data055[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.50000000000000000.
-testcase_ellint_3<double> data056[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17380006262854139, -0.40000000000000002, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34346098216756610, -0.40000000000000002, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50596929935059420, -0.40000000000000002, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.65996392089131262, -0.40000000000000002, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.80558463511364786, -0.40000000000000002, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.94397834522857704, -0.40000000000000002, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0768075114108115, -0.40000000000000002, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.2059184624251329, -0.40000000000000002, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.3331797176377398, -0.40000000000000002, 0.50000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.39999999999999991, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17556422235224273, -0.39999999999999991, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35739675341763921, -0.39999999999999991, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.55214655195037188, -0.39999999999999991, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.76709520942047438, -0.39999999999999991, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0100278761577499, -0.39999999999999991, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.2882265661384342, -0.39999999999999991, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.6059059780051874, -0.39999999999999991, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 1.9600182740224081, -0.39999999999999991, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.3367461373176508, -0.39999999999999991, 0.50000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler056 = 2.5000000000000020e-13;
 
-// Test function for k=-0.40000000000000002, nu=0.50000000000000000.
-template <typename Tp>
-void test056()
+// Test data for k=-0.39999999999999991, nu=0.60000000000000009.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 2.8411408870840790e-16
+// mean(f - f_Boost): 9.7144514654701197e-17
+// variance(f - f_Boost): 1.4860570558543486e-32
+// stddev(f - f_Boost): 1.2190393988113545e-16
+const testcase_ellint_3<double>
+data057[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data056)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data056[i].k), Tp(data056[i].nu),
-                   Tp(data056[i].phi));
-      const Tp f0 = data056[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.59999999999999998.
-testcase_ellint_3<double> data057[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17362711992081248, -0.40000000000000002, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34217074276403953, -0.40000000000000002, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50205389185761617, -0.40000000000000002, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.65182834920372745, -0.40000000000000002, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.79186512820565136, -0.40000000000000002, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.92365535916287134, -0.40000000000000002, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0491915663957907, -0.40000000000000002, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1705934291745104, -0.40000000000000002, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.2899514672527024, -0.40000000000000002, 0.59999999999999998,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.39999999999999991, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17574420264267029, -0.39999999999999991, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35890463689046265, -0.39999999999999991, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55763773975194486, -0.39999999999999991, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.78153324227761267, -0.39999999999999991, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0420205885765887, -0.39999999999999991, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3517205230381770, -0.39999999999999991, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.7210360970313896, -0.39999999999999991, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.1500780510169242, -0.39999999999999991, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.6186940209850191, -0.39999999999999991, 0.60000000000000009, 
+	  1.5707963267948966 },
 };
+const double toler057 = 2.5000000000000020e-13;
 
-// Test function for k=-0.40000000000000002, nu=0.59999999999999998.
-template <typename Tp>
-void test057()
+// Test data for k=-0.39999999999999991, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.1553900340611668e-16
+// mean(f - f_Boost): 1.1657341758564144e-16
+// variance(f - f_Boost): 1.3242789405258207e-32
+// stddev(f - f_Boost): 1.1507731924779187e-16
+const testcase_ellint_3<double>
+data058[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data057)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data057[i].k), Tp(data057[i].nu),
-                   Tp(data057[i].phi));
-      const Tp f0 = data057[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.69999999999999996.
-testcase_ellint_3<double> data058[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17345479265712871, -0.40000000000000002, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34089751955950354, -0.40000000000000002, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.49824200167361343, -0.40000000000000002, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.64402450341199413, -0.40000000000000002, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.77889207804122873, -0.40000000000000002, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.90468169720957992, -0.40000000000000002, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0236847823692916, -0.40000000000000002, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1382465247425164, -0.40000000000000002, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2506255923253344, -0.40000000000000002, 0.69999999999999996,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.39999999999999991, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17592484806010436, -0.39999999999999991, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36043555139631439, -0.39999999999999991, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56332813669944881, -0.39999999999999991, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.79697424562157548, -0.39999999999999991, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0778155987523672, -0.39999999999999991, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.4272018169896268, -0.39999999999999991, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.8684377907453380, -0.39999999999999991, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.4128677409207469, -0.39999999999999991, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.0327078743873241, -0.39999999999999991, 0.70000000000000007, 
+	  1.5707963267948966 },
 };
+const double toler058 = 2.5000000000000020e-13;
 
-// Test function for k=-0.40000000000000002, nu=0.69999999999999996.
-template <typename Tp>
-void test058()
+// Test data for k=-0.39999999999999991, nu=0.80000000000000004.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5727642219519274e-16
+// mean(f - f_Boost): 2.1926904736346843e-16
+// variance(f - f_Boost): 1.5293405480859847e-31
+// stddev(f - f_Boost): 3.9106783913868252e-16
+const testcase_ellint_3<double>
+data059[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data058)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data058[i].k), Tp(data058[i].nu),
-                   Tp(data058[i].phi));
-      const Tp f0 = data058[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.80000000000000004.
-testcase_ellint_3<double> data059[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17328307694277156, -0.40000000000000002, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.33964091800132007, -0.40000000000000002, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49452889372467451, -0.40000000000000002, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.63652940095937327, -0.40000000000000002, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.76659772511159097, -0.40000000000000002, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.88691047977338111, -0.40000000000000002, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.0000273200611638, -0.40000000000000002, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.1084787902188007, -0.40000000000000002, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.2146499565727209, -0.40000000000000002, 0.80000000000000004,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.39999999999999991, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17610616300487833, -0.39999999999999991, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36199013167171978, -0.39999999999999991, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.56923097361842423, -0.39999999999999991, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.81354878456624347, -0.39999999999999991, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1182902719261825, -0.39999999999999991, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.5192950589409022, -0.39999999999999991, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.0678761710223981, -0.39999999999999991, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.8135222249879783, -0.39999999999999991, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.7289548002199902, -0.39999999999999991, 0.80000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler059 = 2.5000000000000020e-13;
 
-// Test function for k=-0.40000000000000002, nu=0.80000000000000004.
-template <typename Tp>
-void test059()
+// Test data for k=-0.39999999999999991, nu=0.90000000000000002.
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.0221626338023938e-16
+// mean(f - f_Boost): 4.1910919179599658e-16
+// variance(f - f_Boost): 6.2246150910247033e-31
+// stddev(f - f_Boost): 7.8896229891070860e-16
+const testcase_ellint_3<double>
+data060[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data059)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data059[i].k), Tp(data059[i].nu),
-                   Tp(data059[i].phi));
-      const Tp f0 = data059[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.40000000000000002, nu=0.90000000000000002.
-testcase_ellint_3<double> data060[] = {
-  { -0.0000000000000000, -0.40000000000000002, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17311196891868130, -0.40000000000000002, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33840055664911906, -0.40000000000000002, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.49091013944075340, -0.40000000000000002, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.62932228186809591, -0.40000000000000002, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.75492278323019801, -0.40000000000000002, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.87021659043854294, -0.40000000000000002, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.97800245228239246, -0.40000000000000002, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.0809625773173694, -0.40000000000000002, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.1815758115929846, -0.40000000000000002, 0.90000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.39999999999999991, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17628815191971123, -0.39999999999999991, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36356903815378772, -0.39999999999999991, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57536079447000310, -0.39999999999999991, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.83141355850172571, -0.39999999999999991, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1646481598721361, -0.39999999999999991, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.6357275034001995, -0.39999999999999991, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.3628787566572398, -0.39999999999999991, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.5521010369134958, -0.39999999999999991, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.3055535102872513, -0.39999999999999991, 0.90000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler060 = 2.5000000000000020e-13;
 
-// Test function for k=-0.40000000000000002, nu=0.90000000000000002.
-template <typename Tp>
-void test060()
+// Test data for k=-0.29999999999999993, nu=0.0000000000000000.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.2241249691539529e-16
+// mean(f - f_Boost): 4.9960036108132046e-17
+// variance(f - f_Boost): 4.6872855002064458e-32
+// stddev(f - f_Boost): 2.1650139722889657e-16
+const testcase_ellint_3<double>
+data061[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data060)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data060[i].k), Tp(data060[i].nu),
-                   Tp(data060[i].phi));
-      const Tp f0 = data060[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.0000000000000000.
-testcase_ellint_3<double> data061[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17461228653000102, -0.30000000000000004, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.34969146102798415, -0.30000000000000004, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52565822873726320, -0.30000000000000004, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.70284226512408532, -0.30000000000000004, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.88144139195111182, -0.30000000000000004, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0614897067260523, -0.30000000000000004, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2428416824174218, -0.30000000000000004, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.4251795877015925, -0.30000000000000004, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.6080486199305126, -0.30000000000000004, 0.0000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.29999999999999993, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17461228653000099, -0.29999999999999993, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.34969146102798421, -0.29999999999999993, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52565822873726309, -0.29999999999999993, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.70284226512408543, -0.29999999999999993, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.88144139195111171, -0.29999999999999993, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0614897067260520, -0.29999999999999993, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2428416824174220, -0.29999999999999993, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.4251795877015929, -0.29999999999999993, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.6080486199305126, -0.29999999999999993, 0.0000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler061 = 2.5000000000000020e-13;
 
-// Test function for k=-0.30000000000000004, nu=0.0000000000000000.
-template <typename Tp>
-void test061()
+// Test data for k=-0.29999999999999993, nu=0.10000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1872304407982844e-16
+// mean(f - f_Boost): 9.4368957093138303e-17
+// variance(f - f_Boost): 4.0359883022230488e-32
+// stddev(f - f_Boost): 2.0089769292411121e-16
+const testcase_ellint_3<double>
+data062[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data061)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data061[i].k), Tp(data061[i].nu),
-                   Tp(data061[i].phi));
-      const Tp f0 = data061[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.10000000000000001.
-testcase_ellint_3<double> data062[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17443631884814378, -0.30000000000000004, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34831316835124926, -0.30000000000000004, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52116586276523857, -0.30000000000000004, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.69269385837910036, -0.30000000000000004, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.86279023163070856, -0.30000000000000004, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0315321461438265, -0.30000000000000004, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.1991449111869024, -0.30000000000000004, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.3659561780923211, -0.30000000000000004, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.5323534693557526, -0.30000000000000004, 0.10000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.29999999999999993, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17478889331392972, -0.29999999999999993, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35108939018329183, -0.29999999999999993, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.53028990896115835, -0.29999999999999993, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.71352417052371409, -0.29999999999999993, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.90153086032405894, -0.29999999999999993, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.0945187977283313, -0.29999999999999993, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.2920699268385680, -0.29999999999999993, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.4931243665896394, -0.29999999999999993, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.6960848815118226, -0.29999999999999993, 0.10000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler062 = 2.5000000000000020e-13;
 
-// Test function for k=-0.30000000000000004, nu=0.10000000000000001.
-template <typename Tp>
-void test062()
+// Test data for k=-0.29999999999999993, nu=0.20000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.2247497610332889e-16
+// mean(f - f_Boost): 1.1102230246251565e-16
+// variance(f - f_Boost): 3.8043060629871325e-32
+// stddev(f - f_Boost): 1.9504630380981672e-16
+const testcase_ellint_3<double>
+data063[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data062)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data062[i].k), Tp(data062[i].nu),
-                   Tp(data062[i].phi));
-      const Tp f0 = data062[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.20000000000000001.
-testcase_ellint_3<double> data063[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17426098615372090, -0.30000000000000004, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34695402664689923, -0.30000000000000004, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.51680555567038933, -0.30000000000000004, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.68303375225260210, -0.30000000000000004, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.84540662891295026, -0.30000000000000004, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0041834051646927, -0.30000000000000004, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1599952702345711, -0.30000000000000004, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.3137179520499163, -0.30000000000000004, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.4663658145259875, -0.30000000000000004, 0.20000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.29999999999999993, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17496614335337535, -0.29999999999999993, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35250745937139372, -0.29999999999999993, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53506875002836884, -0.29999999999999993, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.72479106622248191, -0.29999999999999993, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.92326451535891607, -0.29999999999999993, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1312092060698349, -0.29999999999999993, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3481473154592321, -0.29999999999999993, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.5722049569662748, -0.29999999999999993, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.8002173372290498, -0.29999999999999993, 0.20000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler063 = 2.5000000000000020e-13;
 
-// Test function for k=-0.30000000000000004, nu=0.20000000000000001.
-template <typename Tp>
-void test063()
+// Test data for k=-0.29999999999999993, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.1678685180047551e-16
+// mean(f - f_Boost): 1.0547118733938987e-16
+// variance(f - f_Boost): 7.5633408838247182e-32
+// stddev(f - f_Boost): 2.7501528837184157e-16
+const testcase_ellint_3<double>
+data064[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data063)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data063[i].k), Tp(data063[i].nu),
-                   Tp(data063[i].phi));
-      const Tp f0 = data063[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.29999999999999999.
-testcase_ellint_3<double> data064[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17408628437042845, -0.30000000000000004, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34561356761638401, -0.30000000000000004, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51257058617875850, -0.30000000000000004, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.67382207124602866, -0.30000000000000004, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.82914751587825131, -0.30000000000000004, 0.29999999999999999,
-          0.87266462599716477 },
-  { 0.97907434814374950, -0.30000000000000004, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1246399297351584, -0.30000000000000004, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.2671793970398146, -0.30000000000000004, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.4081767433479089, -0.30000000000000004, 0.29999999999999999,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.29999999999999993, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17514404084107435, -0.29999999999999993, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35394619108645647, -0.29999999999999993, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.54000325463372689, -0.29999999999999993, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.73670193794067651, -0.29999999999999993, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.94689345491722177, -0.29999999999999993, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.1723274608389140, -0.29999999999999993, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.4128880552936287, -0.29999999999999993, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.6659010047449661, -0.29999999999999993, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 1.9260216862473254, -0.29999999999999993, 0.30000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler064 = 2.5000000000000020e-13;
 
-// Test function for k=-0.30000000000000004, nu=0.29999999999999999.
-template <typename Tp>
-void test064()
+// Test data for k=-0.29999999999999993, nu=0.40000000000000002.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.3983279132797385e-16
+// mean(f - f_Boost): 1.1657341758564144e-16
+// variance(f - f_Boost): 1.8245832308692586e-31
+// stddev(f - f_Boost): 4.2715140534349863e-16
+const testcase_ellint_3<double>
+data065[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data064)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data064[i].k), Tp(data064[i].nu),
-                   Tp(data064[i].phi));
-      const Tp f0 = data064[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.40000000000000002.
-testcase_ellint_3<double> data065[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17391220945982730, -0.30000000000000004, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34429133937639689, -0.30000000000000004, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.50845471668581632, -0.30000000000000004, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.66502347027873854, -0.30000000000000004, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.81389191978012254, -0.30000000000000004, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.95590618002140593, -0.30000000000000004, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.0924915195213121, -0.30000000000000004, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2253651604038058, -0.30000000000000004, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.3563643538969761, -0.30000000000000004, 0.40000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.29999999999999993, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17532259000954434, -0.29999999999999993, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35540612770983693, -0.29999999999999993, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54510265552938919, -0.29999999999999993, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.74932476310965057, -0.29999999999999993, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.97272793583093109, -0.29999999999999993, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2188928987074241, -0.29999999999999993, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.4888771674085941, -0.29999999999999993, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.7794558498219191, -0.29999999999999993, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.0822121773175528, -0.29999999999999993, 0.40000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler065 = 2.5000000000000020e-13;
 
-// Test function for k=-0.30000000000000004, nu=0.40000000000000002.
-template <typename Tp>
-void test065()
+// Test data for k=-0.29999999999999993, nu=0.50000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.0516138451673425e-16
+// mean(f - f_Boost): 4.7184478546569152e-17
+// variance(f - f_Boost): 1.9448563670505968e-32
+// stddev(f - f_Boost): 1.3945810722401896e-16
+const testcase_ellint_3<double>
+data066[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data065)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data065[i].k), Tp(data065[i].nu),
-                   Tp(data065[i].phi));
-      const Tp f0 = data065[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.50000000000000000.
-testcase_ellint_3<double> data066[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17373875742088235, -0.30000000000000004, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34298690571124157, -0.30000000000000004, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50445214859646936, -0.30000000000000004, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.65660648352418516, -0.30000000000000004, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.79953670639287289, -0.30000000000000004, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.93443393926588558, -0.30000000000000004, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0630838369016911, -0.30000000000000004, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.1875197325653026, -0.30000000000000004, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.3098448759814960, -0.30000000000000004, 0.50000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.29999999999999993, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17550179513158179, -0.29999999999999993, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35688783251681200, -0.29999999999999993, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.55037700010142798, -0.29999999999999993, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.76273839789895992, -0.29999999999999993, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0011570518830419, -0.29999999999999993, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.2722987414055109, -0.29999999999999993, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.5799590511080066, -0.29999999999999993, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 1.9212367220124293, -0.29999999999999993, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.2833505881933971, -0.29999999999999993, 0.50000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler066 = 2.5000000000000020e-13;
 
-// Test function for k=-0.30000000000000004, nu=0.50000000000000000.
-template <typename Tp>
-void test066()
+// Test data for k=-0.29999999999999993, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.2121157428443725e-16
+// mean(f - f_Boost): 1.9428902930940239e-16
+// variance(f - f_Boost): 1.5987596229703424e-31
+// stddev(f - f_Boost): 3.9984492281012430e-16
+const testcase_ellint_3<double>
+data067[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data066)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data066[i].k), Tp(data066[i].nu),
-                   Tp(data066[i].phi));
-      const Tp f0 = data066[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.59999999999999998.
-testcase_ellint_3<double> data067[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17356592428950826, -0.30000000000000004, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34169984536697379, -0.30000000000000004, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50055748266498457, -0.30000000000000004, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.64854298527106768, -0.30000000000000004, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.78599329284207431, -0.30000000000000004, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.91445452089128221, -0.30000000000000004, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0360412952290587, -0.30000000000000004, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1530473919778639, -0.30000000000000004, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.2677758800420666, -0.30000000000000004, 0.59999999999999998,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.29999999999999993, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17568166052076745, -0.29999999999999993, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35839189074731181, -0.29999999999999993, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55583724744367558, -0.29999999999999993, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.77703498090888223, -0.29999999999999993, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0326772113675962, -0.29999999999999993, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3345139983717369, -0.29999999999999993, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.6921742922838403, -0.29999999999999993, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.1056608968472186, -0.29999999999999993, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.5560975528589061, -0.29999999999999993, 0.60000000000000009, 
+	  1.5707963267948966 },
 };
+const double toler067 = 2.5000000000000020e-13;
 
-// Test function for k=-0.30000000000000004, nu=0.59999999999999998.
-template <typename Tp>
-void test067()
+// Test data for k=-0.29999999999999993, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.0088945789059381e-16
+// mean(f - f_Boost): 1.6653345369377348e-16
+// variance(f - f_Boost): 3.1994213989721786e-31
+// stddev(f - f_Boost): 5.6563428104846852e-16
+const testcase_ellint_3<double>
+data068[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data067)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data067[i].k), Tp(data067[i].nu),
-                   Tp(data067[i].phi));
-      const Tp f0 = data067[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.69999999999999996.
-testcase_ellint_3<double> data068[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17339370613812227, -0.30000000000000004, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34042975138455933, -0.30000000000000004, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.49676568368075985, -0.30000000000000004, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.64080774055753720, -0.30000000000000004, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.77318507779667278, -0.30000000000000004, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.89579782346548631, -0.30000000000000004, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0110573286052202, -0.30000000000000004, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1214710972949633, -0.30000000000000004, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2294913236274980, -0.30000000000000004, 0.69999999999999996,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.29999999999999993, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17586219053197988, -0.29999999999999993, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.35991891074557669, -0.29999999999999993, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56149538019961731, -0.29999999999999993, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.79232303189667685, -0.29999999999999993, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0679345542878826, -0.29999999999999993, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.4084400085913955, -0.29999999999999993, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.8357382859296454, -0.29999999999999993, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.3604197996171519, -0.29999999999999993, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 2.9562123549913872, -0.29999999999999993, 0.70000000000000007, 
+	  1.5707963267948966 },
 };
+const double toler068 = 2.5000000000000020e-13;
 
-// Test function for k=-0.30000000000000004, nu=0.69999999999999996.
-template <typename Tp>
-void test068()
+// Test data for k=-0.29999999999999993, nu=0.80000000000000004.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.1197887707781618e-16
+// mean(f - f_Boost): 3.4416913763379854e-16
+// variance(f - f_Boost): 4.3461914185990199e-31
+// stddev(f - f_Boost): 6.5925650687718054e-16
+const testcase_ellint_3<double>
+data069[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data068)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data068[i].k), Tp(data068[i].nu),
-                   Tp(data068[i].phi));
-      const Tp f0 = data068[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.80000000000000004.
-testcase_ellint_3<double> data069[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17322209907520361, -0.30000000000000004, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.33917623046949996, -0.30000000000000004, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49307204894329176, -0.30000000000000004, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.63337802830291723, -0.30000000000000004, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.76104540997689407, -0.30000000000000004, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.87832009635450736, -0.30000000000000004, 0.80000000000000004,
-          1.0471975511965976 },
-  { 0.98787879723171790, -0.30000000000000004, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.0924036340069336, -0.30000000000000004, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.1944567571590046, -0.30000000000000004, 0.80000000000000004,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.29999999999999993, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17604338956191670, -0.29999999999999993, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36146952517410791, -0.29999999999999993, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.56736453393774644, -0.29999999999999993, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.80873149979001091, -0.29999999999999993, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1077903069860620, -0.29999999999999993, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.4985874311132998, -0.29999999999999993, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.0298167266724954, -0.29999999999999993, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.7483929054985432, -0.29999999999999993, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.6283050484567170, -0.29999999999999993, 0.80000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler069 = 2.5000000000000020e-13;
 
-// Test function for k=-0.30000000000000004, nu=0.80000000000000004.
-template <typename Tp>
-void test069()
+// Test data for k=-0.29999999999999993, nu=0.90000000000000002.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.1301806687926828e-16
+// mean(f - f_Boost): 4.1633363423443370e-16
+// variance(f - f_Boost): 2.2835347143080263e-31
+// stddev(f - f_Boost): 4.7786344433405093e-16
+const testcase_ellint_3<double>
+data070[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data069)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data069[i].k), Tp(data069[i].nu),
-                   Tp(data069[i].phi));
-      const Tp f0 = data069[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.30000000000000004, nu=0.90000000000000002.
-testcase_ellint_3<double> data070[] = {
-  { -0.0000000000000000, -0.30000000000000004, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17305109924485948, -0.30000000000000004, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33793890239556984, -0.30000000000000004, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.48947218005089738, -0.30000000000000004, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.62623332340775151, -0.30000000000000004, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.74951596581511148, -0.30000000000000004, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.86189886597756005, -0.30000000000000004, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.96629451153092005, -0.30000000000000004, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.0655269133492680, -0.30000000000000004, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.1622376896064912, -0.30000000000000004, 0.90000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.29999999999999993, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17622526204962433, -0.29999999999999993, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36304439230777141, -0.29999999999999993, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57345914744719195, -0.29999999999999993, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.82641512928845162, -0.29999999999999993, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1534256210757743, -0.29999999999999993, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.6124900353411677, -0.29999999999999993, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.3165905514845089, -0.29999999999999993, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.4625619526539824, -0.29999999999999993, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.1479514944016787, -0.29999999999999993, 0.90000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler070 = 2.5000000000000020e-13;
 
-// Test function for k=-0.30000000000000004, nu=0.90000000000000002.
-template <typename Tp>
-void test070()
+// Test data for k=-0.19999999999999996, nu=0.0000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 4.2156475739151676e-16
+// mean(f - f_Boost): -5.2735593669694933e-17
+// variance(f - f_Boost): 3.0473442641042680e-32
+// stddev(f - f_Boost): 1.7456644190978597e-16
+const testcase_ellint_3<double>
+data071[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data070)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data070[i].k), Tp(data070[i].nu),
-                   Tp(data070[i].phi));
-      const Tp f0 = data070[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.19999999999999996, nu=0.0000000000000000.
-testcase_ellint_3<double> data071[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17456817290292811, -0.19999999999999996, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.34934315932086801, -0.19999999999999996, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52450880529443988, -0.19999999999999996, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.70020491009844910, -0.19999999999999996, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.87651006649967955, -0.19999999999999996, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0534305870298994, -0.19999999999999996, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2308975521670784, -0.19999999999999996, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.4087733584990738, -0.19999999999999996, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.5868678474541664, -0.19999999999999996, 0.0000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.19999999999999996, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17456817290292806, -0.19999999999999996, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.34934315932086796, -0.19999999999999996, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52450880529443988, -0.19999999999999996, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.70020491009844887, -0.19999999999999996, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.87651006649967977, -0.19999999999999996, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0534305870298994, -0.19999999999999996, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2308975521670789, -0.19999999999999996, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.4087733584990738, -0.19999999999999996, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.5868678474541662, -0.19999999999999996, 0.0000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler071 = 2.5000000000000020e-13;
 
-// Test function for k=-0.19999999999999996, nu=0.0000000000000000.
-template <typename Tp>
-void test071()
+// Test data for k=-0.19999999999999996, nu=0.10000000000000001.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 4.0890622182605400e-16
+// mean(f - f_Boost): -3.8857805861880476e-17
+// variance(f - f_Boost): 2.8794792590749608e-32
+// stddev(f - f_Boost): 1.6969028431454054e-16
+const testcase_ellint_3<double>
+data072[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data071)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data071[i].k), Tp(data071[i].nu),
-                   Tp(data071[i].phi));
-      const Tp f0 = data071[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.19999999999999996, nu=0.10000000000000001.
-testcase_ellint_3<double> data072[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17439228502691750, -0.19999999999999996, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34796731137565740, -0.19999999999999996, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52003370294544848, -0.19999999999999996, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.69012222258631495, -0.19999999999999996, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.85803491465566772, -0.19999999999999996, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0238463961099364, -0.19999999999999996, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.1878691059202153, -0.19999999999999996, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.3505985031831940, -0.19999999999999996, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.5126513474261092, -0.19999999999999996, 0.10000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.19999999999999996, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17474469953608965, -0.19999999999999996, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35073860234984255, -0.19999999999999996, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.52912258712951521, -0.19999999999999996, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.71081701558898069, -0.19999999999999996, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.89640758521169384, -0.19999999999999996, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.0860417038089853, -0.19999999999999996, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.2793599255528623, -0.19999999999999996, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.4754938544089076, -0.19999999999999996, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.6731552050562593, -0.19999999999999996, 0.10000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler072 = 2.5000000000000020e-13;
 
-// Test function for k=-0.19999999999999996, nu=0.10000000000000001.
-template <typename Tp>
-void test072()
+// Test data for k=-0.19999999999999996, nu=0.20000000000000001.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 3.9570963716579749e-16
+// mean(f - f_Boost): -5.8286708792820721e-17
+// variance(f - f_Boost): 3.1158217732380362e-32
+// stddev(f - f_Boost): 1.7651690494788412e-16
+const testcase_ellint_3<double>
+data073[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data072)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data072[i].k), Tp(data072[i].nu),
-                   Tp(data072[i].phi));
-      const Tp f0 = data072[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.19999999999999996, nu=0.20000000000000001.
-testcase_ellint_3<double> data073[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17421703179583750, -0.19999999999999996, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34661057411998791, -0.19999999999999996, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.51569006052647393, -0.19999999999999996, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.68052412821107278, -0.19999999999999996, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.84081341263313825, -0.19999999999999996, 0.20000000000000001,
-          0.87266462599716477 },
-  { 0.99683359988842890, -0.19999999999999996, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1493086715118852, -0.19999999999999996, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.2992699693957541, -0.19999999999999996, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.4479323932249568, -0.19999999999999996, 0.20000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.19999999999999996, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17492186907740698, -0.19999999999999996, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35215414286134267, -0.19999999999999996, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53388285615182440, -0.19999999999999996, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.72200960282688265, -0.19999999999999996, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.91793087614428526, -0.19999999999999996, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1222602841587976, -0.19999999999999996, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3345489407496247, -0.19999999999999996, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.5531225705475502, -0.19999999999999996, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.7751816279738935, -0.19999999999999996, 0.20000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler073 = 2.5000000000000020e-13;
 
-// Test function for k=-0.19999999999999996, nu=0.20000000000000001.
-template <typename Tp>
-void test073()
+// Test data for k=-0.19999999999999996, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.6785817924053817e-16
+// mean(f - f_Boost): -1.1102230246251566e-17
+// variance(f - f_Boost): 9.9840208317034302e-32
+// stddev(f - f_Boost): 3.1597501217190311e-16
+const testcase_ellint_3<double>
+data074[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data073)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data073[i].k), Tp(data073[i].nu),
-                   Tp(data073[i].phi));
-      const Tp f0 = data073[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.19999999999999996, nu=0.29999999999999999.
-testcase_ellint_3<double> data074[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17404240913577707, -0.19999999999999996, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34527248032587193, -0.19999999999999996, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51147118981668416, -0.19999999999999996, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.67137107867777635, -0.19999999999999996, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.82470418188668893, -0.19999999999999996, 0.29999999999999999,
-          0.87266462599716477 },
-  { 0.97202873223594299, -0.19999999999999996, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1144773569375266, -0.19999999999999996, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.2535292433701000, -0.19999999999999996, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.3908453514752481, -0.19999999999999996, 0.29999999999999999,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.19999999999999996, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17509968571715159, -0.19999999999999996, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35359030214835629, -0.19999999999999996, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.53879807274537084, -0.19999999999999996, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.73384116418059731, -0.19999999999999996, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.94132799329524031, -0.19999999999999996, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.1628407021801439, -0.19999999999999996, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.3982440216739438, -0.19999999999999996, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.6450634983653640, -0.19999999999999996, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 1.8983924169967099, -0.19999999999999996, 0.30000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler074 = 2.5000000000000020e-13;
 
-// Test function for k=-0.19999999999999996, nu=0.29999999999999999.
-template <typename Tp>
-void test074()
+// Test data for k=-0.19999999999999996, nu=0.40000000000000002.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3298410018355870e-16
+// mean(f - f_Boost): 1.3877787807814457e-17
+// variance(f - f_Boost): 9.4370567274974557e-32
+// stddev(f - f_Boost): 3.0719792850046133e-16
+const testcase_ellint_3<double>
+data075[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data074)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data074[i].k), Tp(data074[i].nu),
-                   Tp(data074[i].phi));
-      const Tp f0 = data074[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.19999999999999996, nu=0.40000000000000002.
-testcase_ellint_3<double> data075[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17386841301066677, -0.19999999999999996, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34395257914113253, -0.19999999999999996, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.50737088376869466, -0.19999999999999996, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.66262801717277664, -0.19999999999999996, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.80958766645079094, -0.19999999999999996, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.94913754236162040, -0.19999999999999996, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.0827985514223000, -0.19999999999999996, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2124212429050478, -0.19999999999999996, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.3400002519661010, -0.19999999999999996, 0.40000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.19999999999999996, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17527815368535152, -0.19999999999999996, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35504762134297801, -0.19999999999999996, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54387742353211344, -0.19999999999999996, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.74637910471804259, -0.19999999999999996, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.96690539714174639, -0.19999999999999996, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2087859420184757, -0.19999999999999996, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.4729799844168852, -0.19999999999999996, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.7564445064596661, -0.19999999999999996, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.0512956926676802, -0.19999999999999996, 0.40000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler075 = 2.5000000000000020e-13;
 
-// Test function for k=-0.19999999999999996, nu=0.40000000000000002.
-template <typename Tp>
-void test075()
+// Test data for k=-0.19999999999999996, nu=0.50000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3841806057292116e-16
+// mean(f - f_Boost): 8.0491169285323847e-17
+// variance(f - f_Boost): 8.0538110429953348e-32
+// stddev(f - f_Boost): 2.8379237204328335e-16
+const testcase_ellint_3<double>
+data076[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data075)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data075[i].k), Tp(data075[i].nu),
-                   Tp(data075[i].phi));
-      const Tp f0 = data075[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.19999999999999996, nu=0.50000000000000000.
-testcase_ellint_3<double> data076[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17369503942181802, -0.19999999999999996, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34265043534362660, -0.19999999999999996, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50338337208655415, -0.19999999999999996, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.65426373297163642, -0.19999999999999996, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.79536193036145808, -0.19999999999999996, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.92791875910061605, -0.19999999999999996, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0538145052725829, -0.19999999999999996, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.1752060022875899, -0.19999999999999996, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.2943374404397376, -0.19999999999999996, 0.50000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.19999999999999996, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17545727725228877, -0.19999999999999996, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35652666242062175, -0.19999999999999996, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.54913090549102406, -0.19999999999999996, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.75970161209211551, -0.19999999999999996, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 0.99504737401590326, -0.19999999999999996, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.2614666007124373, -0.19999999999999996, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.5625255355205496, -0.19999999999999996, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 1.8954460255613343, -0.19999999999999996, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.2481046259421302, -0.19999999999999996, 0.50000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler076 = 2.5000000000000020e-13;
 
-// Test function for k=-0.19999999999999996, nu=0.50000000000000000.
-template <typename Tp>
-void test076()
+// Test data for k=-0.19999999999999996, nu=0.60000000000000009.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5317584994994743e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 1.0045745697575397e-31
+// stddev(f - f_Boost): 3.1695024369095219e-16
+const testcase_ellint_3<double>
+data077[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data076)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data076[i].k), Tp(data076[i].nu),
-                   Tp(data076[i].phi));
-      const Tp f0 = data076[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.19999999999999996, nu=0.59999999999999998.
-testcase_ellint_3<double> data077[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17352228440746928, -0.19999999999999996, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34136562863713626, -0.19999999999999996, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.49950328177638481, -0.19999999999999996, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.64625032705690832, -0.19999999999999996, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.78193941198403094, -0.19999999999999996, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.90817230934317128, -0.19999999999999996, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0271563751276462, -0.19999999999999996, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1412999379040518, -0.19999999999999996, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.2530330675914561, -0.19999999999999996, 0.59999999999999998,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.19999999999999996, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17563706072900442, -0.19999999999999996, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35802800926807238, -0.19999999999999996, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55456942250515051, -0.19999999999999996, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.77390003828438203, -0.19999999999999996, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0262441366366397, -0.19999999999999996, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3228192988439669, -0.19999999999999996, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.6728005754680795, -0.19999999999999996, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.0761587107468511, -0.19999999999999996, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.5148333891629315, -0.19999999999999996, 0.60000000000000009, 
+	  1.5707963267948966 },
 };
+const double toler077 = 2.5000000000000020e-13;
 
-// Test function for k=-0.19999999999999996, nu=0.59999999999999998.
-template <typename Tp>
-void test077()
+// Test data for k=-0.19999999999999996, nu=0.70000000000000007.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.1818454249546518e-16
+// mean(f - f_Boost): 3.6082248300317589e-17
+// variance(f - f_Boost): 8.9638010532618564e-32
+// stddev(f - f_Boost): 2.9939607634806868e-16
+const testcase_ellint_3<double>
+data078[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data077)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data077[i].k), Tp(data077[i].nu),
-                   Tp(data077[i].phi));
-      const Tp f0 = data077[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.19999999999999996, nu=0.69999999999999996.
-testcase_ellint_3<double> data078[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17335014404233898, -0.19999999999999996, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34009775298617811, -0.19999999999999996, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.49572560201923810, -0.19999999999999996, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.63856276669886525, -0.19999999999999996, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.76924438644867565, -0.19999999999999996, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.88973060843856466, -0.19999999999999996, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0025230471636377, -0.19999999999999996, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1102356376093103, -0.19999999999999996, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2154356555075867, -0.19999999999999996, 0.69999999999999996,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.19999999999999996, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17581750846781172, -0.19999999999999996, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.35955226882028513, -0.19999999999999996, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56020489659466499, -0.19999999999999996, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.78908196988531487, -0.19999999999999996, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0611336754143517, -0.19999999999999996, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.3956969951058884, -0.19999999999999996, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.8138131612209609, -0.19999999999999996, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.3256365528879561, -0.19999999999999996, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 2.9058704854500963, -0.19999999999999996, 0.70000000000000007, 
+	  1.5707963267948966 },
 };
+const double toler078 = 2.5000000000000020e-13;
 
-// Test function for k=-0.19999999999999996, nu=0.69999999999999996.
-template <typename Tp>
-void test078()
+// Test data for k=-0.19999999999999996, nu=0.80000000000000004.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.9866614515542431e-16
+// mean(f - f_Boost): 1.8318679906315082e-16
+// variance(f - f_Boost): 3.1335688610218711e-31
+// stddev(f - f_Boost): 5.5978289193417400e-16
+const testcase_ellint_3<double>
+data079[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data078)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data078[i].k), Tp(data078[i].nu),
-                   Tp(data078[i].phi));
-      const Tp f0 = data078[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.19999999999999996, nu=0.80000000000000004.
-testcase_ellint_3<double> data079[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17317861443718541, -0.19999999999999996, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.33884641598718701, -0.19999999999999996, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49204565281259494, -0.19999999999999996, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.63117851188220353, -0.19999999999999996, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.75721095949544170, -0.19999999999999996, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.87245201443919118, -0.19999999999999996, 0.80000000000000004,
-          1.0471975511965976 },
-  { 0.97966584238831089, -0.19999999999999996, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.0816336325174360, -0.19999999999999996, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.1810223448909913, -0.19999999999999996, 0.80000000000000004,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.19999999999999996, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17599862486281712, -0.19999999999999996, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36110007227128776, -0.19999999999999996, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.56605039658567224, -0.19999999999999996, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.80537523874517691, -0.19999999999999996, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1005662342414086, -0.19999999999999996, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.4845340298105778, -0.19999999999999996, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.0043332244969392, -0.19999999999999996, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.7052856676744761, -0.19999999999999996, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.5622166386422629, -0.19999999999999996, 0.80000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler079 = 2.5000000000000020e-13;
 
-// Test function for k=-0.19999999999999996, nu=0.80000000000000004.
-template <typename Tp>
-void test079()
+// Test data for k=-0.19999999999999996, nu=0.90000000000000002.
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.2817178727913890e-16
+// mean(f - f_Boost): 3.4694469519536142e-16
+// variance(f - f_Boost): 6.6311432369155086e-31
+// stddev(f - f_Boost): 8.1431831840598485e-16
+const testcase_ellint_3<double>
+data080[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data079)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data079[i].k), Tp(data079[i].nu),
-                   Tp(data079[i].phi));
-      const Tp f0 = data079[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.19999999999999996, nu=0.90000000000000002.
-testcase_ellint_3<double> data080[] = {
-  { -0.0000000000000000, -0.19999999999999996, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17300769173837280, -0.19999999999999996, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33761123827372508, -0.19999999999999996, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.48845905690769426, -0.19999999999999996, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.62407720017324986, -0.19999999999999996, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.74578146525124289, -0.19999999999999996, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.85621583540073076, -0.19999999999999996, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.95837725988001199, -0.19999999999999996, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.0551821412633928, -0.19999999999999996, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.1493679916141863, -0.19999999999999996, 0.90000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.19999999999999996, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17618041435044951, -0.19999999999999996, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36267207636502929, -0.19999999999999996, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57212028758237743, -0.19999999999999996, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.82293323876704483, -0.19999999999999996, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1457077279880385, -0.19999999999999996, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.5967346899325681, -0.19999999999999996, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.2856537353421724, -0.19999999999999996, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.4034714304613902, -0.19999999999999996, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.0448269356200361, -0.19999999999999996, 0.90000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler080 = 2.5000000000000020e-13;
 
-// Test function for k=-0.19999999999999996, nu=0.90000000000000002.
-template <typename Tp>
-void test080()
+// Test data for k=-0.099999999999999978, nu=0.0000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.1735566504509645e-16
+// mean(f - f_Boost): -3.6082248300317589e-17
+// variance(f - f_Boost): 8.2258607846939269e-33
+// stddev(f - f_Boost): 9.0696531271564778e-17
+const testcase_ellint_3<double>
+data081[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data080)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data080[i].k), Tp(data080[i].nu),
-                   Tp(data080[i].phi));
-      const Tp f0 = data080[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.099999999999999978, nu=0.0000000000000000.
-testcase_ellint_3<double> data081[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17454173353063665, -0.099999999999999978, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.34913506721468085, -0.099999999999999978, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52382550016538953, -0.099999999999999978, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.69864700854177031, -0.099999999999999978, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.87361792586964870, -0.099999999999999978, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0487386319621685, -0.099999999999999978, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2239913752078757, -0.099999999999999978, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.3993423113684049, -0.099999999999999978, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.5747455615173562, -0.099999999999999978, 0.0000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.099999999999999978, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17454173353063662, -0.099999999999999978, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.34913506721468096, -0.099999999999999978, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52382550016538953, -0.099999999999999978, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.69864700854177020, -0.099999999999999978, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.87361792586964859, -0.099999999999999978, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0487386319621685, -0.099999999999999978, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2239913752078759, -0.099999999999999978, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.3993423113684051, -0.099999999999999978, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.5747455615173558, -0.099999999999999978, 0.0000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler081 = 2.5000000000000020e-13;
 
-// Test function for k=-0.099999999999999978, nu=0.0000000000000000.
-template <typename Tp>
-void test081()
+// Test data for k=-0.099999999999999978, nu=0.10000000000000001.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.0305747373482148e-16
+// mean(f - f_Boost): -3.0531133177191807e-17
+// variance(f - f_Boost): 1.1508025840536076e-34
+// stddev(f - f_Boost): 1.0727546709539920e-17
+const testcase_ellint_3<double>
+data082[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data081)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data081[i].k), Tp(data081[i].nu),
-                   Tp(data081[i].phi));
-      const Tp f0 = data081[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.099999999999999978, nu=0.10000000000000001.
-testcase_ellint_3<double> data082[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17436589347616618, -0.099999999999999978, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34776067871237354, -0.099999999999999978, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.51936064354727807, -0.099999999999999978, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.68860303749364360, -0.099999999999999978, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.85524561882332051, -0.099999999999999978, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0193708301908337, -0.099999999999999978, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.1813474067123044, -0.099999999999999978, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.3417670770424983, -0.099999999999999978, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.5013711111199950, -0.099999999999999978, 0.10000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.099999999999999978, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17471821213559732, -0.099999999999999978, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35052902610011138, -0.099999999999999978, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.52842865990255727, -0.099999999999999978, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.70921799731166713, -0.099999999999999978, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.89340330535868662, -0.099999999999999978, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.0811075784236857, -0.099999999999999978, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.2720133232666426, -0.099999999999999978, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.4653630031861395, -0.099999999999999978, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.6600374067558428, -0.099999999999999978, 0.10000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler082 = 2.5000000000000020e-13;
 
-// Test function for k=-0.099999999999999978, nu=0.10000000000000001.
-template <typename Tp>
-void test082()
+// Test data for k=-0.099999999999999978, nu=0.20000000000000001.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 1.6736714959992433e-16
+// mean(f - f_Boost): 5.5511151231257830e-18
+// variance(f - f_Boost): 3.8043060629871325e-36
+// stddev(f - f_Boost): 1.9504630380981673e-18
+const testcase_ellint_3<double>
+data083[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data082)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data082[i].k), Tp(data082[i].nu),
-                   Tp(data082[i].phi));
-      const Tp f0 = data082[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.099999999999999978, nu=0.20000000000000001.
-testcase_ellint_3<double> data083[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17419068786141345, -0.099999999999999978, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34640537686230127, -0.099999999999999978, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.51502689171753957, -0.099999999999999978, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.67904147863672726, -0.099999999999999978, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.83811885126105179, -0.099999999999999978, 0.20000000000000001,
-          0.87266462599716477 },
-  { 0.99255278555742810, -0.099999999999999978, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1431260546194930, -0.099999999999999978, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.2909589656532101, -0.099999999999999978, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.4373749386463430, -0.099999999999999978, 0.20000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.099999999999999978, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17489533344059083, -0.099999999999999978, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35194305707815038, -0.099999999999999978, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53317790741512527, -0.099999999999999978, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.72036681615081222, -0.099999999999999978, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.91480372268244303, -0.099999999999999978, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1170528708071514, -0.099999999999999978, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3266916802718358, -0.099999999999999978, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.5421622241831547, -0.099999999999999978, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.7608656115083421, -0.099999999999999978, 0.20000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler083 = 2.5000000000000020e-13;
 
-// Test function for k=-0.099999999999999978, nu=0.20000000000000001.
-template <typename Tp>
-void test083()
+// Test data for k=-0.099999999999999978, nu=0.30000000000000004.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 1.9186071760326645e-16
+// mean(f - f_Boost): -1.6653345369377347e-17
+// variance(f - f_Boost): 3.4238754566884194e-35
+// stddev(f - f_Boost): 5.8513891142945016e-18
+const testcase_ellint_3<double>
+data084[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data083)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data083[i].k), Tp(data083[i].nu),
-                   Tp(data083[i].phi));
-      const Tp f0 = data083[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.099999999999999978, nu=0.29999999999999999.
-testcase_ellint_3<double> data084[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17401611261390110, -0.099999999999999978, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34506869507511767, -0.099999999999999978, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51081757604259870, -0.099999999999999978, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.66992297597712303, -0.099999999999999978, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.82209722856174228, -0.099999999999999978, 0.29999999999999999,
-          0.87266462599716477 },
-  { 0.96792430487669612, -0.099999999999999978, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1085964108954092, -0.099999999999999978, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.2456748370836999, -0.099999999999999978, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.3809159606704959, -0.099999999999999978, 0.29999999999999999,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.099999999999999978, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17507310163441189, -0.099999999999999978, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35337768072524217, -0.099999999999999978, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.53808167801629170, -0.099999999999999978, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.73215166755955019, -0.099999999999999978, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.93806546000201219, -0.099999999999999978, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.1573218723395986, -0.099999999999999978, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.3897859679542097, -0.099999999999999978, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.6331009404328622, -0.099999999999999978, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 1.8826015946315438, -0.099999999999999978, 0.30000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler084 = 2.5000000000000020e-13;
 
-// Test function for k=-0.099999999999999978, nu=0.29999999999999999.
-template <typename Tp>
-void test084()
+// Test data for k=-0.099999999999999978, nu=0.40000000000000002.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0338059536914377e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 9.5107651574678308e-35
+// stddev(f - f_Boost): 9.7523151904908362e-18
+const testcase_ellint_3<double>
+data085[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data084)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data084[i].k), Tp(data084[i].nu),
-                   Tp(data084[i].phi));
-      const Tp f0 = data084[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.099999999999999978, nu=0.40000000000000002.
-testcase_ellint_3<double> data085[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17384216369897937, -0.099999999999999978, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34375018311376782, -0.099999999999999978, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.50672650758380455, -0.099999999999999978, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.66121264213337616, -0.099999999999999978, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.80706202005774441, -0.099999999999999978, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.94519376138245892, -0.099999999999999978, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.0771880300759584, -0.099999999999999978, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2049711557188272, -0.099999999999999978, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.3306223265207477, -0.099999999999999978, 0.40000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.099999999999999978, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17525152094559704, -0.099999999999999978, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35483343742825979, -0.099999999999999978, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54314913099505446, -0.099999999999999978, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.74463962034766862, -0.099999999999999978, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.96349276837570441, -0.099999999999999978, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2029081382746343, -0.099999999999999978, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.4638022887050806, -0.099999999999999978, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.7432413830105224, -0.099999999999999978, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.0336367403076760, -0.099999999999999978, 0.40000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler085 = 2.5000000000000020e-13;
 
-// Test function for k=-0.099999999999999978, nu=0.40000000000000002.
-template <typename Tp>
-void test085()
+// Test data for k=-0.099999999999999978, nu=0.50000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.9864616042835278e-16
+// mean(f - f_Boost): 1.0547118733938987e-16
+// variance(f - f_Boost): 7.5633408838247182e-32
+// stddev(f - f_Boost): 2.7501528837184157e-16
+const testcase_ellint_3<double>
+data086[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data085)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data085[i].k), Tp(data085[i].nu),
-                   Tp(data085[i].phi));
-      const Tp f0 = data085[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.099999999999999978, nu=0.50000000000000000.
-testcase_ellint_3<double> data086[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17366883711936554, -0.099999999999999978, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34244940634881876, -0.099999999999999978, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50274793281634378, -0.099999999999999978, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.65287941633275093, -0.099999999999999978, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.79291198790315398, -0.099999999999999978, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.92412201537880345, -0.099999999999999978, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0484480076799370, -0.099999999999999978, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.1681168130475206, -0.099999999999999978, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.2854480708580160, -0.099999999999999978, 0.50000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.099999999999999978, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17543059564292182, -0.099999999999999978, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35631088838721664, -0.099999999999999978, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.54839023346436444, -0.099999999999999978, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.75790846946088830, -0.099999999999999978, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 0.99146713686720678, -0.099999999999999978, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.2551692247937198, -0.099999999999999978, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.5524660788146873, -0.099999999999999978, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 1.8806578570830670, -0.099999999999999978, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.2279868912966849, -0.099999999999999978, 0.50000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler086 = 2.5000000000000020e-13;
 
-// Test function for k=-0.099999999999999978, nu=0.50000000000000000.
-template <typename Tp>
-void test086()
+// Test data for k=-0.099999999999999978, nu=0.60000000000000009.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.6726146516228014e-16
+// mean(f - f_Boost): -3.6082248300317589e-17
+// variance(f - f_Boost): 1.6073193116120635e-34
+// stddev(f - f_Boost): 1.2678009747638087e-17
+const testcase_ellint_3<double>
+data087[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data086)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data086[i].k), Tp(data086[i].nu),
-                   Tp(data086[i].phi));
-      const Tp f0 = data086[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.099999999999999978, nu=0.59999999999999998.
-testcase_ellint_3<double> data087[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17349612891469018, -0.099999999999999978, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34116594505539438, -0.099999999999999978, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.49887649430466685, -0.099999999999999978, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.64489553282165157, -0.099999999999999978, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.77956016553782437, -0.099999999999999978, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.90451074530096309, -0.099999999999999978, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0220113666961632, -0.099999999999999978, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1345351441065563, -0.099999999999999978, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.2445798942989255, -0.099999999999999978, 0.59999999999999998,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.099999999999999978, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17561033003590576, -0.099999999999999978, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35781061668171932, -0.099999999999999978, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55381585659629196, -0.099999999999999978, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.77204910484575640, -0.099999999999999978, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0224751740393108, -0.099999999999999978, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3160230906351114, -0.099999999999999978, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.6616282844233206, -0.099999999999999978, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.0592555664850392, -0.099999999999999978, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.4913004919173822, -0.099999999999999978, 0.60000000000000009, 
+	  1.5707963267948966 },
 };
+const double toler087 = 2.5000000000000020e-13;
 
-// Test function for k=-0.099999999999999978, nu=0.59999999999999998.
-template <typename Tp>
-void test087()
+// Test data for k=-0.099999999999999978, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 2.1004074871280821e-16
+// mean(f - f_Boost): 3.3306690738754695e-17
+// variance(f - f_Boost): 1.3695501826753678e-34
+// stddev(f - f_Boost): 1.1702778228589003e-17
+const testcase_ellint_3<double>
+data088[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data087)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data087[i].k), Tp(data087[i].nu),
-                   Tp(data087[i].phi));
-      const Tp f0 = data087[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.099999999999999978, nu=0.69999999999999996.
-testcase_ellint_3<double> data088[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17332403516105052, -0.099999999999999978, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.33989939374896877, -0.099999999999999978, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.49510719568614081, -0.099999999999999978, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.63723607776354974, -0.099999999999999978, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.76693133887935327, -0.099999999999999978, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.88619382078823827, -0.099999999999999978, 0.69999999999999996,
-          1.0471975511965976 },
-  { 0.99758012018676490, -0.099999999999999978, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1037642270814410, -0.099999999999999978, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2073745911083187, -0.099999999999999978, 0.69999999999999996,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.099999999999999978, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17579072847532518, -0.099999999999999978, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.35933322840606297, -0.099999999999999978, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.55943788649460324, -0.099999999999999978, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.78716856504031707, -0.099999999999999978, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0571501305617423, -0.099999999999999978, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.3882948301743525, -0.099999999999999978, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.8011785680114223, -0.099999999999999978, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.3057268183616464, -0.099999999999999978, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 2.8771910188009739, -0.099999999999999978, 0.70000000000000007, 
+	  1.5707963267948966 },
 };
+const double toler088 = 2.5000000000000020e-13;
 
-// Test function for k=-0.099999999999999978, nu=0.69999999999999996.
-template <typename Tp>
-void test088()
+// Test data for k=-0.099999999999999978, nu=0.80000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.3133043868392355e-16
+// mean(f - f_Boost): 1.8041124150158794e-16
+// variance(f - f_Boost): 6.1843750436434569e-32
+// stddev(f - f_Boost): 2.4868403735751633e-16
+const testcase_ellint_3<double>
+data089[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data088)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data088[i].k), Tp(data088[i].nu),
-                   Tp(data088[i].phi));
-      const Tp f0 = data088[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.099999999999999978, nu=0.80000000000000004.
-testcase_ellint_3<double> data089[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17315255197057020, -0.099999999999999978, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.33864936055747985, -0.099999999999999978, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49143537041117619, -0.099999999999999978, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.62987861760047492, -0.099999999999999978, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.75496005490917517, -0.099999999999999978, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.86903081862701903, -0.099999999999999978, 0.80000000000000004,
-          1.0471975511965976 },
-  { 0.97490814820725591, -0.099999999999999978, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.0754290107171083, -0.099999999999999978, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.1733158866987732, -0.099999999999999978, 0.80000000000000004,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.099999999999999978, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17597179535373417, -0.099999999999999978, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36087935387831499, -0.099999999999999978, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.56526935244526444, -0.099999999999999978, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.80339402590612397, -0.099999999999999978, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.0963358646374459, -0.099999999999999978, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.4763748483246868, -0.099999999999999978, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 1.9896610222794102, -0.099999999999999978, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.6806423920122024, -0.099999999999999978, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.5246199613295612, -0.099999999999999978, 0.80000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler089 = 2.5000000000000020e-13;
 
-// Test function for k=-0.099999999999999978, nu=0.80000000000000004.
-template <typename Tp>
-void test089()
+// Test data for k=-0.099999999999999978, nu=0.90000000000000002.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5624826890976725e-16
+// mean(f - f_Boost): 2.3314683517128288e-16
+// variance(f - f_Boost): 2.9401198977189756e-31
+// stddev(f - f_Boost): 5.4222872459129045e-16
+const testcase_ellint_3<double>
+data090[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data089)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data089[i].k), Tp(data089[i].nu),
-                   Tp(data089[i].phi));
-      const Tp f0 = data089[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=-0.099999999999999978, nu=0.90000000000000002.
-testcase_ellint_3<double> data090[] = {
-  { -0.0000000000000000, -0.099999999999999978, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17298167549096569, -0.099999999999999978, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33741546662741584, -0.099999999999999978, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.48785665376856879, -0.099999999999999978, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.62280288554518959, -0.099999999999999978, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.74358903115455199, -0.099999999999999978, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.85290207679298358, -0.099999999999999978, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.95379006645397379, -0.099999999999999978, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.0492213119872327, -0.099999999999999978, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.1419839485283374, -0.099999999999999978, 0.90000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, -0.099999999999999978, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17615353510599349, -0.099999999999999978, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36244964892922371, -0.099999999999999978, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57132457590110530, -0.099999999999999978, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.82087808820385000, -0.099999999999999978, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1411894342144451, -0.099999999999999978, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.5875929286844597, -0.099999999999999978, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.2678622986596659, -0.099999999999999978, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.3697528941897903, -0.099999999999999978, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 4.9862890417305499, -0.099999999999999978, 0.90000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler090 = 2.5000000000000020e-13;
 
-// Test function for k=-0.099999999999999978, nu=0.90000000000000002.
-template <typename Tp>
-void test090()
+// Test data for k=0.0000000000000000, nu=0.0000000000000000.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.1203697876423447e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
+const testcase_ellint_3<double>
+data091[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data090)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data090[i].k), Tp(data090[i].nu),
-                   Tp(data090[i].phi));
-      const Tp f0 = data090[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.0000000000000000, nu=0.0000000000000000.
-testcase_ellint_3<double> data091[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17453292519943295, 0.0000000000000000, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.34906585039886584, 0.0000000000000000, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52359877559829882, 0.0000000000000000, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.69813170079773179, 0.0000000000000000, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.87266462599716477, 0.0000000000000000, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0471975511965976, 0.0000000000000000, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2217304763960304, 0.0000000000000000, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.3962634015954631, 0.0000000000000000, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.5707963267948966, 0.0000000000000000, 0.0000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17453292519943295, 0.0000000000000000, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.34906585039886590, 0.0000000000000000, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52359877559829882, 0.0000000000000000, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.69813170079773179, 0.0000000000000000, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.87266462599716477, 0.0000000000000000, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0471975511965976, 0.0000000000000000, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2217304763960306, 0.0000000000000000, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.3962634015954636, 0.0000000000000000, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.5707963267948966, 0.0000000000000000, 0.0000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler091 = 2.5000000000000020e-13;
 
-// Test function for k=0.0000000000000000, nu=0.0000000000000000.
-template <typename Tp>
-void test091()
+// Test data for k=0.0000000000000000, nu=0.10000000000000001.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.1019052604815601e-16
+// mean(f - f_Boost): 2.7755575615628915e-18
+// variance(f - f_Boost): 9.5107651574678312e-37
+// stddev(f - f_Boost): 9.7523151904908366e-19
+const testcase_ellint_3<double>
+data092[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data091)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data091[i].k), Tp(data091[i].nu),
-                   Tp(data091[i].phi));
-      const Tp f0 = data091[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.0000000000000000, nu=0.10000000000000001.
-testcase_ellint_3<double> data092[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17435710107516608, 0.0000000000000000, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34769194715329604, 0.0000000000000000, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.51913731575866118, 0.0000000000000000, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.68810051897078461, 0.0000000000000000, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.85432615661706823, 0.0000000000000000, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0179006647340796, 0.0000000000000000, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.1792120640746322, 0.0000000000000000, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.3388834245070498, 0.0000000000000000, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.4976955329233277, 0.0000000000000000, 0.10000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.0000000000000000, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17470938780535167, 0.0000000000000000, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35045931581655582, 0.0000000000000000, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.52819841383849875, 0.0000000000000000, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.70868910807992958, 0.0000000000000000, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.89241311307249638, 0.0000000000000000, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.0794871444666669, 0.0000000000000000, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.2696086247356864, 0.0000000000000000, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.4620562617494721, 0.0000000000000000, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.6557647109660167, 0.0000000000000000, 0.10000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler092 = 2.5000000000000020e-13;
 
-// Test function for k=0.0000000000000000, nu=0.10000000000000001.
-template <typename Tp>
-void test092()
+// Test data for k=0.0000000000000000, nu=0.20000000000000001.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.0831888697465320e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
+const testcase_ellint_3<double>
+data093[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data092)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data092[i].k), Tp(data092[i].nu),
-                   Tp(data092[i].phi));
-      const Tp f0 = data092[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.0000000000000000, nu=0.20000000000000001.
-testcase_ellint_3<double> data093[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17418191132226077, 0.0000000000000000, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34633712256943405, 0.0000000000000000, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.51480684302043711, 0.0000000000000000, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.67855102942481949, 0.0000000000000000, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.83723056090326253, 0.0000000000000000, 0.20000000000000001,
-          0.87266462599716477 },
-  { 0.99114645269578183, 0.0000000000000000, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1411014627915537, 0.0000000000000000, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.2882448138013969, 0.0000000000000000, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.4339343023863691, 0.0000000000000000, 0.20000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.0000000000000000, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17488649304197776, 0.0000000000000000, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35187284488675424, 0.0000000000000000, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53294400750146131, 0.0000000000000000, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.71982347021822823, 0.0000000000000000, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.91377311030258745, 0.0000000000000000, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1153429007215137, 0.0000000000000000, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3241202847784086, 0.0000000000000000, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.5385854914338242, 0.0000000000000000, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.7562036827601815, 0.0000000000000000, 0.20000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler093 = 2.5000000000000020e-13;
 
-// Test function for k=0.0000000000000000, nu=0.20000000000000001.
-template <typename Tp>
-void test093()
+// Test data for k=0.0000000000000000, nu=0.30000000000000004.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.0642101770923591e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
+const testcase_ellint_3<double>
+data094[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data093)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data093[i].k), Tp(data093[i].nu),
-                   Tp(data093[i].phi));
-      const Tp f0 = data093[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.0000000000000000, nu=0.29999999999999999.
-testcase_ellint_3<double> data094[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17400735186871727, 0.0000000000000000, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34500091027020219, 0.0000000000000000, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51060069523901541, 0.0000000000000000, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.66944393961375459, 0.0000000000000000, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.82123776744538157, 0.0000000000000000, 0.29999999999999999,
-          0.87266462599716477 },
-  { 0.96657579245516523, 0.0000000000000000, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1066703663542414, 0.0000000000000000, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.2431094251944901, 0.0000000000000000, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.3776795151134889, 0.0000000000000000, 0.29999999999999999,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.0000000000000000, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17506424509761404, 0.0000000000000000, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35330695794774630, 0.0000000000000000, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.53784398359522367, 0.0000000000000000, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.73159289408687844, 0.0000000000000000, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.93699031797084975, 0.0000000000000000, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.1555098909390267, 0.0000000000000000, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.3870184960144325, 0.0000000000000000, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.6291980835772994, 0.0000000000000000, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 1.8774607092226381, 0.0000000000000000, 0.30000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler094 = 2.5000000000000020e-13;
 
-// Test function for k=0.0000000000000000, nu=0.29999999999999999.
-template <typename Tp>
-void test094()
+// Test data for k=0.0000000000000000, nu=0.40000000000000002.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.0449580089795878e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
+const testcase_ellint_3<double>
+data095[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data094)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data094[i].k), Tp(data094[i].nu),
-                   Tp(data094[i].phi));
-      const Tp f0 = data094[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.0000000000000000, nu=0.40000000000000002.
-testcase_ellint_3<double> data095[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17383341868035865, 0.0000000000000000, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34368286022299821, 0.0000000000000000, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.50651268947499406, 0.0000000000000000, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.66074441806097550, 0.0000000000000000, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.80622931670113485, 0.0000000000000000, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.94389791565435233, 0.0000000000000000, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.0753503387899728, 0.0000000000000000, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2025374759127518, 0.0000000000000000, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.3275651989026322, 0.0000000000000000, 0.40000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.0000000000000000, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17524264820030025, 0.0000000000000000, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35476219513871499, 0.0000000000000000, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54290749235440094, 0.0000000000000000, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.74406433757109913, 0.0000000000000000, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.96236826162553313, 0.0000000000000000, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2009785880262487, 0.0000000000000000, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.4608000106167567, 0.0000000000000000, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.7389349574753439, 0.0000000000000000, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.0278893379868057, 0.0000000000000000, 0.40000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler095 = 2.5000000000000020e-13;
 
-// Test function for k=0.0000000000000000, nu=0.40000000000000002.
-template <typename Tp>
-void test095()
+// Test data for k=0.0000000000000000, nu=0.50000000000000000.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.0254203825026289e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
+const testcase_ellint_3<double>
+data096[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data095)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data095[i].k), Tp(data095[i].nu),
-                   Tp(data095[i].phi));
-      const Tp f0 = data095[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.0000000000000000, nu=0.50000000000000000.
-testcase_ellint_3<double> data096[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17366010776037047, 0.0000000000000000, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34238253799539309, 0.0000000000000000, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50253707775976408, 0.0000000000000000, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.65242145347295766, 0.0000000000000000, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.79210420018698058, 0.0000000000000000, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.92287437995632193, 0.0000000000000000, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0466900550798661, 0.0000000000000000, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.1658007366618623, 0.0000000000000000, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.2825498301618641, 0.0000000000000000, 0.50000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.0000000000000000, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17542170661831016, 0.0000000000000000, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35623911740195419, 0.0000000000000000, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.54814449099863127, 0.0000000000000000, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.75731546607718081, 0.0000000000000000, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 0.99028751188233310, 0.0000000000000000, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.2531022857760581, 0.0000000000000000, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.5491761777615785, 0.0000000000000000, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 1.8758359693666533, 0.0000000000000000, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.2214414690791831, 0.0000000000000000, 0.50000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler096 = 2.5000000000000020e-13;
 
-// Test function for k=0.0000000000000000, nu=0.50000000000000000.
-template <typename Tp>
-void test096()
+// Test data for k=0.0000000000000000, nu=0.60000000000000009.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 2.1742785192400269e-16
+// mean(f - f_Boost): 1.3877787807814457e-17
+// variance(f - f_Boost): 2.3776912893669577e-35
+// stddev(f - f_Boost): 4.8761575952454181e-18
+const testcase_ellint_3<double>
+data097[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data096)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data096[i].k), Tp(data096[i].nu),
-                   Tp(data096[i].phi));
-      const Tp f0 = data096[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.0000000000000000, nu=0.59999999999999998.
-testcase_ellint_3<double> data097[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17348741514884702, 0.0000000000000000, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34109952405241289, 0.0000000000000000, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.49866850781226296, 0.0000000000000000, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.64444732407062510, 0.0000000000000000, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.77877564686544720, 0.0000000000000000, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.90330743691883497, 0.0000000000000000, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0203257987604104, 0.0000000000000000, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1323247918768631, 0.0000000000000000, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.2418235332245127, 0.0000000000000000, 0.59999999999999998,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.0000000000000000, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17560142466065651, 0.0000000000000000, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35773830754879005, 0.0000000000000000, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55356583986445973, 0.0000000000000000, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.77143701715151514, 0.0000000000000000, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0212334940541210, 0.0000000000000000, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3137928444460387, 0.0000000000000000, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.6579755004159076, 0.0000000000000000, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.0537461418295506, 0.0000000000000000, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.4836470664490253, 0.0000000000000000, 0.60000000000000009, 
+	  1.5707963267948966 },
 };
+const double toler097 = 2.5000000000000020e-13;
 
-// Test function for k=0.0000000000000000, nu=0.59999999999999998.
-template <typename Tp>
-void test097()
+// Test data for k=0.0000000000000000, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 4
+// max(|f - f_Boost| / |f_Boost|): 3.0903019454022601e-16
+// mean(f - f_Boost): -6.9388939039072284e-17
+// variance(f - f_Boost): 5.9442282234173945e-34
+// stddev(f - f_Boost): 2.4380787976227090e-17
+const testcase_ellint_3<double>
+data098[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data097)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data097[i].k), Tp(data097[i].nu),
-                   Tp(data097[i].phi));
-      const Tp f0 = data097[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.0000000000000000, nu=0.69999999999999996.
-testcase_ellint_3<double> data098[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17331533692234477, 0.0000000000000000, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.33983341309265941, 0.0000000000000000, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.49490198805931990, 0.0000000000000000, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.63679715525145308, 0.0000000000000000, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.76616861049481944, 0.0000000000000000, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.88503143209004220, 0.0000000000000000, 0.69999999999999996,
-          1.0471975511965976 },
-  { 0.99596060249112173, 0.0000000000000000, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1016495050260424, 0.0000000000000000, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2047457872617382, 0.0000000000000000, 0.69999999999999996,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.0000000000000000, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17578180667760368, 0.0000000000000000, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.35926037139410999, 0.0000000000000000, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.55918341315855080, 0.0000000000000000, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.78653584856932546, 0.0000000000000000, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0558379029273324, 0.0000000000000000, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.3858662544850615, 0.0000000000000000, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.7970491170359040, 0.0000000000000000, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.2992404490153917, 0.0000000000000000, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 2.8678686047727382, 0.0000000000000000, 0.70000000000000007, 
+	  1.5707963267948966 },
 };
+const double toler098 = 2.5000000000000020e-13;
 
-// Test function for k=0.0000000000000000, nu=0.69999999999999996.
-template <typename Tp>
-void test098()
+// Test data for k=0.0000000000000000, nu=0.80000000000000004.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.2373744057922657e-16
+// mean(f - f_Boost): 1.0269562977782698e-16
+// variance(f - f_Boost): 1.4388836606733082e-32
+// stddev(f - f_Boost): 1.1995347684303728e-16
+const testcase_ellint_3<double>
+data099[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data098)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data098[i].k), Tp(data098[i].nu),
-                   Tp(data098[i].phi));
-      const Tp f0 = data098[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.0000000000000000, nu=0.80000000000000004.
-testcase_ellint_3<double> data099[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17314386919344213, 0.0000000000000000, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.33858381342073240, 0.0000000000000000, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49123285640844738, 0.0000000000000000, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.62944854858904520, 0.0000000000000000, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.75421778305499343, 0.0000000000000000, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.86790634112156639, 0.0000000000000000, 0.80000000000000004,
-          1.0471975511965976 },
-  { 0.97334918087427558, 0.0000000000000000, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.0734012615283985, 0.0000000000000000, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.1708024551734544, 0.0000000000000000, 0.80000000000000004,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.0000000000000000, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17596285706118869, 0.0000000000000000, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36080593896484231, 0.0000000000000000, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.56501022706967863, 0.0000000000000000, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.80273891984116930, 0.0000000000000000, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.0949425007763358, 0.0000000000000000, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.4736985692253419, 0.0000000000000000, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 1.9848676587180696, 0.0000000000000000, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.6726187823193546, 0.0000000000000000, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.5124073655203634, 0.0000000000000000, 0.80000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler099 = 2.5000000000000020e-13;
 
-// Test function for k=0.0000000000000000, nu=0.80000000000000004.
-template <typename Tp>
-void test099()
+// Test data for k=0.0000000000000000, nu=0.90000000000000002.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.6108624815885066e-16
+// mean(f - f_Boost): 2.1371793224034264e-16
+// variance(f - f_Boost): 5.6389326618626776e-33
+// stddev(f - f_Boost): 7.5092826966779442e-17
+const testcase_ellint_3<double>
+data100[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data099)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data099[i].k), Tp(data099[i].nu),
-                   Tp(data099[i].phi));
-      const Tp f0 = data099[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.0000000000000000, nu=0.90000000000000002.
-testcase_ellint_3<double> data100[] = {
-  { -0.0000000000000000, 0.0000000000000000, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17297300811030600, 0.0000000000000000, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33735034635360817, 0.0000000000000000, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.48765675230233141, 0.0000000000000000, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.62238126886123568, 0.0000000000000000, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.74286600807269243, 0.0000000000000000, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.85181283909264971, 0.0000000000000000, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.95228683995371122, 0.0000000000000000, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.0472730487412552, 0.0000000000000000, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.1395754288497419, 0.0000000000000000, 0.90000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.0000000000000000, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17614458024574997, 0.0000000000000000, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36237566578821978, 0.0000000000000000, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57106058859196640, 0.0000000000000000, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.82019857015755915, 0.0000000000000000, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1397014388908147, 0.0000000000000000, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.5845952415154960, 0.0000000000000000, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.2620531413370775, 0.0000000000000000, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.3587842061975066, 0.0000000000000000, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 4.9672941328980507, 0.0000000000000000, 0.90000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler100 = 2.5000000000000020e-13;
 
-// Test function for k=0.0000000000000000, nu=0.90000000000000002.
-template <typename Tp>
-void test100()
+// Test data for k=0.10000000000000009, nu=0.0000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.1735566504509645e-16
+// mean(f - f_Boost): -5.8286708792820721e-17
+// variance(f - f_Boost): 4.1942474344433133e-34
+// stddev(f - f_Boost): 2.0479861900030756e-17
+const testcase_ellint_3<double>
+data101[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data100)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data100[i].k), Tp(data100[i].nu),
-                   Tp(data100[i].phi));
-      const Tp f0 = data100[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.10000000000000009, nu=0.0000000000000000.
-testcase_ellint_3<double> data101[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17454173353063665, 0.10000000000000009, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.34913506721468085, 0.10000000000000009, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52382550016538953, 0.10000000000000009, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.69864700854177031, 0.10000000000000009, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.87361792586964870, 0.10000000000000009, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0487386319621685, 0.10000000000000009, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2239913752078757, 0.10000000000000009, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.3993423113684049, 0.10000000000000009, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.5747455615173562, 0.10000000000000009, 0.0000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.10000000000000009, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17454173353063662, 0.10000000000000009, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.34913506721468096, 0.10000000000000009, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52382550016538953, 0.10000000000000009, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.69864700854177020, 0.10000000000000009, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.87361792586964859, 0.10000000000000009, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0487386319621685, 0.10000000000000009, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2239913752078759, 0.10000000000000009, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.3993423113684051, 0.10000000000000009, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.5747455615173560, 0.10000000000000009, 0.0000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler101 = 2.5000000000000020e-13;
 
-// Test function for k=0.10000000000000009, nu=0.0000000000000000.
-template <typename Tp>
-void test101()
+// Test data for k=0.10000000000000009, nu=0.10000000000000001.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.0305747373482148e-16
+// mean(f - f_Boost): -3.0531133177191807e-17
+// variance(f - f_Boost): 1.1508025840536076e-34
+// stddev(f - f_Boost): 1.0727546709539920e-17
+const testcase_ellint_3<double>
+data102[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data101)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data101[i].k), Tp(data101[i].nu),
-                   Tp(data101[i].phi));
-      const Tp f0 = data101[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.10000000000000009, nu=0.10000000000000001.
-testcase_ellint_3<double> data102[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17436589347616618, 0.10000000000000009, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34776067871237354, 0.10000000000000009, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.51936064354727807, 0.10000000000000009, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.68860303749364360, 0.10000000000000009, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.85524561882332051, 0.10000000000000009, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0193708301908337, 0.10000000000000009, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.1813474067123044, 0.10000000000000009, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.3417670770424983, 0.10000000000000009, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.5013711111199950, 0.10000000000000009, 0.10000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.10000000000000009, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17471821213559732, 0.10000000000000009, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35052902610011138, 0.10000000000000009, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.52842865990255727, 0.10000000000000009, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.70921799731166713, 0.10000000000000009, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.89340330535868662, 0.10000000000000009, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.0811075784236857, 0.10000000000000009, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.2720133232666426, 0.10000000000000009, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.4653630031861395, 0.10000000000000009, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.6600374067558428, 0.10000000000000009, 0.10000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler102 = 2.5000000000000020e-13;
 
-// Test function for k=0.10000000000000009, nu=0.10000000000000001.
-template <typename Tp>
-void test102()
+// Test data for k=0.10000000000000009, nu=0.20000000000000001.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 1.6736714959992433e-16
+// mean(f - f_Boost): 5.5511151231257830e-18
+// variance(f - f_Boost): 3.8043060629871325e-36
+// stddev(f - f_Boost): 1.9504630380981673e-18
+const testcase_ellint_3<double>
+data103[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data102)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data102[i].k), Tp(data102[i].nu),
-                   Tp(data102[i].phi));
-      const Tp f0 = data102[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.10000000000000009, nu=0.20000000000000001.
-testcase_ellint_3<double> data103[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17419068786141345, 0.10000000000000009, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34640537686230127, 0.10000000000000009, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.51502689171753957, 0.10000000000000009, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.67904147863672726, 0.10000000000000009, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.83811885126105179, 0.10000000000000009, 0.20000000000000001,
-          0.87266462599716477 },
-  { 0.99255278555742810, 0.10000000000000009, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1431260546194930, 0.10000000000000009, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.2909589656532101, 0.10000000000000009, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.4373749386463430, 0.10000000000000009, 0.20000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.10000000000000009, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17489533344059083, 0.10000000000000009, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35194305707815038, 0.10000000000000009, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53317790741512527, 0.10000000000000009, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.72036681615081222, 0.10000000000000009, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.91480372268244303, 0.10000000000000009, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1170528708071514, 0.10000000000000009, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3266916802718358, 0.10000000000000009, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.5421622241831547, 0.10000000000000009, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.7608656115083421, 0.10000000000000009, 0.20000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler103 = 2.5000000000000020e-13;
 
-// Test function for k=0.10000000000000009, nu=0.20000000000000001.
-template <typename Tp>
-void test103()
+// Test data for k=0.10000000000000009, nu=0.30000000000000004.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 1.9186071760326645e-16
+// mean(f - f_Boost): -1.6653345369377347e-17
+// variance(f - f_Boost): 3.4238754566884194e-35
+// stddev(f - f_Boost): 5.8513891142945016e-18
+const testcase_ellint_3<double>
+data104[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data103)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data103[i].k), Tp(data103[i].nu),
-                   Tp(data103[i].phi));
-      const Tp f0 = data103[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.10000000000000009, nu=0.29999999999999999.
-testcase_ellint_3<double> data104[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17401611261390110, 0.10000000000000009, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34506869507511767, 0.10000000000000009, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51081757604259870, 0.10000000000000009, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.66992297597712303, 0.10000000000000009, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.82209722856174228, 0.10000000000000009, 0.29999999999999999,
-          0.87266462599716477 },
-  { 0.96792430487669612, 0.10000000000000009, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1085964108954092, 0.10000000000000009, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.2456748370836999, 0.10000000000000009, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.3809159606704959, 0.10000000000000009, 0.29999999999999999,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.10000000000000009, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17507310163441189, 0.10000000000000009, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35337768072524217, 0.10000000000000009, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.53808167801629170, 0.10000000000000009, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.73215166755955019, 0.10000000000000009, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.93806546000201219, 0.10000000000000009, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.1573218723395986, 0.10000000000000009, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.3897859679542097, 0.10000000000000009, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.6331009404328622, 0.10000000000000009, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 1.8826015946315438, 0.10000000000000009, 0.30000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler104 = 2.5000000000000020e-13;
 
-// Test function for k=0.10000000000000009, nu=0.29999999999999999.
-template <typename Tp>
-void test104()
+// Test data for k=0.10000000000000009, nu=0.40000000000000002.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0338059536914377e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 9.5107651574678308e-35
+// stddev(f - f_Boost): 9.7523151904908362e-18
+const testcase_ellint_3<double>
+data105[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data104)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data104[i].k), Tp(data104[i].nu),
-                   Tp(data104[i].phi));
-      const Tp f0 = data104[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.10000000000000009, nu=0.40000000000000002.
-testcase_ellint_3<double> data105[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17384216369897937, 0.10000000000000009, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34375018311376782, 0.10000000000000009, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.50672650758380455, 0.10000000000000009, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.66121264213337616, 0.10000000000000009, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.80706202005774441, 0.10000000000000009, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.94519376138245892, 0.10000000000000009, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.0771880300759584, 0.10000000000000009, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2049711557188272, 0.10000000000000009, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.3306223265207477, 0.10000000000000009, 0.40000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.10000000000000009, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17525152094559704, 0.10000000000000009, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35483343742825979, 0.10000000000000009, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54314913099505446, 0.10000000000000009, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.74463962034766862, 0.10000000000000009, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.96349276837570441, 0.10000000000000009, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2029081382746343, 0.10000000000000009, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.4638022887050806, 0.10000000000000009, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.7432413830105224, 0.10000000000000009, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.0336367403076760, 0.10000000000000009, 0.40000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler105 = 2.5000000000000020e-13;
 
-// Test function for k=0.10000000000000009, nu=0.40000000000000002.
-template <typename Tp>
-void test105()
+// Test data for k=0.10000000000000009, nu=0.50000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.9864616042835278e-16
+// mean(f - f_Boost): 9.4368957093138303e-17
+// variance(f - f_Boost): 7.7794254682023874e-32
+// stddev(f - f_Boost): 2.7891621444803792e-16
+const testcase_ellint_3<double>
+data106[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data105)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data105[i].k), Tp(data105[i].nu),
-                   Tp(data105[i].phi));
-      const Tp f0 = data105[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.10000000000000009, nu=0.50000000000000000.
-testcase_ellint_3<double> data106[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17366883711936554, 0.10000000000000009, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34244940634881876, 0.10000000000000009, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50274793281634378, 0.10000000000000009, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.65287941633275093, 0.10000000000000009, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.79291198790315398, 0.10000000000000009, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.92412201537880345, 0.10000000000000009, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0484480076799370, 0.10000000000000009, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.1681168130475206, 0.10000000000000009, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.2854480708580160, 0.10000000000000009, 0.50000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.10000000000000009, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17543059564292182, 0.10000000000000009, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35631088838721664, 0.10000000000000009, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.54839023346436455, 0.10000000000000009, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.75790846946088830, 0.10000000000000009, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 0.99146713686720678, 0.10000000000000009, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.2551692247937198, 0.10000000000000009, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.5524660788146873, 0.10000000000000009, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 1.8806578570830670, 0.10000000000000009, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.2279868912966849, 0.10000000000000009, 0.50000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler106 = 2.5000000000000020e-13;
 
-// Test function for k=0.10000000000000009, nu=0.50000000000000000.
-template <typename Tp>
-void test106()
+// Test data for k=0.10000000000000009, nu=0.60000000000000009.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.6726146516228014e-16
+// mean(f - f_Boost): -3.6082248300317589e-17
+// variance(f - f_Boost): 1.6073193116120635e-34
+// stddev(f - f_Boost): 1.2678009747638087e-17
+const testcase_ellint_3<double>
+data107[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data106)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data106[i].k), Tp(data106[i].nu),
-                   Tp(data106[i].phi));
-      const Tp f0 = data106[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.10000000000000009, nu=0.59999999999999998.
-testcase_ellint_3<double> data107[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17349612891469018, 0.10000000000000009, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34116594505539438, 0.10000000000000009, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.49887649430466685, 0.10000000000000009, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.64489553282165157, 0.10000000000000009, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.77956016553782437, 0.10000000000000009, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.90451074530096309, 0.10000000000000009, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0220113666961632, 0.10000000000000009, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1345351441065563, 0.10000000000000009, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.2445798942989255, 0.10000000000000009, 0.59999999999999998,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.10000000000000009, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17561033003590576, 0.10000000000000009, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35781061668171932, 0.10000000000000009, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55381585659629196, 0.10000000000000009, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.77204910484575640, 0.10000000000000009, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0224751740393108, 0.10000000000000009, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3160230906351114, 0.10000000000000009, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.6616282844233206, 0.10000000000000009, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.0592555664850392, 0.10000000000000009, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.4913004919173822, 0.10000000000000009, 0.60000000000000009, 
+	  1.5707963267948966 },
 };
+const double toler107 = 2.5000000000000020e-13;
 
-// Test function for k=0.10000000000000009, nu=0.59999999999999998.
-template <typename Tp>
-void test107()
+// Test data for k=0.10000000000000009, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 2.1004074871280821e-16
+// mean(f - f_Boost): 3.3306690738754695e-17
+// variance(f - f_Boost): 1.3695501826753678e-34
+// stddev(f - f_Boost): 1.1702778228589003e-17
+const testcase_ellint_3<double>
+data108[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data107)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data107[i].k), Tp(data107[i].nu),
-                   Tp(data107[i].phi));
-      const Tp f0 = data107[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.10000000000000009, nu=0.69999999999999996.
-testcase_ellint_3<double> data108[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17332403516105052, 0.10000000000000009, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.33989939374896877, 0.10000000000000009, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.49510719568614081, 0.10000000000000009, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.63723607776354974, 0.10000000000000009, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.76693133887935327, 0.10000000000000009, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.88619382078823827, 0.10000000000000009, 0.69999999999999996,
-          1.0471975511965976 },
-  { 0.99758012018676490, 0.10000000000000009, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1037642270814410, 0.10000000000000009, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2073745911083187, 0.10000000000000009, 0.69999999999999996,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.10000000000000009, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17579072847532518, 0.10000000000000009, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.35933322840606297, 0.10000000000000009, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.55943788649460324, 0.10000000000000009, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.78716856504031707, 0.10000000000000009, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0571501305617423, 0.10000000000000009, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.3882948301743525, 0.10000000000000009, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.8011785680114223, 0.10000000000000009, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.3057268183616464, 0.10000000000000009, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 2.8771910188009739, 0.10000000000000009, 0.70000000000000007, 
+	  1.5707963267948966 },
 };
+const double toler108 = 2.5000000000000020e-13;
 
-// Test function for k=0.10000000000000009, nu=0.69999999999999996.
-template <typename Tp>
-void test108()
+// Test data for k=0.10000000000000009, nu=0.80000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.3133043868392355e-16
+// mean(f - f_Boost): 1.8041124150158794e-16
+// variance(f - f_Boost): 6.1843750436434569e-32
+// stddev(f - f_Boost): 2.4868403735751633e-16
+const testcase_ellint_3<double>
+data109[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data108)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data108[i].k), Tp(data108[i].nu),
-                   Tp(data108[i].phi));
-      const Tp f0 = data108[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.10000000000000009, nu=0.80000000000000004.
-testcase_ellint_3<double> data109[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17315255197057020, 0.10000000000000009, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.33864936055747985, 0.10000000000000009, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49143537041117619, 0.10000000000000009, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.62987861760047492, 0.10000000000000009, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.75496005490917517, 0.10000000000000009, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.86903081862701903, 0.10000000000000009, 0.80000000000000004,
-          1.0471975511965976 },
-  { 0.97490814820725591, 0.10000000000000009, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.0754290107171083, 0.10000000000000009, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.1733158866987732, 0.10000000000000009, 0.80000000000000004,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.10000000000000009, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17597179535373417, 0.10000000000000009, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36087935387831499, 0.10000000000000009, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.56526935244526444, 0.10000000000000009, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.80339402590612397, 0.10000000000000009, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.0963358646374459, 0.10000000000000009, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.4763748483246868, 0.10000000000000009, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 1.9896610222794102, 0.10000000000000009, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.6806423920122024, 0.10000000000000009, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.5246199613295612, 0.10000000000000009, 0.80000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler109 = 2.5000000000000020e-13;
 
-// Test function for k=0.10000000000000009, nu=0.80000000000000004.
-template <typename Tp>
-void test109()
+// Test data for k=0.10000000000000009, nu=0.90000000000000002.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5624826890976725e-16
+// mean(f - f_Boost): 2.3314683517128288e-16
+// variance(f - f_Boost): 2.9401198977189756e-31
+// stddev(f - f_Boost): 5.4222872459129045e-16
+const testcase_ellint_3<double>
+data110[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data109)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data109[i].k), Tp(data109[i].nu),
-                   Tp(data109[i].phi));
-      const Tp f0 = data109[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.10000000000000009, nu=0.90000000000000002.
-testcase_ellint_3<double> data110[] = {
-  { -0.0000000000000000, 0.10000000000000009, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17298167549096569, 0.10000000000000009, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33741546662741584, 0.10000000000000009, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.48785665376856879, 0.10000000000000009, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.62280288554518959, 0.10000000000000009, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.74358903115455199, 0.10000000000000009, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.85290207679298358, 0.10000000000000009, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.95379006645397379, 0.10000000000000009, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.0492213119872327, 0.10000000000000009, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.1419839485283374, 0.10000000000000009, 0.90000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.10000000000000009, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17615353510599349, 0.10000000000000009, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36244964892922371, 0.10000000000000009, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57132457590110530, 0.10000000000000009, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.82087808820385000, 0.10000000000000009, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1411894342144451, 0.10000000000000009, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.5875929286844597, 0.10000000000000009, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.2678622986596659, 0.10000000000000009, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.3697528941897903, 0.10000000000000009, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 4.9862890417305499, 0.10000000000000009, 0.90000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler110 = 2.5000000000000020e-13;
 
-// Test function for k=0.10000000000000009, nu=0.90000000000000002.
-template <typename Tp>
-void test110()
+// Test data for k=0.20000000000000018, nu=0.0000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 4.2156475739151676e-16
+// mean(f - f_Boost): -5.2735593669694933e-17
+// variance(f - f_Boost): 3.0473442641042680e-32
+// stddev(f - f_Boost): 1.7456644190978597e-16
+const testcase_ellint_3<double>
+data111[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data110)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data110[i].k), Tp(data110[i].nu),
-                   Tp(data110[i].phi));
-      const Tp f0 = data110[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.0000000000000000.
-testcase_ellint_3<double> data111[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17456817290292811, 0.19999999999999996, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.34934315932086801, 0.19999999999999996, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52450880529443988, 0.19999999999999996, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.70020491009844910, 0.19999999999999996, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.87651006649967955, 0.19999999999999996, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0534305870298994, 0.19999999999999996, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2308975521670784, 0.19999999999999996, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.4087733584990738, 0.19999999999999996, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.5868678474541664, 0.19999999999999996, 0.0000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.20000000000000018, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17456817290292806, 0.20000000000000018, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.34934315932086796, 0.20000000000000018, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52450880529443988, 0.20000000000000018, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.70020491009844887, 0.20000000000000018, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.87651006649967977, 0.20000000000000018, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0534305870298994, 0.20000000000000018, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2308975521670789, 0.20000000000000018, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.4087733584990738, 0.20000000000000018, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.5868678474541662, 0.20000000000000018, 0.0000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler111 = 2.5000000000000020e-13;
 
-// Test function for k=0.19999999999999996, nu=0.0000000000000000.
-template <typename Tp>
-void test111()
+// Test data for k=0.20000000000000018, nu=0.10000000000000001.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 4.0890622182605400e-16
+// mean(f - f_Boost): -3.8857805861880476e-17
+// variance(f - f_Boost): 2.8794792590749608e-32
+// stddev(f - f_Boost): 1.6969028431454054e-16
+const testcase_ellint_3<double>
+data112[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data111)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data111[i].k), Tp(data111[i].nu),
-                   Tp(data111[i].phi));
-      const Tp f0 = data111[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.10000000000000001.
-testcase_ellint_3<double> data112[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17439228502691750, 0.19999999999999996, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34796731137565740, 0.19999999999999996, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52003370294544848, 0.19999999999999996, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.69012222258631495, 0.19999999999999996, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.85803491465566772, 0.19999999999999996, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0238463961099364, 0.19999999999999996, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.1878691059202153, 0.19999999999999996, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.3505985031831940, 0.19999999999999996, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.5126513474261092, 0.19999999999999996, 0.10000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.20000000000000018, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17474469953608965, 0.20000000000000018, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35073860234984255, 0.20000000000000018, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.52912258712951521, 0.20000000000000018, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.71081701558898069, 0.20000000000000018, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.89640758521169384, 0.20000000000000018, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.0860417038089853, 0.20000000000000018, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.2793599255528623, 0.20000000000000018, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.4754938544089076, 0.20000000000000018, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.6731552050562593, 0.20000000000000018, 0.10000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler112 = 2.5000000000000020e-13;
 
-// Test function for k=0.19999999999999996, nu=0.10000000000000001.
-template <typename Tp>
-void test112()
+// Test data for k=0.20000000000000018, nu=0.20000000000000001.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 3.9570963716579749e-16
+// mean(f - f_Boost): -5.8286708792820721e-17
+// variance(f - f_Boost): 3.1158217732380362e-32
+// stddev(f - f_Boost): 1.7651690494788412e-16
+const testcase_ellint_3<double>
+data113[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data112)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data112[i].k), Tp(data112[i].nu),
-                   Tp(data112[i].phi));
-      const Tp f0 = data112[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.20000000000000001.
-testcase_ellint_3<double> data113[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17421703179583750, 0.19999999999999996, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34661057411998791, 0.19999999999999996, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.51569006052647393, 0.19999999999999996, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.68052412821107278, 0.19999999999999996, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.84081341263313825, 0.19999999999999996, 0.20000000000000001,
-          0.87266462599716477 },
-  { 0.99683359988842890, 0.19999999999999996, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1493086715118852, 0.19999999999999996, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.2992699693957541, 0.19999999999999996, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.4479323932249568, 0.19999999999999996, 0.20000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.20000000000000018, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17492186907740698, 0.20000000000000018, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35215414286134267, 0.20000000000000018, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53388285615182440, 0.20000000000000018, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.72200960282688265, 0.20000000000000018, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.91793087614428526, 0.20000000000000018, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1222602841587976, 0.20000000000000018, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3345489407496247, 0.20000000000000018, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.5531225705475502, 0.20000000000000018, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.7751816279738935, 0.20000000000000018, 0.20000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler113 = 2.5000000000000020e-13;
 
-// Test function for k=0.19999999999999996, nu=0.20000000000000001.
-template <typename Tp>
-void test113()
+// Test data for k=0.20000000000000018, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.6785817924053817e-16
+// mean(f - f_Boost): -1.1102230246251566e-17
+// variance(f - f_Boost): 9.9840208317034302e-32
+// stddev(f - f_Boost): 3.1597501217190311e-16
+const testcase_ellint_3<double>
+data114[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data113)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data113[i].k), Tp(data113[i].nu),
-                   Tp(data113[i].phi));
-      const Tp f0 = data113[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.29999999999999999.
-testcase_ellint_3<double> data114[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17404240913577707, 0.19999999999999996, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34527248032587193, 0.19999999999999996, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51147118981668416, 0.19999999999999996, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.67137107867777635, 0.19999999999999996, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.82470418188668893, 0.19999999999999996, 0.29999999999999999,
-          0.87266462599716477 },
-  { 0.97202873223594299, 0.19999999999999996, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1144773569375266, 0.19999999999999996, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.2535292433701000, 0.19999999999999996, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.3908453514752481, 0.19999999999999996, 0.29999999999999999,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.20000000000000018, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17509968571715159, 0.20000000000000018, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35359030214835629, 0.20000000000000018, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.53879807274537084, 0.20000000000000018, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.73384116418059731, 0.20000000000000018, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.94132799329524031, 0.20000000000000018, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.1628407021801439, 0.20000000000000018, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.3982440216739438, 0.20000000000000018, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.6450634983653640, 0.20000000000000018, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 1.8983924169967099, 0.20000000000000018, 0.30000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler114 = 2.5000000000000020e-13;
 
-// Test function for k=0.19999999999999996, nu=0.29999999999999999.
-template <typename Tp>
-void test114()
+// Test data for k=0.20000000000000018, nu=0.40000000000000002.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 3.6738449250038925e-16
+// mean(f - f_Boost): -3.0531133177191807e-17
+// variance(f - f_Boost): 2.7810428396951687e-32
+// stddev(f - f_Boost): 1.6676458975739331e-16
+const testcase_ellint_3<double>
+data115[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data114)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data114[i].k), Tp(data114[i].nu),
-                   Tp(data114[i].phi));
-      const Tp f0 = data114[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.40000000000000002.
-testcase_ellint_3<double> data115[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17386841301066677, 0.19999999999999996, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34395257914113253, 0.19999999999999996, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.50737088376869466, 0.19999999999999996, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.66262801717277664, 0.19999999999999996, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.80958766645079094, 0.19999999999999996, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.94913754236162040, 0.19999999999999996, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.0827985514223000, 0.19999999999999996, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2124212429050478, 0.19999999999999996, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.3400002519661010, 0.19999999999999996, 0.40000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.20000000000000018, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17527815368535152, 0.20000000000000018, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35504762134297801, 0.20000000000000018, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54387742353211344, 0.20000000000000018, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.74637910471804259, 0.20000000000000018, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.96690539714174639, 0.20000000000000018, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2087859420184757, 0.20000000000000018, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.4729799844168852, 0.20000000000000018, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.7564445064596661, 0.20000000000000018, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.0512956926676806, 0.20000000000000018, 0.40000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler115 = 2.5000000000000020e-13;
 
-// Test function for k=0.19999999999999996, nu=0.40000000000000002.
-template <typename Tp>
-void test115()
+// Test data for k=0.20000000000000018, nu=0.50000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3841806057292116e-16
+// mean(f - f_Boost): 3.6082248300317589e-17
+// variance(f - f_Boost): 8.9638010532618564e-32
+// stddev(f - f_Boost): 2.9939607634806868e-16
+const testcase_ellint_3<double>
+data116[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data115)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data115[i].k), Tp(data115[i].nu),
-                   Tp(data115[i].phi));
-      const Tp f0 = data115[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.50000000000000000.
-testcase_ellint_3<double> data116[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17369503942181802, 0.19999999999999996, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34265043534362660, 0.19999999999999996, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50338337208655415, 0.19999999999999996, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.65426373297163642, 0.19999999999999996, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.79536193036145808, 0.19999999999999996, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.92791875910061605, 0.19999999999999996, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0538145052725829, 0.19999999999999996, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.1752060022875899, 0.19999999999999996, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.2943374404397376, 0.19999999999999996, 0.50000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.20000000000000018, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17545727725228877, 0.20000000000000018, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35652666242062175, 0.20000000000000018, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.54913090549102406, 0.20000000000000018, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.75970161209211551, 0.20000000000000018, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 0.99504737401590326, 0.20000000000000018, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.2614666007124373, 0.20000000000000018, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.5625255355205498, 0.20000000000000018, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 1.8954460255613346, 0.20000000000000018, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.2481046259421302, 0.20000000000000018, 0.50000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler116 = 2.5000000000000020e-13;
 
-// Test function for k=0.19999999999999996, nu=0.50000000000000000.
-template <typename Tp>
-void test116()
+// Test data for k=0.20000000000000018, nu=0.60000000000000009.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5317584994994743e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 1.0045745697575397e-31
+// stddev(f - f_Boost): 3.1695024369095219e-16
+const testcase_ellint_3<double>
+data117[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data116)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data116[i].k), Tp(data116[i].nu),
-                   Tp(data116[i].phi));
-      const Tp f0 = data116[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.59999999999999998.
-testcase_ellint_3<double> data117[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17352228440746928, 0.19999999999999996, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34136562863713626, 0.19999999999999996, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.49950328177638481, 0.19999999999999996, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.64625032705690832, 0.19999999999999996, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.78193941198403094, 0.19999999999999996, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.90817230934317128, 0.19999999999999996, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0271563751276462, 0.19999999999999996, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1412999379040518, 0.19999999999999996, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.2530330675914561, 0.19999999999999996, 0.59999999999999998,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.20000000000000018, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17563706072900442, 0.20000000000000018, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35802800926807238, 0.20000000000000018, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55456942250515051, 0.20000000000000018, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.77390003828438203, 0.20000000000000018, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0262441366366397, 0.20000000000000018, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3228192988439669, 0.20000000000000018, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.6728005754680795, 0.20000000000000018, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.0761587107468511, 0.20000000000000018, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.5148333891629315, 0.20000000000000018, 0.60000000000000009, 
+	  1.5707963267948966 },
 };
+const double toler117 = 2.5000000000000020e-13;
 
-// Test function for k=0.19999999999999996, nu=0.59999999999999998.
-template <typename Tp>
-void test117()
+// Test data for k=0.20000000000000018, nu=0.70000000000000007.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.2209418045118284e-16
+// mean(f - f_Boost): 2.4980018054066023e-17
+// variance(f - f_Boost): 9.1989071679544611e-32
+// stddev(f - f_Boost): 3.0329700242426498e-16
+const testcase_ellint_3<double>
+data118[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data117)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data117[i].k), Tp(data117[i].nu),
-                   Tp(data117[i].phi));
-      const Tp f0 = data117[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.69999999999999996.
-testcase_ellint_3<double> data118[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17335014404233898, 0.19999999999999996, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34009775298617811, 0.19999999999999996, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.49572560201923810, 0.19999999999999996, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.63856276669886525, 0.19999999999999996, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.76924438644867565, 0.19999999999999996, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.88973060843856466, 0.19999999999999996, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0025230471636377, 0.19999999999999996, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1102356376093103, 0.19999999999999996, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2154356555075867, 0.19999999999999996, 0.69999999999999996,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.20000000000000018, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17581750846781172, 0.20000000000000018, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.35955226882028513, 0.20000000000000018, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56020489659466499, 0.20000000000000018, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.78908196988531498, 0.20000000000000018, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0611336754143517, 0.20000000000000018, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.3956969951058884, 0.20000000000000018, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.8138131612209609, 0.20000000000000018, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.3256365528879561, 0.20000000000000018, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 2.9058704854500963, 0.20000000000000018, 0.70000000000000007, 
+	  1.5707963267948966 },
 };
+const double toler118 = 2.5000000000000020e-13;
 
-// Test function for k=0.19999999999999996, nu=0.69999999999999996.
-template <typename Tp>
-void test118()
+// Test data for k=0.20000000000000018, nu=0.80000000000000004.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.7399960886656824e-16
+// mean(f - f_Boost): 1.3877787807814457e-16
+// variance(f - f_Boost): 1.7585404776158019e-31
+// stddev(f - f_Boost): 4.1934955319110593e-16
+const testcase_ellint_3<double>
+data119[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data118)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data118[i].k), Tp(data118[i].nu),
-                   Tp(data118[i].phi));
-      const Tp f0 = data118[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.80000000000000004.
-testcase_ellint_3<double> data119[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17317861443718541, 0.19999999999999996, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.33884641598718701, 0.19999999999999996, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49204565281259494, 0.19999999999999996, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.63117851188220353, 0.19999999999999996, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.75721095949544170, 0.19999999999999996, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.87245201443919118, 0.19999999999999996, 0.80000000000000004,
-          1.0471975511965976 },
-  { 0.97966584238831089, 0.19999999999999996, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.0816336325174360, 0.19999999999999996, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.1810223448909913, 0.19999999999999996, 0.80000000000000004,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.20000000000000018, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17599862486281712, 0.20000000000000018, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36110007227128776, 0.20000000000000018, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.56605039658567224, 0.20000000000000018, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.80537523874517691, 0.20000000000000018, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1005662342414086, 0.20000000000000018, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.4845340298105778, 0.20000000000000018, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.0043332244969392, 0.20000000000000018, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.7052856676744761, 0.20000000000000018, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.5622166386422633, 0.20000000000000018, 0.80000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler119 = 2.5000000000000020e-13;
 
-// Test function for k=0.19999999999999996, nu=0.80000000000000004.
-template <typename Tp>
-void test119()
+// Test data for k=0.20000000000000018, nu=0.90000000000000002.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1718503329017390e-16
+// mean(f - f_Boost): 2.3592239273284576e-16
+// variance(f - f_Boost): 2.9295534376290287e-31
+// stddev(f - f_Boost): 5.4125349307224141e-16
+const testcase_ellint_3<double>
+data120[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data119)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data119[i].k), Tp(data119[i].nu),
-                   Tp(data119[i].phi));
-      const Tp f0 = data119[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.19999999999999996, nu=0.90000000000000002.
-testcase_ellint_3<double> data120[] = {
-  { -0.0000000000000000, 0.19999999999999996, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17300769173837280, 0.19999999999999996, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33761123827372508, 0.19999999999999996, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.48845905690769426, 0.19999999999999996, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.62407720017324986, 0.19999999999999996, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.74578146525124289, 0.19999999999999996, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.85621583540073076, 0.19999999999999996, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.95837725988001199, 0.19999999999999996, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.0551821412633928, 0.19999999999999996, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.1493679916141863, 0.19999999999999996, 0.90000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.20000000000000018, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17618041435044951, 0.20000000000000018, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36267207636502929, 0.20000000000000018, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57212028758237743, 0.20000000000000018, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.82293323876704483, 0.20000000000000018, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1457077279880388, 0.20000000000000018, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.5967346899325681, 0.20000000000000018, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.2856537353421724, 0.20000000000000018, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.4034714304613902, 0.20000000000000018, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.0448269356200370, 0.20000000000000018, 0.90000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler120 = 2.5000000000000020e-13;
 
-// Test function for k=0.19999999999999996, nu=0.90000000000000002.
-template <typename Tp>
-void test120()
+// Test data for k=0.30000000000000004, nu=0.0000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.2241249691539529e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 2.1399221604302621e-32
+// stddev(f - f_Boost): 1.4628472785736254e-16
+const testcase_ellint_3<double>
+data121[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data120)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data120[i].k), Tp(data120[i].nu),
-                   Tp(data120[i].phi));
-      const Tp f0 = data120[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.30000000000000004, nu=0.0000000000000000.
-testcase_ellint_3<double> data121[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17461228653000102, 0.30000000000000004, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.34969146102798415, 0.30000000000000004, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52565822873726320, 0.30000000000000004, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.70284226512408532, 0.30000000000000004, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.88144139195111182, 0.30000000000000004, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0614897067260523, 0.30000000000000004, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2428416824174218, 0.30000000000000004, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.4251795877015925, 0.30000000000000004, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.6080486199305126, 0.30000000000000004, 0.0000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.30000000000000004, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17461228653000099, 0.30000000000000004, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.34969146102798421, 0.30000000000000004, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52565822873726309, 0.30000000000000004, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.70284226512408543, 0.30000000000000004, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.88144139195111171, 0.30000000000000004, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0614897067260520, 0.30000000000000004, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2428416824174220, 0.30000000000000004, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.4251795877015929, 0.30000000000000004, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.6080486199305128, 0.30000000000000004, 0.0000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler121 = 2.5000000000000020e-13;
 
-// Test function for k=0.30000000000000004, nu=0.0000000000000000.
-template <typename Tp>
-void test121()
+// Test data for k=0.30000000000000004, nu=0.10000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1872304407982844e-16
+// mean(f - f_Boost): 7.2164496600635178e-17
+// variance(f - f_Boost): 4.3555500115139682e-32
+// stddev(f - f_Boost): 2.0869954507650391e-16
+const testcase_ellint_3<double>
+data122[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data121)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data121[i].k), Tp(data121[i].nu),
-                   Tp(data121[i].phi));
-      const Tp f0 = data121[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.30000000000000004, nu=0.10000000000000001.
-testcase_ellint_3<double> data122[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17443631884814378, 0.30000000000000004, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34831316835124926, 0.30000000000000004, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52116586276523857, 0.30000000000000004, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.69269385837910036, 0.30000000000000004, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.86279023163070856, 0.30000000000000004, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0315321461438265, 0.30000000000000004, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.1991449111869024, 0.30000000000000004, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.3659561780923211, 0.30000000000000004, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.5323534693557526, 0.30000000000000004, 0.10000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.30000000000000004, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17478889331392972, 0.30000000000000004, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35108939018329183, 0.30000000000000004, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.53028990896115835, 0.30000000000000004, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.71352417052371409, 0.30000000000000004, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.90153086032405894, 0.30000000000000004, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.0945187977283313, 0.30000000000000004, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.2920699268385683, 0.30000000000000004, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.4931243665896394, 0.30000000000000004, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.6960848815118226, 0.30000000000000004, 0.10000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler122 = 2.5000000000000020e-13;
 
-// Test function for k=0.30000000000000004, nu=0.10000000000000001.
-template <typename Tp>
-void test122()
+// Test data for k=0.30000000000000004, nu=0.20000000000000001.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.2247497610332889e-16
+// mean(f - f_Boost): 6.6613381477509390e-17
+// variance(f - f_Boost): 1.7591111235252501e-32
+// stddev(f - f_Boost): 1.3263148659067538e-16
+const testcase_ellint_3<double>
+data123[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data122)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data122[i].k), Tp(data122[i].nu),
-                   Tp(data122[i].phi));
-      const Tp f0 = data122[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.30000000000000004, nu=0.20000000000000001.
-testcase_ellint_3<double> data123[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17426098615372090, 0.30000000000000004, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34695402664689923, 0.30000000000000004, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.51680555567038933, 0.30000000000000004, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.68303375225260210, 0.30000000000000004, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.84540662891295026, 0.30000000000000004, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0041834051646927, 0.30000000000000004, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1599952702345711, 0.30000000000000004, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.3137179520499163, 0.30000000000000004, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.4663658145259875, 0.30000000000000004, 0.20000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.30000000000000004, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17496614335337535, 0.30000000000000004, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35250745937139372, 0.30000000000000004, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53506875002836884, 0.30000000000000004, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.72479106622248191, 0.30000000000000004, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.92326451535891607, 0.30000000000000004, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1312092060698349, 0.30000000000000004, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3481473154592321, 0.30000000000000004, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.5722049569662750, 0.30000000000000004, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.8002173372290500, 0.30000000000000004, 0.20000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler123 = 2.5000000000000020e-13;
 
-// Test function for k=0.30000000000000004, nu=0.20000000000000001.
-template <typename Tp>
-void test123()
+// Test data for k=0.30000000000000004, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.1678685180047551e-16
+// mean(f - f_Boost): 1.0547118733938987e-16
+// variance(f - f_Boost): 7.5633408838247182e-32
+// stddev(f - f_Boost): 2.7501528837184157e-16
+const testcase_ellint_3<double>
+data124[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data123)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data123[i].k), Tp(data123[i].nu),
-                   Tp(data123[i].phi));
-      const Tp f0 = data123[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.30000000000000004, nu=0.29999999999999999.
-testcase_ellint_3<double> data124[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17408628437042845, 0.30000000000000004, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34561356761638401, 0.30000000000000004, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51257058617875850, 0.30000000000000004, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.67382207124602866, 0.30000000000000004, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.82914751587825131, 0.30000000000000004, 0.29999999999999999,
-          0.87266462599716477 },
-  { 0.97907434814374950, 0.30000000000000004, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1246399297351584, 0.30000000000000004, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.2671793970398146, 0.30000000000000004, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.4081767433479089, 0.30000000000000004, 0.29999999999999999,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.30000000000000004, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17514404084107435, 0.30000000000000004, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35394619108645647, 0.30000000000000004, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.54000325463372689, 0.30000000000000004, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.73670193794067651, 0.30000000000000004, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.94689345491722177, 0.30000000000000004, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.1723274608389140, 0.30000000000000004, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.4128880552936287, 0.30000000000000004, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.6659010047449661, 0.30000000000000004, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 1.9260216862473254, 0.30000000000000004, 0.30000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler124 = 2.5000000000000020e-13;
 
-// Test function for k=0.30000000000000004, nu=0.29999999999999999.
-template <typename Tp>
-void test124()
+// Test data for k=0.30000000000000004, nu=0.40000000000000002.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.3983279132797385e-16
+// mean(f - f_Boost): 1.1657341758564144e-16
+// variance(f - f_Boost): 1.8245832308692586e-31
+// stddev(f - f_Boost): 4.2715140534349863e-16
+const testcase_ellint_3<double>
+data125[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data124)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data124[i].k), Tp(data124[i].nu),
-                   Tp(data124[i].phi));
-      const Tp f0 = data124[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.30000000000000004, nu=0.40000000000000002.
-testcase_ellint_3<double> data125[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17391220945982730, 0.30000000000000004, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34429133937639689, 0.30000000000000004, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.50845471668581632, 0.30000000000000004, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.66502347027873854, 0.30000000000000004, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.81389191978012254, 0.30000000000000004, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.95590618002140593, 0.30000000000000004, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.0924915195213121, 0.30000000000000004, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2253651604038058, 0.30000000000000004, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.3563643538969761, 0.30000000000000004, 0.40000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.30000000000000004, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17532259000954434, 0.30000000000000004, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35540612770983693, 0.30000000000000004, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54510265552938919, 0.30000000000000004, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.74932476310965057, 0.30000000000000004, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.97272793583093109, 0.30000000000000004, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2188928987074241, 0.30000000000000004, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.4888771674085941, 0.30000000000000004, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.7794558498219191, 0.30000000000000004, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.0822121773175528, 0.30000000000000004, 0.40000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler125 = 2.5000000000000020e-13;
 
-// Test function for k=0.30000000000000004, nu=0.40000000000000002.
-template <typename Tp>
-void test125()
+// Test data for k=0.30000000000000004, nu=0.50000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.0516138451673425e-16
+// mean(f - f_Boost): 4.7184478546569152e-17
+// variance(f - f_Boost): 1.9448563670505968e-32
+// stddev(f - f_Boost): 1.3945810722401896e-16
+const testcase_ellint_3<double>
+data126[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data125)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data125[i].k), Tp(data125[i].nu),
-                   Tp(data125[i].phi));
-      const Tp f0 = data125[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.30000000000000004, nu=0.50000000000000000.
-testcase_ellint_3<double> data126[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17373875742088235, 0.30000000000000004, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34298690571124157, 0.30000000000000004, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50445214859646936, 0.30000000000000004, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.65660648352418516, 0.30000000000000004, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.79953670639287289, 0.30000000000000004, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.93443393926588558, 0.30000000000000004, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0630838369016911, 0.30000000000000004, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.1875197325653026, 0.30000000000000004, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.3098448759814960, 0.30000000000000004, 0.50000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.30000000000000004, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17550179513158179, 0.30000000000000004, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35688783251681200, 0.30000000000000004, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.55037700010142798, 0.30000000000000004, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.76273839789895992, 0.30000000000000004, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0011570518830419, 0.30000000000000004, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.2722987414055109, 0.30000000000000004, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.5799590511080066, 0.30000000000000004, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 1.9212367220124293, 0.30000000000000004, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.2833505881933971, 0.30000000000000004, 0.50000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler126 = 2.5000000000000020e-13;
 
-// Test function for k=0.30000000000000004, nu=0.50000000000000000.
-template <typename Tp>
-void test126()
+// Test data for k=0.30000000000000004, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.2121157428443725e-16
+// mean(f - f_Boost): 1.9428902930940239e-16
+// variance(f - f_Boost): 1.5987596229703424e-31
+// stddev(f - f_Boost): 3.9984492281012430e-16
+const testcase_ellint_3<double>
+data127[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data126)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data126[i].k), Tp(data126[i].nu),
-                   Tp(data126[i].phi));
-      const Tp f0 = data126[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.30000000000000004, nu=0.59999999999999998.
-testcase_ellint_3<double> data127[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17356592428950826, 0.30000000000000004, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34169984536697379, 0.30000000000000004, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50055748266498457, 0.30000000000000004, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.64854298527106768, 0.30000000000000004, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.78599329284207431, 0.30000000000000004, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.91445452089128221, 0.30000000000000004, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0360412952290587, 0.30000000000000004, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1530473919778639, 0.30000000000000004, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.2677758800420666, 0.30000000000000004, 0.59999999999999998,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.30000000000000004, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17568166052076745, 0.30000000000000004, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35839189074731181, 0.30000000000000004, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55583724744367558, 0.30000000000000004, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.77703498090888223, 0.30000000000000004, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0326772113675962, 0.30000000000000004, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3345139983717369, 0.30000000000000004, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.6921742922838403, 0.30000000000000004, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.1056608968472186, 0.30000000000000004, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.5560975528589061, 0.30000000000000004, 0.60000000000000009, 
+	  1.5707963267948966 },
 };
+const double toler127 = 2.5000000000000020e-13;
 
-// Test function for k=0.30000000000000004, nu=0.59999999999999998.
-template <typename Tp>
-void test127()
+// Test data for k=0.30000000000000004, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.0088945789059381e-16
+// mean(f - f_Boost): 2.1094237467877973e-16
+// variance(f - f_Boost): 3.0253363535298873e-31
+// stddev(f - f_Boost): 5.5003057674368314e-16
+const testcase_ellint_3<double>
+data128[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data127)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data127[i].k), Tp(data127[i].nu),
-                   Tp(data127[i].phi));
-      const Tp f0 = data127[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.30000000000000004, nu=0.69999999999999996.
-testcase_ellint_3<double> data128[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17339370613812227, 0.30000000000000004, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34042975138455933, 0.30000000000000004, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.49676568368075985, 0.30000000000000004, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.64080774055753720, 0.30000000000000004, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.77318507779667278, 0.30000000000000004, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.89579782346548631, 0.30000000000000004, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0110573286052202, 0.30000000000000004, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1214710972949633, 0.30000000000000004, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2294913236274980, 0.30000000000000004, 0.69999999999999996,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.30000000000000004, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17586219053197988, 0.30000000000000004, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.35991891074557669, 0.30000000000000004, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56149538019961731, 0.30000000000000004, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.79232303189667685, 0.30000000000000004, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0679345542878826, 0.30000000000000004, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.4084400085913955, 0.30000000000000004, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.8357382859296454, 0.30000000000000004, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.3604197996171519, 0.30000000000000004, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 2.9562123549913872, 0.30000000000000004, 0.70000000000000007, 
+	  1.5707963267948966 },
 };
+const double toler128 = 2.5000000000000020e-13;
 
-// Test function for k=0.30000000000000004, nu=0.69999999999999996.
-template <typename Tp>
-void test128()
+// Test data for k=0.30000000000000004, nu=0.80000000000000004.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.1197887707781618e-16
+// mean(f - f_Boost): 3.4416913763379854e-16
+// variance(f - f_Boost): 4.3461914185990199e-31
+// stddev(f - f_Boost): 6.5925650687718054e-16
+const testcase_ellint_3<double>
+data129[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data128)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data128[i].k), Tp(data128[i].nu),
-                   Tp(data128[i].phi));
-      const Tp f0 = data128[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.30000000000000004, nu=0.80000000000000004.
-testcase_ellint_3<double> data129[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17322209907520361, 0.30000000000000004, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.33917623046949996, 0.30000000000000004, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49307204894329176, 0.30000000000000004, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.63337802830291723, 0.30000000000000004, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.76104540997689407, 0.30000000000000004, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.87832009635450736, 0.30000000000000004, 0.80000000000000004,
-          1.0471975511965976 },
-  { 0.98787879723171790, 0.30000000000000004, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.0924036340069336, 0.30000000000000004, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.1944567571590046, 0.30000000000000004, 0.80000000000000004,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.30000000000000004, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17604338956191670, 0.30000000000000004, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36146952517410791, 0.30000000000000004, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.56736453393774644, 0.30000000000000004, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.80873149979001091, 0.30000000000000004, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1077903069860620, 0.30000000000000004, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.4985874311132998, 0.30000000000000004, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.0298167266724954, 0.30000000000000004, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.7483929054985432, 0.30000000000000004, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.6283050484567170, 0.30000000000000004, 0.80000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler129 = 2.5000000000000020e-13;
 
-// Test function for k=0.30000000000000004, nu=0.80000000000000004.
-template <typename Tp>
-void test129()
+// Test data for k=0.30000000000000004, nu=0.90000000000000002.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.1301806687926828e-16
+// mean(f - f_Boost): 4.1633363423443370e-16
+// variance(f - f_Boost): 2.2835347143080263e-31
+// stddev(f - f_Boost): 4.7786344433405093e-16
+const testcase_ellint_3<double>
+data130[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data129)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data129[i].k), Tp(data129[i].nu),
-                   Tp(data129[i].phi));
-      const Tp f0 = data129[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.30000000000000004, nu=0.90000000000000002.
-testcase_ellint_3<double> data130[] = {
-  { -0.0000000000000000, 0.30000000000000004, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17305109924485948, 0.30000000000000004, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33793890239556984, 0.30000000000000004, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.48947218005089738, 0.30000000000000004, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.62623332340775151, 0.30000000000000004, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.74951596581511148, 0.30000000000000004, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.86189886597756005, 0.30000000000000004, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.96629451153092005, 0.30000000000000004, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.0655269133492680, 0.30000000000000004, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.1622376896064912, 0.30000000000000004, 0.90000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.30000000000000004, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17622526204962433, 0.30000000000000004, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36304439230777141, 0.30000000000000004, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57345914744719195, 0.30000000000000004, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.82641512928845162, 0.30000000000000004, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1534256210757743, 0.30000000000000004, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.6124900353411677, 0.30000000000000004, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.3165905514845089, 0.30000000000000004, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.4625619526539824, 0.30000000000000004, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.1479514944016787, 0.30000000000000004, 0.90000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler130 = 2.5000000000000020e-13;
 
-// Test function for k=0.30000000000000004, nu=0.90000000000000002.
-template <typename Tp>
-void test130()
+// Test data for k=0.40000000000000013, nu=0.0000000000000000.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.0831445028587608e-15
+// mean(f - f_Boost): 1.7486012637846215e-16
+// variance(f - f_Boost): 3.1664095331106078e-31
+// stddev(f - f_Boost): 5.6270858649132121e-16
+const testcase_ellint_3<double>
+data131[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data130)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data130[i].k), Tp(data130[i].nu),
-                   Tp(data130[i].phi));
-      const Tp f0 = data130[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.0000000000000000.
-testcase_ellint_3<double> data131[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17467414669441531, 0.39999999999999991, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35018222772483443, 0.39999999999999991, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52729015917508748, 0.39999999999999991, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.70662374407341255, 0.39999999999999991, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.88859210497602170, 0.39999999999999991, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0733136290471379, 0.39999999999999991, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2605612170157061, 0.39999999999999991, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.4497513956433437, 0.39999999999999991, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.6399998658645112, 0.39999999999999991, 0.0000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.40000000000000013, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17467414669441528, 0.40000000000000013, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35018222772483443, 0.40000000000000013, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52729015917508748, 0.40000000000000013, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.70662374407341244, 0.40000000000000013, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.88859210497602159, 0.40000000000000013, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0733136290471381, 0.40000000000000013, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2605612170157066, 0.40000000000000013, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.4497513956433439, 0.40000000000000013, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.6399998658645112, 0.40000000000000013, 0.0000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler131 = 2.5000000000000020e-13;
 
-// Test function for k=0.39999999999999991, nu=0.0000000000000000.
-template <typename Tp>
-void test131()
+// Test data for k=0.40000000000000013, nu=0.10000000000000001.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.0263824105456986e-15
+// mean(f - f_Boost): 1.7486012637846215e-16
+// variance(f - f_Boost): 3.1664095331106078e-31
+// stddev(f - f_Boost): 5.6270858649132121e-16
+const testcase_ellint_3<double>
+data132[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data131)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data131[i].k), Tp(data131[i].nu),
-                   Tp(data131[i].phi));
-      const Tp f0 = data131[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.10000000000000001.
-testcase_ellint_3<double> data132[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17449806706684673, 0.39999999999999991, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34880048623856075, 0.39999999999999991, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52277322065757403, 0.39999999999999991, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.69638072056918376, 0.39999999999999991, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.86968426619831540, 0.39999999999999991, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0428044206578095, 0.39999999999999991, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.2158651158274378, 0.39999999999999991, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.3889447129893322, 0.39999999999999991, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.5620566886683604, 0.39999999999999991, 0.10000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.40000000000000013, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17485086590796767, 0.40000000000000013, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35158366412506992, 0.40000000000000013, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.53194731675711726, 0.40000000000000013, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.71740615528010931, 0.40000000000000013, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.90896157773487030, 0.40000000000000013, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.1069605483834348, 0.40000000000000013, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.3109353428823001, 0.40000000000000013, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.5195460789903450, 0.40000000000000013, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.7306968836847190, 0.40000000000000013, 0.10000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler132 = 2.5000000000000020e-13;
 
-// Test function for k=0.39999999999999991, nu=0.10000000000000001.
-template <typename Tp>
-void test132()
+// Test data for k=0.40000000000000013, nu=0.20000000000000001.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.6644296021947179e-16
+// mean(f - f_Boost): 2.0816681711721685e-16
+// variance(f - f_Boost): 3.0360740073926687e-31
+// stddev(f - f_Boost): 5.5100580826273227e-16
+const testcase_ellint_3<double>
+data133[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data132)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data132[i].k), Tp(data132[i].nu),
-                   Tp(data132[i].phi));
-      const Tp f0 = data132[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.20000000000000001.
-testcase_ellint_3<double> data133[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17432262290723399, 0.39999999999999991, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34743795258968596, 0.39999999999999991, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.51838919472805123, 0.39999999999999991, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.68663134739057918, 0.39999999999999991, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.85206432981833979, 0.39999999999999991, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0149595349004430, 0.39999999999999991, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1758349405464676, 0.39999999999999991, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.3353337673882635, 0.39999999999999991, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.4941414344266770, 0.39999999999999991, 0.20000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.40000000000000013, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17502822886437389, 0.40000000000000013, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35300530062530805, 0.40000000000000013, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53675259548210896, 0.40000000000000013, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.72878006428676934, 0.40000000000000013, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.93100219010583574, 0.40000000000000013, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1443487271187611, 0.40000000000000013, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3683427764108813, 0.40000000000000013, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.6008221459300933, 0.40000000000000013, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.8380358826317627, 0.40000000000000013, 0.20000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler133 = 2.5000000000000020e-13;
 
-// Test function for k=0.39999999999999991, nu=0.20000000000000001.
-template <typename Tp>
-void test133()
+// Test data for k=0.40000000000000013, nu=0.30000000000000004.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0271556462838835e-16
+// mean(f - f_Boost): 2.0816681711721685e-16
+// variance(f - f_Boost): 3.0360740073926687e-31
+// stddev(f - f_Boost): 5.5100580826273227e-16
+const testcase_ellint_3<double>
+data134[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data133)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data133[i].k), Tp(data133[i].nu),
-                   Tp(data133[i].phi));
-      const Tp f0 = data133[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.29999999999999999.
-testcase_ellint_3<double> data134[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17414781013591543, 0.39999999999999991, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34609415696777285, 0.39999999999999991, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51413131295862546, 0.39999999999999991, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.67733527622935630, 0.39999999999999991, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.83558675182733266, 0.39999999999999991, 0.29999999999999999,
-          0.87266462599716477 },
-  { 0.98940140808865906, 0.39999999999999991, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1396968797728058, 0.39999999999999991, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.2875920037865087, 0.39999999999999991, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.4342789859950078, 0.39999999999999991, 0.29999999999999999,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.40000000000000013, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17520623975982899, 0.40000000000000013, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35444766141612105, 0.40000000000000013, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.54171455841536009, 0.40000000000000013, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.74080517001084012, 0.40000000000000013, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.95496950509296574, 0.40000000000000013, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.1862627879844718, 0.40000000000000013, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.4346501803799458, 0.40000000000000013, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.6971744798077699, 0.40000000000000013, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 1.9677924132520139, 0.40000000000000013, 0.30000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler134 = 2.5000000000000020e-13;
 
-// Test function for k=0.39999999999999991, nu=0.29999999999999999.
-template <typename Tp>
-void test134()
+// Test data for k=0.40000000000000013, nu=0.40000000000000002.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3436329231972794e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 2.9507053793392374e-31
+// stddev(f - f_Boost): 5.4320395611033958e-16
+const testcase_ellint_3<double>
+data135[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data134)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data134[i].k), Tp(data134[i].nu),
-                   Tp(data134[i].phi));
-      const Tp f0 = data134[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.40000000000000002.
-testcase_ellint_3<double> data135[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17397362471112710, 0.39999999999999991, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34476864603333196, 0.39999999999999991, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.50999329415379357, 0.39999999999999991, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.66845674551396017, 0.39999999999999991, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.82012848346231748, 0.39999999999999991, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.96582449258349057, 0.39999999999999991, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.1068473749476286, 0.39999999999999991, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2447132729159986, 0.39999999999999991, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.3809986210732901, 0.39999999999999991, 0.40000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.40000000000000013, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17538490283034375, 0.40000000000000013, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35591129064319948, 0.40000000000000013, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54684250413264535, 0.40000000000000013, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.75355027742668290, 0.40000000000000013, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.98117935026780634, 0.40000000000000013, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2337464222030736, 0.40000000000000013, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.5125183419289221, 0.40000000000000013, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.8140224451130313, 0.40000000000000013, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.1289968719280026, 0.40000000000000013, 0.40000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler135 = 2.5000000000000020e-13;
 
-// Test function for k=0.39999999999999991, nu=0.40000000000000002.
-template <typename Tp>
-void test135()
+// Test data for k=0.40000000000000013, nu=0.50000000000000000.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.7013794022122431e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 1.4989821857033475e-31
+// stddev(f - f_Boost): 3.8716691306248618e-16
+const testcase_ellint_3<double>
+data136[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data135)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data135[i].k), Tp(data135[i].nu),
-                   Tp(data135[i].phi));
-      const Tp f0 = data135[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.50000000000000000.
-testcase_ellint_3<double> data136[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17380006262854139, 0.39999999999999991, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34346098216756610, 0.39999999999999991, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50596929935059420, 0.39999999999999991, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.65996392089131262, 0.39999999999999991, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.80558463511364786, 0.39999999999999991, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.94397834522857704, 0.39999999999999991, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0768075114108115, 0.39999999999999991, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.2059184624251329, 0.39999999999999991, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.3331797176377398, 0.39999999999999991, 0.50000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.40000000000000013, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17556422235224273, 0.40000000000000013, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35739675341763921, 0.40000000000000013, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.55214655195037188, 0.40000000000000013, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.76709520942047438, 0.40000000000000013, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0100278761577499, 0.40000000000000013, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.2882265661384342, 0.40000000000000013, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.6059059780051876, 0.40000000000000013, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 1.9600182740224081, 0.40000000000000013, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.3367461373176512, 0.40000000000000013, 0.50000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler136 = 2.5000000000000020e-13;
 
-// Test function for k=0.39999999999999991, nu=0.50000000000000000.
-template <typename Tp>
-void test136()
+// Test data for k=0.40000000000000013, nu=0.60000000000000009.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.4792115132836117e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 4.8893797490374802e-31
+// stddev(f - f_Boost): 6.9924099915819294e-16
+const testcase_ellint_3<double>
+data137[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data136)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data136[i].k), Tp(data136[i].nu),
-                   Tp(data136[i].phi));
-      const Tp f0 = data136[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.59999999999999998.
-testcase_ellint_3<double> data137[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17362711992081248, 0.39999999999999991, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34217074276403953, 0.39999999999999991, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50205389185761617, 0.39999999999999991, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.65182834920372745, 0.39999999999999991, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.79186512820565136, 0.39999999999999991, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.92365535916287134, 0.39999999999999991, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0491915663957907, 0.39999999999999991, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1705934291745104, 0.39999999999999991, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.2899514672527024, 0.39999999999999991, 0.59999999999999998,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.40000000000000013, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17574420264267029, 0.40000000000000013, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35890463689046265, 0.40000000000000013, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55763773975194486, 0.40000000000000013, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.78153324227761267, 0.40000000000000013, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0420205885765887, 0.40000000000000013, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3517205230381770, 0.40000000000000013, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.7210360970313896, 0.40000000000000013, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.1500780510169246, 0.40000000000000013, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.6186940209850191, 0.40000000000000013, 0.60000000000000009, 
+	  1.5707963267948966 },
 };
+const double toler137 = 2.5000000000000020e-13;
 
-// Test function for k=0.39999999999999991, nu=0.59999999999999998.
-template <typename Tp>
-void test137()
+// Test data for k=0.40000000000000013, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.8573292020719759e-16
+// mean(f - f_Boost): 2.2759572004815707e-16
+// variance(f - f_Boost): 2.9613098824898137e-31
+// stddev(f - f_Boost): 5.4417918762938862e-16
+const testcase_ellint_3<double>
+data138[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data137)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data137[i].k), Tp(data137[i].nu),
-                   Tp(data137[i].phi));
-      const Tp f0 = data137[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.69999999999999996.
-testcase_ellint_3<double> data138[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17345479265712871, 0.39999999999999991, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34089751955950354, 0.39999999999999991, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.49824200167361343, 0.39999999999999991, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.64402450341199413, 0.39999999999999991, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.77889207804122873, 0.39999999999999991, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.90468169720957992, 0.39999999999999991, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0236847823692916, 0.39999999999999991, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1382465247425164, 0.39999999999999991, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2506255923253344, 0.39999999999999991, 0.69999999999999996,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.40000000000000013, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17592484806010436, 0.40000000000000013, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36043555139631439, 0.40000000000000013, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56332813669944881, 0.40000000000000013, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.79697424562157548, 0.40000000000000013, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0778155987523672, 0.40000000000000013, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.4272018169896268, 0.40000000000000013, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.8684377907453382, 0.40000000000000013, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.4128677409207473, 0.40000000000000013, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.0327078743873246, 0.40000000000000013, 0.70000000000000007, 
+	  1.5707963267948966 },
 };
+const double toler138 = 2.5000000000000020e-13;
 
-// Test function for k=0.39999999999999991, nu=0.69999999999999996.
-template <typename Tp>
-void test138()
+// Test data for k=0.40000000000000013, nu=0.80000000000000004.
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.5273712585384737e-16
+// mean(f - f_Boost): 4.5241588253475131e-16
+// variance(f - f_Boost): 1.1866477068555882e-30
+// stddev(f - f_Boost): 1.0893336067778265e-15
+const testcase_ellint_3<double>
+data139[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data138)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data138[i].k), Tp(data138[i].nu),
-                   Tp(data138[i].phi));
-      const Tp f0 = data138[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.80000000000000004.
-testcase_ellint_3<double> data139[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17328307694277156, 0.39999999999999991, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.33964091800132007, 0.39999999999999991, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49452889372467451, 0.39999999999999991, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.63652940095937327, 0.39999999999999991, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.76659772511159097, 0.39999999999999991, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.88691047977338111, 0.39999999999999991, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.0000273200611640, 0.39999999999999991, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.1084787902188007, 0.39999999999999991, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.2146499565727209, 0.39999999999999991, 0.80000000000000004,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.40000000000000013, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17610616300487833, 0.40000000000000013, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36199013167171978, 0.40000000000000013, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.56923097361842434, 0.40000000000000013, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.81354878456624347, 0.40000000000000013, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1182902719261825, 0.40000000000000013, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.5192950589409022, 0.40000000000000013, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.0678761710223981, 0.40000000000000013, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.8135222249879788, 0.40000000000000013, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.7289548002199902, 0.40000000000000013, 0.80000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler139 = 2.5000000000000020e-13;
 
-// Test function for k=0.39999999999999991, nu=0.80000000000000004.
-template <typename Tp>
-void test139()
+// Test data for k=0.40000000000000013, nu=0.90000000000000002.
+// max(|f - f_Boost|): 6.2172489379008766e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.1718379478872251e-15
+// mean(f - f_Boost): 8.4099394115355610e-16
+// variance(f - f_Boost): 3.5684096037099424e-30
+// stddev(f - f_Boost): 1.8890234523980751e-15
+const testcase_ellint_3<double>
+data140[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data139)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data139[i].k), Tp(data139[i].nu),
-                   Tp(data139[i].phi));
-      const Tp f0 = data139[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.39999999999999991, nu=0.90000000000000002.
-testcase_ellint_3<double> data140[] = {
-  { -0.0000000000000000, 0.39999999999999991, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17311196891868130, 0.39999999999999991, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33840055664911906, 0.39999999999999991, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.49091013944075340, 0.39999999999999991, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.62932228186809591, 0.39999999999999991, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.75492278323019801, 0.39999999999999991, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.87021659043854294, 0.39999999999999991, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.97800245228239246, 0.39999999999999991, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.0809625773173694, 0.39999999999999991, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.1815758115929846, 0.39999999999999991, 0.90000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.40000000000000013, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17628815191971123, 0.40000000000000013, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36356903815378772, 0.40000000000000013, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57536079447000310, 0.40000000000000013, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.83141355850172571, 0.40000000000000013, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1646481598721361, 0.40000000000000013, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.6357275034001995, 0.40000000000000013, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.3628787566572402, 0.40000000000000013, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.5521010369134962, 0.40000000000000013, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.3055535102872513, 0.40000000000000013, 0.90000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler140 = 2.5000000000000020e-13;
 
-// Test function for k=0.39999999999999991, nu=0.90000000000000002.
-template <typename Tp>
-void test140()
+// Test data for k=0.50000000000000000, nu=0.0000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.4551389361831220e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 2.5893058141206173e-32
+// stddev(f - f_Boost): 1.6091320064309879e-16
+const testcase_ellint_3<double>
+data141[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data140)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data140[i].k), Tp(data140[i].nu),
-                   Tp(data140[i].phi));
-      const Tp f0 = data140[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.50000000000000000, nu=0.0000000000000000.
-testcase_ellint_3<double> data141[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17475385514035785, 0.50000000000000000, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35081868470101585, 0.50000000000000000, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.52942862705190585, 0.50000000000000000, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.71164727562630326, 0.50000000000000000, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.89824523594227768, 0.50000000000000000, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.0895506700518851, 0.50000000000000000, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.2853005857432933, 0.50000000000000000, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.4845545520549484, 0.50000000000000000, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.6857503548125963, 0.50000000000000000, 0.0000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.50000000000000000, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17475385514035785, 0.50000000000000000, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35081868470101579, 0.50000000000000000, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.52942862705190574, 0.50000000000000000, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.71164727562630326, 0.50000000000000000, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.89824523594227768, 0.50000000000000000, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.0895506700518853, 0.50000000000000000, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.2853005857432933, 0.50000000000000000, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.4845545520549488, 0.50000000000000000, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.6857503548125961, 0.50000000000000000, 0.0000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler141 = 2.5000000000000020e-13;
 
-// Test function for k=0.50000000000000000, nu=0.0000000000000000.
-template <typename Tp>
-void test141()
+// Test data for k=0.50000000000000000, nu=0.10000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.7416868347177582e-16
+// mean(f - f_Boost): 2.7755575615628915e-18
+// variance(f - f_Boost): 5.4326441655972001e-32
+// stddev(f - f_Boost): 2.3308033305273100e-16
+const testcase_ellint_3<double>
+data142[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data141)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data141[i].k), Tp(data141[i].nu),
-                   Tp(data141[i].phi));
-      const Tp f0 = data141[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.50000000000000000, nu=0.10000000000000001.
-testcase_ellint_3<double> data142[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17457763120814676, 0.50000000000000000, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.34943246340849154, 0.50000000000000000, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52487937869610801, 0.50000000000000000, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.70127785096388395, 0.50000000000000000, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.87898815988624479, 0.50000000000000000, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0582764576094172, 0.50000000000000000, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.2391936844060207, 0.50000000000000000, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.4214793542995841, 0.50000000000000000, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.6045524936084892, 0.50000000000000000, 0.10000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.50000000000000000, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17493071928248824, 0.50000000000000000, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35222467688034798, 0.50000000000000000, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.53411928652008112, 0.50000000000000000, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.72256398117177589, 0.50000000000000000, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.91899583232771009, 0.50000000000000000, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.1240549163055360, 0.50000000000000000, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.3372938086286021, 0.50000000000000000, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.5570024469132429, 0.50000000000000000, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.7803034946545480, 0.50000000000000000, 0.10000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler142 = 2.5000000000000020e-13;
 
-// Test function for k=0.50000000000000000, nu=0.10000000000000001.
-template <typename Tp>
-void test142()
+// Test data for k=0.50000000000000000, nu=0.20000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1198767993730867e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 5.0311947683004831e-32
+// stddev(f - f_Boost): 2.2430324938128922e-16
+const testcase_ellint_3<double>
+data143[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data142)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data142[i].k), Tp(data142[i].nu),
-                   Tp(data142[i].phi));
-      const Tp f0 = data142[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.50000000000000000, nu=0.20000000000000001.
-testcase_ellint_3<double> data143[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17440204336345433, 0.50000000000000000, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34806552388338824, 0.50000000000000000, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.52046416757129821, 0.50000000000000000, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.69140924550993876, 0.50000000000000000, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.86104678636125520, 0.50000000000000000, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0297439459053981, 0.50000000000000000, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.1979214112912036, 0.50000000000000000, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.3659033858648930, 0.50000000000000000, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.5338490483665983, 0.50000000000000000, 0.20000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.50000000000000000, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17510822779582402, 0.50000000000000000, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35365094725531487, 0.50000000000000000, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.53895933237328697, 0.50000000000000000, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.73408090840070794, 0.50000000000000000, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.94145442818535396, 0.50000000000000000, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1624120186296487, 0.50000000000000000, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.3965823372867114, 0.50000000000000000, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.6414308440430099, 0.50000000000000000, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.8922947612264018, 0.50000000000000000, 0.20000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler143 = 2.5000000000000020e-13;
 
-// Test function for k=0.50000000000000000, nu=0.20000000000000001.
-template <typename Tp>
-void test143()
+// Test data for k=0.50000000000000000, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3800262770228813e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 8.5027191584278157e-32
+// stddev(f - f_Boost): 2.9159422419567599e-16
+const testcase_ellint_3<double>
+data144[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data143)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data143[i].k), Tp(data143[i].nu),
-                   Tp(data143[i].phi));
-      const Tp f0 = data143[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.50000000000000000, nu=0.29999999999999999.
-testcase_ellint_3<double> data144[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17422708752228896, 0.50000000000000000, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34671739434855858, 0.50000000000000000, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51617616305641889, 0.50000000000000000, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.68200047612545178, 0.50000000000000000, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.84427217869498372, 0.50000000000000000, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.0035637821389782, 0.50000000000000000, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1606800483933113, 0.50000000000000000, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.3164407134643459, 0.50000000000000000, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.4715681939859637, 0.50000000000000000, 0.29999999999999999,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.50000000000000000, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17528638488102041, 0.50000000000000000, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35509802222332720, 0.50000000000000000, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.54395740731866193, 0.50000000000000000, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.74625871438752667, 0.50000000000000000, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.96588271186092023, 0.50000000000000000, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.2054319584357329, 0.50000000000000000, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.4651077994832871, 0.50000000000000000, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.7416018368052644, 0.50000000000000000, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.0277924458111314, 0.50000000000000000, 0.30000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler144 = 2.5000000000000020e-13;
 
-// Test function for k=0.50000000000000000, nu=0.29999999999999999.
-template <typename Tp>
-void test144()
+// Test data for k=0.50000000000000000, nu=0.40000000000000002.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.0439932918341581e-16
+// mean(f - f_Boost): 3.0531133177191807e-17
+// variance(f - f_Boost): 9.0809736800018602e-32
+// stddev(f - f_Boost): 3.0134653938616686e-16
+const testcase_ellint_3<double>
+data145[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data144)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data144[i].k), Tp(data144[i].nu),
-                   Tp(data144[i].phi));
-      const Tp f0 = data144[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.50000000000000000, nu=0.40000000000000002.
-testcase_ellint_3<double> data145[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17405275963859917, 0.50000000000000000, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34538761957029329, 0.50000000000000000, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.51200902646603919, 0.50000000000000000, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.67301522212868792, 0.50000000000000000, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.82853844466313320, 0.50000000000000000, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.97942097862681488, 0.50000000000000000, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.1268429801220616, 0.50000000000000000, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.2720406704533922, 0.50000000000000000, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.4161679518465340, 0.50000000000000000, 0.40000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.50000000000000000, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17546519477859268, 0.50000000000000000, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35656644822531680, 0.50000000000000000, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.54912289677411319, 0.50000000000000000, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.75916731611690047, 0.50000000000000000, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 0.99260415631328214, 0.50000000000000000, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2541925856918670, 0.50000000000000000, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.5456393705347609, 0.50000000000000000, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.8631904972952076, 0.50000000000000000, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.1962905366178065, 0.50000000000000000, 0.40000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler145 = 2.5000000000000020e-13;
 
-// Test function for k=0.50000000000000000, nu=0.40000000000000002.
-template <typename Tp>
-void test145()
+// Test data for k=0.50000000000000000, nu=0.50000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.6797816859260978e-16
+// mean(f - f_Boost): 9.4368957093138303e-17
+// variance(f - f_Boost): 7.7794254682023874e-32
+// stddev(f - f_Boost): 2.7891621444803792e-16
+const testcase_ellint_3<double>
+data146[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data145)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data145[i].k), Tp(data145[i].nu),
-                   Tp(data145[i].phi));
-      const Tp f0 = data145[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.50000000000000000, nu=0.50000000000000000.
-testcase_ellint_3<double> data146[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17387905570381157, 0.50000000000000000, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34407576010465207, 0.50000000000000000, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.50795686560160835, 0.50000000000000000, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.66442115453330175, 0.50000000000000000, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.81373829119355345, 0.50000000000000000, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.95705743313235825, 0.50000000000000000, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.0959131991362556, 0.50000000000000000, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.2318900529754597, 0.50000000000000000, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.3664739530045971, 0.50000000000000000, 0.50000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.50000000000000000, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17564466176941509, 0.50000000000000000, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35805679276065394, 0.50000000000000000, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.55446601496200032, 0.50000000000000000, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.77288783578259013, 0.50000000000000000, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0220246013918972, 0.50000000000000000, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.3101681612463965, 0.50000000000000000, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.6422994881851025, 0.50000000000000000, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.0152636030998816, 0.50000000000000000, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.4136715042011945, 0.50000000000000000, 0.50000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler146 = 2.5000000000000020e-13;
 
-// Test function for k=0.50000000000000000, nu=0.50000000000000000.
-template <typename Tp>
-void test146()
+// Test data for k=0.50000000000000000, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.9178421578645735e-16
+// mean(f - f_Boost): 1.3322676295501878e-16
+// variance(f - f_Boost): 1.7749370367472766e-31
+// stddev(f - f_Boost): 4.2130001622920411e-16
+const testcase_ellint_3<double>
+data147[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data146)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data146[i].k), Tp(data146[i].nu),
-                   Tp(data146[i].phi));
-      const Tp f0 = data146[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.50000000000000000, nu=0.59999999999999998.
-testcase_ellint_3<double> data147[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17370597174637581, 0.50000000000000000, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34278139158591414, 0.50000000000000000, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50401419439302719, 0.50000000000000000, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.65618938076167221, 0.50000000000000000, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.79977959248855424, 0.50000000000000000, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.93625925190753545, 0.50000000000000000, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0674905658379710, 0.50000000000000000, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.1953481298023048, 0.50000000000000000, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.3215740290190876, 0.50000000000000000, 0.59999999999999998,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.50000000000000000, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17582479017522740, 0.50000000000000000, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.35956964546660036, 0.50000000000000000, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.55999790372984193, 0.50000000000000000, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.78751507911209895, 0.50000000000000000, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0546620505035220, 0.50000000000000000, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.3754438357425935, 0.50000000000000000, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.7615727400820127, 0.50000000000000000, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.2134638067565242, 0.50000000000000000, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.7090491861753558, 0.50000000000000000, 0.60000000000000009, 
+	  1.5707963267948966 },
 };
+const double toler147 = 2.5000000000000020e-13;
 
-// Test function for k=0.50000000000000000, nu=0.59999999999999998.
-template <typename Tp>
-void test147()
+// Test data for k=0.50000000000000000, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0745105182189226e-16
+// mean(f - f_Boost): 4.1633363423443370e-17
+// variance(f - f_Boost): 1.9996383743576116e-32
+// stddev(f - f_Boost): 1.4140857026211713e-16
+const testcase_ellint_3<double>
+data148[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data147)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data147[i].k), Tp(data147[i].nu),
-                   Tp(data147[i].phi));
-      const Tp f0 = data147[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.50000000000000000, nu=0.69999999999999996.
-testcase_ellint_3<double> data148[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17353350383131641, 0.50000000000000000, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34150410405436771, 0.50000000000000000, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.50017589696443487, 0.50000000000000000, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.64829398188419962, 0.50000000000000000, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.78658270782402073, 0.50000000000000000, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.91684738336675053, 0.50000000000000000, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0412486789555937, 0.50000000000000000, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1619021847612001, 0.50000000000000000, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.2807475181182502, 0.50000000000000000, 0.69999999999999996,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.50000000000000000, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17600558435914915, 0.50000000000000000, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36110561926726259, 0.50000000000000000, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56573074641137111, 0.50000000000000000, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.80316073084237205, 0.50000000000000000, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.0911910688131461, 0.50000000000000000, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.4530946406380640, 0.50000000000000000, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.9144386536785372, 0.50000000000000000, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.4878788958234970, 0.50000000000000000, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.1433945297859225, 0.50000000000000000, 0.70000000000000007, 
+	  1.5707963267948966 },
 };
+const double toler148 = 2.5000000000000020e-13;
 
-// Test function for k=0.50000000000000000, nu=0.69999999999999996.
-template <typename Tp>
-void test148()
+// Test data for k=0.50000000000000000, nu=0.80000000000000004.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.4380477375534667e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 1.4989821857033475e-31
+// stddev(f - f_Boost): 3.8716691306248618e-16
+const testcase_ellint_3<double>
+data149[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data148)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data148[i].k), Tp(data148[i].nu),
-                   Tp(data148[i].phi));
-      const Tp f0 = data148[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.50000000000000000, nu=0.80000000000000004.
-testcase_ellint_3<double> data149[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17336164805979126, 0.50000000000000000, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34024350132086773, 0.50000000000000000, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49643719555734084, 0.50000000000000000, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.64071162456976150, 0.50000000000000000, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.77407836177211908, 0.50000000000000000, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.89867058251905652, 0.50000000000000000, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.0169181822134912, 0.50000000000000000, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.1311363312779448, 0.50000000000000000, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.2434165408189539, 0.50000000000000000, 0.80000000000000004,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.50000000000000000, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17618704872620228, 0.50000000000000000, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36266535159745827, 0.50000000000000000, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.57167789954529158, 0.50000000000000000, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.81995752984315018, 0.50000000000000000, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1325112162158122, 0.50000000000000000, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.5479055930718042, 0.50000000000000000, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.1215243941010486, 0.50000000000000000, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 2.9069405767650132, 0.50000000000000000, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 3.8750701888108066, 0.50000000000000000, 0.80000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler149 = 2.5000000000000020e-13;
 
-// Test function for k=0.50000000000000000, nu=0.80000000000000004.
-template <typename Tp>
-void test149()
+// Test data for k=0.50000000000000000, nu=0.90000000000000002.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.6192315188521289e-16
+// mean(f - f_Boost): 3.5249581031848718e-16
+// variance(f - f_Boost): 2.5029385557256515e-31
+// stddev(f - f_Boost): 5.0029376927217987e-16
+const testcase_ellint_3<double>
+data150[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data149)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data149[i].k), Tp(data149[i].nu),
-                   Tp(data149[i].phi));
-      const Tp f0 = data149[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.50000000000000000, nu=0.90000000000000002.
-testcase_ellint_3<double> data150[] = {
-  { -0.0000000000000000, 0.50000000000000000, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17319040056865681, 0.50000000000000000, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33899920036578557, 0.50000000000000000, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.49279362182695186, 0.50000000000000000, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.63342123379746151, 0.50000000000000000, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.76220595179550321, 0.50000000000000000, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.88160004743532294, 0.50000000000000000, 0.90000000000000002,
-          1.0471975511965976 },
-  { 0.99427448642310134, 0.50000000000000000, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.1027091512470093, 0.50000000000000000, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.2091116095504744, 0.50000000000000000, 0.90000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.50000000000000000, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17636918772384180, 0.50000000000000000, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36424950570740700, 0.50000000000000000, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.57785404590231426, 0.50000000000000000, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.83806480521716531, 0.50000000000000000, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1798568683069752, 0.50000000000000000, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.6678766243739607, 0.50000000000000000, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.4282976450693483, 0.50000000000000000, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.6810787666126656, 0.50000000000000000, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.5355132096026454, 0.50000000000000000, 0.90000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler150 = 2.5000000000000020e-13;
 
-// Test function for k=0.50000000000000000, nu=0.90000000000000002.
-template <typename Tp>
-void test150()
+// Test data for k=0.60000000000000009, nu=0.0000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.3664899092028927e-16
+// mean(f - f_Boost): 3.0531133177191807e-17
+// variance(f - f_Boost): 7.8758646268991113e-33
+// stddev(f - f_Boost): 8.8746068233466605e-17
+const testcase_ellint_3<double>
+data151[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data150)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data150[i].k), Tp(data150[i].nu),
-                   Tp(data150[i].phi));
-      const Tp f0 = data150[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.60000000000000009, nu=0.0000000000000000.
-testcase_ellint_3<double> data151[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17485154362988362, 0.60000000000000009, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35160509865544326, 0.60000000000000009, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.53210652578446160, 0.60000000000000009, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.71805304664485670, 0.60000000000000009, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.91082759030195970, 0.60000000000000009, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.1112333229323366, 0.60000000000000009, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.3191461190365270, 0.60000000000000009, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.5332022105084775, 0.60000000000000009, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.7507538029157526, 0.60000000000000009, 0.0000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.60000000000000009, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17485154362988359, 0.60000000000000009, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35160509865544320, 0.60000000000000009, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.53210652578446138, 0.60000000000000009, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.71805304664485659, 0.60000000000000009, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.91082759030195981, 0.60000000000000009, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.1112333229323361, 0.60000000000000009, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.3191461190365270, 0.60000000000000009, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.5332022105084779, 0.60000000000000009, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.7507538029157526, 0.60000000000000009, 0.0000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler151 = 2.5000000000000020e-13;
 
-// Test function for k=0.60000000000000009, nu=0.0000000000000000.
-template <typename Tp>
-void test151()
+// Test data for k=0.60000000000000009, nu=0.10000000000000001.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.2335247010355137e-16
+// mean(f - f_Boost): 8.6042284408449634e-17
+// variance(f - f_Boost): 2.2835347143080263e-33
+// stddev(f - f_Boost): 4.7786344433405099e-17
+const testcase_ellint_3<double>
+data152[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data151)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data151[i].k), Tp(data151[i].nu),
-                   Tp(data151[i].phi));
-      const Tp f0 = data151[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.60000000000000009, nu=0.10000000000000001.
-testcase_ellint_3<double> data152[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17467514275022014, 0.60000000000000009, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.35021333086258255, 0.60000000000000009, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.52751664092962713, 0.60000000000000009, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.70752126971957885, 0.60000000000000009, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.89111058756112871, 0.60000000000000009, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.0789241202877773, 0.60000000000000009, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.2710800210399946, 0.60000000000000009, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.4669060574440278, 0.60000000000000009, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.6648615773343014, 0.60000000000000009, 0.10000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.60000000000000009, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17502858548476194, 0.60000000000000009, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35301673150537388, 0.60000000000000009, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.53683932476326812, 0.60000000000000009, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.72914228589586771, 0.60000000000000009, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.93208036718354692, 0.60000000000000009, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.1468984688863377, 0.60000000000000009, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.3733904977062528, 0.60000000000000009, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.6094225663372157, 0.60000000000000009, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.8508766487100685, 0.60000000000000009, 0.10000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler152 = 2.5000000000000020e-13;
 
-// Test function for k=0.60000000000000009, nu=0.10000000000000001.
-template <typename Tp>
-void test152()
+// Test data for k=0.60000000000000009, nu=0.20000000000000001.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.2547200163366559e-16
+// mean(f - f_Boost): -2.4980018054066023e-17
+// variance(f - f_Boost): 2.1685495635542404e-32
+// stddev(f - f_Boost): 1.4725995937641163e-16
+const testcase_ellint_3<double>
+data153[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data152)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data152[i].k), Tp(data152[i].nu),
-                   Tp(data152[i].phi));
-      const Tp f0 = data152[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.60000000000000009, nu=0.20000000000000001.
-testcase_ellint_3<double> data153[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17449937871800653, 0.60000000000000009, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34884093647346553, 0.60000000000000009, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.52306221119844110, 0.60000000000000009, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.69749955678982223, 0.60000000000000009, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.87274610682416853, 0.60000000000000009, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0494620540750796, 0.60000000000000009, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.2280847305507339, 0.60000000000000009, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.4085436279696888, 0.60000000000000009, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.5901418016279374, 0.60000000000000009, 0.20000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.60000000000000009, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17520627248155893, 0.60000000000000009, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35444873935437748, 0.60000000000000009, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.54172310557682524, 0.60000000000000009, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.74084300280734672, 0.60000000000000009, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.95509001527006121, 0.60000000000000009, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.1865688084431796, 0.60000000000000009, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.4352978868932600, 0.60000000000000009, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.6983400371331818, 0.60000000000000009, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 1.9695980282802217, 0.60000000000000009, 0.20000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler153 = 2.5000000000000020e-13;
 
-// Test function for k=0.60000000000000009, nu=0.20000000000000001.
-template <typename Tp>
-void test153()
+// Test data for k=0.60000000000000009, nu=0.30000000000000004.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.9470074709717020e-16
+// mean(f - f_Boost): 3.0531133177191807e-17
+// variance(f - f_Boost): 1.1508025840536076e-34
+// stddev(f - f_Boost): 1.0727546709539920e-17
+const testcase_ellint_3<double>
+data154[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data153)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data153[i].k), Tp(data153[i].nu),
-                   Tp(data153[i].phi));
-      const Tp f0 = data153[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.60000000000000009, nu=0.29999999999999999.
-testcase_ellint_3<double> data154[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17432424744393935, 0.60000000000000009, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34748744127146447, 0.60000000000000009, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.51873632743924847, 0.60000000000000009, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.68794610396313127, 0.60000000000000009, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.85558070175468726, 0.60000000000000009, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.0224416343605658, 0.60000000000000009, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.1893144457936788, 0.60000000000000009, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.3566435377982575, 0.60000000000000009, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.5243814243493585, 0.60000000000000009, 0.29999999999999999,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.60000000000000009, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17538460882640122, 0.60000000000000009, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35590165133735557, 0.60000000000000009, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.54676661152254535, 0.60000000000000009, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.75321709418305305, 0.60000000000000009, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.98012637808992920, 0.60000000000000009, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.2310891277158875, 0.60000000000000009, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.5069157924585623, 0.60000000000000009, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.8039583598337940, 0.60000000000000009, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.1134154405060599, 0.60000000000000009, 0.30000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler154 = 2.5000000000000020e-13;
 
-// Test function for k=0.60000000000000009, nu=0.29999999999999999.
-template <typename Tp>
-void test154()
+// Test data for k=0.60000000000000009, nu=0.40000000000000002.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.8974839914337670e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 2.2849613290816465e-32
+// stddev(f - f_Boost): 1.5116088545260797e-16
+const testcase_ellint_3<double>
+data155[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data154)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data154[i].k), Tp(data154[i].nu),
-                   Tp(data154[i].phi));
-      const Tp f0 = data154[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.60000000000000009, nu=0.40000000000000002.
-testcase_ellint_3<double> data155[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17414974487670720, 0.60000000000000009, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34615238767335027, 0.60000000000000009, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.51453257838108579, 0.60000000000000009, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.67882386787534410, 0.60000000000000009, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.83948470233173578, 0.60000000000000009, 0.40000000000000002,
-          0.87266462599716477 },
-  { 0.99753496200074021, 0.60000000000000009, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.1541101404388487, 0.60000000000000009, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.3100911323398816, 0.60000000000000009, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.4659345278069984, 0.60000000000000009, 0.40000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.60000000000000009, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17556359876533037, 0.60000000000000009, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35737601674244679, 0.60000000000000009, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.55197933771320218, 0.60000000000000009, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.76633591620002905, 0.60000000000000009, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 1.0075231136019616, 0.60000000000000009, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.2815842073813450, 0.60000000000000009, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.5911666941449827, 0.60000000000000009, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 1.9323227566025762, 0.60000000000000009, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.2925036420985130, 0.60000000000000009, 0.40000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler155 = 2.5000000000000020e-13;
 
-// Test function for k=0.60000000000000009, nu=0.40000000000000002.
-template <typename Tp>
-void test155()
+// Test data for k=0.60000000000000009, nu=0.50000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 2.1397785842303966e-16
+// mean(f - f_Boost): 9.1593399531575410e-17
+// variance(f - f_Boost): 1.5339913122479866e-32
+// stddev(f - f_Boost): 1.2385440291923362e-16
+const testcase_ellint_3<double>
+data156[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data155)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data155[i].k), Tp(data155[i].nu),
-                   Tp(data155[i].phi));
-      const Tp f0 = data155[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.60000000000000009, nu=0.50000000000000000.
-testcase_ellint_3<double> data156[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17397586700252810, 0.60000000000000009, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34483533397138516, 0.60000000000000009, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.51044500461706499, 0.60000000000000009, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.67009988034712675, 0.60000000000000009, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.82434762375735193, 0.60000000000000009, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.97447346702799043, 0.60000000000000009, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.1219494000522143, 0.60000000000000009, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.2680242605954488, 0.60000000000000009, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.4135484285693078, 0.60000000000000009, 0.50000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.60000000000000009, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17574324658480217, 0.60000000000000009, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35887240603169313, 0.60000000000000009, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.55737161826345261, 0.60000000000000009, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.78028227313077458, 0.60000000000000009, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0376989776486290, 0.60000000000000009, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.3395933991042928, 0.60000000000000009, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.6924049626591784, 0.60000000000000009, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.0931011856518920, 0.60000000000000009, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.5239007084492711, 0.60000000000000009, 0.50000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler156 = 2.5000000000000020e-13;
 
-// Test function for k=0.60000000000000009, nu=0.50000000000000000.
-template <typename Tp>
-void test156()
+// Test data for k=0.60000000000000009, nu=0.60000000000000009.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.6651378277398083e-16
+// mean(f - f_Boost): 1.1934897514720432e-16
+// variance(f - f_Boost): 1.7585404776158019e-33
+// stddev(f - f_Boost): 4.1934955319110598e-17
+const testcase_ellint_3<double>
+data157[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data156)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data156[i].k), Tp(data156[i].nu),
-                   Tp(data156[i].phi));
-      const Tp f0 = data156[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.60000000000000009, nu=0.59999999999999998.
-testcase_ellint_3<double> data157[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17380260984469356, 0.60000000000000009, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34353585361777839, 0.60000000000000009, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50646805774321402, 0.60000000000000009, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.66174468108625517, 0.60000000000000009, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.81007462280278408, 0.60000000000000009, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.95303466945718773, 0.60000000000000009, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.0924118588677503, 0.60000000000000009, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.2297640574847937, 0.60000000000000009, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.3662507535812816, 0.60000000000000009, 0.59999999999999998,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.60000000000000009, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17592355661219386, 0.60000000000000009, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.36039141192661606, 0.60000000000000009, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.56295472636903854, 0.60000000000000009, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.79515295130165986, 0.60000000000000009, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0711886441942242, 0.60000000000000009, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.4072952835139891, 0.60000000000000009, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.8174863977376825, 0.60000000000000009, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.3029921578542232, 0.60000000000000009, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 2.8388723099514972, 0.60000000000000009, 0.60000000000000009, 
+	  1.5707963267948966 },
 };
+const double toler157 = 2.5000000000000020e-13;
 
-// Test function for k=0.60000000000000009, nu=0.59999999999999998.
-template <typename Tp>
-void test157()
+// Test data for k=0.60000000000000009, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.0027679235921772e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 2.2849613290816465e-32
+// stddev(f - f_Boost): 1.5116088545260797e-16
+const testcase_ellint_3<double>
+data158[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data157)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data157[i].k), Tp(data157[i].nu),
-                   Tp(data157[i].phi));
-      const Tp f0 = data157[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.60000000000000009, nu=0.69999999999999996.
-testcase_ellint_3<double> data158[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17362996946312009, 0.60000000000000009, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34225353454870588, 0.60000000000000009, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.50259656397799546, 0.60000000000000009, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.65373184496628944, 0.60000000000000009, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.79658372884056439, 0.60000000000000009, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.93303240100245466, 0.60000000000000009, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0651547944716557, 0.60000000000000009, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.1947676204853441, 0.60000000000000009, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.3232737468822811, 0.60000000000000009, 0.69999999999999996,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.60000000000000009, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17610453321631936, 0.60000000000000009, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36193365056369764, 0.60000000000000009, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.56874098962268527, 0.60000000000000009, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.81106198671477181, 0.60000000000000009, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.1086886419010082, 0.60000000000000009, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.4879048567239257, 0.60000000000000009, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 1.9780310073615925, 0.60000000000000009, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.5941545586772712, 0.60000000000000009, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.3029735898397159, 0.60000000000000009, 0.70000000000000007, 
+	  1.5707963267948966 },
 };
+const double toler158 = 2.5000000000000020e-13;
 
-// Test function for k=0.60000000000000009, nu=0.69999999999999996.
-template <typename Tp>
-void test158()
+// Test data for k=0.60000000000000009, nu=0.80000000000000004.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 7.3044933435043190e-16
+// mean(f - f_Boost): 2.6367796834847468e-16
+// variance(f - f_Boost): 8.5834655546147173e-33
+// stddev(f - f_Boost): 9.2646994309662939e-17
+const testcase_ellint_3<double>
+data159[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data158)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data158[i].k), Tp(data158[i].nu),
-                   Tp(data158[i].phi));
-      const Tp f0 = data158[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.60000000000000009, nu=0.80000000000000004.
-testcase_ellint_3<double> data159[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17345794195390687, 0.60000000000000009, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34098797854531027, 0.60000000000000009, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.49882569168826230, 0.60000000000000009, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.64603758566475511, 0.60000000000000009, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.78380365594769730, 0.60000000000000009, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.91430946255611223, 0.60000000000000009, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.0398955217270607, 0.60000000000000009, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.1625948314277679, 0.60000000000000009, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.2840021261752192, 0.60000000000000009, 0.80000000000000004,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.60000000000000009, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17628618080795252, 0.60000000000000009, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36349976272521012, 0.60000000000000009, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.57474392342151914, 0.60000000000000009, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.82814493499158170, 0.60000000000000009, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1511281795998280, 0.60000000000000009, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.5864286332503075, 0.60000000000000009, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.1958944866494527, 0.60000000000000009, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 3.0398358172574604, 0.60000000000000009, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 4.0867036409261832, 0.60000000000000009, 0.80000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler159 = 2.5000000000000020e-13;
 
-// Test function for k=0.60000000000000009, nu=0.80000000000000004.
-template <typename Tp>
-void test159()
+// Test data for k=0.60000000000000009, nu=0.90000000000000002.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.5952142720718732e-16
+// mean(f - f_Boost): 4.6351811278100284e-16
+// variance(f - f_Boost): 2.1278339779151204e-31
+// stddev(f - f_Boost): 4.6128450851021651e-16
+const testcase_ellint_3<double>
+data160[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data159)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data159[i].k), Tp(data159[i].nu),
-                   Tp(data159[i].phi));
-      const Tp f0 = data159[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.60000000000000009, nu=0.90000000000000002.
-testcase_ellint_3<double> data160[] = {
-  { -0.0000000000000000, 0.60000000000000009, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17328652344890033, 0.60000000000000009, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.33973880062929018, 0.60000000000000009, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.49515092233122765, 0.60000000000000009, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.63864042139737043, 0.60000000000000009, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.77167205646538850, 0.60000000000000009, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.89673202848034428, 0.60000000000000009, 0.90000000000000002,
-          1.0471975511965976 },
-  { 1.0163984492661304, 0.60000000000000009, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.1328845785162431, 0.60000000000000009, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.2479362973851875, 0.60000000000000009, 0.90000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.60000000000000009, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17646850384035848, 0.60000000000000009, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36509041515134105, 0.60000000000000009, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.58097838596260631, 0.60000000000000009, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.84656453396163722, 0.60000000000000009, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.1997828426963724, 0.60000000000000009, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.7112436789225605, 0.60000000000000009, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.5193168553672312, 0.60000000000000009, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 3.8656670488606690, 0.60000000000000009, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 5.8709993116265604, 0.60000000000000009, 0.90000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler160 = 2.5000000000000020e-13;
 
-// Test function for k=0.60000000000000009, nu=0.90000000000000002.
-template <typename Tp>
-void test160()
+// Test data for k=0.70000000000000018, nu=0.0000000000000000.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.1569224977685422e-16
+// mean(f - f_Boost): 7.7715611723760953e-17
+// variance(f - f_Boost): 1.6571557210371951e-32
+// stddev(f - f_Boost): 1.2873056051447903e-16
+const testcase_ellint_3<double>
+data161[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data160)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data160[i].k), Tp(data160[i].nu),
-                   Tp(data160[i].phi));
-      const Tp f0 = data160[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.0000000000000000.
-testcase_ellint_3<double> data161[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17496737466916720, 0.69999999999999996, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35254687535677925, 0.69999999999999996, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.53536740275997130, 0.69999999999999996, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.72603797651684465, 0.69999999999999996, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.92698296348313458, 0.69999999999999996, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.1400447527693316, 0.69999999999999996, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.3657668117194071, 0.69999999999999996, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.6024686895959159, 0.69999999999999996, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.8456939983747236, 0.69999999999999996, 0.0000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.70000000000000018, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17496737466916723, 0.70000000000000018, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35254687535677931, 0.70000000000000018, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.53536740275997130, 0.70000000000000018, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.72603797651684454, 0.70000000000000018, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.92698296348313447, 0.70000000000000018, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.1400447527693318, 0.70000000000000018, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.3657668117194073, 0.70000000000000018, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.6024686895959164, 0.70000000000000018, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.8456939983747236, 0.70000000000000018, 0.0000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler161 = 2.5000000000000020e-13;
 
-// Test function for k=0.69999999999999996, nu=0.0000000000000000.
-template <typename Tp>
-void test161()
+// Test data for k=0.70000000000000018, nu=0.10000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.9552278747527691e-16
+// mean(f - f_Boost): 1.1102230246251565e-16
+// variance(f - f_Boost): 1.3695501826753678e-32
+// stddev(f - f_Boost): 1.1702778228589004e-16
+const testcase_ellint_3<double>
+data162[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data161)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data161[i].k), Tp(data161[i].nu),
-                   Tp(data161[i].phi));
-      const Tp f0 = data161[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.10000000000000001.
-testcase_ellint_3<double> data162[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17479076384884681, 0.69999999999999996, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.35114844900396364, 0.69999999999999996, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.53072776947527012, 0.69999999999999996, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.71530198262386246, 0.69999999999999996, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.90666760677828306, 0.69999999999999996, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.1063366517438080, 0.69999999999999996, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.3149477243092147, 0.69999999999999996, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.5314886725038925, 0.69999999999999996, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.7528050171757608, 0.69999999999999996, 0.10000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.70000000000000018, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17514462737300920, 0.70000000000000018, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35396527997470451, 0.70000000000000018, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.54015179589433981, 0.70000000000000018, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.73734430854477728, 0.70000000000000018, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.94888950796697047, 0.70000000000000018, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.1772807959736322, 0.70000000000000018, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.4231796401075834, 0.70000000000000018, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.6841856799887471, 0.70000000000000018, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 1.9541347343119564, 0.70000000000000018, 0.10000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler162 = 2.5000000000000020e-13;
 
-// Test function for k=0.69999999999999996, nu=0.10000000000000001.
-template <typename Tp>
-void test162()
+// Test data for k=0.70000000000000018, nu=0.20000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.7430437016285820e-16
+// mean(f - f_Boost): 3.3306690738754695e-17
+// variance(f - f_Boost): 1.3695501826753678e-34
+// stddev(f - f_Boost): 1.1702778228589003e-17
+const testcase_ellint_3<double>
+data163[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data162)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data162[i].k), Tp(data162[i].nu),
-                   Tp(data162[i].phi));
-      const Tp f0 = data162[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.20000000000000001.
-testcase_ellint_3<double> data163[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17461479077791472, 0.69999999999999996, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.34976950621407538, 0.69999999999999996, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.52622533231350188, 0.69999999999999996, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.70508774017895226, 0.69999999999999996, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.88775302531730294, 0.69999999999999996, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.0756195476149006, 0.69999999999999996, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.2695349716654372, 0.69999999999999996, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.4690814617070540, 0.69999999999999996, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.6721098780092147, 0.69999999999999996, 0.20000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.70000000000000018, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17532252613350796, 0.70000000000000018, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35540417596807522, 0.70000000000000018, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.54508913033361928, 0.70000000000000018, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.74927635777718415, 0.70000000000000018, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.97261706337936338, 0.70000000000000018, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.2187303976209327, 0.70000000000000018, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.4887796709222487, 0.70000000000000018, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.7796581281839214, 0.70000000000000018, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 2.0829290325820207, 0.70000000000000018, 0.20000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler163 = 2.5000000000000020e-13;
 
-// Test function for k=0.69999999999999996, nu=0.20000000000000001.
-template <typename Tp>
-void test163()
+// Test data for k=0.70000000000000018, nu=0.30000000000000004.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.2570807706941696e-16
+// mean(f - f_Boost): 8.8817841970012528e-17
+// variance(f - f_Boost): 1.5582437633995295e-32
+// stddev(f - f_Boost): 1.2482963443828271e-16
+const testcase_ellint_3<double>
+data164[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data163)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data163[i].k), Tp(data163[i].nu),
-                   Tp(data163[i].phi));
-      const Tp f0 = data163[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.29999999999999999.
-testcase_ellint_3<double> data164[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17443945136076172, 0.69999999999999996, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34840956983535287, 0.69999999999999996, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.52185308551329179, 0.69999999999999996, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.69535240431168266, 0.69999999999999996, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.87007983473964923, 0.69999999999999996, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.0474657975577066, 0.69999999999999996, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.2286225419931889, 0.69999999999999996, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.4136490671013271, 0.69999999999999996, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.6011813647733213, 0.69999999999999996, 0.29999999999999999,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.70000000000000018, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17550107516328570, 0.70000000000000018, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35686409576571965, 0.70000000000000018, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.55018827316513352, 0.70000000000000018, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.76189759494390275, 0.70000000000000018, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 0.99844623430885626, 0.70000000000000018, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.2652862989039833, 0.70000000000000018, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.5647666808691361, 0.70000000000000018, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 1.8932499694938165, 0.70000000000000018, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.2392290510988535, 0.70000000000000018, 0.30000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler164 = 2.5000000000000020e-13;
 
-// Test function for k=0.69999999999999996, nu=0.29999999999999999.
-template <typename Tp>
-void test164()
+// Test data for k=0.70000000000000018, nu=0.40000000000000002.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.3719045096496910e-16
+// mean(f - f_Boost): 1.3600232051658169e-16
+// variance(f - f_Boost): 1.1718213750516114e-32
+// stddev(f - f_Boost): 1.0825069861444829e-16
+const testcase_ellint_3<double>
+data165[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data164)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data164[i].k), Tp(data164[i].nu),
-                   Tp(data164[i].phi));
-      const Tp f0 = data164[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.40000000000000002.
-testcase_ellint_3<double> data165[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17426474153983226, 0.69999999999999996, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34706817945773732, 0.69999999999999996, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.51760452851738159, 0.69999999999999996, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.68605801534722766, 0.69999999999999996, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.85351339387296532, 0.69999999999999996, 0.40000000000000002,
-          0.87266462599716477 },
-  { 1.0215297967969537, 0.69999999999999996, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.1915051074460528, 0.69999999999999996, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.3639821911744707, 0.69999999999999996, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.5382162002954762, 0.69999999999999996, 0.40000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.70000000000000018, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17568027871494424, 0.70000000000000018, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35834559208180261, 0.70000000000000018, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.55545885451190613, 0.70000000000000018, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.77528120402568113, 0.70000000000000018, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 1.0267241287600322, 0.70000000000000018, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.3181380338980246, 0.70000000000000018, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.6542840785132087, 0.70000000000000018, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 2.0315595131131823, 0.70000000000000018, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.4342502915307880, 0.70000000000000018, 0.40000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler165 = 2.5000000000000020e-13;
 
-// Test function for k=0.69999999999999996, nu=0.40000000000000002.
-template <typename Tp>
-void test165()
+// Test data for k=0.70000000000000018, nu=0.50000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.0277361210295499e-16
+// mean(f - f_Boost): 1.6930901125533636e-16
+// variance(f - f_Boost): 6.3799163752809956e-32
+// stddev(f - f_Boost): 2.5258496343371268e-16
+const testcase_ellint_3<double>
+data166[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data165)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data165[i].k), Tp(data165[i].nu),
-                   Tp(data165[i].phi));
-      const Tp f0 = data165[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.50000000000000000.
-testcase_ellint_3<double> data166[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17409065729516093, 0.69999999999999996, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34574489064986091, 0.69999999999999996, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.51347361925579793, 0.69999999999999996, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.67717079489579290, 0.69999999999999996, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.83793902055292280, 0.69999999999999996, 0.50000000000000000,
-          0.87266462599716477 },
-  { 0.99752863545289705, 0.69999999999999996, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.1576240080401499, 0.69999999999999996, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.3191464023923762, 0.69999999999999996, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.4818433192178544, 0.69999999999999996, 0.50000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.70000000000000018, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17586014108156545, 0.70000000000000018, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.35984923894341653, 0.70000000000000018, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.56091135606739995, 0.70000000000000018, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.78951212635197054, 0.70000000000000018, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0578865732938731, 0.70000000000000018, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.3789149005151722, 0.70000000000000018, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.7620212286086228, 0.70000000000000018, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.2051554347435589, 0.70000000000000018, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.6868019968236996, 0.70000000000000018, 0.50000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler166 = 2.5000000000000020e-13;
 
-// Test function for k=0.69999999999999996, nu=0.50000000000000000.
-template <typename Tp>
-void test166()
+// Test data for k=0.70000000000000018, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.8597454441867134e-16
+// mean(f - f_Boost): 2.5535129566378598e-16
+// variance(f - f_Boost): 2.8561208198482198e-31
+// stddev(f - f_Boost): 5.3442687243889785e-16
+const testcase_ellint_3<double>
+data167[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data166)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data166[i].k), Tp(data166[i].nu),
-                   Tp(data166[i].phi));
-      const Tp f0 = data166[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.59999999999999998.
-testcase_ellint_3<double> data167[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17391719464391611, 0.69999999999999996, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34443927423869031, 0.69999999999999996, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.50945473266486074, 0.69999999999999996, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.66866056326513823, 0.69999999999999996, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.82325830002337352, 0.69999999999999996, 0.59999999999999998,
-          0.87266462599716477 },
-  { 0.97522808245669357, 0.69999999999999996, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.1265300613705282, 0.69999999999999996, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.2784066076152003, 0.69999999999999996, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.4309994736080540, 0.69999999999999996, 0.59999999999999998,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.70000000000000018, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17604066659721918, 0.70000000000000018, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.36137563278353424, 0.70000000000000018, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.56655721272747606, 0.70000000000000018, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.80468966552978305, 0.70000000000000018, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.0924902943683852, 0.70000000000000018, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.4499247992499800, 0.70000000000000018, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 1.8953714382113818, 0.70000000000000018, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.4323229949248670, 0.70000000000000018, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 3.0314573496746746, 0.70000000000000018, 0.60000000000000009, 
+	  1.5707963267948966 },
 };
+const double toler167 = 2.5000000000000020e-13;
 
-// Test function for k=0.69999999999999996, nu=0.59999999999999998.
-template <typename Tp>
-void test167()
+// Test data for k=0.70000000000000018, nu=0.70000000000000007.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.2316852368580916e-16
+// mean(f - f_Boost): 7.7715611723760953e-17
+// variance(f - f_Boost): 7.4564398834547797e-34
+// stddev(f - f_Boost): 2.7306482533374340e-17
+const testcase_ellint_3<double>
+data168[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data167)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data167[i].k), Tp(data167[i].nu),
-                   Tp(data167[i].phi));
-      const Tp f0 = data167[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.69999999999999996.
-testcase_ellint_3<double> data168[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17374434963995028, 0.69999999999999996, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34315091562900674, 0.69999999999999996, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.50554262375653358, 0.69999999999999996, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.66050025406305812, 0.69999999999999996, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.80938620118847404, 0.69999999999999996, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.95443223855852144, 0.69999999999999996, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.0978573207128302, 0.69999999999999996, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.2411754575007123, 0.69999999999999996, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.3848459188329196, 0.69999999999999996, 0.69999999999999996,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.70000000000000018, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17622185963747933, 0.70000000000000018, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36292539360435261, 0.70000000000000018, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.57240892970150015, 0.70000000000000018, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.82093084713182629, 0.70000000000000018, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.1312609022179871, 0.70000000000000018, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.5345768067715795, 0.70000000000000018, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 2.0668847445934424, 0.70000000000000018, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.7483444537551245, 0.70000000000000018, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.5408408771788569, 0.70000000000000018, 0.70000000000000007, 
+	  1.5707963267948966 },
 };
+const double toler168 = 2.5000000000000020e-13;
 
-// Test function for k=0.69999999999999996, nu=0.69999999999999996.
-template <typename Tp>
-void test168()
+// Test data for k=0.70000000000000018, nu=0.80000000000000004.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.1198716111867353e-16
+// mean(f - f_Boost): 2.2482016248659419e-16
+// variance(f - f_Boost): 5.4326441655972001e-32
+// stddev(f - f_Boost): 2.3308033305273100e-16
+const testcase_ellint_3<double>
+data169[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data168)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data168[i].k), Tp(data168[i].nu),
-                   Tp(data168[i].phi));
-      const Tp f0 = data168[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.80000000000000004.
-testcase_ellint_3<double> data169[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17357211837335737, 0.69999999999999996, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34187941416012108, 0.69999999999999996, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.50173239465478270, 0.69999999999999996, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.65266550725988315, 0.69999999999999996, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.79624879865249298, 0.69999999999999996, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.93497577043296920, 0.69999999999999996, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.0713041566930748, 0.69999999999999996, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.2069772023255652, 0.69999999999999996, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.3427110650397533, 0.69999999999999996, 0.80000000000000004,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.70000000000000018, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17640372461994805, 0.70000000000000018, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36449916621651091, 0.70000000000000018, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.57848021800372584, 0.70000000000000018, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.83837480968392586, 0.70000000000000018, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.1751669030061143, 0.70000000000000018, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.6381851899173603, 0.70000000000000018, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.3002065924302197, 0.70000000000000018, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 3.2337600665337871, 0.70000000000000018, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 4.4042405729076970, 0.70000000000000018, 0.80000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler169 = 2.5000000000000020e-13;
 
-// Test function for k=0.69999999999999996, nu=0.80000000000000004.
-template <typename Tp>
-void test169()
+// Test data for k=0.70000000000000018, nu=0.90000000000000002.
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 8.5869439826269878e-16
+// mean(f - f_Boost): 7.4384942649885490e-16
+// variance(f - f_Boost): 9.7403930714297352e-31
+// stddev(f - f_Boost): 9.8693429727767263e-16
+const testcase_ellint_3<double>
+data170[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data169)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data169[i].k), Tp(data169[i].nu),
-                   Tp(data169[i].phi));
-      const Tp f0 = data169[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.69999999999999996, nu=0.90000000000000002.
-testcase_ellint_3<double> data170[] = {
-  { -0.0000000000000000, 0.69999999999999996, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17340049697003634, 0.69999999999999996, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.34062438249741556, 0.69999999999999996, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.49801946510076878, 0.69999999999999996, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.64513432604750487, 0.69999999999999996, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.78378145487573758, 0.69999999999999996, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.91671799500854634, 0.69999999999999996, 0.90000000000000002,
-          1.0471975511965976 },
-  { 1.0466193579463123, 0.69999999999999996, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.1754218079199146, 0.69999999999999996, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.3040500499695911, 0.69999999999999996, 0.90000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.70000000000000018, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17658626600478800, 0.70000000000000018, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36609762156017206, 0.70000000000000018, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.58478615187842409, 0.70000000000000018, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.85718862878291846, 0.70000000000000018, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.2255385617397643, 0.70000000000000018, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.7696521899992941, 0.70000000000000018, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.6476314987883507, 0.70000000000000018, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 4.1373434902898083, 0.70000000000000018, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 6.3796094177887763, 0.70000000000000018, 0.90000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler170 = 2.5000000000000020e-13;
 
-// Test function for k=0.69999999999999996, nu=0.90000000000000002.
-template <typename Tp>
-void test170()
+// Test data for k=0.80000000000000004, nu=0.0000000000000000.
+// max(|f - f_Boost|): 1.5543122344752192e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.7898565163847540e-16
+// mean(f - f_Boost): 2.3869795029440865e-16
+// variance(f - f_Boost): 2.1368406725192426e-31
+// stddev(f - f_Boost): 4.6225974002926564e-16
+const testcase_ellint_3<double>
+data171[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data170)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data170[i].k), Tp(data170[i].nu),
-                   Tp(data170[i].phi));
-      const Tp f0 = data170[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.80000000000000004, nu=0.0000000000000000.
-testcase_ellint_3<double> data171[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17510154241338902, 0.80000000000000004, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35365068839779390, 0.80000000000000004, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.53926804409084561, 0.80000000000000004, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.73587926028070383, 0.80000000000000004, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.94770942970071170, 0.80000000000000004, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.1789022995388239, 0.80000000000000004, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.4323027881876009, 0.80000000000000004, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.7069629739121674, 0.80000000000000004, 0.0000000000000000,
-          1.3962634015954636 },
-  { 1.9953027776647296, 0.80000000000000004, 0.0000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.80000000000000004, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17510154241338899, 0.80000000000000004, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35365068839779396, 0.80000000000000004, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.53926804409084550, 0.80000000000000004, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.73587926028070372, 0.80000000000000004, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.94770942970071170, 0.80000000000000004, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.1789022995388236, 0.80000000000000004, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.4323027881876012, 0.80000000000000004, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.7069629739121677, 0.80000000000000004, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 1.9953027776647294, 0.80000000000000004, 0.0000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler171 = 2.5000000000000020e-13;
 
-// Test function for k=0.80000000000000004, nu=0.0000000000000000.
-template <typename Tp>
-void test171()
+// Test data for k=0.80000000000000004, nu=0.10000000000000001.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3898786942190374e-16
+// mean(f - f_Boost): 2.3869795029440865e-16
+// variance(f - f_Boost): 2.9190059990693968e-31
+// stddev(f - f_Boost): 5.4027826155319237e-16
+const testcase_ellint_3<double>
+data172[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data171)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data171[i].k), Tp(data171[i].nu),
-                   Tp(data171[i].phi));
-      const Tp f0 = data171[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.80000000000000004, nu=0.10000000000000001.
-testcase_ellint_3<double> data172[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17492468824017166, 0.80000000000000004, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.35224443521476911, 0.80000000000000004, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.53456851853226961, 0.80000000000000004, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.72488875602364944, 0.80000000000000004, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.92661354274638952, 0.80000000000000004, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.1432651144499077, 0.80000000000000004, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.3774479927211429, 0.80000000000000004, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.6287092337196041, 0.80000000000000004, 0.10000000000000001,
-          1.3962634015954636 },
-  { 1.8910755418379521, 0.80000000000000004, 0.10000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.80000000000000004, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17527903952342144, 0.80000000000000004, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35507705313548549, 0.80000000000000004, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.54411455987643553, 0.80000000000000004, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.74745625666804383, 0.80000000000000004, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.97046953684238557, 0.80000000000000004, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.2183080025184605, 0.80000000000000004, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.4943711151994405, 0.80000000000000004, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.7972401309544201, 0.80000000000000004, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 2.1172616484005085, 0.80000000000000004, 0.10000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler172 = 2.5000000000000020e-13;
 
-// Test function for k=0.80000000000000004, nu=0.10000000000000001.
-template <typename Tp>
-void test172()
+// Test data for k=0.80000000000000004, nu=0.20000000000000001.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.8513740186068518e-16
+// mean(f - f_Boost): 2.8310687127941490e-16
+// variance(f - f_Boost): 2.7528339102381189e-31
+// stddev(f - f_Boost): 5.2467455724840699e-16
+const testcase_ellint_3<double>
+data173[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data172)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data172[i].k), Tp(data172[i].nu),
-                   Tp(data172[i].phi));
-      const Tp f0 = data172[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.80000000000000004, nu=0.20000000000000001.
-testcase_ellint_3<double> data173[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17474847286224943, 0.80000000000000004, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.35085779529084682, 0.80000000000000004, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.53000829263059157, 0.80000000000000004, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.71443466027453406, 0.80000000000000004, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.90698196872715420, 0.80000000000000004, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.1108198200558581, 0.80000000000000004, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.3284988909963957, 0.80000000000000004, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.5600369318140328, 0.80000000000000004, 0.20000000000000001,
-          1.3962634015954636 },
-  { 1.8007226661734588, 0.80000000000000004, 0.20000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.80000000000000004, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17545718375086419, 0.80000000000000004, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35652404627248163, 0.80000000000000004, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.54911638512920913, 0.80000000000000004, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.75967684282131176, 0.80000000000000004, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 0.99513526893543769, 0.80000000000000004, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.2622192109995993, 0.80000000000000004, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.5654106676347741, 0.80000000000000004, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 1.9029531718534984, 0.80000000000000004, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 2.2624789434186798, 0.80000000000000004, 0.20000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler173 = 2.5000000000000020e-13;
 
-// Test function for k=0.80000000000000004, nu=0.20000000000000001.
-template <typename Tp>
-void test173()
+// Test data for k=0.80000000000000004, nu=0.30000000000000004.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.2825261583337354e-16
+// mean(f - f_Boost): 2.6367796834847468e-16
+// variance(f - f_Boost): 2.8249350208968825e-31
+// stddev(f - f_Boost): 5.3150117788175054e-16
+const testcase_ellint_3<double>
+data174[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data173)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data173[i].k), Tp(data173[i].nu),
-                   Tp(data173[i].phi));
-      const Tp f0 = data173[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.80000000000000004, nu=0.29999999999999999.
-testcase_ellint_3<double> data174[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17457289217669891, 0.80000000000000004, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.34949028801501258, 0.80000000000000004, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.52558024362769318, 0.80000000000000004, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.70447281740094914, 0.80000000000000004, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.88864745641528986, 0.80000000000000004, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.0811075819341465, 0.80000000000000004, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.2844589654082377, 0.80000000000000004, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.4991461361277849, 0.80000000000000004, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.7214611048717301, 0.80000000000000004, 0.29999999999999999,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.80000000000000004, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17563597931587369, 0.80000000000000004, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35799220412005128, 0.80000000000000004, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.55428253691111318, 0.80000000000000004, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.77260647376977365, 0.80000000000000004, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 1.0220015271210958, 0.80000000000000004, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.3115965312302671, 0.80000000000000004, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.6478518468813512, 0.80000000000000004, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 2.0290458414203481, 0.80000000000000004, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.4392042002725693, 0.80000000000000004, 0.30000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler174 = 2.5000000000000020e-13;
 
-// Test function for k=0.80000000000000004, nu=0.29999999999999999.
-template <typename Tp>
-void test174()
+// Test data for k=0.80000000000000004, nu=0.40000000000000002.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3462748389836647e-16
+// mean(f - f_Boost): 3.3861802251067273e-16
+// variance(f - f_Boost): 4.3719465706454422e-31
+// stddev(f - f_Boost): 6.6120696991527871e-16
+const testcase_ellint_3<double>
+data175[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data174)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data174[i].k), Tp(data174[i].nu),
-                   Tp(data174[i].phi));
-      const Tp f0 = data174[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.80000000000000004, nu=0.40000000000000002.
-testcase_ellint_3<double> data175[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17439794211872178, 0.80000000000000004, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34814144964568972, 0.80000000000000004, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.52127776285273075, 0.80000000000000004, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.69496411438966599, 0.80000000000000004, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.87146878427509589, 0.80000000000000004, 0.40000000000000002,
-          0.87266462599716477 },
-  { 1.0537579024937762, 0.80000000000000004, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.2445534387922637, 0.80000000000000004, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.4446769766361993, 0.80000000000000004, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.6512267838651289, 0.80000000000000004, 0.40000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.80000000000000004, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17581543047866136, 0.80000000000000004, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.35948208343061633, 0.80000000000000004, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.55962280893702021, 0.80000000000000004, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.78632063889234116, 0.80000000000000004, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 1.0514333069550323, 0.80000000000000004, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.3677213138838757, 0.80000000000000004, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.7451736773665165, 0.80000000000000004, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 2.1830100424586831, 0.80000000000000004, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 2.6604037035529724, 0.80000000000000004, 0.40000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler175 = 2.5000000000000020e-13;
 
-// Test function for k=0.80000000000000004, nu=0.40000000000000002.
-template <typename Tp>
-void test175()
+// Test data for k=0.80000000000000004, nu=0.50000000000000000.
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0388243828581744e-16
+// mean(f - f_Boost): 3.8580250105724191e-16
+// variance(f - f_Boost): 6.4106456575047741e-31
+// stddev(f - f_Boost): 8.0066507713929764e-16
+const testcase_ellint_3<double>
+data176[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data175)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data175[i].k), Tp(data175[i].nu),
-                   Tp(data175[i].phi));
-      const Tp f0 = data175[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.80000000000000004, nu=0.50000000000000000.
-testcase_ellint_3<double> data176[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17422361866118047, 0.80000000000000004, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34681083254170475, 0.80000000000000004, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.51709470815494440, 0.80000000000000004, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.68587375344080259, 0.80000000000000004, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.85532571852810624, 0.80000000000000004, 0.50000000000000000,
-          0.87266462599716477 },
-  { 1.0284677391874906, 0.80000000000000004, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.2081693942686225, 0.80000000000000004, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.3955803006426311, 0.80000000000000004, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.5884528947755532, 0.80000000000000004, 0.50000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.80000000000000004, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17599554153999472, 0.80000000000000004, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.36099426243351540, 0.80000000000000004, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.56514786174780673, 0.80000000000000004, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.80090697622371010, 0.80000000000000004, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.0838891627679339, 0.80000000000000004, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.4323506654466280, 0.80000000000000004, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 1.8625761085390575, 0.80000000000000004, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.3768757305654766, 0.80000000000000004, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 2.9478781158239746, 0.80000000000000004, 0.50000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler176 = 2.5000000000000020e-13;
 
-// Test function for k=0.80000000000000004, nu=0.50000000000000000.
-template <typename Tp>
-void test176()
+// Test data for k=0.80000000000000004, nu=0.60000000000000009.
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.0631099169042069e-15
+// mean(f - f_Boost): 4.8294701571194306e-16
+// variance(f - f_Boost): 1.1633910328160319e-30
+// stddev(f - f_Boost): 1.0786060600682865e-15
+const testcase_ellint_3<double>
+data177[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data176)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data176[i].k), Tp(data176[i].nu),
-                   Tp(data176[i].phi));
-      const Tp f0 = data176[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.80000000000000004, nu=0.59999999999999998.
-testcase_ellint_3<double> data177[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17404991781414092, 0.80000000000000004, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34549800443625167, 0.80000000000000004, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.51302536167001556, 0.80000000000000004, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.67717065003912258, 0.80000000000000004, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.84011512421134416, 0.80000000000000004, 0.59999999999999998,
-          0.87266462599716477 },
-  { 1.0049863847088742, 0.80000000000000004, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.1748145941898918, 0.80000000000000004, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.3510319699755071, 0.80000000000000004, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.5319262547427865, 0.80000000000000004, 0.59999999999999998,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.80000000000000004, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17617631684170665, 0.80000000000000004, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.36252934193666231, 0.80000000000000004, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.57086932622945163, 0.80000000000000004, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.81646796740150973, 0.80000000000000004, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.1199552158519064, 0.80000000000000004, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.5079766673336394, 0.80000000000000004, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 2.0082747447038165, 0.80000000000000004, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.6315146066775523, 0.80000000000000004, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 3.3418121892288051, 0.80000000000000004, 0.60000000000000009, 
+	  1.5707963267948966 },
 };
+const double toler177 = 2.5000000000000020e-13;
 
-// Test function for k=0.80000000000000004, nu=0.59999999999999998.
-template <typename Tp>
-void test177()
+// Test data for k=0.80000000000000004, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.6544679145741375e-16
+// mean(f - f_Boost): 3.2751579226442120e-16
+// variance(f - f_Boost): 4.4236851331020672e-31
+// stddev(f - f_Boost): 6.6510789599147505e-16
+const testcase_ellint_3<double>
+data178[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data177)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data177[i].k), Tp(data177[i].nu),
-                   Tp(data177[i].phi));
-      const Tp f0 = data177[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.80000000000000004, nu=0.69999999999999996.
-testcase_ellint_3<double> data178[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17387683562442202, 0.80000000000000004, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34420254775101611, 0.80000000000000004, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.50906439222143685, 0.80000000000000004, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.66882693152688433, 0.80000000000000004, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.82574792844091316, 0.80000000000000004, 0.69999999999999996,
-          0.87266462599716477 },
-  { 0.98310431309490953, 0.80000000000000004, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.1440884535113258, 0.80000000000000004, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.3103743938952537, 0.80000000000000004, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.4806912324625332, 0.80000000000000004, 0.69999999999999996,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.80000000000000004, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17635776076721221, 0.80000000000000004, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36408794649916976, 0.80000000000000004, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.57679992290624138, 0.80000000000000004, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.83312441418142813, 0.80000000000000004, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.1603958891464856, 0.80000000000000004, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.5982855143796213, 0.80000000000000004, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 2.1962484408371821, 0.80000000000000004, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 2.9873281786111869, 0.80000000000000004, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 3.9268876980046397, 0.80000000000000004, 0.70000000000000007, 
+	  1.5707963267948966 },
 };
+const double toler178 = 2.5000000000000020e-13;
 
-// Test function for k=0.80000000000000004, nu=0.69999999999999996.
-template <typename Tp>
-void test178()
+// Test data for k=0.80000000000000004, nu=0.80000000000000004.
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0176949165011079e-16
+// mean(f - f_Boost): 7.0499162063697436e-16
+// variance(f - f_Boost): 1.7230805408026989e-30
+// stddev(f - f_Boost): 1.3126616246400665e-15
+const testcase_ellint_3<double>
+data179[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data178)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data178[i].k), Tp(data178[i].nu),
-                   Tp(data178[i].phi));
-      const Tp f0 = data178[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.80000000000000004, nu=0.80000000000000004.
-testcase_ellint_3<double> data179[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17370436817515206, 0.80000000000000004, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34292405894783395, 0.80000000000000004, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.50520682176250087, 0.80000000000000004, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.66081751679736189, 0.80000000000000004, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.81214672249355102, 0.80000000000000004, 0.80000000000000004,
-          0.87266462599716477 },
-  { 0.96264481387685574, 0.80000000000000004, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.1156611352656258, 0.80000000000000004, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.2730756225143889, 0.80000000000000004, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.4339837018309474, 0.80000000000000004, 0.80000000000000004,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.80000000000000004, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17653987774203392, 0.80000000000000004, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36567072568046877, 0.80000000000000004, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.58295359996558616, 0.80000000000000004, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.85101998309176108, 0.80000000000000004, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.2062322059736537, 0.80000000000000004, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.7090321420917429, 0.80000000000000004, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.4529058049405066, 0.80000000000000004, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 3.5368893360106948, 0.80000000000000004, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 4.9246422058196062, 0.80000000000000004, 0.80000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler179 = 2.5000000000000020e-13;
 
-// Test function for k=0.80000000000000004, nu=0.80000000000000004.
-template <typename Tp>
-void test179()
+// Test data for k=0.80000000000000004, nu=0.90000000000000002.
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.7782721357365268e-16
+// mean(f - f_Boost): 8.9928064994637676e-16
+// variance(f - f_Boost): 1.5485199571025344e-30
+// stddev(f - f_Boost): 1.2443954183066307e-15
+const testcase_ellint_3<double>
+data180[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data179)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data179[i].k), Tp(data179[i].nu),
-                   Tp(data179[i].phi));
-      const Tp f0 = data179[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.80000000000000004, nu=0.90000000000000002.
-testcase_ellint_3<double> data180[] = {
-  { -0.0000000000000000, 0.80000000000000004, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17353251158533153, 0.80000000000000004, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.34166214791545768, 0.80000000000000004, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.50144799535130580, 0.80000000000000004, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.65311976193814447, 0.80000000000000004, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.79924384892320866, 0.80000000000000004, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.94345762353365625, 0.80000000000000004, 0.90000000000000002,
-          1.0471975511965976 },
-  { 1.0892582069219159, 0.80000000000000004, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.2387000876610268, 0.80000000000000004, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.3911845406776222, 0.80000000000000004, 0.90000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.80000000000000004, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17672267223433513, 0.80000000000000004, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36727835537196063, 0.80000000000000004, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.58934569363716649, 0.80000000000000004, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.87032723471138851, 0.80000000000000004, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.2588676111323349, 0.80000000000000004, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.8498731900660019, 0.80000000000000004, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 2.8368381299300420, 0.80000000000000004, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 4.5674844191654058, 0.80000000000000004, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 7.2263259298637115, 0.80000000000000004, 0.90000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler180 = 2.5000000000000020e-13;
 
-// Test function for k=0.80000000000000004, nu=0.90000000000000002.
-template <typename Tp>
-void test180()
+// Test data for k=0.90000000000000013, nu=0.0000000000000000.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.3381508715713360e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 4.1942474344433133e-34
+// stddev(f - f_Boost): 2.0479861900030756e-17
+const testcase_ellint_3<double>
+data181[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data180)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data180[i].k), Tp(data180[i].nu),
-                   Tp(data180[i].phi));
-      const Tp f0 = data180[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.0000000000000000.
-testcase_ellint_3<double> data181[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.0000000000000000,
-          0.0000000000000000 },
-  { 0.17525427376115027, 0.89999999999999991, 0.0000000000000000,
-          0.17453292519943295 },
-  { 0.35492464591297446, 0.89999999999999991, 0.0000000000000000,
-          0.34906585039886590 },
-  { 0.54388221416157123, 0.89999999999999991, 0.0000000000000000,
-          0.52359877559829882 },
-  { 0.74797400423532501, 0.89999999999999991, 0.0000000000000000,
-          0.69813170079773179 },
-  { 0.97463898451966458, 0.89999999999999991, 0.0000000000000000,
-          0.87266462599716477 },
-  { 1.2334463254523438, 0.89999999999999991, 0.0000000000000000,
-          1.0471975511965976 },
-  { 1.5355247765594910, 0.89999999999999991, 0.0000000000000000,
-          1.2217304763960306 },
-  { 1.8882928567775117, 0.89999999999999991, 0.0000000000000000,
-          1.3962634015954636 },
-  { 2.2805491384227699, 0.89999999999999991, 0.0000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.90000000000000013, 0.0000000000000000, 
+	  0.0000000000000000 },
+  { 0.17525427376115027, 0.90000000000000013, 0.0000000000000000, 
+	  0.17453292519943295 },
+  { 0.35492464591297446, 0.90000000000000013, 0.0000000000000000, 
+	  0.34906585039886590 },
+  { 0.54388221416157123, 0.90000000000000013, 0.0000000000000000, 
+	  0.52359877559829882 },
+  { 0.74797400423532512, 0.90000000000000013, 0.0000000000000000, 
+	  0.69813170079773179 },
+  { 0.97463898451966446, 0.90000000000000013, 0.0000000000000000, 
+	  0.87266462599716477 },
+  { 1.2334463254523440, 0.90000000000000013, 0.0000000000000000, 
+	  1.0471975511965976 },
+  { 1.5355247765594915, 0.90000000000000013, 0.0000000000000000, 
+	  1.2217304763960306 },
+  { 1.8882928567775128, 0.90000000000000013, 0.0000000000000000, 
+	  1.3962634015954636 },
+  { 2.2805491384227707, 0.90000000000000013, 0.0000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler181 = 2.5000000000000020e-13;
 
-// Test function for k=0.89999999999999991, nu=0.0000000000000000.
-template <typename Tp>
-void test181()
+// Test data for k=0.90000000000000013, nu=0.10000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.1500594295134815e-16
+// mean(f - f_Boost): 9.1593399531575410e-17
+// variance(f - f_Boost): 1.0357223256482469e-33
+// stddev(f - f_Boost): 3.2182640128619758e-17
+const testcase_ellint_3<double>
+data182[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data181)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data181[i].k), Tp(data181[i].nu),
-                   Tp(data181[i].phi));
-      const Tp f0 = data181[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.10000000000000001.
-testcase_ellint_3<double> data182[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.10000000000000001,
-          0.0000000000000000 },
-  { 0.17507714233254659, 0.89999999999999991, 0.10000000000000001,
-          0.17453292519943295 },
-  { 0.35350932904326521, 0.89999999999999991, 0.10000000000000001,
-          0.34906585039886590 },
-  { 0.53911129989870987, 0.89999999999999991, 0.10000000000000001,
-          0.52359877559829882 },
-  { 0.73666644254508407, 0.89999999999999991, 0.10000000000000001,
-          0.69813170079773179 },
-  { 0.95250736612100184, 0.89999999999999991, 0.10000000000000001,
-          0.87266462599716477 },
-  { 1.1950199550905591, 0.89999999999999991, 0.10000000000000001,
-          1.0471975511965976 },
-  { 1.4741687286340848, 0.89999999999999991, 0.10000000000000001,
-          1.2217304763960306 },
-  { 1.7968678183506053, 0.89999999999999991, 0.10000000000000001,
-          1.3962634015954636 },
-  { 2.1537868513875282, 0.89999999999999991, 0.10000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.90000000000000013, 0.10000000000000001, 
+	  0.0000000000000000 },
+  { 0.17543204932716244, 0.90000000000000013, 0.10000000000000001, 
+	  0.17453292519943295 },
+  { 0.35636022898551184, 0.90000000000000013, 0.10000000000000001, 
+	  0.34906585039886590 },
+  { 0.54880278898382595, 0.90000000000000013, 0.10000000000000001, 
+	  0.52359877559829882 },
+  { 0.75988834774529268, 0.90000000000000013, 0.10000000000000001, 
+	  0.69813170079773179 },
+  { 0.99853303003568117, 0.90000000000000013, 0.10000000000000001, 
+	  0.87266462599716477 },
+  { 1.2759958823999022, 0.90000000000000013, 0.10000000000000001, 
+	  1.0471975511965976 },
+  { 1.6051187364639401, 0.90000000000000013, 0.10000000000000001, 
+	  1.2217304763960306 },
+  { 1.9941406879519474, 0.90000000000000013, 0.10000000000000001, 
+	  1.3962634015954636 },
+  { 2.4295011187834890, 0.90000000000000013, 0.10000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler182 = 2.5000000000000020e-13;
 
-// Test function for k=0.89999999999999991, nu=0.10000000000000001.
-template <typename Tp>
-void test182()
+// Test data for k=0.90000000000000013, nu=0.20000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.9533518431433547e-16
+// mean(f - f_Boost): 1.0269562977782698e-16
+// variance(f - f_Boost): 1.4388836606733082e-32
+// stddev(f - f_Boost): 1.1995347684303728e-16
+const testcase_ellint_3<double>
+data183[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data182)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data182[i].k), Tp(data182[i].nu),
-                   Tp(data182[i].phi));
-      const Tp f0 = data182[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.20000000000000001.
-testcase_ellint_3<double> data183[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.20000000000000001,
-          0.0000000000000000 },
-  { 0.17490065089140930, 0.89999999999999991, 0.20000000000000001,
-          0.17453292519943295 },
-  { 0.35211377590661436, 0.89999999999999991, 0.20000000000000001,
-          0.34906585039886590 },
-  { 0.53448220334204111, 0.89999999999999991, 0.20000000000000001,
-          0.52359877559829882 },
-  { 0.72591368943179591, 0.89999999999999991, 0.20000000000000001,
-          0.69813170079773179 },
-  { 0.93192539780038763, 0.89999999999999991, 0.20000000000000001,
-          0.87266462599716477 },
-  { 1.1600809679692681, 0.89999999999999991, 0.20000000000000001,
-          1.0471975511965976 },
-  { 1.4195407225882508, 0.89999999999999991, 0.20000000000000001,
-          1.2217304763960306 },
-  { 1.7168966476424521, 0.89999999999999991, 0.20000000000000001,
-          1.3962634015954636 },
-  { 2.0443194576468890, 0.89999999999999991, 0.20000000000000001,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.90000000000000013, 0.20000000000000001, 
+	  0.0000000000000000 },
+  { 0.17561047321968409, 0.90000000000000013, 0.20000000000000001, 
+	  0.17453292519943295 },
+  { 0.35781659944356109, 0.90000000000000013, 0.20000000000000001, 
+	  0.34906585039886590 },
+  { 0.55388150905215283, 0.90000000000000013, 0.20000000000000001, 
+	  0.52359877559829882 },
+  { 0.77246874123251441, 0.90000000000000013, 0.20000000000000001, 
+	  0.69813170079773179 },
+  { 1.0244466254771925, 0.90000000000000013, 0.20000000000000001, 
+	  0.87266462599716477 },
+  { 1.3234824077640801, 0.90000000000000013, 0.20000000000000001, 
+	  1.0471975511965976 },
+  { 1.6849848968804240, 0.90000000000000013, 0.20000000000000001, 
+	  1.2217304763960306 },
+  { 2.1185749045502278, 0.90000000000000013, 0.20000000000000001, 
+	  1.3962634015954636 },
+  { 2.6076835743348417, 0.90000000000000013, 0.20000000000000001, 
+	  1.5707963267948966 },
 };
+const double toler183 = 2.5000000000000020e-13;
 
-// Test function for k=0.89999999999999991, nu=0.20000000000000001.
-template <typename Tp>
-void test183()
+// Test data for k=0.90000000000000013, nu=0.30000000000000004.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.9712691025502371e-16
+// mean(f - f_Boost): 6.9388939039072284e-17
+// variance(f - f_Boost): 5.9442282234173945e-34
+// stddev(f - f_Boost): 2.4380787976227090e-17
+const testcase_ellint_3<double>
+data184[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data183)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data183[i].k), Tp(data183[i].nu),
-                   Tp(data183[i].phi));
-      const Tp f0 = data183[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.29999999999999999.
-testcase_ellint_3<double> data184[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.29999999999999999,
-          0.0000000000000000 },
-  { 0.17472479532647534, 0.89999999999999991, 0.29999999999999999,
-          0.17453292519943295 },
-  { 0.35073750187374114, 0.89999999999999991, 0.29999999999999999,
-          0.34906585039886590 },
-  { 0.52998766129466968, 0.89999999999999991, 0.29999999999999999,
-          0.52359877559829882 },
-  { 0.71566993548699565, 0.89999999999999991, 0.29999999999999999,
-          0.69813170079773179 },
-  { 0.91271517762560195, 0.89999999999999991, 0.29999999999999999,
-          0.87266462599716477 },
-  { 1.1281241199843368, 0.89999999999999991, 0.29999999999999999,
-          1.0471975511965976 },
-  { 1.3704929576917448, 0.89999999999999991, 0.29999999999999999,
-          1.2217304763960306 },
-  { 1.6461981511487711, 0.89999999999999991, 0.29999999999999999,
-          1.3962634015954636 },
-  { 1.9486280260314424, 0.89999999999999991, 0.29999999999999999,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.90000000000000013, 0.30000000000000004, 
+	  0.0000000000000000 },
+  { 0.17578954966746221, 0.90000000000000013, 0.30000000000000004, 
+	  0.17453292519943295 },
+  { 0.35929429810867447, 0.90000000000000013, 0.30000000000000004, 
+	  0.34906585039886590 },
+  { 0.55912757154240822, 0.90000000000000013, 0.30000000000000004, 
+	  0.52359877559829882 },
+  { 0.78578314722025389, 0.90000000000000013, 0.30000000000000004, 
+	  0.69813170079773179 },
+  { 1.0526941001131365, 0.90000000000000013, 0.30000000000000004, 
+	  0.87266462599716477 },
+  { 1.3769682234538601, 0.90000000000000013, 0.30000000000000004, 
+	  1.0471975511965976 },
+  { 1.7779437432911240, 0.90000000000000013, 0.30000000000000004, 
+	  1.2217304763960306 },
+  { 2.2676509341813635, 0.90000000000000013, 0.30000000000000004, 
+	  1.3962634015954636 },
+  { 2.8256506968858517, 0.90000000000000013, 0.30000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler184 = 2.5000000000000020e-13;
 
-// Test function for k=0.89999999999999991, nu=0.29999999999999999.
-template <typename Tp>
-void test184()
+// Test data for k=0.90000000000000013, nu=0.40000000000000002.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.7042235432234642e-16
+// mean(f - f_Boost): 1.8041124150158794e-16
+// variance(f - f_Boost): 8.5834655546147173e-33
+// stddev(f - f_Boost): 9.2646994309662939e-17
+const testcase_ellint_3<double>
+data185[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data184)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data184[i].k), Tp(data184[i].nu),
-                   Tp(data184[i].phi));
-      const Tp f0 = data184[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.40000000000000002.
-testcase_ellint_3<double> data185[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.40000000000000002,
-          0.0000000000000000 },
-  { 0.17454957156468839, 0.89999999999999991, 0.40000000000000002,
-          0.17453292519943295 },
-  { 0.34938003933330430, 0.89999999999999991, 0.40000000000000002,
-          0.34906585039886590 },
-  { 0.52562093533067444, 0.89999999999999991, 0.40000000000000002,
-          0.52359877559829882 },
-  { 0.70589461324915681, 0.89999999999999991, 0.40000000000000002,
-          0.69813170079773179 },
-  { 0.89472658511942849, 0.89999999999999991, 0.40000000000000002,
-          0.87266462599716477 },
-  { 1.0987419542323438, 0.89999999999999991, 0.40000000000000002,
-          1.0471975511965976 },
-  { 1.3261349565496301, 0.89999999999999991, 0.40000000000000002,
-          1.2217304763960306 },
-  { 1.5831293909853761, 0.89999999999999991, 0.40000000000000002,
-          1.3962634015954636 },
-  { 1.8641114227238347, 0.89999999999999991, 0.40000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.90000000000000013, 0.40000000000000002, 
+	  0.0000000000000000 },
+  { 0.17596928293938452, 0.90000000000000013, 0.40000000000000002, 
+	  0.17453292519943295 },
+  { 0.36079388642472821, 0.90000000000000013, 0.40000000000000002, 
+	  0.34906585039886590 },
+  { 0.56455096667115612, 0.90000000000000013, 0.40000000000000002, 
+	  0.52359877559829882 },
+  { 0.79990996997869435, 0.90000000000000013, 0.40000000000000002, 
+	  0.69813170079773179 },
+  { 1.0836647913872215, 0.90000000000000013, 0.40000000000000002, 
+	  0.87266462599716477 },
+  { 1.4378726836091849, 0.90000000000000013, 0.40000000000000002, 
+	  1.0471975511965976 },
+  { 1.8880446720682853, 0.90000000000000013, 0.40000000000000002, 
+	  1.2217304763960306 },
+  { 2.4505848932025232, 0.90000000000000013, 0.40000000000000002, 
+	  1.3962634015954636 },
+  { 3.1000689868578624, 0.90000000000000013, 0.40000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler185 = 2.5000000000000020e-13;
 
-// Test function for k=0.89999999999999991, nu=0.40000000000000002.
-template <typename Tp>
-void test185()
+// Test data for k=0.90000000000000013, nu=0.50000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.3939646155354115e-16
+// mean(f - f_Boost): 1.5820678100908481e-16
+// variance(f - f_Boost): 1.0089970755557622e-32
+// stddev(f - f_Boost): 1.0044884646205561e-16
+const testcase_ellint_3<double>
+data186[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data185)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data185[i].k), Tp(data185[i].nu),
-                   Tp(data185[i].phi));
-      const Tp f0 = data185[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.50000000000000000.
-testcase_ellint_3<double> data186[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.50000000000000000,
-          0.0000000000000000 },
-  { 0.17437497557073336, 0.89999999999999991, 0.50000000000000000,
-          0.17453292519943295 },
-  { 0.34804093691586013, 0.89999999999999991, 0.50000000000000000,
-          0.34906585039886590 },
-  { 0.52137576320372903, 0.89999999999999991, 0.50000000000000000,
-          0.52359877559829882 },
-  { 0.69655163996912262, 0.89999999999999991, 0.50000000000000000,
-          0.69813170079773179 },
-  { 0.87783188683054236, 0.89999999999999991, 0.50000000000000000,
-          0.87266462599716477 },
-  { 1.0716015959755183, 0.89999999999999991, 0.50000000000000000,
-          1.0471975511965976 },
-  { 1.2857636916026749, 0.89999999999999991, 0.50000000000000000,
-          1.2217304763960306 },
-  { 1.5264263913252358, 0.89999999999999991, 0.50000000000000000,
-          1.3962634015954636 },
-  { 1.7888013241937859, 0.89999999999999991, 0.50000000000000000,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.90000000000000013, 0.50000000000000000, 
+	  0.0000000000000000 },
+  { 0.17614967734498183, 0.90000000000000013, 0.50000000000000000, 
+	  0.17453292519943295 },
+  { 0.36231594750319435, 0.90000000000000013, 0.50000000000000000, 
+	  0.34906585039886590 },
+  { 0.57016256984349567, 0.90000000000000013, 0.50000000000000000, 
+	  0.52359877559829882 },
+  { 0.81494025918293422, 0.90000000000000013, 0.50000000000000000, 
+	  0.69813170079773179 },
+  { 1.1178482279283477, 0.90000000000000013, 0.50000000000000000, 
+	  0.87266462599716477 },
+  { 1.5081455873012106, 0.90000000000000013, 0.50000000000000000, 
+	  1.0471975511965976 },
+  { 2.0213599730863998, 0.90000000000000013, 0.50000000000000000, 
+	  1.2217304763960306 },
+  { 2.6822467012926832, 0.90000000000000013, 0.50000000000000000, 
+	  1.3962634015954636 },
+  { 3.4591069002104686, 0.90000000000000013, 0.50000000000000000, 
+	  1.5707963267948966 },
 };
+const double toler186 = 2.5000000000000020e-13;
 
-// Test function for k=0.89999999999999991, nu=0.50000000000000000.
-template <typename Tp>
-void test186()
+// Test data for k=0.90000000000000013, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.4914274070443813e-16
+// mean(f - f_Boost): 3.4694469519536142e-16
+// variance(f - f_Boost): 2.5224926888894056e-31
+// stddev(f - f_Boost): 5.0224423231027804e-16
+const testcase_ellint_3<double>
+data187[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data186)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data186[i].k), Tp(data186[i].nu),
-                   Tp(data186[i].phi));
-      const Tp f0 = data186[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.59999999999999998.
-testcase_ellint_3<double> data187[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.59999999999999998,
-          0.0000000000000000 },
-  { 0.17420100334657815, 0.89999999999999991, 0.59999999999999998,
-          0.17453292519943295 },
-  { 0.34671975876122157, 0.89999999999999991, 0.59999999999999998,
-          0.34906585039886590 },
-  { 0.51724631570707957, 0.89999999999999991, 0.59999999999999998,
-          0.52359877559829882 },
-  { 0.68760879113743034, 0.89999999999999991, 0.59999999999999998,
-          0.69813170079773179 },
-  { 0.86192157779698364, 0.89999999999999991, 0.59999999999999998,
-          0.87266462599716477 },
-  { 1.0464279696166352, 0.89999999999999991, 0.59999999999999998,
-          1.0471975511965976 },
-  { 1.2488156247094004, 0.89999999999999991, 0.59999999999999998,
-          1.2217304763960306 },
-  { 1.4750988777188470, 0.89999999999999991, 0.59999999999999998,
-          1.3962634015954636 },
-  { 1.7211781128919521, 0.89999999999999991, 0.59999999999999998,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.90000000000000013, 0.60000000000000009, 
+	  0.0000000000000000 },
+  { 0.17633073723493825, 0.90000000000000013, 0.60000000000000009, 
+	  0.17453292519943295 },
+  { 0.36386108723492810, 0.90000000000000013, 0.60000000000000009, 
+	  0.34906585039886590 },
+  { 0.57597424744716241, 0.90000000000000013, 0.60000000000000009, 
+	  0.52359877559829882 },
+  { 0.83098051948501150, 0.90000000000000013, 0.60000000000000009, 
+	  0.69813170079773179 },
+  { 1.1558706545698916, 0.90000000000000013, 0.60000000000000009, 
+	  0.87266462599716477 },
+  { 1.5905576379415669, 0.90000000000000013, 0.60000000000000009, 
+	  1.0471975511965976 },
+  { 2.1875186010215084, 0.90000000000000013, 0.60000000000000009, 
+	  1.2217304763960306 },
+  { 2.9885767771316853, 0.90000000000000013, 0.60000000000000009, 
+	  1.3962634015954636 },
+  { 3.9549939883570238, 0.90000000000000013, 0.60000000000000009, 
+	  1.5707963267948966 },
 };
+const double toler187 = 2.5000000000000020e-13;
 
-// Test function for k=0.89999999999999991, nu=0.59999999999999998.
-template <typename Tp>
-void test187()
+// Test data for k=0.90000000000000013, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.5442489886293633e-16
+// mean(f - f_Boost): 4.3576253716537392e-16
+// variance(f - f_Boost): 2.2187568928205130e-31
+// stddev(f - f_Boost): 4.7103682370070737e-16
+const testcase_ellint_3<double>
+data188[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data187)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data187[i].k), Tp(data187[i].nu),
-                   Tp(data187[i].phi));
-      const Tp f0 = data187[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.69999999999999996.
-testcase_ellint_3<double> data188[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.69999999999999996,
-          0.0000000000000000 },
-  { 0.17402765093102210, 0.89999999999999991, 0.69999999999999996,
-          0.17453292519943295 },
-  { 0.34541608382635131, 0.89999999999999991, 0.69999999999999996,
-          0.34906585039886590 },
-  { 0.51322715827061693, 0.89999999999999991, 0.69999999999999996,
-          0.52359877559829882 },
-  { 0.67903717872440283, 0.89999999999999991, 0.69999999999999996,
-          0.69813170079773179 },
-  { 0.84690113601682671, 0.89999999999999991, 0.69999999999999996,
-          0.87266462599716477 },
-  { 1.0229914311548416, 0.89999999999999991, 0.69999999999999996,
-          1.0471975511965976 },
-  { 1.2148329639709381, 0.89999999999999991, 0.69999999999999996,
-          1.2217304763960306 },
-  { 1.4283586501307799, 0.89999999999999991, 0.69999999999999996,
-          1.3962634015954636 },
-  { 1.6600480747670936, 0.89999999999999991, 0.69999999999999996,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.90000000000000013, 0.70000000000000007, 
+	  0.0000000000000000 },
+  { 0.17651246700160939, 0.90000000000000013, 0.70000000000000007, 
+	  0.17453292519943295 },
+  { 0.36542993547358982, 0.90000000000000013, 0.70000000000000007, 
+	  0.34906585039886590 },
+  { 0.58199897877674867, 0.90000000000000013, 0.70000000000000007, 
+	  0.52359877559829882 },
+  { 0.84815633587352857, 0.90000000000000013, 0.70000000000000007, 
+	  0.69813170079773179 },
+  { 1.1985495623872375, 0.90000000000000013, 0.70000000000000007, 
+	  0.87266462599716477 },
+  { 1.6892158134027691, 0.90000000000000013, 0.70000000000000007, 
+	  1.0471975511965976 },
+  { 2.4029722191094236, 0.90000000000000013, 0.70000000000000007, 
+	  1.2217304763960306 },
+  { 3.4201084941340061, 0.90000000000000013, 0.70000000000000007, 
+	  1.3962634015954636 },
+  { 4.6985482312992444, 0.90000000000000013, 0.70000000000000007, 
+	  1.5707963267948966 },
 };
+const double toler188 = 2.5000000000000020e-13;
 
-// Test function for k=0.89999999999999991, nu=0.69999999999999996.
-template <typename Tp>
-void test188()
+// Test data for k=0.90000000000000013, nu=0.80000000000000004.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.9362432595976420e-16
+// mean(f - f_Boost): 3.0531133177191805e-16
+// variance(f - f_Boost): 1.1508025840536076e-32
+// stddev(f - f_Boost): 1.0727546709539920e-16
+const testcase_ellint_3<double>
+data189[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data188)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data188[i].k), Tp(data188[i].nu),
-                   Tp(data188[i].phi));
-      const Tp f0 = data188[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.80000000000000004.
-testcase_ellint_3<double> data189[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.80000000000000004,
-          0.0000000000000000 },
-  { 0.17385491439925149, 0.89999999999999991, 0.80000000000000004,
-          0.17453292519943295 },
-  { 0.34412950523113928, 0.89999999999999991, 0.80000000000000004,
-          0.34906585039886590 },
-  { 0.50931321668729601, 0.89999999999999991, 0.80000000000000004,
-          0.52359877559829882 },
-  { 0.67081081392296327, 0.89999999999999991, 0.80000000000000004,
-          0.69813170079773179 },
-  { 0.83268846097293259, 0.89999999999999991, 0.80000000000000004,
-          0.87266462599716477 },
-  { 1.0010985015814025, 0.89999999999999991, 0.80000000000000004,
-          1.0471975511965976 },
-  { 1.1834394045489678, 0.89999999999999991, 0.80000000000000004,
-          1.2217304763960306 },
-  { 1.3855695891683182, 0.89999999999999991, 0.80000000000000004,
-          1.3962634015954636 },
-  { 1.6044591960982200, 0.89999999999999991, 0.80000000000000004,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.90000000000000013, 0.80000000000000004, 
+	  0.0000000000000000 },
+  { 0.17669487107954862, 0.90000000000000013, 0.80000000000000004, 
+	  0.17453292519943295 },
+  { 0.36702314729628421, 0.90000000000000013, 0.80000000000000004, 
+	  0.34906585039886590 },
+  { 0.58825099711365492, 0.90000000000000013, 0.80000000000000004, 
+	  0.52359877559829882 },
+  { 0.86661711422209031, 0.90000000000000013, 0.80000000000000004, 
+	  0.69813170079773179 },
+  { 1.2469779109884802, 0.90000000000000013, 0.80000000000000004, 
+	  0.87266462599716477 },
+  { 1.8105469760531578, 0.90000000000000013, 0.80000000000000004, 
+	  1.0471975511965976 },
+  { 2.6989505165893752, 0.90000000000000013, 0.80000000000000004, 
+	  1.2217304763960306 },
+  { 4.0935213267757433, 0.90000000000000013, 0.80000000000000004, 
+	  1.3962634015954636 },
+  { 5.9820740813645727, 0.90000000000000013, 0.80000000000000004, 
+	  1.5707963267948966 },
 };
+const double toler189 = 2.5000000000000020e-13;
 
-// Test function for k=0.89999999999999991, nu=0.80000000000000004.
-template <typename Tp>
-void test189()
+// Test data for k=0.90000000000000013, nu=0.90000000000000002.
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.9577148062669782e-16
+// mean(f - f_Boost): 5.9119376061289588e-16
+// variance(f - f_Boost): 1.7340883003959522e-31
+// stddev(f - f_Boost): 4.1642385863395872e-16
+const testcase_ellint_3<double>
+data190[10] =
 {
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data189)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data189[i].k), Tp(data189[i].nu),
-                   Tp(data189[i].phi));
-      const Tp f0 = data189[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
-
-// Test data for k=0.89999999999999991, nu=0.90000000000000002.
-testcase_ellint_3<double> data190[] = {
-  { -0.0000000000000000, 0.89999999999999991, 0.90000000000000002,
-          0.0000000000000000 },
-  { 0.17368278986240138, 0.89999999999999991, 0.90000000000000002,
-          0.17453292519943295 },
-  { 0.34285962963961397, 0.89999999999999991, 0.90000000000000002,
-          0.34906585039886590 },
-  { 0.50549974644993312, 0.89999999999999991, 0.90000000000000002,
-          0.52359877559829882 },
-  { 0.66290623857720876, 0.89999999999999991, 0.90000000000000002,
-          0.69813170079773179 },
-  { 0.81921183128847164, 0.89999999999999991, 0.90000000000000002,
-          0.87266462599716477 },
-  { 0.98058481956066368, 0.89999999999999991, 0.90000000000000002,
-          1.0471975511965976 },
-  { 1.1543223520473569, 0.89999999999999991, 0.90000000000000002,
-          1.2217304763960306 },
-  { 1.3462119782292934, 0.89999999999999991, 0.90000000000000002,
-          1.3962634015954636 },
-  { 1.5536420236310944, 0.89999999999999991, 0.90000000000000002,
-          1.5707963267948966 },
+  { 0.0000000000000000, 0.90000000000000013, 0.90000000000000002, 
+	  0.0000000000000000 },
+  { 0.17687795394604169, 0.90000000000000013, 0.90000000000000002, 
+	  0.17453292519943295 },
+  { 0.36864140434751286, 0.90000000000000013, 0.90000000000000002, 
+	  0.34906585039886590 },
+  { 0.59474595366817051, 0.90000000000000013, 0.90000000000000002, 
+	  0.52359877559829882 },
+  { 0.88654237226056665, 0.90000000000000013, 0.90000000000000002, 
+	  0.69813170079773179 },
+  { 1.3026595810616726, 0.90000000000000013, 0.90000000000000002, 
+	  0.87266462599716477 },
+  { 1.9653635459278080, 0.90000000000000013, 0.90000000000000002, 
+	  1.0471975511965976 },
+  { 3.1451407527189468, 0.90000000000000013, 0.90000000000000002, 
+	  1.2217304763960306 },
+  { 5.3745230680316132, 0.90000000000000013, 0.90000000000000002, 
+	  1.3962634015954636 },
+  { 8.9942562031858717, 0.90000000000000013, 0.90000000000000002, 
+	  1.5707963267948966 },
 };
+const double toler190 = 2.5000000000000020e-13;
 
-// Test function for k=0.89999999999999991, nu=0.90000000000000002.
-template <typename Tp>
-void test190()
-{
-  const Tp eps = std::numeric_limits<Tp>::epsilon();
-  Tp max_abs_diff = -Tp(1);
-  Tp max_abs_frac = -Tp(1);
-  unsigned int num_datum = sizeof(data190)
-                         / sizeof(testcase_ellint_3<double>);
-  for (unsigned int i = 0; i < num_datum; ++i)
-    {
-      const Tp f = std::tr1::ellint_3(Tp(data190[i].k), Tp(data190[i].nu),
-                   Tp(data190[i].phi));
-      const Tp f0 = data190[i].f0;
-      const Tp diff = f - f0;
-      if (std::abs(diff) > max_abs_diff)
-        max_abs_diff = std::abs(diff);
-      if (std::abs(f0) > Tp(10) * eps
-       && std::abs(f) > Tp(10) * eps)
-        {
-          const Tp frac = diff / f0;
-          if (std::abs(frac) > max_abs_frac)
-            max_abs_frac = std::abs(frac);
-        }
-    }
-  VERIFY(max_abs_frac < Tp(2.5000000000000020e-13));
-}
+template<typename Ret, unsigned int Num>
+  void
+  test(const testcase_ellint_3<Ret> (&data)[Num], Ret toler)
+  {
+    bool test __attribute__((unused)) = true;
+    const Ret eps = std::numeric_limits<Ret>::epsilon();
+    Ret max_abs_diff = -Ret(1);
+    Ret max_abs_frac = -Ret(1);
+    unsigned int num_datum = Num;
+    for (unsigned int i = 0; i < num_datum; ++i)
+  	 {
+	const Ret f = std::tr1::ellint_3(data[i].k, data[i].nu,
+		     data[i].phi);
+	const Ret f0 = data[i].f0;
+	const Ret diff = f - f0;
+	if (std::abs(diff) > max_abs_diff)
+	  max_abs_diff = std::abs(diff);
+	if (std::abs(f0) > Ret(10) * eps
+	 && std::abs(f) > Ret(10) * eps)
+	  {
+	    const Ret frac = diff / f0;
+	    if (std::abs(frac) > max_abs_frac)
+	      max_abs_frac = std::abs(frac);
+	  }
+      }
+    VERIFY(max_abs_frac < toler);
+  }
 
-int main(int, char**)
+int
+main()
 {
-  test001<double>();
-  test002<double>();
-  test003<double>();
-  test004<double>();
-  test005<double>();
-  test006<double>();
-  test007<double>();
-  test008<double>();
-  test009<double>();
-  test010<double>();
-  test011<double>();
-  test012<double>();
-  test013<double>();
-  test014<double>();
-  test015<double>();
-  test016<double>();
-  test017<double>();
-  test018<double>();
-  test019<double>();
-  test020<double>();
-  test021<double>();
-  test022<double>();
-  test023<double>();
-  test024<double>();
-  test025<double>();
-  test026<double>();
-  test027<double>();
-  test028<double>();
-  test029<double>();
-  test030<double>();
-  test031<double>();
-  test032<double>();
-  test033<double>();
-  test034<double>();
-  test035<double>();
-  test036<double>();
-  test037<double>();
-  test038<double>();
-  test039<double>();
-  test040<double>();
-  test041<double>();
-  test042<double>();
-  test043<double>();
-  test044<double>();
-  test045<double>();
-  test046<double>();
-  test047<double>();
-  test048<double>();
-  test049<double>();
-  test050<double>();
-  test051<double>();
-  test052<double>();
-  test053<double>();
-  test054<double>();
-  test055<double>();
-  test056<double>();
-  test057<double>();
-  test058<double>();
-  test059<double>();
-  test060<double>();
-  test061<double>();
-  test062<double>();
-  test063<double>();
-  test064<double>();
-  test065<double>();
-  test066<double>();
-  test067<double>();
-  test068<double>();
-  test069<double>();
-  test070<double>();
-  test071<double>();
-  test072<double>();
-  test073<double>();
-  test074<double>();
-  test075<double>();
-  test076<double>();
-  test077<double>();
-  test078<double>();
-  test079<double>();
-  test080<double>();
-  test081<double>();
-  test082<double>();
-  test083<double>();
-  test084<double>();
-  test085<double>();
-  test086<double>();
-  test087<double>();
-  test088<double>();
-  test089<double>();
-  test090<double>();
-  test091<double>();
-  test092<double>();
-  test093<double>();
-  test094<double>();
-  test095<double>();
-  test096<double>();
-  test097<double>();
-  test098<double>();
-  test099<double>();
-  test100<double>();
-  test101<double>();
-  test102<double>();
-  test103<double>();
-  test104<double>();
-  test105<double>();
-  test106<double>();
-  test107<double>();
-  test108<double>();
-  test109<double>();
-  test110<double>();
-  test111<double>();
-  test112<double>();
-  test113<double>();
-  test114<double>();
-  test115<double>();
-  test116<double>();
-  test117<double>();
-  test118<double>();
-  test119<double>();
-  test120<double>();
-  test121<double>();
-  test122<double>();
-  test123<double>();
-  test124<double>();
-  test125<double>();
-  test126<double>();
-  test127<double>();
-  test128<double>();
-  test129<double>();
-  test130<double>();
-  test131<double>();
-  test132<double>();
-  test133<double>();
-  test134<double>();
-  test135<double>();
-  test136<double>();
-  test137<double>();
-  test138<double>();
-  test139<double>();
-  test140<double>();
-  test141<double>();
-  test142<double>();
-  test143<double>();
-  test144<double>();
-  test145<double>();
-  test146<double>();
-  test147<double>();
-  test148<double>();
-  test149<double>();
-  test150<double>();
-  test151<double>();
-  test152<double>();
-  test153<double>();
-  test154<double>();
-  test155<double>();
-  test156<double>();
-  test157<double>();
-  test158<double>();
-  test159<double>();
-  test160<double>();
-  test161<double>();
-  test162<double>();
-  test163<double>();
-  test164<double>();
-  test165<double>();
-  test166<double>();
-  test167<double>();
-  test168<double>();
-  test169<double>();
-  test170<double>();
-  test171<double>();
-  test172<double>();
-  test173<double>();
-  test174<double>();
-  test175<double>();
-  test176<double>();
-  test177<double>();
-  test178<double>();
-  test179<double>();
-  test180<double>();
-  test181<double>();
-  test182<double>();
-  test183<double>();
-  test184<double>();
-  test185<double>();
-  test186<double>();
-  test187<double>();
-  test188<double>();
-  test189<double>();
-  test190<double>();
+  test(data001, toler001);
+  test(data002, toler002);
+  test(data003, toler003);
+  test(data004, toler004);
+  test(data005, toler005);
+  test(data006, toler006);
+  test(data007, toler007);
+  test(data008, toler008);
+  test(data009, toler009);
+  test(data010, toler010);
+  test(data011, toler011);
+  test(data012, toler012);
+  test(data013, toler013);
+  test(data014, toler014);
+  test(data015, toler015);
+  test(data016, toler016);
+  test(data017, toler017);
+  test(data018, toler018);
+  test(data019, toler019);
+  test(data020, toler020);
+  test(data021, toler021);
+  test(data022, toler022);
+  test(data023, toler023);
+  test(data024, toler024);
+  test(data025, toler025);
+  test(data026, toler026);
+  test(data027, toler027);
+  test(data028, toler028);
+  test(data029, toler029);
+  test(data030, toler030);
+  test(data031, toler031);
+  test(data032, toler032);
+  test(data033, toler033);
+  test(data034, toler034);
+  test(data035, toler035);
+  test(data036, toler036);
+  test(data037, toler037);
+  test(data038, toler038);
+  test(data039, toler039);
+  test(data040, toler040);
+  test(data041, toler041);
+  test(data042, toler042);
+  test(data043, toler043);
+  test(data044, toler044);
+  test(data045, toler045);
+  test(data046, toler046);
+  test(data047, toler047);
+  test(data048, toler048);
+  test(data049, toler049);
+  test(data050, toler050);
+  test(data051, toler051);
+  test(data052, toler052);
+  test(data053, toler053);
+  test(data054, toler054);
+  test(data055, toler055);
+  test(data056, toler056);
+  test(data057, toler057);
+  test(data058, toler058);
+  test(data059, toler059);
+  test(data060, toler060);
+  test(data061, toler061);
+  test(data062, toler062);
+  test(data063, toler063);
+  test(data064, toler064);
+  test(data065, toler065);
+  test(data066, toler066);
+  test(data067, toler067);
+  test(data068, toler068);
+  test(data069, toler069);
+  test(data070, toler070);
+  test(data071, toler071);
+  test(data072, toler072);
+  test(data073, toler073);
+  test(data074, toler074);
+  test(data075, toler075);
+  test(data076, toler076);
+  test(data077, toler077);
+  test(data078, toler078);
+  test(data079, toler079);
+  test(data080, toler080);
+  test(data081, toler081);
+  test(data082, toler082);
+  test(data083, toler083);
+  test(data084, toler084);
+  test(data085, toler085);
+  test(data086, toler086);
+  test(data087, toler087);
+  test(data088, toler088);
+  test(data089, toler089);
+  test(data090, toler090);
+  test(data091, toler091);
+  test(data092, toler092);
+  test(data093, toler093);
+  test(data094, toler094);
+  test(data095, toler095);
+  test(data096, toler096);
+  test(data097, toler097);
+  test(data098, toler098);
+  test(data099, toler099);
+  test(data100, toler100);
+  test(data101, toler101);
+  test(data102, toler102);
+  test(data103, toler103);
+  test(data104, toler104);
+  test(data105, toler105);
+  test(data106, toler106);
+  test(data107, toler107);
+  test(data108, toler108);
+  test(data109, toler109);
+  test(data110, toler110);
+  test(data111, toler111);
+  test(data112, toler112);
+  test(data113, toler113);
+  test(data114, toler114);
+  test(data115, toler115);
+  test(data116, toler116);
+  test(data117, toler117);
+  test(data118, toler118);
+  test(data119, toler119);
+  test(data120, toler120);
+  test(data121, toler121);
+  test(data122, toler122);
+  test(data123, toler123);
+  test(data124, toler124);
+  test(data125, toler125);
+  test(data126, toler126);
+  test(data127, toler127);
+  test(data128, toler128);
+  test(data129, toler129);
+  test(data130, toler130);
+  test(data131, toler131);
+  test(data132, toler132);
+  test(data133, toler133);
+  test(data134, toler134);
+  test(data135, toler135);
+  test(data136, toler136);
+  test(data137, toler137);
+  test(data138, toler138);
+  test(data139, toler139);
+  test(data140, toler140);
+  test(data141, toler141);
+  test(data142, toler142);
+  test(data143, toler143);
+  test(data144, toler144);
+  test(data145, toler145);
+  test(data146, toler146);
+  test(data147, toler147);
+  test(data148, toler148);
+  test(data149, toler149);
+  test(data150, toler150);
+  test(data151, toler151);
+  test(data152, toler152);
+  test(data153, toler153);
+  test(data154, toler154);
+  test(data155, toler155);
+  test(data156, toler156);
+  test(data157, toler157);
+  test(data158, toler158);
+  test(data159, toler159);
+  test(data160, toler160);
+  test(data161, toler161);
+  test(data162, toler162);
+  test(data163, toler163);
+  test(data164, toler164);
+  test(data165, toler165);
+  test(data166, toler166);
+  test(data167, toler167);
+  test(data168, toler168);
+  test(data169, toler169);
+  test(data170, toler170);
+  test(data171, toler171);
+  test(data172, toler172);
+  test(data173, toler173);
+  test(data174, toler174);
+  test(data175, toler175);
+  test(data176, toler176);
+  test(data177, toler177);
+  test(data178, toler178);
+  test(data179, toler179);
+  test(data180, toler180);
+  test(data181, toler181);
+  test(data182, toler182);
+  test(data183, toler183);
+  test(data184, toler184);
+  test(data185, toler185);
+  test(data186, toler186);
+  test(data187, toler187);
+  test(data188, toler188);
+  test(data189, toler189);
+  test(data190, toler190);
   return 0;
 }
Index: libstdc++-v3/testsuite/special_functions/06_comp_ellint_3/pr66689.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/special_functions/06_comp_ellint_3/pr66689.cc b/libstdc++-v3/testsuite/special_functions/06_comp_ellint_3/pr66689.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/special_functions/06_comp_ellint_3/pr66689.cc	(revision 262353)
@@ -0,0 +1,24 @@
+// { dg-do run { target c++11 } }
+// { dg-require-c-std "" }
+// { dg-options "-D__STDCPP_WANT_MATH_SPEC_FUNCS__" }
+// { dg-add-options ieee }
+
+#include <cmath>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  double Pi1 = std::comp_ellint_3(0.75, 0.0);
+  VERIFY(std::abs(Pi1 - 1.91099) < 0.00001);
+
+  double Pi2 = std::comp_ellint_3(0.75, 0.5);
+  VERIFY(std::abs(Pi2 - 2.80011) < 0.00001);
+}
+
+int
+main()
+{
+  test01();
+  return 0;
+}
Index: libstdc++-v3/testsuite/special_functions/06_comp_ellint_3/check_value.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/special_functions/06_comp_ellint_3/check_value.cc b/libstdc++-v3/testsuite/special_functions/06_comp_ellint_3/check_value.cc
--- a/libstdc++-v3/testsuite/special_functions/06_comp_ellint_3/check_value.cc	(revision 262353)
+++ b/libstdc++-v3/testsuite/special_functions/06_comp_ellint_3/check_value.cc	(revision 262353)
@@ -1,7 +1,7 @@
 // { dg-do run { target c++11 } }
 // { dg-options "-D__STDCPP_WANT_MATH_SPEC_FUNCS__" }
 //
-// Copyright (C) 2016-2017 Free Software Foundation, Inc.
+// Copyright (C) 2016-2018 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -37,387 +37,444 @@
 #endif
 #include <specfun_testcase.h>
 
-
 // Test data for k=-0.90000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 2.6751587294384150e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 1.2838262090802751e-16
+// mean(f - f_Boost): 4.4408920985006264e-17
+// variance(f - f_Boost): 2.4347558803117648e-34
+// stddev(f - f_Boost): 1.5603704304785339e-17
 const testcase_comp_ellint_3<double>
 data001[10] =
 {
   { 2.2805491384227703, -0.90000000000000002, 0.0000000000000000 },
-  { 2.1537868513875287, -0.90000000000000002, 0.10000000000000001 },
-  { 2.0443194576468890, -0.90000000000000002, 0.20000000000000001 },
-  { 1.9486280260314426, -0.90000000000000002, 0.29999999999999999 },
-  { 1.8641114227238349, -0.90000000000000002, 0.40000000000000002 },
-  { 1.7888013241937861, -0.90000000000000002, 0.50000000000000000 },
-  { 1.7211781128919523, -0.90000000000000002, 0.59999999999999998 },
-  { 1.6600480747670940, -0.90000000000000002, 0.69999999999999996 },
-  { 1.6044591960982202, -0.90000000000000002, 0.80000000000000004 },
-  { 1.5536420236310946, -0.90000000000000002, 0.90000000000000002 },
+  { 2.4295011187834885, -0.90000000000000002, 0.10000000000000001 },
+  { 2.6076835743348412, -0.90000000000000002, 0.20000000000000001 },
+  { 2.8256506968858512, -0.90000000000000002, 0.30000000000000004 },
+  { 3.1000689868578619, -0.90000000000000002, 0.40000000000000002 },
+  { 3.4591069002104677, -0.90000000000000002, 0.50000000000000000 },
+  { 3.9549939883570229, -0.90000000000000002, 0.60000000000000009 },
+  { 4.6985482312992435, -0.90000000000000002, 0.70000000000000007 },
+  { 5.9820740813645710, -0.90000000000000002, 0.80000000000000004 },
+  { 8.9942562031858699, -0.90000000000000002, 0.90000000000000002 },
 };
 const double toler001 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 1.5960830388244336e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.1949393471095187e-16
+// mean(f - f_Boost): 9.5479180117763459e-16
+// variance(f - f_Boost): 5.4782007307014711e-34
+// stddev(f - f_Boost): 2.3405556457178006e-17
 const testcase_comp_ellint_3<double>
 data002[10] =
 {
-  { 1.9953027776647296, -0.80000000000000004, 0.0000000000000000 },
-  { 1.8910755418379521, -0.80000000000000004, 0.10000000000000001 },
-  { 1.8007226661734588, -0.80000000000000004, 0.20000000000000001 },
-  { 1.7214611048717301, -0.80000000000000004, 0.29999999999999999 },
-  { 1.6512267838651289, -0.80000000000000004, 0.40000000000000002 },
-  { 1.5884528947755532, -0.80000000000000004, 0.50000000000000000 },
-  { 1.5319262547427865, -0.80000000000000004, 0.59999999999999998 },
-  { 1.4806912324625332, -0.80000000000000004, 0.69999999999999996 },
-  { 1.4339837018309471, -0.80000000000000004, 0.80000000000000004 },
-  { 1.3911845406776222, -0.80000000000000004, 0.90000000000000002 },
+  { 1.9953027776647294, -0.80000000000000004, 0.0000000000000000 },
+  { 2.1172616484005085, -0.80000000000000004, 0.10000000000000001 },
+  { 2.2624789434186798, -0.80000000000000004, 0.20000000000000001 },
+  { 2.4392042002725698, -0.80000000000000004, 0.30000000000000004 },
+  { 2.6604037035529728, -0.80000000000000004, 0.40000000000000002 },
+  { 2.9478781158239751, -0.80000000000000004, 0.50000000000000000 },
+  { 3.3418121892288055, -0.80000000000000004, 0.60000000000000009 },
+  { 3.9268876980046397, -0.80000000000000004, 0.70000000000000007 },
+  { 4.9246422058196071, -0.80000000000000004, 0.80000000000000004 },
+  { 7.2263259298637132, -0.80000000000000004, 0.90000000000000002 },
 };
 const double toler002 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3074070916136724e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 3
+// max(|f - f_Boost| / |f_Boost|): 1.9832236886714888e-16
+// mean(f - f_Boost): -1.5543122344752191e-16
+// variance(f - f_Boost): 2.9825759533819119e-33
+// stddev(f - f_Boost): 5.4612965066748680e-17
 const testcase_comp_ellint_3<double>
 data003[10] =
 {
-  { 1.8456939983747236, -0.69999999999999996, 0.0000000000000000 },
-  { 1.7528050171757608, -0.69999999999999996, 0.10000000000000001 },
-  { 1.6721098780092145, -0.69999999999999996, 0.20000000000000001 },
-  { 1.6011813647733213, -0.69999999999999996, 0.29999999999999999 },
-  { 1.5382162002954762, -0.69999999999999996, 0.40000000000000002 },
-  { 1.4818433192178544, -0.69999999999999996, 0.50000000000000000 },
-  { 1.4309994736080540, -0.69999999999999996, 0.59999999999999998 },
-  { 1.3848459188329196, -0.69999999999999996, 0.69999999999999996 },
-  { 1.3427110650397531, -0.69999999999999996, 0.80000000000000004 },
-  { 1.3040500499695913, -0.69999999999999996, 0.90000000000000002 },
+  { 1.8456939983747234, -0.69999999999999996, 0.0000000000000000 },
+  { 1.9541347343119564, -0.69999999999999996, 0.10000000000000001 },
+  { 2.0829290325820202, -0.69999999999999996, 0.20000000000000001 },
+  { 2.2392290510988535, -0.69999999999999996, 0.30000000000000004 },
+  { 2.4342502915307880, -0.69999999999999996, 0.40000000000000002 },
+  { 2.6868019968236996, -0.69999999999999996, 0.50000000000000000 },
+  { 3.0314573496746742, -0.69999999999999996, 0.60000000000000009 },
+  { 3.5408408771788564, -0.69999999999999996, 0.70000000000000007 },
+  { 4.4042405729076961, -0.69999999999999996, 0.80000000000000004 },
+  { 6.3796094177887754, -0.69999999999999996, 0.90000000000000002 },
 };
 const double toler003 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1891472451898755e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 2
+// max(|f - f_Boost| / |f_Boost|): 2.2547200163366559e-16
+// mean(f - f_Boost): -1.9984014443252818e-16
+// variance(f - f_Boost): 4.9303806576313241e-33
+// stddev(f - f_Boost): 7.0216669371534022e-17
 const testcase_comp_ellint_3<double>
 data004[10] =
 {
   { 1.7507538029157526, -0.59999999999999998, 0.0000000000000000 },
-  { 1.6648615773343014, -0.59999999999999998, 0.10000000000000001 },
-  { 1.5901418016279374, -0.59999999999999998, 0.20000000000000001 },
-  { 1.5243814243493585, -0.59999999999999998, 0.29999999999999999 },
-  { 1.4659345278069984, -0.59999999999999998, 0.40000000000000002 },
-  { 1.4135484285693078, -0.59999999999999998, 0.50000000000000000 },
-  { 1.3662507535812816, -0.59999999999999998, 0.59999999999999998 },
-  { 1.3232737468822813, -0.59999999999999998, 0.69999999999999996 },
-  { 1.2840021261752192, -0.59999999999999998, 0.80000000000000004 },
-  { 1.2479362973851875, -0.59999999999999998, 0.90000000000000002 },
+  { 1.8508766487100685, -0.59999999999999998, 0.10000000000000001 },
+  { 1.9695980282802217, -0.59999999999999998, 0.20000000000000001 },
+  { 2.1134154405060599, -0.59999999999999998, 0.30000000000000004 },
+  { 2.2925036420985130, -0.59999999999999998, 0.40000000000000002 },
+  { 2.5239007084492711, -0.59999999999999998, 0.50000000000000000 },
+  { 2.8388723099514972, -0.59999999999999998, 0.60000000000000009 },
+  { 3.3029735898397159, -0.59999999999999998, 0.70000000000000007 },
+  { 4.0867036409261832, -0.59999999999999998, 0.80000000000000004 },
+  { 5.8709993116265604, -0.59999999999999998, 0.90000000000000002 },
 };
 const double toler004 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 1.7857620325589816e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 3
+// max(|f - f_Boost| / |f_Boost|): 2.1900131385114407e-16
+// mean(f - f_Boost): 2.4424906541753446e-16
+// variance(f - f_Boost): 7.3651365379430888e-33
+// stddev(f - f_Boost): 8.5820373676319358e-17
 const testcase_comp_ellint_3<double>
 data005[10] =
 {
-  { 1.6857503548125963, -0.50000000000000000, 0.0000000000000000 },
-  { 1.6045524936084892, -0.50000000000000000, 0.10000000000000001 },
-  { 1.5338490483665983, -0.50000000000000000, 0.20000000000000001 },
-  { 1.4715681939859637, -0.50000000000000000, 0.29999999999999999 },
-  { 1.4161679518465340, -0.50000000000000000, 0.40000000000000002 },
-  { 1.3664739530045971, -0.50000000000000000, 0.50000000000000000 },
-  { 1.3215740290190876, -0.50000000000000000, 0.59999999999999998 },
-  { 1.2807475181182502, -0.50000000000000000, 0.69999999999999996 },
-  { 1.2434165408189539, -0.50000000000000000, 0.80000000000000004 },
-  { 1.2091116095504744, -0.50000000000000000, 0.90000000000000002 },
+  { 1.6857503548125961, -0.50000000000000000, 0.0000000000000000 },
+  { 1.7803034946545482, -0.50000000000000000, 0.10000000000000001 },
+  { 1.8922947612264021, -0.50000000000000000, 0.20000000000000001 },
+  { 2.0277924458111314, -0.50000000000000000, 0.30000000000000004 },
+  { 2.1962905366178065, -0.50000000000000000, 0.40000000000000002 },
+  { 2.4136715042011945, -0.50000000000000000, 0.50000000000000000 },
+  { 2.7090491861753558, -0.50000000000000000, 0.60000000000000009 },
+  { 3.1433945297859229, -0.50000000000000000, 0.70000000000000007 },
+  { 3.8750701888108070, -0.50000000000000000, 0.80000000000000004 },
+  { 5.5355132096026463, -0.50000000000000000, 0.90000000000000002 },
 };
 const double toler005 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.1925080711125793e-16
+// Test data for k=-0.39999999999999991.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1718164615986397e-16
+// mean(f - f_Boost): 6.2172489379008762e-16
+// variance(f - f_Boost): 1.6458949750907531e-31
+// stddev(f - f_Boost): 4.0569631192441877e-16
 const testcase_comp_ellint_3<double>
 data006[10] =
 {
-  { 1.6399998658645112, -0.40000000000000002, 0.0000000000000000 },
-  { 1.5620566886683604, -0.40000000000000002, 0.10000000000000001 },
-  { 1.4941414344266770, -0.40000000000000002, 0.20000000000000001 },
-  { 1.4342789859950078, -0.40000000000000002, 0.29999999999999999 },
-  { 1.3809986210732901, -0.40000000000000002, 0.40000000000000002 },
-  { 1.3331797176377398, -0.40000000000000002, 0.50000000000000000 },
-  { 1.2899514672527024, -0.40000000000000002, 0.59999999999999998 },
-  { 1.2506255923253344, -0.40000000000000002, 0.69999999999999996 },
-  { 1.2146499565727209, -0.40000000000000002, 0.80000000000000004 },
-  { 1.1815758115929846, -0.40000000000000002, 0.90000000000000002 },
+  { 1.6399998658645112, -0.39999999999999991, 0.0000000000000000 },
+  { 1.7306968836847190, -0.39999999999999991, 0.10000000000000001 },
+  { 1.8380358826317627, -0.39999999999999991, 0.20000000000000001 },
+  { 1.9677924132520139, -0.39999999999999991, 0.30000000000000004 },
+  { 2.1289968719280026, -0.39999999999999991, 0.40000000000000002 },
+  { 2.3367461373176512, -0.39999999999999991, 0.50000000000000000 },
+  { 2.6186940209850191, -0.39999999999999991, 0.60000000000000009 },
+  { 3.0327078743873246, -0.39999999999999991, 0.70000000000000007 },
+  { 3.7289548002199902, -0.39999999999999991, 0.80000000000000004 },
+  { 5.3055535102872513, -0.39999999999999991, 0.90000000000000002 },
 };
 const double toler006 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8209844149902043e-16
+// Test data for k=-0.29999999999999993.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.9274792319434433e-16
+// mean(f - f_Boost): 6.2172489379008762e-16
+// variance(f - f_Boost): 8.7651211691223537e-33
+// stddev(f - f_Boost): 9.3622225828712025e-17
 const testcase_comp_ellint_3<double>
 data007[10] =
 {
-  { 1.6080486199305128, -0.30000000000000004, 0.0000000000000000 },
-  { 1.5323534693557528, -0.30000000000000004, 0.10000000000000001 },
-  { 1.4663658145259877, -0.30000000000000004, 0.20000000000000001 },
-  { 1.4081767433479091, -0.30000000000000004, 0.29999999999999999 },
-  { 1.3563643538969763, -0.30000000000000004, 0.40000000000000002 },
-  { 1.3098448759814962, -0.30000000000000004, 0.50000000000000000 },
-  { 1.2677758800420669, -0.30000000000000004, 0.59999999999999998 },
-  { 1.2294913236274982, -0.30000000000000004, 0.69999999999999996 },
-  { 1.1944567571590048, -0.30000000000000004, 0.80000000000000004 },
-  { 1.1622376896064914, -0.30000000000000004, 0.90000000000000002 },
+  { 1.6080486199305128, -0.29999999999999993, 0.0000000000000000 },
+  { 1.6960848815118226, -0.29999999999999993, 0.10000000000000001 },
+  { 1.8002173372290500, -0.29999999999999993, 0.20000000000000001 },
+  { 1.9260216862473254, -0.29999999999999993, 0.30000000000000004 },
+  { 2.0822121773175533, -0.29999999999999993, 0.40000000000000002 },
+  { 2.2833505881933971, -0.29999999999999993, 0.50000000000000000 },
+  { 2.5560975528589065, -0.29999999999999993, 0.60000000000000009 },
+  { 2.9562123549913877, -0.29999999999999993, 0.70000000000000007 },
+  { 3.6283050484567170, -0.29999999999999993, 0.80000000000000004 },
+  { 5.1479514944016795, -0.29999999999999993, 0.90000000000000002 },
 };
 const double toler007 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8637687241174905e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.9753938705764407e-16
+// mean(f - f_Boost): 3.1086244689504381e-16
+// variance(f - f_Boost): 4.1147374377268827e-32
+// stddev(f - f_Boost): 2.0284815596220939e-16
 const testcase_comp_ellint_3<double>
 data008[10] =
 {
-  { 1.5868678474541660, -0.19999999999999996, 0.0000000000000000 },
-  { 1.5126513474261087, -0.19999999999999996, 0.10000000000000001 },
-  { 1.4479323932249564, -0.19999999999999996, 0.20000000000000001 },
-  { 1.3908453514752477, -0.19999999999999996, 0.29999999999999999 },
-  { 1.3400002519661005, -0.19999999999999996, 0.40000000000000002 },
-  { 1.2943374404397372, -0.19999999999999996, 0.50000000000000000 },
-  { 1.2530330675914556, -0.19999999999999996, 0.59999999999999998 },
-  { 1.2154356555075863, -0.19999999999999996, 0.69999999999999996 },
-  { 1.1810223448909909, -0.19999999999999996, 0.80000000000000004 },
-  { 1.1493679916141861, -0.19999999999999996, 0.90000000000000002 },
+  { 1.5868678474541662, -0.19999999999999996, 0.0000000000000000 },
+  { 1.6731552050562593, -0.19999999999999996, 0.10000000000000001 },
+  { 1.7751816279738935, -0.19999999999999996, 0.20000000000000001 },
+  { 1.8983924169967101, -0.19999999999999996, 0.30000000000000004 },
+  { 2.0512956926676806, -0.19999999999999996, 0.40000000000000002 },
+  { 2.2481046259421302, -0.19999999999999996, 0.50000000000000000 },
+  { 2.5148333891629315, -0.19999999999999996, 0.60000000000000009 },
+  { 2.9058704854500967, -0.19999999999999996, 0.70000000000000007 },
+  { 3.5622166386422633, -0.19999999999999996, 0.80000000000000004 },
+  { 5.0448269356200370, -0.19999999999999996, 0.90000000000000002 },
 };
 const double toler008 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8887517676790089e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 1.9932308021417639e-16
+// mean(f - f_Boost): 0.0000000000000000
+// variance(f - f_Boost): 6.8368087769470551e-64
+// stddev(f - f_Boost): 2.6147291976315738e-32
 const testcase_comp_ellint_3<double>
 data009[10] =
 {
-  { 1.5747455615173562, -0.099999999999999978, 0.0000000000000000 },
-  { 1.5013711111199950, -0.099999999999999978, 0.10000000000000001 },
-  { 1.4373749386463430, -0.099999999999999978, 0.20000000000000001 },
-  { 1.3809159606704959, -0.099999999999999978, 0.29999999999999999 },
-  { 1.3306223265207477, -0.099999999999999978, 0.40000000000000002 },
-  { 1.2854480708580160, -0.099999999999999978, 0.50000000000000000 },
-  { 1.2445798942989255, -0.099999999999999978, 0.59999999999999998 },
-  { 1.2073745911083185, -0.099999999999999978, 0.69999999999999996 },
-  { 1.1733158866987732, -0.099999999999999978, 0.80000000000000004 },
-  { 1.1419839485283374, -0.099999999999999978, 0.90000000000000002 },
+  { 1.5747455615173560, -0.099999999999999978, 0.0000000000000000 },
+  { 1.6600374067558428, -0.099999999999999978, 0.10000000000000001 },
+  { 1.7608656115083421, -0.099999999999999978, 0.20000000000000001 },
+  { 1.8826015946315438, -0.099999999999999978, 0.30000000000000004 },
+  { 2.0336367403076760, -0.099999999999999978, 0.40000000000000002 },
+  { 2.2279868912966849, -0.099999999999999978, 0.50000000000000000 },
+  { 2.4913004919173827, -0.099999999999999978, 0.60000000000000009 },
+  { 2.8771910188009744, -0.099999999999999978, 0.70000000000000007 },
+  { 3.5246199613295617, -0.099999999999999978, 0.80000000000000004 },
+  { 4.9862890417305508, -0.099999999999999978, 0.90000000000000002 },
 };
 const double toler009 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 1.6725702444488137e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.1899085000907084e-16
+// mean(f - f_Boost): -2.2204460492503131e-16
+// variance(f - f_Boost): 5.4782007307014711e-32
+// stddev(f - f_Boost): 2.3405556457178008e-16
 const testcase_comp_ellint_3<double>
 data010[10] =
 {
   { 1.5707963267948966, 0.0000000000000000, 0.0000000000000000 },
-  { 1.4976955329233277, 0.0000000000000000, 0.10000000000000001 },
-  { 1.4339343023863691, 0.0000000000000000, 0.20000000000000001 },
-  { 1.3776795151134889, 0.0000000000000000, 0.29999999999999999 },
-  { 1.3275651989026320, 0.0000000000000000, 0.40000000000000002 },
-  { 1.2825498301618641, 0.0000000000000000, 0.50000000000000000 },
-  { 1.2418235332245127, 0.0000000000000000, 0.59999999999999998 },
-  { 1.2047457872617382, 0.0000000000000000, 0.69999999999999996 },
-  { 1.1708024551734544, 0.0000000000000000, 0.80000000000000004 },
-  { 1.1395754288497419, 0.0000000000000000, 0.90000000000000002 },
+  { 1.6557647109660170, 0.0000000000000000, 0.10000000000000001 },
+  { 1.7562036827601817, 0.0000000000000000, 0.20000000000000001 },
+  { 1.8774607092226381, 0.0000000000000000, 0.30000000000000004 },
+  { 2.0278893379868062, 0.0000000000000000, 0.40000000000000002 },
+  { 2.2214414690791831, 0.0000000000000000, 0.50000000000000000 },
+  { 2.4836470664490258, 0.0000000000000000, 0.60000000000000009 },
+  { 2.8678686047727386, 0.0000000000000000, 0.70000000000000007 },
+  { 3.5124073655203634, 0.0000000000000000, 0.80000000000000004 },
+  { 4.9672941328980516, 0.0000000000000000, 0.90000000000000002 },
 };
 const double toler010 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8887517676790089e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 1.9932308021417639e-16
+// mean(f - f_Boost): -2.2204460492503132e-17
+// variance(f - f_Boost): 6.0868897007794120e-35
+// stddev(f - f_Boost): 7.8018521523926693e-18
 const testcase_comp_ellint_3<double>
 data011[10] =
 {
-  { 1.5747455615173562, 0.10000000000000009, 0.0000000000000000 },
-  { 1.5013711111199950, 0.10000000000000009, 0.10000000000000001 },
-  { 1.4373749386463430, 0.10000000000000009, 0.20000000000000001 },
-  { 1.3809159606704959, 0.10000000000000009, 0.29999999999999999 },
-  { 1.3306223265207477, 0.10000000000000009, 0.40000000000000002 },
-  { 1.2854480708580160, 0.10000000000000009, 0.50000000000000000 },
-  { 1.2445798942989255, 0.10000000000000009, 0.59999999999999998 },
-  { 1.2073745911083185, 0.10000000000000009, 0.69999999999999996 },
-  { 1.1733158866987732, 0.10000000000000009, 0.80000000000000004 },
-  { 1.1419839485283374, 0.10000000000000009, 0.90000000000000002 },
+  { 1.5747455615173560, 0.10000000000000009, 0.0000000000000000 },
+  { 1.6600374067558428, 0.10000000000000009, 0.10000000000000001 },
+  { 1.7608656115083421, 0.10000000000000009, 0.20000000000000001 },
+  { 1.8826015946315440, 0.10000000000000009, 0.30000000000000004 },
+  { 2.0336367403076760, 0.10000000000000009, 0.40000000000000002 },
+  { 2.2279868912966849, 0.10000000000000009, 0.50000000000000000 },
+  { 2.4913004919173827, 0.10000000000000009, 0.60000000000000009 },
+  { 2.8771910188009744, 0.10000000000000009, 0.70000000000000007 },
+  { 3.5246199613295617, 0.10000000000000009, 0.80000000000000004 },
+  { 4.9862890417305508, 0.10000000000000009, 0.90000000000000002 },
 };
 const double toler011 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8637687241174905e-16
+// Test data for k=0.20000000000000018.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.9753938705764407e-16
+// mean(f - f_Boost): 3.1086244689504381e-16
+// variance(f - f_Boost): 4.1147374377268827e-32
+// stddev(f - f_Boost): 2.0284815596220939e-16
 const testcase_comp_ellint_3<double>
 data012[10] =
 {
-  { 1.5868678474541660, 0.19999999999999996, 0.0000000000000000 },
-  { 1.5126513474261087, 0.19999999999999996, 0.10000000000000001 },
-  { 1.4479323932249564, 0.19999999999999996, 0.20000000000000001 },
-  { 1.3908453514752477, 0.19999999999999996, 0.29999999999999999 },
-  { 1.3400002519661005, 0.19999999999999996, 0.40000000000000002 },
-  { 1.2943374404397372, 0.19999999999999996, 0.50000000000000000 },
-  { 1.2530330675914556, 0.19999999999999996, 0.59999999999999998 },
-  { 1.2154356555075863, 0.19999999999999996, 0.69999999999999996 },
-  { 1.1810223448909909, 0.19999999999999996, 0.80000000000000004 },
-  { 1.1493679916141861, 0.19999999999999996, 0.90000000000000002 },
+  { 1.5868678474541662, 0.20000000000000018, 0.0000000000000000 },
+  { 1.6731552050562593, 0.20000000000000018, 0.10000000000000001 },
+  { 1.7751816279738935, 0.20000000000000018, 0.20000000000000001 },
+  { 1.8983924169967101, 0.20000000000000018, 0.30000000000000004 },
+  { 2.0512956926676806, 0.20000000000000018, 0.40000000000000002 },
+  { 2.2481046259421302, 0.20000000000000018, 0.50000000000000000 },
+  { 2.5148333891629315, 0.20000000000000018, 0.60000000000000009 },
+  { 2.9058704854500967, 0.20000000000000018, 0.70000000000000007 },
+  { 3.5622166386422633, 0.20000000000000018, 0.80000000000000004 },
+  { 5.0448269356200370, 0.20000000000000018, 0.90000000000000002 },
 };
 const double toler012 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8209844149902043e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.4585997630846713e-16
+// mean(f - f_Boost): 5.1070259132757197e-16
+// variance(f - f_Boost): 1.7591111235252501e-32
+// stddev(f - f_Boost): 1.3263148659067538e-16
 const testcase_comp_ellint_3<double>
 data013[10] =
 {
   { 1.6080486199305128, 0.30000000000000004, 0.0000000000000000 },
-  { 1.5323534693557528, 0.30000000000000004, 0.10000000000000001 },
-  { 1.4663658145259877, 0.30000000000000004, 0.20000000000000001 },
-  { 1.4081767433479091, 0.30000000000000004, 0.29999999999999999 },
-  { 1.3563643538969763, 0.30000000000000004, 0.40000000000000002 },
-  { 1.3098448759814962, 0.30000000000000004, 0.50000000000000000 },
-  { 1.2677758800420669, 0.30000000000000004, 0.59999999999999998 },
-  { 1.2294913236274982, 0.30000000000000004, 0.69999999999999996 },
-  { 1.1944567571590048, 0.30000000000000004, 0.80000000000000004 },
-  { 1.1622376896064914, 0.30000000000000004, 0.90000000000000002 },
+  { 1.6960848815118228, 0.30000000000000004, 0.10000000000000001 },
+  { 1.8002173372290500, 0.30000000000000004, 0.20000000000000001 },
+  { 1.9260216862473254, 0.30000000000000004, 0.30000000000000004 },
+  { 2.0822121773175533, 0.30000000000000004, 0.40000000000000002 },
+  { 2.2833505881933975, 0.30000000000000004, 0.50000000000000000 },
+  { 2.5560975528589065, 0.30000000000000004, 0.60000000000000009 },
+  { 2.9562123549913877, 0.30000000000000004, 0.70000000000000007 },
+  { 3.6283050484567174, 0.30000000000000004, 0.80000000000000004 },
+  { 5.1479514944016795, 0.30000000000000004, 0.90000000000000002 },
 };
 const double toler013 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.1925080711125793e-16
+// Test data for k=0.40000000000000013.
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.7696531428672557e-16
+// mean(f - f_Boost): 1.1990408665951691e-15
+// variance(f - f_Boost): 2.6514491536595121e-31
+// stddev(f - f_Boost): 5.1492224205791612e-16
 const testcase_comp_ellint_3<double>
 data014[10] =
 {
-  { 1.6399998658645112, 0.39999999999999991, 0.0000000000000000 },
-  { 1.5620566886683604, 0.39999999999999991, 0.10000000000000001 },
-  { 1.4941414344266770, 0.39999999999999991, 0.20000000000000001 },
-  { 1.4342789859950078, 0.39999999999999991, 0.29999999999999999 },
-  { 1.3809986210732901, 0.39999999999999991, 0.40000000000000002 },
-  { 1.3331797176377398, 0.39999999999999991, 0.50000000000000000 },
-  { 1.2899514672527024, 0.39999999999999991, 0.59999999999999998 },
-  { 1.2506255923253344, 0.39999999999999991, 0.69999999999999996 },
-  { 1.2146499565727209, 0.39999999999999991, 0.80000000000000004 },
-  { 1.1815758115929846, 0.39999999999999991, 0.90000000000000002 },
+  { 1.6399998658645112, 0.40000000000000013, 0.0000000000000000 },
+  { 1.7306968836847190, 0.40000000000000013, 0.10000000000000001 },
+  { 1.8380358826317629, 0.40000000000000013, 0.20000000000000001 },
+  { 1.9677924132520141, 0.40000000000000013, 0.30000000000000004 },
+  { 2.1289968719280030, 0.40000000000000013, 0.40000000000000002 },
+  { 2.3367461373176512, 0.40000000000000013, 0.50000000000000000 },
+  { 2.6186940209850196, 0.40000000000000013, 0.60000000000000009 },
+  { 3.0327078743873246, 0.40000000000000013, 0.70000000000000007 },
+  { 3.7289548002199906, 0.40000000000000013, 0.80000000000000004 },
+  { 5.3055535102872522, 0.40000000000000013, 0.90000000000000002 },
 };
 const double toler014 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 1.7857620325589816e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 3
+// max(|f - f_Boost| / |f_Boost|): 2.1900131385114407e-16
+// mean(f - f_Boost): 2.4424906541753446e-16
+// variance(f - f_Boost): 7.3651365379430888e-33
+// stddev(f - f_Boost): 8.5820373676319358e-17
 const testcase_comp_ellint_3<double>
 data015[10] =
 {
-  { 1.6857503548125963, 0.50000000000000000, 0.0000000000000000 },
-  { 1.6045524936084892, 0.50000000000000000, 0.10000000000000001 },
-  { 1.5338490483665983, 0.50000000000000000, 0.20000000000000001 },
-  { 1.4715681939859637, 0.50000000000000000, 0.29999999999999999 },
-  { 1.4161679518465340, 0.50000000000000000, 0.40000000000000002 },
-  { 1.3664739530045971, 0.50000000000000000, 0.50000000000000000 },
-  { 1.3215740290190876, 0.50000000000000000, 0.59999999999999998 },
-  { 1.2807475181182502, 0.50000000000000000, 0.69999999999999996 },
-  { 1.2434165408189539, 0.50000000000000000, 0.80000000000000004 },
-  { 1.2091116095504744, 0.50000000000000000, 0.90000000000000002 },
+  { 1.6857503548125961, 0.50000000000000000, 0.0000000000000000 },
+  { 1.7803034946545482, 0.50000000000000000, 0.10000000000000001 },
+  { 1.8922947612264021, 0.50000000000000000, 0.20000000000000001 },
+  { 2.0277924458111314, 0.50000000000000000, 0.30000000000000004 },
+  { 2.1962905366178065, 0.50000000000000000, 0.40000000000000002 },
+  { 2.4136715042011945, 0.50000000000000000, 0.50000000000000000 },
+  { 2.7090491861753558, 0.50000000000000000, 0.60000000000000009 },
+  { 3.1433945297859229, 0.50000000000000000, 0.70000000000000007 },
+  { 3.8750701888108070, 0.50000000000000000, 0.80000000000000004 },
+  { 5.5355132096026463, 0.50000000000000000, 0.90000000000000002 },
 };
 const double toler015 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.7124937590522226e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 2
+// max(|f - f_Boost| / |f_Boost|): 2.2547200163366559e-16
+// mean(f - f_Boost): -2.2204460492503131e-16
+// variance(f - f_Boost): 6.0868897007794117e-33
+// stddev(f - f_Boost): 7.8018521523926690e-17
 const testcase_comp_ellint_3<double>
 data016[10] =
 {
   { 1.7507538029157526, 0.60000000000000009, 0.0000000000000000 },
-  { 1.6648615773343014, 0.60000000000000009, 0.10000000000000001 },
-  { 1.5901418016279374, 0.60000000000000009, 0.20000000000000001 },
-  { 1.5243814243493585, 0.60000000000000009, 0.29999999999999999 },
-  { 1.4659345278069984, 0.60000000000000009, 0.40000000000000002 },
-  { 1.4135484285693078, 0.60000000000000009, 0.50000000000000000 },
-  { 1.3662507535812816, 0.60000000000000009, 0.59999999999999998 },
-  { 1.3232737468822813, 0.60000000000000009, 0.69999999999999996 },
-  { 1.2840021261752192, 0.60000000000000009, 0.80000000000000004 },
-  { 1.2479362973851873, 0.60000000000000009, 0.90000000000000002 },
+  { 1.8508766487100687, 0.60000000000000009, 0.10000000000000001 },
+  { 1.9695980282802217, 0.60000000000000009, 0.20000000000000001 },
+  { 2.1134154405060599, 0.60000000000000009, 0.30000000000000004 },
+  { 2.2925036420985130, 0.60000000000000009, 0.40000000000000002 },
+  { 2.5239007084492711, 0.60000000000000009, 0.50000000000000000 },
+  { 2.8388723099514976, 0.60000000000000009, 0.60000000000000009 },
+  { 3.3029735898397159, 0.60000000000000009, 0.70000000000000007 },
+  { 4.0867036409261832, 0.60000000000000009, 0.80000000000000004 },
+  { 5.8709993116265613, 0.60000000000000009, 0.90000000000000002 },
 };
 const double toler016 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3074070916136724e-16
+// Test data for k=0.70000000000000018.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.9298727220933567e-16
+// mean(f - f_Boost): 4.8849813083506892e-16
+// variance(f - f_Boost): 2.0476296953421943e-31
+// stddev(f - f_Boost): 4.5250742483877478e-16
 const testcase_comp_ellint_3<double>
 data017[10] =
 {
-  { 1.8456939983747236, 0.69999999999999996, 0.0000000000000000 },
-  { 1.7528050171757608, 0.69999999999999996, 0.10000000000000001 },
-  { 1.6721098780092145, 0.69999999999999996, 0.20000000000000001 },
-  { 1.6011813647733213, 0.69999999999999996, 0.29999999999999999 },
-  { 1.5382162002954762, 0.69999999999999996, 0.40000000000000002 },
-  { 1.4818433192178544, 0.69999999999999996, 0.50000000000000000 },
-  { 1.4309994736080540, 0.69999999999999996, 0.59999999999999998 },
-  { 1.3848459188329196, 0.69999999999999996, 0.69999999999999996 },
-  { 1.3427110650397531, 0.69999999999999996, 0.80000000000000004 },
-  { 1.3040500499695913, 0.69999999999999996, 0.90000000000000002 },
+  { 1.8456939983747238, 0.70000000000000018, 0.0000000000000000 },
+  { 1.9541347343119566, 0.70000000000000018, 0.10000000000000001 },
+  { 2.0829290325820207, 0.70000000000000018, 0.20000000000000001 },
+  { 2.2392290510988540, 0.70000000000000018, 0.30000000000000004 },
+  { 2.4342502915307880, 0.70000000000000018, 0.40000000000000002 },
+  { 2.6868019968237000, 0.70000000000000018, 0.50000000000000000 },
+  { 3.0314573496746746, 0.70000000000000018, 0.60000000000000009 },
+  { 3.5408408771788569, 0.70000000000000018, 0.70000000000000007 },
+  { 4.4042405729076970, 0.70000000000000018, 0.80000000000000004 },
+  { 6.3796094177887763, 0.70000000000000018, 0.90000000000000002 },
 };
 const double toler017 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 1.5960830388244336e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.1949393471095187e-16
+// mean(f - f_Boost): 9.5479180117763459e-16
+// variance(f - f_Boost): 5.4782007307014711e-34
+// stddev(f - f_Boost): 2.3405556457178006e-17
 const testcase_comp_ellint_3<double>
 data018[10] =
 {
-  { 1.9953027776647296, 0.80000000000000004, 0.0000000000000000 },
-  { 1.8910755418379521, 0.80000000000000004, 0.10000000000000001 },
-  { 1.8007226661734588, 0.80000000000000004, 0.20000000000000001 },
-  { 1.7214611048717301, 0.80000000000000004, 0.29999999999999999 },
-  { 1.6512267838651289, 0.80000000000000004, 0.40000000000000002 },
-  { 1.5884528947755532, 0.80000000000000004, 0.50000000000000000 },
-  { 1.5319262547427865, 0.80000000000000004, 0.59999999999999998 },
-  { 1.4806912324625332, 0.80000000000000004, 0.69999999999999996 },
-  { 1.4339837018309471, 0.80000000000000004, 0.80000000000000004 },
-  { 1.3911845406776222, 0.80000000000000004, 0.90000000000000002 },
+  { 1.9953027776647294, 0.80000000000000004, 0.0000000000000000 },
+  { 2.1172616484005085, 0.80000000000000004, 0.10000000000000001 },
+  { 2.2624789434186798, 0.80000000000000004, 0.20000000000000001 },
+  { 2.4392042002725698, 0.80000000000000004, 0.30000000000000004 },
+  { 2.6604037035529728, 0.80000000000000004, 0.40000000000000002 },
+  { 2.9478781158239751, 0.80000000000000004, 0.50000000000000000 },
+  { 3.3418121892288055, 0.80000000000000004, 0.60000000000000009 },
+  { 3.9268876980046397, 0.80000000000000004, 0.70000000000000007 },
+  { 4.9246422058196071, 0.80000000000000004, 0.80000000000000004 },
+  { 7.2263259298637132, 0.80000000000000004, 0.90000000000000002 },
 };
 const double toler018 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 2.6751587294384150e-16
+// Test data for k=0.90000000000000013.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 3
+// max(|f - f_Boost| / |f_Boost|): 1.5716352001310461e-16
+// mean(f - f_Boost): 4.4408920985006264e-17
+// variance(f - f_Boost): 2.4347558803117648e-34
+// stddev(f - f_Boost): 1.5603704304785339e-17
 const testcase_comp_ellint_3<double>
 data019[10] =
 {
-  { 2.2805491384227703, 0.89999999999999991, 0.0000000000000000 },
-  { 2.1537868513875287, 0.89999999999999991, 0.10000000000000001 },
-  { 2.0443194576468895, 0.89999999999999991, 0.20000000000000001 },
-  { 1.9486280260314426, 0.89999999999999991, 0.29999999999999999 },
-  { 1.8641114227238351, 0.89999999999999991, 0.40000000000000002 },
-  { 1.7888013241937863, 0.89999999999999991, 0.50000000000000000 },
-  { 1.7211781128919525, 0.89999999999999991, 0.59999999999999998 },
-  { 1.6600480747670940, 0.89999999999999991, 0.69999999999999996 },
-  { 1.6044591960982202, 0.89999999999999991, 0.80000000000000004 },
-  { 1.5536420236310948, 0.89999999999999991, 0.90000000000000002 },
+  { 2.2805491384227707, 0.90000000000000013, 0.0000000000000000 },
+  { 2.4295011187834890, 0.90000000000000013, 0.10000000000000001 },
+  { 2.6076835743348421, 0.90000000000000013, 0.20000000000000001 },
+  { 2.8256506968858521, 0.90000000000000013, 0.30000000000000004 },
+  { 3.1000689868578628, 0.90000000000000013, 0.40000000000000002 },
+  { 3.4591069002104686, 0.90000000000000013, 0.50000000000000000 },
+  { 3.9549939883570242, 0.90000000000000013, 0.60000000000000009 },
+  { 4.6985482312992453, 0.90000000000000013, 0.70000000000000007 },
+  { 5.9820740813645727, 0.90000000000000013, 0.80000000000000004 },
+  { 8.9942562031858735, 0.90000000000000013, 0.90000000000000002 },
 };
 const double toler019 = 2.5000000000000020e-13;
 
-template<typename Tp, unsigned int Num>
+template<typename Ret, unsigned int Num>
   void
-  test(const testcase_comp_ellint_3<Tp> (&data)[Num], Tp toler)
+  test(const testcase_comp_ellint_3<Ret> (&data)[Num], Ret toler)
   {
-    const Tp eps = std::numeric_limits<Tp>::epsilon();
-    Tp max_abs_diff = -Tp(1);
-    Tp max_abs_frac = -Tp(1);
+    bool test __attribute__((unused)) = true;
+    const Ret eps = std::numeric_limits<Ret>::epsilon();
+    Ret max_abs_diff = -Ret(1);
+    Ret max_abs_frac = -Ret(1);
     unsigned int num_datum = Num;
     for (unsigned int i = 0; i < num_datum; ++i)
       {
-	const Tp f = std::comp_ellint_3(data[i].k, data[i].nu);
-	const Tp f0 = data[i].f0;
-	const Tp diff = f - f0;
+	const Ret f = std::comp_ellint_3(data[i].k, data[i].nu);
+	const Ret f0 = data[i].f0;
+	const Ret diff = f - f0;
 	if (std::abs(diff) > max_abs_diff)
 	  max_abs_diff = std::abs(diff);
-	if (std::abs(f0) > Tp(10) * eps
-	 && std::abs(f) > Tp(10) * eps)
+	if (std::abs(f0) > Ret(10) * eps
+	 && std::abs(f) > Ret(10) * eps)
 	  {
-	    const Tp frac = diff / f0;
+	    const Ret frac = diff / f0;
 	    if (std::abs(frac) > max_abs_frac)
 	      max_abs_frac = std::abs(frac);
 	  }
Index: libstdc++-v3/testsuite/special_functions/14_expint/pr68397.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/special_functions/14_expint/pr68397.cc b/libstdc++-v3/testsuite/special_functions/14_expint/pr68397.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/special_functions/14_expint/pr68397.cc	(revision 262353)
@@ -0,0 +1,47 @@
+// { dg-do run { target c++11 } }
+// { dg-options "-D__STDCPP_WANT_MATH_SPEC_FUNCS__" }
+// Copyright (C) 2017 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// PR libstdc++/68397 -  std::tr1::expint fails in __expint_En_cont_frac
+// for some long double arguments due to low __max_iter value
+
+#include <cmath>
+#include <testsuite_hooks.h>
+
+int
+test01()
+{
+  // Answers from Wolfram Alpha.
+  long double ans_ok = -0.10001943365331651406888645149537315243646135979573L;
+  long double ans_bomb = -0.10777727809650077516264612749163100483995270163783L;
+
+  auto Ei_ok = std::expint(-1.500001L);
+  auto diff_ok = Ei_ok - ans_ok;
+  VERIFY(std::abs(diff_ok) < 1.0e-15);
+
+  auto Ei_bomb = std::expint(-1.450001L);
+  auto diff_bomb = Ei_bomb - ans_bomb;
+  VERIFY(std::abs(diff_bomb) < 1.0e-15);
+}
+
+int
+main()
+{
+  test01();
+  return 0;
+}
Index: libstdc++-v3/testsuite/special_functions/13_ellint_3/pr66689.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/special_functions/13_ellint_3/pr66689.cc b/libstdc++-v3/testsuite/special_functions/13_ellint_3/pr66689.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/special_functions/13_ellint_3/pr66689.cc	(revision 262353)
@@ -0,0 +1,26 @@
+// { dg-do run { target c++11 } }
+// { dg-require-c-std "" }
+// { dg-options "-D__STDCPP_WANT_MATH_SPEC_FUNCS__" }
+// { dg-add-options ieee }
+
+#include <cmath>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  const double pi = 3.141592654;
+
+  double Pi1 = std::ellint_3(0.75, 0.0, pi / 2.0);
+  VERIFY(std::abs(Pi1 - 1.91099) < 0.00001);
+
+  double Pi2 = std::ellint_3(0.75, 0.5, pi / 2.0);
+  VERIFY(std::abs(Pi2 - 2.80011) < 0.00001);
+}
+
+int
+main()
+{
+  test01();
+  return 0;
+}
Index: libstdc++-v3/testsuite/special_functions/13_ellint_3/check_value.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/special_functions/13_ellint_3/check_value.cc b/libstdc++-v3/testsuite/special_functions/13_ellint_3/check_value.cc
--- a/libstdc++-v3/testsuite/special_functions/13_ellint_3/check_value.cc	(revision 262353)
+++ b/libstdc++-v3/testsuite/special_functions/13_ellint_3/check_value.cc	(revision 262353)
@@ -1,7 +1,7 @@
 // { dg-do run { target c++11 } }
 // { dg-options "-D__STDCPP_WANT_MATH_SPEC_FUNCS__" }
 //
-// Copyright (C) 2016-2017 Free Software Foundation, Inc.
+// Copyright (C) 2016-2018 Free Software Foundation, Inc.
 //
 // This file is part of the GNU ISO C++ Library.  This library is free
 // software; you can redistribute it and/or modify it under the
@@ -37,30 +37,32 @@
 #endif
 #include <specfun_testcase.h>
 
-
 // Test data for k=-0.90000000000000002, nu=0.0000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 2.9686139313362077e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 5.7842011620951154e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 4.1942474344433133e-34
+// stddev(f - f_Boost): 2.0479861900030756e-17
 const testcase_ellint_3<double>
 data001[10] =
 {
   { 0.0000000000000000, -0.90000000000000002, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17525427376115024, -0.90000000000000002, 0.0000000000000000, 
+  { 0.17525427376115027, -0.90000000000000002, 0.0000000000000000, 
 	  0.17453292519943295 },
   { 0.35492464591297446, -0.90000000000000002, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.54388221416157112, -0.90000000000000002, 0.0000000000000000, 
+  { 0.54388221416157123, -0.90000000000000002, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.74797400423532490, -0.90000000000000002, 0.0000000000000000, 
+  { 0.74797400423532512, -0.90000000000000002, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.97463898451966458, -0.90000000000000002, 0.0000000000000000, 
+  { 0.97463898451966446, -0.90000000000000002, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.2334463254523440, -0.90000000000000002, 0.0000000000000000, 
+  { 1.2334463254523438, -0.90000000000000002, 0.0000000000000000, 
 	  1.0471975511965976 },
   { 1.5355247765594913, -0.90000000000000002, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.8882928567775121, -0.90000000000000002, 0.0000000000000000, 
+  { 1.8882928567775126, -0.90000000000000002, 0.0000000000000000, 
 	  1.3962634015954636 },
   { 2.2805491384227703, -0.90000000000000002, 0.0000000000000000, 
 	  1.5707963267948966 },
@@ -68,269 +70,299 @@
 const double toler001 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.10000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.0141810743801079e-16
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.1500594295134815e-16
+// mean(f - f_Boost): 1.0269562977782698e-16
+// variance(f - f_Boost): 1.4388836606733082e-32
+// stddev(f - f_Boost): 1.1995347684303728e-16
 const testcase_ellint_3<double>
 data002[10] =
 {
   { 0.0000000000000000, -0.90000000000000002, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17507714233254656, -0.90000000000000002, 0.10000000000000001, 
+  { 0.17543204932716244, -0.90000000000000002, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.35350932904326521, -0.90000000000000002, 0.10000000000000001, 
+  { 0.35636022898551184, -0.90000000000000002, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.53911129989870976, -0.90000000000000002, 0.10000000000000001, 
+  { 0.54880278898382584, -0.90000000000000002, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.73666644254508395, -0.90000000000000002, 0.10000000000000001, 
+  { 0.75988834774529268, -0.90000000000000002, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.95250736612100195, -0.90000000000000002, 0.10000000000000001, 
+  { 0.99853303003568117, -0.90000000000000002, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.1950199550905594, -0.90000000000000002, 0.10000000000000001, 
+  { 1.2759958823999022, -0.90000000000000002, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.4741687286340850, -0.90000000000000002, 0.10000000000000001, 
+  { 1.6051187364639401, -0.90000000000000002, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.7968678183506057, -0.90000000000000002, 0.10000000000000001, 
+  { 1.9941406879519472, -0.90000000000000002, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 2.1537868513875287, -0.90000000000000002, 0.10000000000000001, 
+  { 2.4295011187834881, -0.90000000000000002, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler002 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.20000000000000001.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.0588292817405780e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 5.2711357908578066e-16
+// mean(f - f_Boost): 8.0491169285323847e-17
+// variance(f - f_Boost): 7.9985534974304465e-34
+// stddev(f - f_Boost): 2.8281714052423424e-17
 const testcase_ellint_3<double>
 data003[10] =
 {
   { 0.0000000000000000, -0.90000000000000002, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17490065089140927, -0.90000000000000002, 0.20000000000000001, 
+  { 0.17561047321968409, -0.90000000000000002, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.35211377590661436, -0.90000000000000002, 0.20000000000000001, 
+  { 0.35781659944356109, -0.90000000000000002, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.53448220334204100, -0.90000000000000002, 0.20000000000000001, 
+  { 0.55388150905215283, -0.90000000000000002, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.72591368943179579, -0.90000000000000002, 0.20000000000000001, 
+  { 0.77246874123251441, -0.90000000000000002, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.93192539780038763, -0.90000000000000002, 0.20000000000000001, 
+  { 1.0244466254771925, -0.90000000000000002, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.1600809679692683, -0.90000000000000002, 0.20000000000000001, 
+  { 1.3234824077640801, -0.90000000000000002, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.4195407225882510, -0.90000000000000002, 0.20000000000000001, 
+  { 1.6849848968804237, -0.90000000000000002, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.7168966476424525, -0.90000000000000002, 0.20000000000000001, 
+  { 2.1185749045502273, -0.90000000000000002, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 2.0443194576468890, -0.90000000000000002, 0.20000000000000001, 
+  { 2.6076835743348412, -0.90000000000000002, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler003 = 2.5000000000000020e-13;
 
-// Test data for k=-0.90000000000000002, nu=0.29999999999999999.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.2403611223075570e-16
+// Test data for k=-0.90000000000000002, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.9955372494296814e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 4.1942474344433133e-34
+// stddev(f - f_Boost): 2.0479861900030756e-17
 const testcase_ellint_3<double>
 data004[10] =
 {
-  { 0.0000000000000000, -0.90000000000000002, 0.29999999999999999, 
+  { 0.0000000000000000, -0.90000000000000002, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17472479532647531, -0.90000000000000002, 0.29999999999999999, 
+  { 0.17578954966746221, -0.90000000000000002, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.35073750187374114, -0.90000000000000002, 0.29999999999999999, 
+  { 0.35929429810867447, -0.90000000000000002, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.52998766129466957, -0.90000000000000002, 0.29999999999999999, 
+  { 0.55912757154240811, -0.90000000000000002, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.71566993548699553, -0.90000000000000002, 0.29999999999999999, 
+  { 0.78578314722025389, -0.90000000000000002, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.91271517762560195, -0.90000000000000002, 0.29999999999999999, 
+  { 1.0526941001131365, -0.90000000000000002, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.1281241199843370, -0.90000000000000002, 0.29999999999999999, 
+  { 1.3769682234538601, -0.90000000000000002, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.3704929576917451, -0.90000000000000002, 0.29999999999999999, 
+  { 1.7779437432911238, -0.90000000000000002, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.6461981511487713, -0.90000000000000002, 0.29999999999999999, 
+  { 2.2676509341813631, -0.90000000000000002, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.9486280260314426, -0.90000000000000002, 0.29999999999999999, 
+  { 2.8256506968858512, -0.90000000000000002, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler004 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3487482375512111e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.7042235432234642e-16
+// mean(f - f_Boost): 2.0261570199409106e-16
+// variance(f - f_Boost): 5.8024227149195491e-32
+// stddev(f - f_Boost): 2.4088218520512364e-16
 const testcase_ellint_3<double>
 data005[10] =
 {
   { 0.0000000000000000, -0.90000000000000002, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17454957156468837, -0.90000000000000002, 0.40000000000000002, 
+  { 0.17596928293938452, -0.90000000000000002, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34938003933330430, -0.90000000000000002, 0.40000000000000002, 
+  { 0.36079388642472821, -0.90000000000000002, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.52562093533067433, -0.90000000000000002, 0.40000000000000002, 
+  { 0.56455096667115612, -0.90000000000000002, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.70589461324915670, -0.90000000000000002, 0.40000000000000002, 
+  { 0.79990996997869435, -0.90000000000000002, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.89472658511942849, -0.90000000000000002, 0.40000000000000002, 
+  { 1.0836647913872215, -0.90000000000000002, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 1.0987419542323440, -0.90000000000000002, 0.40000000000000002, 
+  { 1.4378726836091849, -0.90000000000000002, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.3261349565496303, -0.90000000000000002, 0.40000000000000002, 
+  { 1.8880446720682853, -0.90000000000000002, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.5831293909853765, -0.90000000000000002, 0.40000000000000002, 
+  { 2.4505848932025227, -0.90000000000000002, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.8641114227238349, -0.90000000000000002, 0.40000000000000002, 
+  { 3.1000689868578615, -0.90000000000000002, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler005 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.50000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.4538944656036724e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 3.8944086593755267e-16
+// mean(f - f_Boost): 6.9388939039072284e-17
+// variance(f - f_Boost): 1.7333369499485123e-32
+// stddev(f - f_Boost): 1.3165625507162629e-16
 const testcase_ellint_3<double>
 data006[10] =
 {
   { 0.0000000000000000, -0.90000000000000002, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17437497557073334, -0.90000000000000002, 0.50000000000000000, 
+  { 0.17614967734498183, -0.90000000000000002, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34804093691586013, -0.90000000000000002, 0.50000000000000000, 
+  { 0.36231594750319435, -0.90000000000000002, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.52137576320372891, -0.90000000000000002, 0.50000000000000000, 
+  { 0.57016256984349567, -0.90000000000000002, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.69655163996912262, -0.90000000000000002, 0.50000000000000000, 
+  { 0.81494025918293422, -0.90000000000000002, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.87783188683054236, -0.90000000000000002, 0.50000000000000000, 
+  { 1.1178482279283477, -0.90000000000000002, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 1.0716015959755185, -0.90000000000000002, 0.50000000000000000, 
+  { 1.5081455873012106, -0.90000000000000002, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.2857636916026749, -0.90000000000000002, 0.50000000000000000, 
+  { 2.0213599730863998, -0.90000000000000002, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.5264263913252363, -0.90000000000000002, 0.50000000000000000, 
+  { 2.6822467012926827, -0.90000000000000002, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.7888013241937861, -0.90000000000000002, 0.50000000000000000, 
+  { 3.4591069002104677, -0.90000000000000002, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler006 = 2.5000000000000020e-13;
 
-// Test data for k=-0.90000000000000002, nu=0.59999999999999998.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.5560830683344639e-16
+// Test data for k=-0.90000000000000002, nu=0.60000000000000009.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.0602096790645418e-16
+// mean(f - f_Boost): 1.0269562977782698e-16
+// variance(f - f_Boost): 1.4388836606733082e-32
+// stddev(f - f_Boost): 1.1995347684303728e-16
 const testcase_ellint_3<double>
 data007[10] =
 {
-  { 0.0000000000000000, -0.90000000000000002, 0.59999999999999998, 
+  { 0.0000000000000000, -0.90000000000000002, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17420100334657812, -0.90000000000000002, 0.59999999999999998, 
+  { 0.17633073723493825, -0.90000000000000002, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34671975876122157, -0.90000000000000002, 0.59999999999999998, 
+  { 0.36386108723492810, -0.90000000000000002, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.51724631570707946, -0.90000000000000002, 0.59999999999999998, 
+  { 0.57597424744716241, -0.90000000000000002, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.68760879113743023, -0.90000000000000002, 0.59999999999999998, 
+  { 0.83098051948501150, -0.90000000000000002, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.86192157779698364, -0.90000000000000002, 0.59999999999999998, 
+  { 1.1558706545698916, -0.90000000000000002, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 1.0464279696166354, -0.90000000000000002, 0.59999999999999998, 
+  { 1.5905576379415669, -0.90000000000000002, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.2488156247094007, -0.90000000000000002, 0.59999999999999998, 
+  { 2.1875186010215080, -0.90000000000000002, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.4750988777188472, -0.90000000000000002, 0.59999999999999998, 
+  { 2.9885767771316849, -0.90000000000000002, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.7211781128919523, -0.90000000000000002, 0.59999999999999998, 
+  { 3.9549939883570224, -0.90000000000000002, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler007 = 2.5000000000000020e-13;
 
-// Test data for k=-0.90000000000000002, nu=0.69999999999999996.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.4833366769839281e-16
+// Test data for k=-0.90000000000000002, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.1938610791060186e-16
+// mean(f - f_Boost): 3.0253577421035517e-16
+// variance(f - f_Boost): 4.2342877557562532e-32
+// stddev(f - f_Boost): 2.0577385051935665e-16
 const testcase_ellint_3<double>
 data008[10] =
 {
-  { 0.0000000000000000, -0.90000000000000002, 0.69999999999999996, 
+  { 0.0000000000000000, -0.90000000000000002, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17402765093102207, -0.90000000000000002, 0.69999999999999996, 
+  { 0.17651246700160939, -0.90000000000000002, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34541608382635131, -0.90000000000000002, 0.69999999999999996, 
+  { 0.36542993547358982, -0.90000000000000002, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.51322715827061682, -0.90000000000000002, 0.69999999999999996, 
+  { 0.58199897877674867, -0.90000000000000002, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.67903717872440272, -0.90000000000000002, 0.69999999999999996, 
+  { 0.84815633587352857, -0.90000000000000002, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.84690113601682671, -0.90000000000000002, 0.69999999999999996, 
+  { 1.1985495623872375, -0.90000000000000002, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 1.0229914311548418, -0.90000000000000002, 0.69999999999999996, 
+  { 1.6892158134027688, -0.90000000000000002, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.2148329639709381, -0.90000000000000002, 0.69999999999999996, 
+  { 2.4029722191094236, -0.90000000000000002, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.4283586501307803, -0.90000000000000002, 0.69999999999999996, 
+  { 3.4201084941340052, -0.90000000000000002, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.6600480747670940, -0.90000000000000002, 0.69999999999999996, 
+  { 4.6985482312992435, -0.90000000000000002, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler008 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.7525301941362493e-16
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.5091520146032660e-16
+// mean(f - f_Boost): 2.8310687127941490e-16
+// variance(f - f_Boost): 9.8950000698295322e-33
+// stddev(f - f_Boost): 9.9473614943006532e-17
 const testcase_ellint_3<double>
 data009[10] =
 {
   { 0.0000000000000000, -0.90000000000000002, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17385491439925146, -0.90000000000000002, 0.80000000000000004, 
+  { 0.17669487107954862, -0.90000000000000002, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34412950523113928, -0.90000000000000002, 0.80000000000000004, 
+  { 0.36702314729628421, -0.90000000000000002, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.50931321668729590, -0.90000000000000002, 0.80000000000000004, 
+  { 0.58825099711365492, -0.90000000000000002, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.67081081392296327, -0.90000000000000002, 0.80000000000000004, 
+  { 0.86661711422209031, -0.90000000000000002, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.83268846097293259, -0.90000000000000002, 0.80000000000000004, 
+  { 1.2469779109884802, -0.90000000000000002, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 1.0010985015814027, -0.90000000000000002, 0.80000000000000004, 
+  { 1.8105469760531578, -0.90000000000000002, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.1834394045489680, -0.90000000000000002, 0.80000000000000004, 
+  { 2.6989505165893752, -0.90000000000000002, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.3855695891683186, -0.90000000000000002, 0.80000000000000004, 
+  { 4.0935213267757424, -0.90000000000000002, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.6044591960982202, -0.90000000000000002, 0.80000000000000004, 
+  { 5.9820740813645710, -0.90000000000000002, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler009 = 2.5000000000000020e-13;
 
 // Test data for k=-0.90000000000000002, nu=0.90000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8471853989694167e-16
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 8.2628580104449673e-16
+// mean(f - f_Boost): 8.5764728652293339e-16
+// variance(f - f_Boost): 8.9671393318321280e-31
+// stddev(f - f_Boost): 9.4694980499666013e-16
 const testcase_ellint_3<double>
 data010[10] =
 {
   { 0.0000000000000000, -0.90000000000000002, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17368278986240135, -0.90000000000000002, 0.90000000000000002, 
+  { 0.17687795394604169, -0.90000000000000002, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.34285962963961397, -0.90000000000000002, 0.90000000000000002, 
+  { 0.36864140434751286, -0.90000000000000002, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.50549974644993312, -0.90000000000000002, 0.90000000000000002, 
+  { 0.59474595366817051, -0.90000000000000002, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.66290623857720876, -0.90000000000000002, 0.90000000000000002, 
+  { 0.88654237226056665, -0.90000000000000002, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.81921183128847175, -0.90000000000000002, 0.90000000000000002, 
+  { 1.3026595810616726, -0.90000000000000002, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.98058481956066390, -0.90000000000000002, 0.90000000000000002, 
+  { 1.9653635459278078, -0.90000000000000002, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 1.1543223520473569, -0.90000000000000002, 0.90000000000000002, 
+  { 3.1451407527189463, -0.90000000000000002, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.3462119782292938, -0.90000000000000002, 0.90000000000000002, 
+  { 5.3745230680316114, -0.90000000000000002, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.5536420236310946, -0.90000000000000002, 0.90000000000000002, 
+  { 8.9942562031858682, -0.90000000000000002, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler010 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.0000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1175183168766718e-16
+// max(|f - f_Boost|): 1.5543122344752192e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.7898565163847540e-16
+// mean(f - f_Boost): 2.3869795029440865e-16
+// variance(f - f_Boost): 2.1368406725192426e-31
+// stddev(f - f_Boost): 4.6225974002926564e-16
 const testcase_ellint_3<double>
 data011[10] =
 {
@@ -338,289 +370,319 @@
 	  0.0000000000000000 },
   { 0.17510154241338899, -0.80000000000000004, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35365068839779390, -0.80000000000000004, 0.0000000000000000, 
+  { 0.35365068839779396, -0.80000000000000004, 0.0000000000000000, 
 	  0.34906585039886590 },
   { 0.53926804409084550, -0.80000000000000004, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.73587926028070361, -0.80000000000000004, 0.0000000000000000, 
+  { 0.73587926028070372, -0.80000000000000004, 0.0000000000000000, 
 	  0.69813170079773179 },
   { 0.94770942970071170, -0.80000000000000004, 0.0000000000000000, 
 	  0.87266462599716477 },
   { 1.1789022995388236, -0.80000000000000004, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.4323027881876009, -0.80000000000000004, 0.0000000000000000, 
+  { 1.4323027881876012, -0.80000000000000004, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.7069629739121674, -0.80000000000000004, 0.0000000000000000, 
+  { 1.7069629739121677, -0.80000000000000004, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.9953027776647296, -0.80000000000000004, 0.0000000000000000, 
+  { 1.9953027776647294, -0.80000000000000004, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler011 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.10000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1537164503193145e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3898786942190374e-16
+// mean(f - f_Boost): 2.3869795029440865e-16
+// variance(f - f_Boost): 2.9190059990693968e-31
+// stddev(f - f_Boost): 5.4027826155319237e-16
 const testcase_ellint_3<double>
 data012[10] =
 {
   { 0.0000000000000000, -0.80000000000000004, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17492468824017163, -0.80000000000000004, 0.10000000000000001, 
+  { 0.17527903952342144, -0.80000000000000004, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.35224443521476911, -0.80000000000000004, 0.10000000000000001, 
+  { 0.35507705313548549, -0.80000000000000004, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.53456851853226950, -0.80000000000000004, 0.10000000000000001, 
+  { 0.54411455987643553, -0.80000000000000004, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.72488875602364922, -0.80000000000000004, 0.10000000000000001, 
+  { 0.74745625666804383, -0.80000000000000004, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.92661354274638952, -0.80000000000000004, 0.10000000000000001, 
+  { 0.97046953684238557, -0.80000000000000004, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.1432651144499075, -0.80000000000000004, 0.10000000000000001, 
+  { 1.2183080025184605, -0.80000000000000004, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.3774479927211429, -0.80000000000000004, 0.10000000000000001, 
+  { 1.4943711151994405, -0.80000000000000004, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.6287092337196041, -0.80000000000000004, 0.10000000000000001, 
+  { 1.7972401309544201, -0.80000000000000004, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.8910755418379521, -0.80000000000000004, 0.10000000000000001, 
+  { 2.1172616484005085, -0.80000000000000004, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler012 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.20000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1894552974436829e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.8513740186068518e-16
+// mean(f - f_Boost): 2.8310687127941490e-16
+// variance(f - f_Boost): 2.7528339102381189e-31
+// stddev(f - f_Boost): 5.2467455724840699e-16
 const testcase_ellint_3<double>
 data013[10] =
 {
   { 0.0000000000000000, -0.80000000000000004, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17474847286224940, -0.80000000000000004, 0.20000000000000001, 
+  { 0.17545718375086419, -0.80000000000000004, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.35085779529084682, -0.80000000000000004, 0.20000000000000001, 
+  { 0.35652404627248163, -0.80000000000000004, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.53000829263059146, -0.80000000000000004, 0.20000000000000001, 
+  { 0.54911638512920913, -0.80000000000000004, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.71443466027453384, -0.80000000000000004, 0.20000000000000001, 
+  { 0.75967684282131176, -0.80000000000000004, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.90698196872715420, -0.80000000000000004, 0.20000000000000001, 
+  { 0.99513526893543769, -0.80000000000000004, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.1108198200558579, -0.80000000000000004, 0.20000000000000001, 
+  { 1.2622192109995993, -0.80000000000000004, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.3284988909963957, -0.80000000000000004, 0.20000000000000001, 
+  { 1.5654106676347741, -0.80000000000000004, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.5600369318140328, -0.80000000000000004, 0.20000000000000001, 
+  { 1.9029531718534984, -0.80000000000000004, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.8007226661734588, -0.80000000000000004, 0.20000000000000001, 
+  { 2.2624789434186798, -0.80000000000000004, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler013 = 2.5000000000000020e-13;
 
-// Test data for k=-0.80000000000000004, nu=0.29999999999999999.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2247517409029886e-16
+// Test data for k=-0.80000000000000004, nu=0.30000000000000004.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.2825261583337354e-16
+// mean(f - f_Boost): 2.6367796834847468e-16
+// variance(f - f_Boost): 2.8249350208968825e-31
+// stddev(f - f_Boost): 5.3150117788175054e-16
 const testcase_ellint_3<double>
 data014[10] =
 {
-  { 0.0000000000000000, -0.80000000000000004, 0.29999999999999999, 
+  { 0.0000000000000000, -0.80000000000000004, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17457289217669889, -0.80000000000000004, 0.29999999999999999, 
+  { 0.17563597931587369, -0.80000000000000004, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34949028801501258, -0.80000000000000004, 0.29999999999999999, 
+  { 0.35799220412005128, -0.80000000000000004, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.52558024362769307, -0.80000000000000004, 0.29999999999999999, 
+  { 0.55428253691111318, -0.80000000000000004, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.70447281740094891, -0.80000000000000004, 0.29999999999999999, 
+  { 0.77260647376977365, -0.80000000000000004, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.88864745641528986, -0.80000000000000004, 0.29999999999999999, 
+  { 1.0220015271210958, -0.80000000000000004, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.0811075819341462, -0.80000000000000004, 0.29999999999999999, 
+  { 1.3115965312302671, -0.80000000000000004, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.2844589654082377, -0.80000000000000004, 0.29999999999999999, 
+  { 1.6478518468813512, -0.80000000000000004, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.4991461361277847, -0.80000000000000004, 0.29999999999999999, 
+  { 2.0290458414203481, -0.80000000000000004, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.7214611048717301, -0.80000000000000004, 0.29999999999999999, 
+  { 2.4392042002725693, -0.80000000000000004, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler014 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2596216594752862e-16
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3462748389836647e-16
+// mean(f - f_Boost): 3.3861802251067273e-16
+// variance(f - f_Boost): 4.3719465706454422e-31
+// stddev(f - f_Boost): 6.6120696991527871e-16
 const testcase_ellint_3<double>
 data015[10] =
 {
   { 0.0000000000000000, -0.80000000000000004, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17439794211872175, -0.80000000000000004, 0.40000000000000002, 
+  { 0.17581543047866136, -0.80000000000000004, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34814144964568972, -0.80000000000000004, 0.40000000000000002, 
+  { 0.35948208343061633, -0.80000000000000004, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.52127776285273064, -0.80000000000000004, 0.40000000000000002, 
+  { 0.55962280893702021, -0.80000000000000004, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.69496411438966588, -0.80000000000000004, 0.40000000000000002, 
+  { 0.78632063889234116, -0.80000000000000004, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.87146878427509589, -0.80000000000000004, 0.40000000000000002, 
+  { 1.0514333069550323, -0.80000000000000004, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 1.0537579024937762, -0.80000000000000004, 0.40000000000000002, 
+  { 1.3677213138838757, -0.80000000000000004, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.2445534387922637, -0.80000000000000004, 0.40000000000000002, 
+  { 1.7451736773665165, -0.80000000000000004, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.4446769766361993, -0.80000000000000004, 0.40000000000000002, 
+  { 2.1830100424586831, -0.80000000000000004, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.6512267838651289, -0.80000000000000004, 0.40000000000000002, 
+  { 2.6604037035529724, -0.80000000000000004, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler015 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.50000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2940800093915668e-16
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0388243828581744e-16
+// mean(f - f_Boost): 3.8580250105724191e-16
+// variance(f - f_Boost): 6.4106456575047741e-31
+// stddev(f - f_Boost): 8.0066507713929764e-16
 const testcase_ellint_3<double>
 data016[10] =
 {
   { 0.0000000000000000, -0.80000000000000004, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17422361866118044, -0.80000000000000004, 0.50000000000000000, 
+  { 0.17599554153999472, -0.80000000000000004, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34681083254170475, -0.80000000000000004, 0.50000000000000000, 
+  { 0.36099426243351540, -0.80000000000000004, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.51709470815494440, -0.80000000000000004, 0.50000000000000000, 
+  { 0.56514786174780673, -0.80000000000000004, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.68587375344080237, -0.80000000000000004, 0.50000000000000000, 
+  { 0.80090697622371010, -0.80000000000000004, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.85532571852810624, -0.80000000000000004, 0.50000000000000000, 
+  { 1.0838891627679339, -0.80000000000000004, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 1.0284677391874903, -0.80000000000000004, 0.50000000000000000, 
+  { 1.4323506654466280, -0.80000000000000004, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.2081693942686225, -0.80000000000000004, 0.50000000000000000, 
+  { 1.8625761085390575, -0.80000000000000004, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.3955803006426311, -0.80000000000000004, 0.50000000000000000, 
+  { 2.3768757305654766, -0.80000000000000004, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.5884528947755532, -0.80000000000000004, 0.50000000000000000, 
+  { 2.9478781158239746, -0.80000000000000004, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler016 = 2.5000000000000020e-13;
 
-// Test data for k=-0.80000000000000004, nu=0.59999999999999998.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3281408974056389e-16
+// Test data for k=-0.80000000000000004, nu=0.60000000000000009.
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.0631099169042069e-15
+// mean(f - f_Boost): 4.8294701571194306e-16
+// variance(f - f_Boost): 1.1633910328160319e-30
+// stddev(f - f_Boost): 1.0786060600682865e-15
 const testcase_ellint_3<double>
 data017[10] =
 {
-  { 0.0000000000000000, -0.80000000000000004, 0.59999999999999998, 
+  { 0.0000000000000000, -0.80000000000000004, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17404991781414089, -0.80000000000000004, 0.59999999999999998, 
+  { 0.17617631684170665, -0.80000000000000004, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34549800443625167, -0.80000000000000004, 0.59999999999999998, 
+  { 0.36252934193666231, -0.80000000000000004, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.51302536167001545, -0.80000000000000004, 0.59999999999999998, 
+  { 0.57086932622945163, -0.80000000000000004, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.67717065003912236, -0.80000000000000004, 0.59999999999999998, 
+  { 0.81646796740150973, -0.80000000000000004, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.84011512421134416, -0.80000000000000004, 0.59999999999999998, 
+  { 1.1199552158519064, -0.80000000000000004, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 1.0049863847088740, -0.80000000000000004, 0.59999999999999998, 
+  { 1.5079766673336394, -0.80000000000000004, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.1748145941898920, -0.80000000000000004, 0.59999999999999998, 
+  { 2.0082747447038165, -0.80000000000000004, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.3510319699755071, -0.80000000000000004, 0.59999999999999998, 
+  { 2.6315146066775523, -0.80000000000000004, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.5319262547427865, -0.80000000000000004, 0.59999999999999998, 
+  { 3.3418121892288051, -0.80000000000000004, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler017 = 2.5000000000000020e-13;
 
-// Test data for k=-0.80000000000000004, nu=0.69999999999999996.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3618176466061808e-16
+// Test data for k=-0.80000000000000004, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.6544679145741375e-16
+// mean(f - f_Boost): 3.2751579226442120e-16
+// variance(f - f_Boost): 4.4236851331020672e-31
+// stddev(f - f_Boost): 6.6510789599147505e-16
 const testcase_ellint_3<double>
 data018[10] =
 {
-  { 0.0000000000000000, -0.80000000000000004, 0.69999999999999996, 
+  { 0.0000000000000000, -0.80000000000000004, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17387683562442199, -0.80000000000000004, 0.69999999999999996, 
+  { 0.17635776076721221, -0.80000000000000004, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34420254775101611, -0.80000000000000004, 0.69999999999999996, 
+  { 0.36408794649916976, -0.80000000000000004, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.50906439222143673, -0.80000000000000004, 0.69999999999999996, 
+  { 0.57679992290624138, -0.80000000000000004, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.66882693152688422, -0.80000000000000004, 0.69999999999999996, 
+  { 0.83312441418142813, -0.80000000000000004, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.82574792844091316, -0.80000000000000004, 0.69999999999999996, 
+  { 1.1603958891464856, -0.80000000000000004, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.98310431309490931, -0.80000000000000004, 0.69999999999999996, 
+  { 1.5982855143796213, -0.80000000000000004, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.1440884535113258, -0.80000000000000004, 0.69999999999999996, 
+  { 2.1962484408371821, -0.80000000000000004, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.3103743938952537, -0.80000000000000004, 0.69999999999999996, 
+  { 2.9873281786111869, -0.80000000000000004, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.4806912324625332, -0.80000000000000004, 0.69999999999999996, 
+  { 3.9268876980046397, -0.80000000000000004, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler018 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3951228558314112e-16
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0176949165011079e-16
+// mean(f - f_Boost): 7.0499162063697436e-16
+// variance(f - f_Boost): 1.7230805408026989e-30
+// stddev(f - f_Boost): 1.3126616246400665e-15
 const testcase_ellint_3<double>
 data019[10] =
 {
   { 0.0000000000000000, -0.80000000000000004, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17370436817515203, -0.80000000000000004, 0.80000000000000004, 
+  { 0.17653987774203392, -0.80000000000000004, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34292405894783395, -0.80000000000000004, 0.80000000000000004, 
+  { 0.36567072568046877, -0.80000000000000004, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.50520682176250076, -0.80000000000000004, 0.80000000000000004, 
+  { 0.58295359996558616, -0.80000000000000004, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.66081751679736178, -0.80000000000000004, 0.80000000000000004, 
+  { 0.85101998309176108, -0.80000000000000004, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.81214672249355102, -0.80000000000000004, 0.80000000000000004, 
+  { 1.2062322059736537, -0.80000000000000004, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.96264481387685552, -0.80000000000000004, 0.80000000000000004, 
+  { 1.7090321420917429, -0.80000000000000004, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.1156611352656258, -0.80000000000000004, 0.80000000000000004, 
+  { 2.4529058049405066, -0.80000000000000004, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.2730756225143889, -0.80000000000000004, 0.80000000000000004, 
+  { 3.5368893360106948, -0.80000000000000004, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.4339837018309471, -0.80000000000000004, 0.80000000000000004, 
+  { 4.9246422058196062, -0.80000000000000004, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler019 = 2.5000000000000020e-13;
 
 // Test data for k=-0.80000000000000004, nu=0.90000000000000002.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 4.4280684534289690e-16
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.7782721357365268e-16
+// mean(f - f_Boost): 8.9928064994637676e-16
+// variance(f - f_Boost): 1.5485199571025344e-30
+// stddev(f - f_Boost): 1.2443954183066307e-15
 const testcase_ellint_3<double>
 data020[10] =
 {
   { 0.0000000000000000, -0.80000000000000004, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17353251158533151, -0.80000000000000004, 0.90000000000000002, 
+  { 0.17672267223433513, -0.80000000000000004, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.34166214791545768, -0.80000000000000004, 0.90000000000000002, 
+  { 0.36727835537196063, -0.80000000000000004, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.50144799535130569, -0.80000000000000004, 0.90000000000000002, 
+  { 0.58934569363716649, -0.80000000000000004, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.65311976193814425, -0.80000000000000004, 0.90000000000000002, 
+  { 0.87032723471138851, -0.80000000000000004, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.79924384892320866, -0.80000000000000004, 0.90000000000000002, 
+  { 1.2588676111323349, -0.80000000000000004, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.94345762353365603, -0.80000000000000004, 0.90000000000000002, 
+  { 1.8498731900660019, -0.80000000000000004, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 1.0892582069219161, -0.80000000000000004, 0.90000000000000002, 
+  { 2.8368381299300420, -0.80000000000000004, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.2387000876610268, -0.80000000000000004, 0.90000000000000002, 
+  { 4.5674844191654058, -0.80000000000000004, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.3911845406776222, -0.80000000000000004, 0.90000000000000002, 
+  { 7.2263259298637115, -0.80000000000000004, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler020 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.0000000000000000.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.5930208052157665e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.5425633303580569e-16
+// mean(f - f_Boost): 7.7715611723760953e-17
+// variance(f - f_Boost): 7.4564398834547797e-34
+// stddev(f - f_Boost): 2.7306482533374340e-17
 const testcase_ellint_3<double>
 data021[10] =
 {
@@ -628,289 +690,319 @@
 	  0.0000000000000000 },
   { 0.17496737466916723, -0.69999999999999996, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35254687535677925, -0.69999999999999996, 0.0000000000000000, 
+  { 0.35254687535677931, -0.69999999999999996, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.53536740275997119, -0.69999999999999996, 0.0000000000000000, 
+  { 0.53536740275997130, -0.69999999999999996, 0.0000000000000000, 
 	  0.52359877559829882 },
   { 0.72603797651684454, -0.69999999999999996, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.92698296348313458, -0.69999999999999996, 0.0000000000000000, 
+  { 0.92698296348313447, -0.69999999999999996, 0.0000000000000000, 
 	  0.87266462599716477 },
   { 1.1400447527693316, -0.69999999999999996, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.3657668117194073, -0.69999999999999996, 0.0000000000000000, 
+  { 1.3657668117194071, -0.69999999999999996, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.6024686895959159, -0.69999999999999996, 0.0000000000000000, 
+  { 1.6024686895959162, -0.69999999999999996, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.8456939983747236, -0.69999999999999996, 0.0000000000000000, 
+  { 1.8456939983747234, -0.69999999999999996, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler021 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.10000000000000001.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.6735282577377367e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.2736371663370261e-16
+// mean(f - f_Boost): 8.8817841970012528e-17
+// variance(f - f_Boost): 9.7390235212470591e-34
+// stddev(f - f_Boost): 3.1207408609570677e-17
 const testcase_ellint_3<double>
 data022[10] =
 {
   { 0.0000000000000000, -0.69999999999999996, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17479076384884684, -0.69999999999999996, 0.10000000000000001, 
+  { 0.17514462737300920, -0.69999999999999996, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.35114844900396364, -0.69999999999999996, 0.10000000000000001, 
+  { 0.35396527997470451, -0.69999999999999996, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.53072776947527001, -0.69999999999999996, 0.10000000000000001, 
+  { 0.54015179589433981, -0.69999999999999996, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.71530198262386235, -0.69999999999999996, 0.10000000000000001, 
+  { 0.73734430854477728, -0.69999999999999996, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.90666760677828306, -0.69999999999999996, 0.10000000000000001, 
+  { 0.94888950796697047, -0.69999999999999996, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.1063366517438080, -0.69999999999999996, 0.10000000000000001, 
+  { 1.1772807959736322, -0.69999999999999996, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.3149477243092149, -0.69999999999999996, 0.10000000000000001, 
+  { 1.4231796401075831, -0.69999999999999996, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.5314886725038925, -0.69999999999999996, 0.10000000000000001, 
+  { 1.6841856799887469, -0.69999999999999996, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.7528050171757608, -0.69999999999999996, 0.10000000000000001, 
+  { 1.9541347343119562, -0.69999999999999996, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler022 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.20000000000000001.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.7517969287516802e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.9907249355047774e-16
+// mean(f - f_Boost): 3.3306690738754695e-17
+// variance(f - f_Boost): 1.3695501826753678e-34
+// stddev(f - f_Boost): 1.1702778228589003e-17
 const testcase_ellint_3<double>
 data023[10] =
 {
   { 0.0000000000000000, -0.69999999999999996, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17461479077791475, -0.69999999999999996, 0.20000000000000001, 
+  { 0.17532252613350796, -0.69999999999999996, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34976950621407538, -0.69999999999999996, 0.20000000000000001, 
+  { 0.35540417596807522, -0.69999999999999996, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.52622533231350177, -0.69999999999999996, 0.20000000000000001, 
+  { 0.54508913033361928, -0.69999999999999996, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.70508774017895215, -0.69999999999999996, 0.20000000000000001, 
+  { 0.74927635777718415, -0.69999999999999996, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.88775302531730294, -0.69999999999999996, 0.20000000000000001, 
+  { 0.97261706337936338, -0.69999999999999996, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0756195476149006, -0.69999999999999996, 0.20000000000000001, 
+  { 1.2187303976209327, -0.69999999999999996, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.2695349716654374, -0.69999999999999996, 0.20000000000000001, 
+  { 1.4887796709222487, -0.69999999999999996, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.4690814617070540, -0.69999999999999996, 0.20000000000000001, 
+  { 1.7796581281839212, -0.69999999999999996, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.6721098780092145, -0.69999999999999996, 0.20000000000000001, 
+  { 2.0829290325820202, -0.69999999999999996, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler023 = 2.5000000000000020e-13;
 
-// Test data for k=-0.69999999999999996, nu=0.29999999999999999.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8280039841080712e-16
+// Test data for k=-0.69999999999999996, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.6912897610535316e-16
+// mean(f - f_Boost): 1.6653345369377347e-17
+// variance(f - f_Boost): 2.6207864467918357e-32
+// stddev(f - f_Boost): 1.6188843216214787e-16
 const testcase_ellint_3<double>
 data024[10] =
 {
-  { 0.0000000000000000, -0.69999999999999996, 0.29999999999999999, 
+  { 0.0000000000000000, -0.69999999999999996, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17443945136076175, -0.69999999999999996, 0.29999999999999999, 
+  { 0.17550107516328570, -0.69999999999999996, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34840956983535287, -0.69999999999999996, 0.29999999999999999, 
+  { 0.35686409576571959, -0.69999999999999996, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.52185308551329168, -0.69999999999999996, 0.29999999999999999, 
+  { 0.55018827316513352, -0.69999999999999996, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.69535240431168255, -0.69999999999999996, 0.29999999999999999, 
+  { 0.76189759494390275, -0.69999999999999996, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.87007983473964923, -0.69999999999999996, 0.29999999999999999, 
+  { 0.99844623430885615, -0.69999999999999996, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.0474657975577066, -0.69999999999999996, 0.29999999999999999, 
+  { 1.2652862989039833, -0.69999999999999996, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.2286225419931891, -0.69999999999999996, 0.29999999999999999, 
+  { 1.5647666808691361, -0.69999999999999996, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.4136490671013271, -0.69999999999999996, 0.29999999999999999, 
+  { 1.8932499694938163, -0.69999999999999996, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.6011813647733213, -0.69999999999999996, 0.29999999999999999, 
+  { 2.2392290510988535, -0.69999999999999996, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler024 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3472957053482092e-16
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.5578567644745380e-16
+// mean(f - f_Boost): 1.4710455076283324e-16
+// variance(f - f_Boost): 2.6715739327327140e-33
+// stddev(f - f_Boost): 5.1687270509601433e-17
 const testcase_ellint_3<double>
 data025[10] =
 {
   { 0.0000000000000000, -0.69999999999999996, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17426474153983229, -0.69999999999999996, 0.40000000000000002, 
+  { 0.17568027871494424, -0.69999999999999996, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34706817945773732, -0.69999999999999996, 0.40000000000000002, 
+  { 0.35834559208180261, -0.69999999999999996, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.51760452851738148, -0.69999999999999996, 0.40000000000000002, 
+  { 0.55545885451190613, -0.69999999999999996, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.68605801534722755, -0.69999999999999996, 0.40000000000000002, 
+  { 0.77528120402568101, -0.69999999999999996, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.85351339387296532, -0.69999999999999996, 0.40000000000000002, 
+  { 1.0267241287600319, -0.69999999999999996, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 1.0215297967969539, -0.69999999999999996, 0.40000000000000002, 
+  { 1.3181380338980246, -0.69999999999999996, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.1915051074460530, -0.69999999999999996, 0.40000000000000002, 
+  { 1.6542840785132085, -0.69999999999999996, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.3639821911744707, -0.69999999999999996, 0.40000000000000002, 
+  { 2.0315595131131818, -0.69999999999999996, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.5382162002954762, -0.69999999999999996, 0.40000000000000002, 
+  { 2.4342502915307875, -0.69999999999999996, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler025 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.50000000000000000.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.9748346743390620e-16
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.0416041815443256e-16
+// mean(f - f_Boost): 1.9151347174783951e-16
+// variance(f - f_Boost): 7.8758646268991113e-33
+// stddev(f - f_Boost): 8.8746068233466605e-17
 const testcase_ellint_3<double>
 data026[10] =
 {
   { 0.0000000000000000, -0.69999999999999996, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17409065729516096, -0.69999999999999996, 0.50000000000000000, 
+  { 0.17586014108156545, -0.69999999999999996, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34574489064986091, -0.69999999999999996, 0.50000000000000000, 
+  { 0.35984923894341653, -0.69999999999999996, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.51347361925579782, -0.69999999999999996, 0.50000000000000000, 
+  { 0.56091135606739995, -0.69999999999999996, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.67717079489579279, -0.69999999999999996, 0.50000000000000000, 
+  { 0.78951212635197054, -0.69999999999999996, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.83793902055292280, -0.69999999999999996, 0.50000000000000000, 
+  { 1.0578865732938729, -0.69999999999999996, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.99752863545289705, -0.69999999999999996, 0.50000000000000000, 
+  { 1.3789149005151722, -0.69999999999999996, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.1576240080401501, -0.69999999999999996, 0.50000000000000000, 
+  { 1.7620212286086225, -0.69999999999999996, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.3191464023923762, -0.69999999999999996, 0.50000000000000000, 
+  { 2.2051554347435585, -0.69999999999999996, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.4818433192178544, -0.69999999999999996, 0.50000000000000000, 
+  { 2.6868019968236991, -0.69999999999999996, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler026 = 2.5000000000000020e-13;
 
-// Test data for k=-0.69999999999999996, nu=0.59999999999999998.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 4.0457157538295173e-16
+// Test data for k=-0.69999999999999996, nu=0.60000000000000009.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.6515644573247170e-16
+// mean(f - f_Boost): 9.9920072216264091e-17
+// variance(f - f_Boost): 1.2325951644078310e-33
+// stddev(f - f_Boost): 3.5108334685767011e-17
 const testcase_ellint_3<double>
 data027[10] =
 {
-  { 0.0000000000000000, -0.69999999999999996, 0.59999999999999998, 
+  { 0.0000000000000000, -0.69999999999999996, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17391719464391614, -0.69999999999999996, 0.59999999999999998, 
+  { 0.17604066659721918, -0.69999999999999996, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34443927423869031, -0.69999999999999996, 0.59999999999999998, 
+  { 0.36137563278353424, -0.69999999999999996, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50945473266486063, -0.69999999999999996, 0.59999999999999998, 
+  { 0.56655721272747606, -0.69999999999999996, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.66866056326513812, -0.69999999999999996, 0.59999999999999998, 
+  { 0.80468966552978305, -0.69999999999999996, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.82325830002337352, -0.69999999999999996, 0.59999999999999998, 
+  { 1.0924902943683852, -0.69999999999999996, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.97522808245669368, -0.69999999999999996, 0.59999999999999998, 
+  { 1.4499247992499797, -0.69999999999999996, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.1265300613705285, -0.69999999999999996, 0.59999999999999998, 
+  { 1.8953714382113815, -0.69999999999999996, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.2784066076152001, -0.69999999999999996, 0.59999999999999998, 
+  { 2.4323229949248670, -0.69999999999999996, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.4309994736080540, -0.69999999999999996, 0.59999999999999998, 
+  { 3.0314573496746742, -0.69999999999999996, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler027 = 2.5000000000000020e-13;
 
-// Test data for k=-0.69999999999999996, nu=0.69999999999999996.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 5.4867405596732161e-16
+// Test data for k=-0.69999999999999996, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.8475278552871384e-16
+// mean(f - f_Boost): 9.9920072216264091e-17
+// variance(f - f_Boost): 1.2325951644078310e-33
+// stddev(f - f_Boost): 3.5108334685767011e-17
 const testcase_ellint_3<double>
 data028[10] =
 {
-  { 0.0000000000000000, -0.69999999999999996, 0.69999999999999996, 
+  { 0.0000000000000000, -0.69999999999999996, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17374434963995031, -0.69999999999999996, 0.69999999999999996, 
+  { 0.17622185963747933, -0.69999999999999996, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34315091562900674, -0.69999999999999996, 0.69999999999999996, 
+  { 0.36292539360435261, -0.69999999999999996, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.50554262375653347, -0.69999999999999996, 0.69999999999999996, 
+  { 0.57240892970150015, -0.69999999999999996, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.66050025406305801, -0.69999999999999996, 0.69999999999999996, 
+  { 0.82093084713182629, -0.69999999999999996, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.80938620118847404, -0.69999999999999996, 0.69999999999999996, 
+  { 1.1312609022179871, -0.69999999999999996, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.95443223855852144, -0.69999999999999996, 0.69999999999999996, 
+  { 1.5345768067715795, -0.69999999999999996, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0978573207128304, -0.69999999999999996, 0.69999999999999996, 
+  { 2.0668847445934420, -0.69999999999999996, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.2411754575007123, -0.69999999999999996, 0.69999999999999996, 
+  { 2.7483444537551240, -0.69999999999999996, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.3848459188329196, -0.69999999999999996, 0.69999999999999996, 
+  { 3.5408408771788560, -0.69999999999999996, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler028 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1829502028913879e-16
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.8664526853112274e-16
+// mean(f - f_Boost): 1.6930901125533636e-16
+// variance(f - f_Boost): 3.5389557150937801e-33
+// stddev(f - f_Boost): 5.9489122661994095e-17
 const testcase_ellint_3<double>
 data029[10] =
 {
   { 0.0000000000000000, -0.69999999999999996, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17357211837335740, -0.69999999999999996, 0.80000000000000004, 
+  { 0.17640372461994805, -0.69999999999999996, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34187941416012108, -0.69999999999999996, 0.80000000000000004, 
+  { 0.36449916621651091, -0.69999999999999996, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.50173239465478259, -0.69999999999999996, 0.80000000000000004, 
+  { 0.57848021800372573, -0.69999999999999996, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.65266550725988315, -0.69999999999999996, 0.80000000000000004, 
+  { 0.83837480968392586, -0.69999999999999996, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.79624879865249298, -0.69999999999999996, 0.80000000000000004, 
+  { 1.1751669030061143, -0.69999999999999996, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.93497577043296920, -0.69999999999999996, 0.80000000000000004, 
+  { 1.6381851899173601, -0.69999999999999996, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.0713041566930750, -0.69999999999999996, 0.80000000000000004, 
+  { 2.3002065924302197, -0.69999999999999996, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.2069772023255654, -0.69999999999999996, 0.80000000000000004, 
+  { 3.2337600665337862, -0.69999999999999996, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.3427110650397531, -0.69999999999999996, 0.80000000000000004, 
+  { 4.4042405729076961, -0.69999999999999996, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler029 = 2.5000000000000020e-13;
 
 // Test data for k=-0.69999999999999996, nu=0.90000000000000002.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2494869624129105e-16
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 8.5869439826269878e-16
+// mean(f - f_Boost): 6.7723604502134545e-16
+// variance(f - f_Boost): 4.8757508225668289e-31
+// stddev(f - f_Boost): 6.9826576763914390e-16
 const testcase_ellint_3<double>
 data030[10] =
 {
   { 0.0000000000000000, -0.69999999999999996, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17340049697003637, -0.69999999999999996, 0.90000000000000002, 
+  { 0.17658626600478800, -0.69999999999999996, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.34062438249741556, -0.69999999999999996, 0.90000000000000002, 
+  { 0.36609762156017206, -0.69999999999999996, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.49801946510076867, -0.69999999999999996, 0.90000000000000002, 
+  { 0.58478615187842409, -0.69999999999999996, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.64513432604750476, -0.69999999999999996, 0.90000000000000002, 
+  { 0.85718862878291846, -0.69999999999999996, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.78378145487573758, -0.69999999999999996, 0.90000000000000002, 
+  { 1.2255385617397643, -0.69999999999999996, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.91671799500854623, -0.69999999999999996, 0.90000000000000002, 
+  { 1.7696521899992939, -0.69999999999999996, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 1.0466193579463123, -0.69999999999999996, 0.90000000000000002, 
+  { 2.6476314987883502, -0.69999999999999996, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.1754218079199146, -0.69999999999999996, 0.90000000000000002, 
+  { 4.1373434902898083, -0.69999999999999996, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.3040500499695913, -0.69999999999999996, 0.90000000000000002, 
+  { 6.3796094177887746, -0.69999999999999996, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler030 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.0000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 2.8964816695821429e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.3664899092028927e-16
+// mean(f - f_Boost): 5.2735593669694933e-17
+// variance(f - f_Boost): 3.4333862218458872e-34
+// stddev(f - f_Boost): 1.8529398861932589e-17
 const testcase_ellint_3<double>
 data031[10] =
 {
@@ -918,289 +1010,319 @@
 	  0.0000000000000000 },
   { 0.17485154362988359, -0.59999999999999998, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35160509865544326, -0.59999999999999998, 0.0000000000000000, 
+  { 0.35160509865544320, -0.59999999999999998, 0.0000000000000000, 
 	  0.34906585039886590 },
   { 0.53210652578446138, -0.59999999999999998, 0.0000000000000000, 
 	  0.52359877559829882 },
   { 0.71805304664485659, -0.59999999999999998, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.91082759030195970, -0.59999999999999998, 0.0000000000000000, 
+  { 0.91082759030195981, -0.59999999999999998, 0.0000000000000000, 
 	  0.87266462599716477 },
   { 1.1112333229323361, -0.59999999999999998, 0.0000000000000000, 
 	  1.0471975511965976 },
   { 1.3191461190365270, -0.59999999999999998, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.5332022105084773, -0.59999999999999998, 0.0000000000000000, 
+  { 1.5332022105084779, -0.59999999999999998, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.7507538029157526, -0.59999999999999998, 0.0000000000000000, 
+  { 1.7507538029157523, -0.59999999999999998, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler031 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.10000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 2.6674242225057385e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.2335247010355137e-16
+// mean(f - f_Boost): 8.6042284408449634e-17
+// variance(f - f_Boost): 2.2835347143080263e-33
+// stddev(f - f_Boost): 4.7786344433405099e-17
 const testcase_ellint_3<double>
 data032[10] =
 {
   { 0.0000000000000000, -0.59999999999999998, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17467514275022011, -0.59999999999999998, 0.10000000000000001, 
+  { 0.17502858548476194, -0.59999999999999998, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.35021333086258255, -0.59999999999999998, 0.10000000000000001, 
+  { 0.35301673150537388, -0.59999999999999998, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52751664092962691, -0.59999999999999998, 0.10000000000000001, 
+  { 0.53683932476326812, -0.59999999999999998, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.70752126971957874, -0.59999999999999998, 0.10000000000000001, 
+  { 0.72914228589586771, -0.59999999999999998, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.89111058756112871, -0.59999999999999998, 0.10000000000000001, 
+  { 0.93208036718354692, -0.59999999999999998, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0789241202877768, -0.59999999999999998, 0.10000000000000001, 
+  { 1.1468984688863377, -0.59999999999999998, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.2710800210399946, -0.59999999999999998, 0.10000000000000001, 
+  { 1.3733904977062528, -0.59999999999999998, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.4669060574440276, -0.59999999999999998, 0.10000000000000001, 
+  { 1.6094225663372157, -0.59999999999999998, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.6648615773343014, -0.59999999999999998, 0.10000000000000001, 
+  { 1.8508766487100685, -0.59999999999999998, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler032 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.20000000000000001.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1891472451898755e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0940560416437693e-16
+// mean(f - f_Boost): 4.1633363423443370e-17
+// variance(f - f_Boost): 8.5834655546147173e-33
+// stddev(f - f_Boost): 9.2646994309662939e-17
 const testcase_ellint_3<double>
 data033[10] =
 {
   { 0.0000000000000000, -0.59999999999999998, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17449937871800650, -0.59999999999999998, 0.20000000000000001, 
+  { 0.17520627248155893, -0.59999999999999998, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34884093647346553, -0.59999999999999998, 0.20000000000000001, 
+  { 0.35444873935437748, -0.59999999999999998, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.52306221119844087, -0.59999999999999998, 0.20000000000000001, 
+  { 0.54172310557682524, -0.59999999999999998, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.69749955678982223, -0.59999999999999998, 0.20000000000000001, 
+  { 0.74084300280734672, -0.59999999999999998, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.87274610682416853, -0.59999999999999998, 0.20000000000000001, 
+  { 0.95509001527006121, -0.59999999999999998, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0494620540750792, -0.59999999999999998, 0.20000000000000001, 
+  { 1.1865688084431796, -0.59999999999999998, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.2280847305507339, -0.59999999999999998, 0.20000000000000001, 
+  { 1.4352978868932598, -0.59999999999999998, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.4085436279696886, -0.59999999999999998, 0.20000000000000001, 
+  { 1.6983400371331816, -0.59999999999999998, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.5901418016279374, -0.59999999999999998, 0.20000000000000001, 
+  { 1.9695980282802215, -0.59999999999999998, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler033 = 2.5000000000000020e-13;
 
-// Test data for k=-0.59999999999999998, nu=0.29999999999999999.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 2.9132420715478757e-16
+// Test data for k=-0.59999999999999998, nu=0.30000000000000004.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.9470074709717020e-16
+// mean(f - f_Boost): 7.4940054162198071e-17
+// variance(f - f_Boost): 1.6823592487044846e-32
+// stddev(f - f_Boost): 1.2970579203352812e-16
 const testcase_ellint_3<double>
 data034[10] =
 {
-  { 0.0000000000000000, -0.59999999999999998, 0.29999999999999999, 
+  { 0.0000000000000000, -0.59999999999999998, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17432424744393932, -0.59999999999999998, 0.29999999999999999, 
+  { 0.17538460882640122, -0.59999999999999998, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34748744127146447, -0.59999999999999998, 0.29999999999999999, 
+  { 0.35590165133735557, -0.59999999999999998, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51873632743924825, -0.59999999999999998, 0.29999999999999999, 
+  { 0.54676661152254535, -0.59999999999999998, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.68794610396313116, -0.59999999999999998, 0.29999999999999999, 
+  { 0.75321709418305305, -0.59999999999999998, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.85558070175468726, -0.59999999999999998, 0.29999999999999999, 
+  { 0.98012637808992920, -0.59999999999999998, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.0224416343605653, -0.59999999999999998, 0.29999999999999999, 
+  { 1.2310891277158875, -0.59999999999999998, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1893144457936788, -0.59999999999999998, 0.29999999999999999, 
+  { 1.5069157924585623, -0.59999999999999998, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.3566435377982575, -0.59999999999999998, 0.29999999999999999, 
+  { 1.8039583598337940, -0.59999999999999998, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.5243814243493585, -0.59999999999999998, 0.29999999999999999, 
+  { 2.1134154405060599, -0.59999999999999998, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler034 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3897581541285558e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.7909659715991921e-16
+// mean(f - f_Boost): -2.7755575615628915e-18
+// variance(f - f_Boost): 2.4044165394594425e-32
+// stddev(f - f_Boost): 1.5506181152880429e-16
 const testcase_ellint_3<double>
 data035[10] =
 {
   { 0.0000000000000000, -0.59999999999999998, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17414974487670717, -0.59999999999999998, 0.40000000000000002, 
+  { 0.17556359876533037, -0.59999999999999998, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34615238767335027, -0.59999999999999998, 0.40000000000000002, 
+  { 0.35737601674244679, -0.59999999999999998, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.51453257838108557, -0.59999999999999998, 0.40000000000000002, 
+  { 0.55197933771320218, -0.59999999999999998, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.67882386787534399, -0.59999999999999998, 0.40000000000000002, 
+  { 0.76633591620002894, -0.59999999999999998, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.83948470233173578, -0.59999999999999998, 0.40000000000000002, 
+  { 1.0075231136019616, -0.59999999999999998, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.99753496200073977, -0.59999999999999998, 0.40000000000000002, 
+  { 1.2815842073813450, -0.59999999999999998, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.1541101404388487, -0.59999999999999998, 0.40000000000000002, 
+  { 1.5911666941449827, -0.59999999999999998, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.3100911323398814, -0.59999999999999998, 0.40000000000000002, 
+  { 1.9323227566025762, -0.59999999999999998, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.4659345278069984, -0.59999999999999998, 0.40000000000000002, 
+  { 2.2925036420985130, -0.59999999999999998, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler035 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.50000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.5022138270566200e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.6240126899196213e-16
+// mean(f - f_Boost): 9.1593399531575410e-17
+// variance(f - f_Boost): 1.0357223256482469e-33
+// stddev(f - f_Boost): 3.2182640128619758e-17
 const testcase_ellint_3<double>
 data036[10] =
 {
   { 0.0000000000000000, -0.59999999999999998, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17397586700252807, -0.59999999999999998, 0.50000000000000000, 
+  { 0.17574324658480217, -0.59999999999999998, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34483533397138516, -0.59999999999999998, 0.50000000000000000, 
+  { 0.35887240603169313, -0.59999999999999998, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.51044500461706477, -0.59999999999999998, 0.50000000000000000, 
+  { 0.55737161826345261, -0.59999999999999998, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.67009988034712664, -0.59999999999999998, 0.50000000000000000, 
+  { 0.78028227313077458, -0.59999999999999998, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.82434762375735193, -0.59999999999999998, 0.50000000000000000, 
+  { 1.0376989776486290, -0.59999999999999998, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.97447346702798998, -0.59999999999999998, 0.50000000000000000, 
+  { 1.3395933991042925, -0.59999999999999998, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.1219494000522143, -0.59999999999999998, 0.50000000000000000, 
+  { 1.6924049626591782, -0.59999999999999998, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.2680242605954484, -0.59999999999999998, 0.50000000000000000, 
+  { 2.0931011856518920, -0.59999999999999998, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.4135484285693078, -0.59999999999999998, 0.50000000000000000, 
+  { 2.5239007084492706, -0.59999999999999998, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler036 = 2.5000000000000020e-13;
 
-// Test data for k=-0.59999999999999998, nu=0.59999999999999998.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.2504224329684343e-16
+// Test data for k=-0.59999999999999998, nu=0.60000000000000009.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.6651378277398083e-16
+// mean(f - f_Boost): 1.1934897514720432e-16
+// variance(f - f_Boost): 1.7585404776158019e-33
+// stddev(f - f_Boost): 4.1934955319110598e-17
 const testcase_ellint_3<double>
 data037[10] =
 {
-  { 0.0000000000000000, -0.59999999999999998, 0.59999999999999998, 
+  { 0.0000000000000000, -0.59999999999999998, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17380260984469353, -0.59999999999999998, 0.59999999999999998, 
+  { 0.17592355661219386, -0.59999999999999998, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34353585361777839, -0.59999999999999998, 0.59999999999999998, 
+  { 0.36039141192661606, -0.59999999999999998, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50646805774321380, -0.59999999999999998, 0.59999999999999998, 
+  { 0.56295472636903854, -0.59999999999999998, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.66174468108625506, -0.59999999999999998, 0.59999999999999998, 
+  { 0.79515295130165986, -0.59999999999999998, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.81007462280278408, -0.59999999999999998, 0.59999999999999998, 
+  { 1.0711886441942242, -0.59999999999999998, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.95303466945718729, -0.59999999999999998, 0.59999999999999998, 
+  { 1.4072952835139891, -0.59999999999999998, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0924118588677505, -0.59999999999999998, 0.59999999999999998, 
+  { 1.8174863977376825, -0.59999999999999998, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.2297640574847937, -0.59999999999999998, 0.59999999999999998, 
+  { 2.3029921578542232, -0.59999999999999998, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.3662507535812816, -0.59999999999999998, 0.59999999999999998, 
+  { 2.8388723099514972, -0.59999999999999998, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler037 = 2.5000000000000020e-13;
 
-// Test data for k=-0.59999999999999998, nu=0.69999999999999996.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3559889697529752e-16
+// Test data for k=-0.59999999999999998, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.2451074234797436e-16
+// mean(f - f_Boost): 5.2735593669694933e-17
+// variance(f - f_Boost): 3.4333862218458872e-34
+// stddev(f - f_Boost): 1.8529398861932589e-17
 const testcase_ellint_3<double>
 data038[10] =
 {
-  { 0.0000000000000000, -0.59999999999999998, 0.69999999999999996, 
+  { 0.0000000000000000, -0.59999999999999998, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17362996946312007, -0.59999999999999998, 0.69999999999999996, 
+  { 0.17610453321631936, -0.59999999999999998, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34225353454870588, -0.59999999999999998, 0.69999999999999996, 
+  { 0.36193365056369764, -0.59999999999999998, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.50259656397799524, -0.59999999999999998, 0.69999999999999996, 
+  { 0.56874098962268527, -0.59999999999999998, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.65373184496628933, -0.59999999999999998, 0.69999999999999996, 
+  { 0.81106198671477181, -0.59999999999999998, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.79658372884056439, -0.59999999999999998, 0.69999999999999996, 
+  { 1.1086886419010082, -0.59999999999999998, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.93303240100245421, -0.59999999999999998, 0.69999999999999996, 
+  { 1.4879048567239257, -0.59999999999999998, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0651547944716557, -0.59999999999999998, 0.69999999999999996, 
+  { 1.9780310073615923, -0.59999999999999998, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1947676204853441, -0.59999999999999998, 0.69999999999999996, 
+  { 2.5941545586772712, -0.59999999999999998, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.3232737468822813, -0.59999999999999998, 0.69999999999999996, 
+  { 3.3029735898397155, -0.59999999999999998, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler038 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.80000000000000004.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.1879494682720725e-16
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.3826960061025914e-16
+// mean(f - f_Boost): 2.7478019859472625e-16
+// variance(f - f_Boost): 4.6451528105588637e-32
+// stddev(f - f_Boost): 2.1552616570984749e-16
 const testcase_ellint_3<double>
 data039[10] =
 {
   { 0.0000000000000000, -0.59999999999999998, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17345794195390685, -0.59999999999999998, 0.80000000000000004, 
+  { 0.17628618080795252, -0.59999999999999998, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34098797854531027, -0.59999999999999998, 0.80000000000000004, 
+  { 0.36349976272521012, -0.59999999999999998, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49882569168826213, -0.59999999999999998, 0.80000000000000004, 
+  { 0.57474392342151914, -0.59999999999999998, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.64603758566475511, -0.59999999999999998, 0.80000000000000004, 
+  { 0.82814493499158159, -0.59999999999999998, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.78380365594769730, -0.59999999999999998, 0.80000000000000004, 
+  { 1.1511281795998280, -0.59999999999999998, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.91430946255611190, -0.59999999999999998, 0.80000000000000004, 
+  { 1.5864286332503075, -0.59999999999999998, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.0398955217270607, -0.59999999999999998, 0.80000000000000004, 
+  { 2.1958944866494527, -0.59999999999999998, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.1625948314277679, -0.59999999999999998, 0.80000000000000004, 
+  { 3.0398358172574604, -0.59999999999999998, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.2840021261752192, -0.59999999999999998, 0.80000000000000004, 
+  { 4.0867036409261832, -0.59999999999999998, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler039 = 2.5000000000000020e-13;
 
 // Test data for k=-0.59999999999999998, nu=0.90000000000000002.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.4768329326726447e-16
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.7440178400898422e-16
+// mean(f - f_Boost): 5.0792703376600914e-16
+// variance(f - f_Boost): 1.9863137923719990e-31
+// stddev(f - f_Boost): 4.4568080420543122e-16
 const testcase_ellint_3<double>
 data040[10] =
 {
   { 0.0000000000000000, -0.59999999999999998, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17328652344890030, -0.59999999999999998, 0.90000000000000002, 
+  { 0.17646850384035848, -0.59999999999999998, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33973880062929018, -0.59999999999999998, 0.90000000000000002, 
+  { 0.36509041515134105, -0.59999999999999998, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.49515092233122743, -0.59999999999999998, 0.90000000000000002, 
+  { 0.58097838596260631, -0.59999999999999998, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.63864042139737043, -0.59999999999999998, 0.90000000000000002, 
+  { 0.84656453396163722, -0.59999999999999998, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.77167205646538850, -0.59999999999999998, 0.90000000000000002, 
+  { 1.1997828426963724, -0.59999999999999998, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.89673202848034383, -0.59999999999999998, 0.90000000000000002, 
+  { 1.7112436789225605, -0.59999999999999998, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 1.0163984492661304, -0.59999999999999998, 0.90000000000000002, 
+  { 2.5193168553672312, -0.59999999999999998, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.1328845785162431, -0.59999999999999998, 0.90000000000000002, 
+  { 3.8656670488606686, -0.59999999999999998, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.2479362973851875, -0.59999999999999998, 0.90000000000000002, 
+  { 5.8709993116265595, -0.59999999999999998, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler040 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.0000000000000000.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.1201497220602069e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.4551389361831220e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 2.5893058141206173e-32
+// stddev(f - f_Boost): 1.6091320064309879e-16
 const testcase_ellint_3<double>
 data041[10] =
 {
@@ -1208,1469 +1330,1619 @@
 	  0.0000000000000000 },
   { 0.17475385514035785, -0.50000000000000000, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35081868470101585, -0.50000000000000000, 0.0000000000000000, 
+  { 0.35081868470101579, -0.50000000000000000, 0.0000000000000000, 
 	  0.34906585039886590 },
   { 0.52942862705190574, -0.50000000000000000, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.71164727562630314, -0.50000000000000000, 0.0000000000000000, 
+  { 0.71164727562630326, -0.50000000000000000, 0.0000000000000000, 
 	  0.69813170079773179 },
   { 0.89824523594227768, -0.50000000000000000, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.0895506700518851, -0.50000000000000000, 0.0000000000000000, 
+  { 1.0895506700518853, -0.50000000000000000, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2853005857432931, -0.50000000000000000, 0.0000000000000000, 
+  { 1.2853005857432933, -0.50000000000000000, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.4845545520549484, -0.50000000000000000, 0.0000000000000000, 
+  { 1.4845545520549488, -0.50000000000000000, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.6857503548125963, -0.50000000000000000, 0.0000000000000000, 
+  { 1.6857503548125961, -0.50000000000000000, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler041 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.10000000000000001.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.1662857256911530e-16
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.7416868347177582e-16
+// mean(f - f_Boost): 2.7755575615628915e-18
+// variance(f - f_Boost): 5.4326441655972001e-32
+// stddev(f - f_Boost): 2.3308033305273100e-16
 const testcase_ellint_3<double>
 data042[10] =
 {
   { 0.0000000000000000, -0.50000000000000000, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17457763120814676, -0.50000000000000000, 0.10000000000000001, 
+  { 0.17493071928248824, -0.50000000000000000, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34943246340849154, -0.50000000000000000, 0.10000000000000001, 
+  { 0.35222467688034798, -0.50000000000000000, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52487937869610790, -0.50000000000000000, 0.10000000000000001, 
+  { 0.53411928652008112, -0.50000000000000000, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.70127785096388384, -0.50000000000000000, 0.10000000000000001, 
+  { 0.72256398117177589, -0.50000000000000000, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.87898815988624479, -0.50000000000000000, 0.10000000000000001, 
+  { 0.91899583232771009, -0.50000000000000000, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0582764576094172, -0.50000000000000000, 0.10000000000000001, 
+  { 1.1240549163055360, -0.50000000000000000, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.2391936844060205, -0.50000000000000000, 0.10000000000000001, 
+  { 1.3372938086286021, -0.50000000000000000, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.4214793542995841, -0.50000000000000000, 0.10000000000000001, 
+  { 1.5570024469132429, -0.50000000000000000, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.6045524936084892, -0.50000000000000000, 0.10000000000000001, 
+  { 1.7803034946545480, -0.50000000000000000, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler042 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.20000000000000001.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.2114786773102175e-16
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1198767993730867e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 5.0311947683004831e-32
+// stddev(f - f_Boost): 2.2430324938128922e-16
 const testcase_ellint_3<double>
 data043[10] =
 {
   { 0.0000000000000000, -0.50000000000000000, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17440204336345433, -0.50000000000000000, 0.20000000000000001, 
+  { 0.17510822779582402, -0.50000000000000000, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34806552388338824, -0.50000000000000000, 0.20000000000000001, 
+  { 0.35365094725531487, -0.50000000000000000, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.52046416757129810, -0.50000000000000000, 0.20000000000000001, 
+  { 0.53895933237328697, -0.50000000000000000, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.69140924550993865, -0.50000000000000000, 0.20000000000000001, 
+  { 0.73408090840070794, -0.50000000000000000, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.86104678636125520, -0.50000000000000000, 0.20000000000000001, 
+  { 0.94145442818535396, -0.50000000000000000, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0297439459053981, -0.50000000000000000, 0.20000000000000001, 
+  { 1.1624120186296487, -0.50000000000000000, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1979214112912033, -0.50000000000000000, 0.20000000000000001, 
+  { 1.3965823372867114, -0.50000000000000000, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.3659033858648930, -0.50000000000000000, 0.20000000000000001, 
+  { 1.6414308440430099, -0.50000000000000000, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.5338490483665983, -0.50000000000000000, 0.20000000000000001, 
+  { 1.8922947612264018, -0.50000000000000000, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler043 = 2.5000000000000020e-13;
 
-// Test data for k=-0.50000000000000000, nu=0.29999999999999999.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.2557837230041312e-16
+// Test data for k=-0.50000000000000000, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3800262770228813e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 8.5027191584278157e-32
+// stddev(f - f_Boost): 2.9159422419567599e-16
 const testcase_ellint_3<double>
 data044[10] =
 {
-  { 0.0000000000000000, -0.50000000000000000, 0.29999999999999999, 
+  { 0.0000000000000000, -0.50000000000000000, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17422708752228896, -0.50000000000000000, 0.29999999999999999, 
+  { 0.17528638488102041, -0.50000000000000000, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34671739434855858, -0.50000000000000000, 0.29999999999999999, 
+  { 0.35509802222332720, -0.50000000000000000, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51617616305641878, -0.50000000000000000, 0.29999999999999999, 
+  { 0.54395740731866193, -0.50000000000000000, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.68200047612545167, -0.50000000000000000, 0.29999999999999999, 
+  { 0.74625871438752667, -0.50000000000000000, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.84427217869498372, -0.50000000000000000, 0.29999999999999999, 
+  { 0.96588271186092023, -0.50000000000000000, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.0035637821389782, -0.50000000000000000, 0.29999999999999999, 
+  { 1.2054319584357329, -0.50000000000000000, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1606800483933111, -0.50000000000000000, 0.29999999999999999, 
+  { 1.4651077994832871, -0.50000000000000000, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.3164407134643459, -0.50000000000000000, 0.29999999999999999, 
+  { 1.7416018368052644, -0.50000000000000000, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.4715681939859637, -0.50000000000000000, 0.29999999999999999, 
+  { 2.0277924458111314, -0.50000000000000000, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler044 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.40000000000000002.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.2992508582900068e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.0439932918341581e-16
+// mean(f - f_Boost): 3.0531133177191807e-17
+// variance(f - f_Boost): 9.0809736800018602e-32
+// stddev(f - f_Boost): 3.0134653938616686e-16
 const testcase_ellint_3<double>
 data045[10] =
 {
   { 0.0000000000000000, -0.50000000000000000, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17405275963859917, -0.50000000000000000, 0.40000000000000002, 
+  { 0.17546519477859268, -0.50000000000000000, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34538761957029329, -0.50000000000000000, 0.40000000000000002, 
+  { 0.35656644822531680, -0.50000000000000000, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.51200902646603907, -0.50000000000000000, 0.40000000000000002, 
+  { 0.54912289677411319, -0.50000000000000000, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.67301522212868792, -0.50000000000000000, 0.40000000000000002, 
+  { 0.75916731611690047, -0.50000000000000000, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.82853844466313320, -0.50000000000000000, 0.40000000000000002, 
+  { 0.99260415631328214, -0.50000000000000000, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.97942097862681488, -0.50000000000000000, 0.40000000000000002, 
+  { 1.2541925856918670, -0.50000000000000000, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.1268429801220614, -0.50000000000000000, 0.40000000000000002, 
+  { 1.5456393705347609, -0.50000000000000000, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2720406704533922, -0.50000000000000000, 0.40000000000000002, 
+  { 1.8631904972952076, -0.50000000000000000, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.4161679518465340, -0.50000000000000000, 0.40000000000000002, 
+  { 2.1962905366178065, -0.50000000000000000, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler045 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.50000000000000000.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3419255755184137e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.6797816859260978e-16
+// mean(f - f_Boost): 9.4368957093138303e-17
+// variance(f - f_Boost): 7.7794254682023874e-32
+// stddev(f - f_Boost): 2.7891621444803792e-16
 const testcase_ellint_3<double>
 data046[10] =
 {
   { 0.0000000000000000, -0.50000000000000000, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17387905570381157, -0.50000000000000000, 0.50000000000000000, 
+  { 0.17564466176941509, -0.50000000000000000, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34407576010465207, -0.50000000000000000, 0.50000000000000000, 
+  { 0.35805679276065394, -0.50000000000000000, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50795686560160824, -0.50000000000000000, 0.50000000000000000, 
+  { 0.55446601496200032, -0.50000000000000000, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.66442115453330164, -0.50000000000000000, 0.50000000000000000, 
+  { 0.77288783578259013, -0.50000000000000000, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.81373829119355345, -0.50000000000000000, 0.50000000000000000, 
+  { 1.0220246013918972, -0.50000000000000000, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.95705743313235825, -0.50000000000000000, 0.50000000000000000, 
+  { 1.3101681612463965, -0.50000000000000000, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0959131991362554, -0.50000000000000000, 0.50000000000000000, 
+  { 1.6422994881851025, -0.50000000000000000, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.2318900529754597, -0.50000000000000000, 0.50000000000000000, 
+  { 2.0152636030998816, -0.50000000000000000, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.3664739530045971, -0.50000000000000000, 0.50000000000000000, 
+  { 2.4136715042011945, -0.50000000000000000, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler046 = 2.5000000000000020e-13;
 
-// Test data for k=-0.50000000000000000, nu=0.59999999999999998.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3838494104749599e-16
+// Test data for k=-0.50000000000000000, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.9178421578645735e-16
+// mean(f - f_Boost): 1.3322676295501878e-16
+// variance(f - f_Boost): 1.7749370367472766e-31
+// stddev(f - f_Boost): 4.2130001622920411e-16
 const testcase_ellint_3<double>
 data047[10] =
 {
-  { 0.0000000000000000, -0.50000000000000000, 0.59999999999999998, 
+  { 0.0000000000000000, -0.50000000000000000, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17370597174637581, -0.50000000000000000, 0.59999999999999998, 
+  { 0.17582479017522740, -0.50000000000000000, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34278139158591414, -0.50000000000000000, 0.59999999999999998, 
+  { 0.35956964546660036, -0.50000000000000000, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50401419439302708, -0.50000000000000000, 0.59999999999999998, 
+  { 0.55999790372984193, -0.50000000000000000, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.65618938076167210, -0.50000000000000000, 0.59999999999999998, 
+  { 0.78751507911209895, -0.50000000000000000, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.79977959248855424, -0.50000000000000000, 0.59999999999999998, 
+  { 1.0546620505035220, -0.50000000000000000, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.93625925190753545, -0.50000000000000000, 0.59999999999999998, 
+  { 1.3754438357425935, -0.50000000000000000, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0674905658379708, -0.50000000000000000, 0.59999999999999998, 
+  { 1.7615727400820127, -0.50000000000000000, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1953481298023050, -0.50000000000000000, 0.59999999999999998, 
+  { 2.2134638067565242, -0.50000000000000000, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.3215740290190876, -0.50000000000000000, 0.59999999999999998, 
+  { 2.7090491861753558, -0.50000000000000000, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler047 = 2.5000000000000020e-13;
 
-// Test data for k=-0.50000000000000000, nu=0.69999999999999996.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.4250604066951477e-16
+// Test data for k=-0.50000000000000000, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0745105182189226e-16
+// mean(f - f_Boost): 4.1633363423443370e-17
+// variance(f - f_Boost): 1.9996383743576116e-32
+// stddev(f - f_Boost): 1.4140857026211713e-16
 const testcase_ellint_3<double>
 data048[10] =
 {
-  { 0.0000000000000000, -0.50000000000000000, 0.69999999999999996, 
+  { 0.0000000000000000, -0.50000000000000000, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17353350383131641, -0.50000000000000000, 0.69999999999999996, 
+  { 0.17600558435914915, -0.50000000000000000, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34150410405436771, -0.50000000000000000, 0.69999999999999996, 
+  { 0.36110561926726259, -0.50000000000000000, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.50017589696443487, -0.50000000000000000, 0.69999999999999996, 
+  { 0.56573074641137111, -0.50000000000000000, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.64829398188419951, -0.50000000000000000, 0.69999999999999996, 
+  { 0.80316073084237205, -0.50000000000000000, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.78658270782402073, -0.50000000000000000, 0.69999999999999996, 
+  { 1.0911910688131461, -0.50000000000000000, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.91684738336675053, -0.50000000000000000, 0.69999999999999996, 
+  { 1.4530946406380640, -0.50000000000000000, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0412486789555935, -0.50000000000000000, 0.69999999999999996, 
+  { 1.9144386536785372, -0.50000000000000000, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1619021847612001, -0.50000000000000000, 0.69999999999999996, 
+  { 2.4878788958234970, -0.50000000000000000, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2807475181182502, -0.50000000000000000, 0.69999999999999996, 
+  { 3.1433945297859225, -0.50000000000000000, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler048 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.5715240651179632e-16
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.4380477375534667e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 1.4989821857033475e-31
+// stddev(f - f_Boost): 3.8716691306248618e-16
 const testcase_ellint_3<double>
 data049[10] =
 {
   { 0.0000000000000000, -0.50000000000000000, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17336164805979126, -0.50000000000000000, 0.80000000000000004, 
+  { 0.17618704872620228, -0.50000000000000000, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34024350132086773, -0.50000000000000000, 0.80000000000000004, 
+  { 0.36266535159745827, -0.50000000000000000, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49643719555734073, -0.50000000000000000, 0.80000000000000004, 
+  { 0.57167789954529158, -0.50000000000000000, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.64071162456976150, -0.50000000000000000, 0.80000000000000004, 
+  { 0.81995752984315018, -0.50000000000000000, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.77407836177211908, -0.50000000000000000, 0.80000000000000004, 
+  { 1.1325112162158122, -0.50000000000000000, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.89867058251905652, -0.50000000000000000, 0.80000000000000004, 
+  { 1.5479055930718042, -0.50000000000000000, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.0169181822134910, -0.50000000000000000, 0.80000000000000004, 
+  { 2.1215243941010486, -0.50000000000000000, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.1311363312779448, -0.50000000000000000, 0.80000000000000004, 
+  { 2.9069405767650132, -0.50000000000000000, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.2434165408189539, -0.50000000000000000, 0.80000000000000004, 
+  { 3.8750701888108066, -0.50000000000000000, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler049 = 2.5000000000000020e-13;
 
 // Test data for k=-0.50000000000000000, nu=0.90000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.4664649039489274e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.6192315188521289e-16
+// mean(f - f_Boost): 3.5249581031848718e-16
+// variance(f - f_Boost): 2.5029385557256515e-31
+// stddev(f - f_Boost): 5.0029376927217987e-16
 const testcase_ellint_3<double>
 data050[10] =
 {
   { 0.0000000000000000, -0.50000000000000000, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17319040056865681, -0.50000000000000000, 0.90000000000000002, 
+  { 0.17636918772384180, -0.50000000000000000, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33899920036578557, -0.50000000000000000, 0.90000000000000002, 
+  { 0.36424950570740700, -0.50000000000000000, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.49279362182695174, -0.50000000000000000, 0.90000000000000002, 
+  { 0.57785404590231426, -0.50000000000000000, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.63342123379746151, -0.50000000000000000, 0.90000000000000002, 
+  { 0.83806480521716531, -0.50000000000000000, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.76220595179550321, -0.50000000000000000, 0.90000000000000002, 
+  { 1.1798568683069752, -0.50000000000000000, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.88160004743532294, -0.50000000000000000, 0.90000000000000002, 
+  { 1.6678766243739607, -0.50000000000000000, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.99427448642310123, -0.50000000000000000, 0.90000000000000002, 
+  { 2.4282976450693483, -0.50000000000000000, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.1027091512470095, -0.50000000000000000, 0.90000000000000002, 
+  { 3.6810787666126656, -0.50000000000000000, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.2091116095504744, -0.50000000000000000, 0.90000000000000002, 
+  { 5.5355132096026454, -0.50000000000000000, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler050 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.0000000000000000.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.0617918857203532e-16
+// Test data for k=-0.39999999999999991, nu=0.0000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.1423314994346225e-16
+// mean(f - f_Boost): 1.9428902930940238e-17
+// variance(f - f_Boost): 2.2263750157116445e-32
+// stddev(f - f_Boost): 1.4921042241450980e-16
 const testcase_ellint_3<double>
 data051[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.0000000000000000, 
+  { 0.0000000000000000, -0.39999999999999991, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17467414669441528, -0.40000000000000002, 0.0000000000000000, 
+  { 0.17467414669441528, -0.39999999999999991, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35018222772483443, -0.40000000000000002, 0.0000000000000000, 
+  { 0.35018222772483443, -0.39999999999999991, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.52729015917508737, -0.40000000000000002, 0.0000000000000000, 
+  { 0.52729015917508748, -0.39999999999999991, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.70662374407341244, -0.40000000000000002, 0.0000000000000000, 
+  { 0.70662374407341244, -0.39999999999999991, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.88859210497602170, -0.40000000000000002, 0.0000000000000000, 
+  { 0.88859210497602159, -0.39999999999999991, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.0733136290471379, -0.40000000000000002, 0.0000000000000000, 
+  { 1.0733136290471381, -0.39999999999999991, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2605612170157061, -0.40000000000000002, 0.0000000000000000, 
+  { 1.2605612170157066, -0.39999999999999991, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.4497513956433439, -0.40000000000000002, 0.0000000000000000, 
+  { 1.4497513956433439, -0.39999999999999991, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.6399998658645112, -0.40000000000000002, 0.0000000000000000, 
+  { 1.6399998658645112, -0.39999999999999991, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler051 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.10000000000000001.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2644663257577874e-16
+// Test data for k=-0.39999999999999991, nu=0.10000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.8489340395463703e-16
+// mean(f - f_Boost): 6.3837823915946496e-17
+// variance(f - f_Boost): 4.4785242050000272e-32
+// stddev(f - f_Boost): 2.1162523963365114e-16
 const testcase_ellint_3<double>
 data052[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.10000000000000001, 
+  { 0.0000000000000000, -0.39999999999999991, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17449806706684670, -0.40000000000000002, 0.10000000000000001, 
+  { 0.17485086590796767, -0.39999999999999991, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34880048623856075, -0.40000000000000002, 0.10000000000000001, 
+  { 0.35158366412506992, -0.39999999999999991, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52277322065757392, -0.40000000000000002, 0.10000000000000001, 
+  { 0.53194731675711726, -0.39999999999999991, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.69638072056918365, -0.40000000000000002, 0.10000000000000001, 
+  { 0.71740615528010931, -0.39999999999999991, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.86968426619831540, -0.40000000000000002, 0.10000000000000001, 
+  { 0.90896157773487030, -0.39999999999999991, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0428044206578095, -0.40000000000000002, 0.10000000000000001, 
+  { 1.1069605483834348, -0.39999999999999991, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.2158651158274378, -0.40000000000000002, 0.10000000000000001, 
+  { 1.3109353428823001, -0.39999999999999991, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.3889447129893324, -0.40000000000000002, 0.10000000000000001, 
+  { 1.5195460789903448, -0.39999999999999991, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.5620566886683604, -0.40000000000000002, 0.10000000000000001, 
+  { 1.7306968836847187, -0.39999999999999991, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler052 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.20000000000000001.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.4583049464169287e-16
+// Test data for k=-0.39999999999999991, nu=0.20000000000000001.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.0467985583872730e-16
+// mean(f - f_Boost): 8.6042284408449634e-17
+// variance(f - f_Boost): 1.5826864298542218e-32
+// stddev(f - f_Boost): 1.2580486595733180e-16
 const testcase_ellint_3<double>
 data053[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.20000000000000001, 
+  { 0.0000000000000000, -0.39999999999999991, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17432262290723397, -0.40000000000000002, 0.20000000000000001, 
+  { 0.17502822886437389, -0.39999999999999991, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34743795258968596, -0.40000000000000002, 0.20000000000000001, 
+  { 0.35300530062530805, -0.39999999999999991, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.51838919472805101, -0.40000000000000002, 0.20000000000000001, 
+  { 0.53675259548210896, -0.39999999999999991, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.68663134739057907, -0.40000000000000002, 0.20000000000000001, 
+  { 0.72878006428676934, -0.39999999999999991, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.85206432981833979, -0.40000000000000002, 0.20000000000000001, 
+  { 0.93100219010583563, -0.39999999999999991, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0149595349004430, -0.40000000000000002, 0.20000000000000001, 
+  { 1.1443487271187609, -0.39999999999999991, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1758349405464676, -0.40000000000000002, 0.20000000000000001, 
+  { 1.3683427764108813, -0.39999999999999991, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.3353337673882637, -0.40000000000000002, 0.20000000000000001, 
+  { 1.6008221459300933, -0.39999999999999991, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.4941414344266770, -0.40000000000000002, 0.20000000000000001, 
+  { 1.8380358826317627, -0.39999999999999991, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler053 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.29999999999999999.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.1925080711125793e-16
+// Test data for k=-0.39999999999999991, nu=0.30000000000000004.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.9973414591826100e-16
+// mean(f - f_Boost): 8.6042284408449634e-17
+// variance(f - f_Boost): 1.5826864298542218e-32
+// stddev(f - f_Boost): 1.2580486595733180e-16
 const testcase_ellint_3<double>
 data054[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.29999999999999999, 
+  { 0.0000000000000000, -0.39999999999999991, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17414781013591540, -0.40000000000000002, 0.29999999999999999, 
+  { 0.17520623975982899, -0.39999999999999991, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34609415696777285, -0.40000000000000002, 0.29999999999999999, 
+  { 0.35444766141612105, -0.39999999999999991, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51413131295862535, -0.40000000000000002, 0.29999999999999999, 
+  { 0.54171455841536009, -0.39999999999999991, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.67733527622935630, -0.40000000000000002, 0.29999999999999999, 
+  { 0.74080517001084012, -0.39999999999999991, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.83558675182733266, -0.40000000000000002, 0.29999999999999999, 
+  { 0.95496950509296563, -0.39999999999999991, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 0.98940140808865906, -0.40000000000000002, 0.29999999999999999, 
+  { 1.1862627879844718, -0.39999999999999991, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1396968797728058, -0.40000000000000002, 0.29999999999999999, 
+  { 1.4346501803799458, -0.39999999999999991, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.2875920037865090, -0.40000000000000002, 0.29999999999999999, 
+  { 1.6971744798077697, -0.39999999999999991, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.4342789859950078, -0.40000000000000002, 0.29999999999999999, 
+  { 1.9677924132520139, -0.39999999999999991, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler054 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.40000000000000002.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.8235661108581362e-16
+// Test data for k=-0.39999999999999991, nu=0.40000000000000002.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.2577246923979600e-16
+// mean(f - f_Boost): 1.8596235662471373e-16
+// variance(f - f_Boost): 1.6222417021441306e-31
+// stddev(f - f_Boost): 4.0277061736727151e-16
 const testcase_ellint_3<double>
 data055[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.40000000000000002, 
+  { 0.0000000000000000, -0.39999999999999991, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17397362471112707, -0.40000000000000002, 0.40000000000000002, 
+  { 0.17538490283034375, -0.39999999999999991, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34476864603333196, -0.40000000000000002, 0.40000000000000002, 
+  { 0.35591129064319948, -0.39999999999999991, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.50999329415379346, -0.40000000000000002, 0.40000000000000002, 
+  { 0.54684250413264535, -0.39999999999999991, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.66845674551396006, -0.40000000000000002, 0.40000000000000002, 
+  { 0.75355027742668290, -0.39999999999999991, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.82012848346231748, -0.40000000000000002, 0.40000000000000002, 
+  { 0.98117935026780634, -0.39999999999999991, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.96582449258349057, -0.40000000000000002, 0.40000000000000002, 
+  { 1.2337464222030734, -0.39999999999999991, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.1068473749476286, -0.40000000000000002, 0.40000000000000002, 
+  { 1.5125183419289221, -0.39999999999999991, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2447132729159989, -0.40000000000000002, 0.40000000000000002, 
+  { 1.8140224451130311, -0.39999999999999991, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.3809986210732901, -0.40000000000000002, 0.40000000000000002, 
+  { 2.1289968719280026, -0.39999999999999991, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler055 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.50000000000000000.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.9965792755639576e-16
+// Test data for k=-0.39999999999999991, nu=0.50000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.8009196014748294e-16
+// mean(f - f_Boost): 1.6375789613221060e-16
+// variance(f - f_Boost): 6.4788283329186610e-32
+// stddev(f - f_Boost): 2.5453542647181080e-16
 const testcase_ellint_3<double>
 data056[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.50000000000000000, 
+  { 0.0000000000000000, -0.39999999999999991, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17380006262854136, -0.40000000000000002, 0.50000000000000000, 
+  { 0.17556422235224273, -0.39999999999999991, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34346098216756610, -0.40000000000000002, 0.50000000000000000, 
+  { 0.35739675341763921, -0.39999999999999991, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50596929935059420, -0.40000000000000002, 0.50000000000000000, 
+  { 0.55214655195037188, -0.39999999999999991, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.65996392089131251, -0.40000000000000002, 0.50000000000000000, 
+  { 0.76709520942047438, -0.39999999999999991, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.80558463511364786, -0.40000000000000002, 0.50000000000000000, 
+  { 1.0100278761577499, -0.39999999999999991, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.94397834522857704, -0.40000000000000002, 0.50000000000000000, 
+  { 1.2882265661384342, -0.39999999999999991, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0768075114108115, -0.40000000000000002, 0.50000000000000000, 
+  { 1.6059059780051874, -0.39999999999999991, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.2059184624251333, -0.40000000000000002, 0.50000000000000000, 
+  { 1.9600182740224081, -0.39999999999999991, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.3331797176377398, -0.40000000000000002, 0.50000000000000000, 
+  { 2.3367461373176508, -0.39999999999999991, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler056 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.59999999999999998.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.1640223038298069e-16
+// Test data for k=-0.39999999999999991, nu=0.60000000000000009.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 2.8411408870840790e-16
+// mean(f - f_Boost): 9.7144514654701197e-17
+// variance(f - f_Boost): 1.4860570558543486e-32
+// stddev(f - f_Boost): 1.2190393988113545e-16
 const testcase_ellint_3<double>
 data057[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.59999999999999998, 
+  { 0.0000000000000000, -0.39999999999999991, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17362711992081245, -0.40000000000000002, 0.59999999999999998, 
+  { 0.17574420264267029, -0.39999999999999991, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34217074276403953, -0.40000000000000002, 0.59999999999999998, 
+  { 0.35890463689046265, -0.39999999999999991, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50205389185761606, -0.40000000000000002, 0.59999999999999998, 
+  { 0.55763773975194486, -0.39999999999999991, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.65182834920372734, -0.40000000000000002, 0.59999999999999998, 
+  { 0.78153324227761267, -0.39999999999999991, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.79186512820565136, -0.40000000000000002, 0.59999999999999998, 
+  { 1.0420205885765887, -0.39999999999999991, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.92365535916287134, -0.40000000000000002, 0.59999999999999998, 
+  { 1.3517205230381770, -0.39999999999999991, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0491915663957907, -0.40000000000000002, 0.59999999999999998, 
+  { 1.7210360970313896, -0.39999999999999991, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1705934291745106, -0.40000000000000002, 0.59999999999999998, 
+  { 2.1500780510169242, -0.39999999999999991, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.2899514672527024, -0.40000000000000002, 0.59999999999999998, 
+  { 2.6186940209850191, -0.39999999999999991, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler057 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.69999999999999996.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.3264047918332349e-16
+// Test data for k=-0.39999999999999991, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.1553900340611668e-16
+// mean(f - f_Boost): 1.1657341758564144e-16
+// variance(f - f_Boost): 1.3242789405258207e-32
+// stddev(f - f_Boost): 1.1507731924779187e-16
 const testcase_ellint_3<double>
 data058[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.69999999999999996, 
+  { 0.0000000000000000, -0.39999999999999991, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17345479265712868, -0.40000000000000002, 0.69999999999999996, 
+  { 0.17592484806010436, -0.39999999999999991, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34089751955950354, -0.40000000000000002, 0.69999999999999996, 
+  { 0.36043555139631439, -0.39999999999999991, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.49824200167361332, -0.40000000000000002, 0.69999999999999996, 
+  { 0.56332813669944881, -0.39999999999999991, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.64402450341199402, -0.40000000000000002, 0.69999999999999996, 
+  { 0.79697424562157548, -0.39999999999999991, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.77889207804122873, -0.40000000000000002, 0.69999999999999996, 
+  { 1.0778155987523672, -0.39999999999999991, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.90468169720957992, -0.40000000000000002, 0.69999999999999996, 
+  { 1.4272018169896268, -0.39999999999999991, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0236847823692916, -0.40000000000000002, 0.69999999999999996, 
+  { 1.8684377907453380, -0.39999999999999991, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1382465247425166, -0.40000000000000002, 0.69999999999999996, 
+  { 2.4128677409207469, -0.39999999999999991, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2506255923253344, -0.40000000000000002, 0.69999999999999996, 
+  { 3.0327078743873241, -0.39999999999999991, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler058 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.80000000000000004.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 6.6611561645571024e-16
+// Test data for k=-0.39999999999999991, nu=0.80000000000000004.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5727642219519274e-16
+// mean(f - f_Boost): 2.1926904736346843e-16
+// variance(f - f_Boost): 1.5293405480859847e-31
+// stddev(f - f_Boost): 3.9106783913868252e-16
 const testcase_ellint_3<double>
 data059[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.80000000000000004, 
+  { 0.0000000000000000, -0.39999999999999991, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17328307694277154, -0.40000000000000002, 0.80000000000000004, 
+  { 0.17610616300487833, -0.39999999999999991, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.33964091800132007, -0.40000000000000002, 0.80000000000000004, 
+  { 0.36199013167171978, -0.39999999999999991, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49452889372467440, -0.40000000000000002, 0.80000000000000004, 
+  { 0.56923097361842423, -0.39999999999999991, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.63652940095937316, -0.40000000000000002, 0.80000000000000004, 
+  { 0.81354878456624347, -0.39999999999999991, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.76659772511159097, -0.40000000000000002, 0.80000000000000004, 
+  { 1.1182902719261825, -0.39999999999999991, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.88691047977338111, -0.40000000000000002, 0.80000000000000004, 
+  { 1.5192950589409022, -0.39999999999999991, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.0000273200611638, -0.40000000000000002, 0.80000000000000004, 
+  { 2.0678761710223981, -0.39999999999999991, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.1084787902188009, -0.40000000000000002, 0.80000000000000004, 
+  { 2.8135222249879783, -0.39999999999999991, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.2146499565727209, -0.40000000000000002, 0.80000000000000004, 
+  { 3.7289548002199902, -0.39999999999999991, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler059 = 2.5000000000000020e-13;
 
-// Test data for k=-0.40000000000000002, nu=0.90000000000000002.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.6376730823308004e-16
+// Test data for k=-0.39999999999999991, nu=0.90000000000000002.
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.0221626338023938e-16
+// mean(f - f_Boost): 4.1910919179599658e-16
+// variance(f - f_Boost): 6.2246150910247033e-31
+// stddev(f - f_Boost): 7.8896229891070860e-16
 const testcase_ellint_3<double>
 data060[10] =
 {
-  { 0.0000000000000000, -0.40000000000000002, 0.90000000000000002, 
+  { 0.0000000000000000, -0.39999999999999991, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17311196891868127, -0.40000000000000002, 0.90000000000000002, 
+  { 0.17628815191971123, -0.39999999999999991, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33840055664911906, -0.40000000000000002, 0.90000000000000002, 
+  { 0.36356903815378772, -0.39999999999999991, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.49091013944075329, -0.40000000000000002, 0.90000000000000002, 
+  { 0.57536079447000310, -0.39999999999999991, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.62932228186809580, -0.40000000000000002, 0.90000000000000002, 
+  { 0.83141355850172571, -0.39999999999999991, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.75492278323019801, -0.40000000000000002, 0.90000000000000002, 
+  { 1.1646481598721361, -0.39999999999999991, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.87021659043854294, -0.40000000000000002, 0.90000000000000002, 
+  { 1.6357275034001995, -0.39999999999999991, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.97800245228239246, -0.40000000000000002, 0.90000000000000002, 
+  { 2.3628787566572398, -0.39999999999999991, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.0809625773173697, -0.40000000000000002, 0.90000000000000002, 
+  { 3.5521010369134958, -0.39999999999999991, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.1815758115929846, -0.40000000000000002, 0.90000000000000002, 
+  { 5.3055535102872513, -0.39999999999999991, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler060 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.0000000000000000.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.3361874537309281e-16
+// Test data for k=-0.29999999999999993, nu=0.0000000000000000.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.2241249691539529e-16
+// mean(f - f_Boost): 4.9960036108132046e-17
+// variance(f - f_Boost): 4.6872855002064458e-32
+// stddev(f - f_Boost): 2.1650139722889657e-16
 const testcase_ellint_3<double>
 data061[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.0000000000000000, 
+  { 0.0000000000000000, -0.29999999999999993, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17461228653000099, -0.30000000000000004, 0.0000000000000000, 
+  { 0.17461228653000099, -0.29999999999999993, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.34969146102798415, -0.30000000000000004, 0.0000000000000000, 
+  { 0.34969146102798421, -0.29999999999999993, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.52565822873726320, -0.30000000000000004, 0.0000000000000000, 
+  { 0.52565822873726309, -0.29999999999999993, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.70284226512408532, -0.30000000000000004, 0.0000000000000000, 
+  { 0.70284226512408543, -0.29999999999999993, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.88144139195111182, -0.30000000000000004, 0.0000000000000000, 
+  { 0.88144139195111171, -0.29999999999999993, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.0614897067260520, -0.30000000000000004, 0.0000000000000000, 
+  { 1.0614897067260520, -0.29999999999999993, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2428416824174218, -0.30000000000000004, 0.0000000000000000, 
+  { 1.2428416824174220, -0.29999999999999993, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.4251795877015927, -0.30000000000000004, 0.0000000000000000, 
+  { 1.4251795877015929, -0.29999999999999993, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.6080486199305128, -0.30000000000000004, 0.0000000000000000, 
+  { 1.6080486199305126, -0.29999999999999993, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler061 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.10000000000000001.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.3908043711907203e-16
+// Test data for k=-0.29999999999999993, nu=0.10000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1872304407982844e-16
+// mean(f - f_Boost): 9.4368957093138303e-17
+// variance(f - f_Boost): 4.0359883022230488e-32
+// stddev(f - f_Boost): 2.0089769292411121e-16
 const testcase_ellint_3<double>
 data062[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.10000000000000001, 
+  { 0.0000000000000000, -0.29999999999999993, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17443631884814376, -0.30000000000000004, 0.10000000000000001, 
+  { 0.17478889331392972, -0.29999999999999993, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34831316835124926, -0.30000000000000004, 0.10000000000000001, 
+  { 0.35108939018329183, -0.29999999999999993, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52116586276523857, -0.30000000000000004, 0.10000000000000001, 
+  { 0.53028990896115835, -0.29999999999999993, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.69269385837910036, -0.30000000000000004, 0.10000000000000001, 
+  { 0.71352417052371409, -0.29999999999999993, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.86279023163070856, -0.30000000000000004, 0.10000000000000001, 
+  { 0.90153086032405894, -0.29999999999999993, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0315321461438263, -0.30000000000000004, 0.10000000000000001, 
+  { 1.0945187977283313, -0.29999999999999993, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.1991449111869024, -0.30000000000000004, 0.10000000000000001, 
+  { 1.2920699268385680, -0.29999999999999993, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.3659561780923213, -0.30000000000000004, 0.10000000000000001, 
+  { 1.4931243665896394, -0.29999999999999993, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.5323534693557528, -0.30000000000000004, 0.10000000000000001, 
+  { 1.6960848815118226, -0.29999999999999993, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler062 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.20000000000000001.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.4447238179454079e-16
+// Test data for k=-0.29999999999999993, nu=0.20000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.2247497610332889e-16
+// mean(f - f_Boost): 1.1102230246251565e-16
+// variance(f - f_Boost): 3.8043060629871325e-32
+// stddev(f - f_Boost): 1.9504630380981672e-16
 const testcase_ellint_3<double>
 data063[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.20000000000000001, 
+  { 0.0000000000000000, -0.29999999999999993, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17426098615372088, -0.30000000000000004, 0.20000000000000001, 
+  { 0.17496614335337535, -0.29999999999999993, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34695402664689923, -0.30000000000000004, 0.20000000000000001, 
+  { 0.35250745937139372, -0.29999999999999993, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.51680555567038933, -0.30000000000000004, 0.20000000000000001, 
+  { 0.53506875002836884, -0.29999999999999993, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.68303375225260210, -0.30000000000000004, 0.20000000000000001, 
+  { 0.72479106622248191, -0.29999999999999993, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.84540662891295026, -0.30000000000000004, 0.20000000000000001, 
+  { 0.92326451535891607, -0.29999999999999993, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0041834051646927, -0.30000000000000004, 0.20000000000000001, 
+  { 1.1312092060698349, -0.29999999999999993, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1599952702345711, -0.30000000000000004, 0.20000000000000001, 
+  { 1.3481473154592321, -0.29999999999999993, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.3137179520499165, -0.30000000000000004, 0.20000000000000001, 
+  { 1.5722049569662748, -0.29999999999999993, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.4663658145259877, -0.30000000000000004, 0.20000000000000001, 
+  { 1.8002173372290498, -0.29999999999999993, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler063 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.29999999999999999.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.4979715256503266e-16
+// Test data for k=-0.29999999999999993, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.1678685180047551e-16
+// mean(f - f_Boost): 1.0547118733938987e-16
+// variance(f - f_Boost): 7.5633408838247182e-32
+// stddev(f - f_Boost): 2.7501528837184157e-16
 const testcase_ellint_3<double>
 data064[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.29999999999999999, 
+  { 0.0000000000000000, -0.29999999999999993, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17408628437042842, -0.30000000000000004, 0.29999999999999999, 
+  { 0.17514404084107435, -0.29999999999999993, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34561356761638401, -0.30000000000000004, 0.29999999999999999, 
+  { 0.35394619108645647, -0.29999999999999993, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51257058617875850, -0.30000000000000004, 0.29999999999999999, 
+  { 0.54000325463372689, -0.29999999999999993, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.67382207124602878, -0.30000000000000004, 0.29999999999999999, 
+  { 0.73670193794067651, -0.29999999999999993, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.82914751587825131, -0.30000000000000004, 0.29999999999999999, 
+  { 0.94689345491722177, -0.29999999999999993, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 0.97907434814374938, -0.30000000000000004, 0.29999999999999999, 
+  { 1.1723274608389140, -0.29999999999999993, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1246399297351584, -0.30000000000000004, 0.29999999999999999, 
+  { 1.4128880552936287, -0.29999999999999993, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.2671793970398149, -0.30000000000000004, 0.29999999999999999, 
+  { 1.6659010047449661, -0.29999999999999993, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.4081767433479091, -0.30000000000000004, 0.29999999999999999, 
+  { 1.9260216862473254, -0.29999999999999993, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler064 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.40000000000000002.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.5505716921759864e-16
+// Test data for k=-0.29999999999999993, nu=0.40000000000000002.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.3983279132797385e-16
+// mean(f - f_Boost): 1.1657341758564144e-16
+// variance(f - f_Boost): 1.8245832308692586e-31
+// stddev(f - f_Boost): 4.2715140534349863e-16
 const testcase_ellint_3<double>
 data065[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.40000000000000002, 
+  { 0.0000000000000000, -0.29999999999999993, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17391220945982727, -0.30000000000000004, 0.40000000000000002, 
+  { 0.17532259000954434, -0.29999999999999993, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34429133937639689, -0.30000000000000004, 0.40000000000000002, 
+  { 0.35540612770983693, -0.29999999999999993, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.50845471668581632, -0.30000000000000004, 0.40000000000000002, 
+  { 0.54510265552938919, -0.29999999999999993, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.66502347027873854, -0.30000000000000004, 0.40000000000000002, 
+  { 0.74932476310965057, -0.29999999999999993, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.81389191978012254, -0.30000000000000004, 0.40000000000000002, 
+  { 0.97272793583093109, -0.29999999999999993, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.95590618002140570, -0.30000000000000004, 0.40000000000000002, 
+  { 1.2188928987074241, -0.29999999999999993, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.0924915195213121, -0.30000000000000004, 0.40000000000000002, 
+  { 1.4888771674085941, -0.29999999999999993, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2253651604038061, -0.30000000000000004, 0.40000000000000002, 
+  { 1.7794558498219191, -0.29999999999999993, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.3563643538969763, -0.30000000000000004, 0.40000000000000002, 
+  { 2.0822121773175528, -0.29999999999999993, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler065 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.50000000000000000.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.7807908859023716e-16
+// Test data for k=-0.29999999999999993, nu=0.50000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.0516138451673425e-16
+// mean(f - f_Boost): 4.7184478546569152e-17
+// variance(f - f_Boost): 1.9448563670505968e-32
+// stddev(f - f_Boost): 1.3945810722401896e-16
 const testcase_ellint_3<double>
 data066[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.50000000000000000, 
+  { 0.0000000000000000, -0.29999999999999993, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17373875742088232, -0.30000000000000004, 0.50000000000000000, 
+  { 0.17550179513158179, -0.29999999999999993, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34298690571124157, -0.30000000000000004, 0.50000000000000000, 
+  { 0.35688783251681200, -0.29999999999999993, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50445214859646936, -0.30000000000000004, 0.50000000000000000, 
+  { 0.55037700010142798, -0.29999999999999993, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.65660648352418516, -0.30000000000000004, 0.50000000000000000, 
+  { 0.76273839789895992, -0.29999999999999993, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.79953670639287289, -0.30000000000000004, 0.50000000000000000, 
+  { 1.0011570518830419, -0.29999999999999993, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.93443393926588536, -0.30000000000000004, 0.50000000000000000, 
+  { 1.2722987414055109, -0.29999999999999993, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0630838369016911, -0.30000000000000004, 0.50000000000000000, 
+  { 1.5799590511080066, -0.29999999999999993, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.1875197325653029, -0.30000000000000004, 0.50000000000000000, 
+  { 1.9212367220124293, -0.29999999999999993, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.3098448759814962, -0.30000000000000004, 0.50000000000000000, 
+  { 2.2833505881933971, -0.29999999999999993, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler066 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.59999999999999998.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.0057999499931649e-16
+// Test data for k=-0.29999999999999993, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.2121157428443725e-16
+// mean(f - f_Boost): 1.9428902930940239e-16
+// variance(f - f_Boost): 1.5987596229703424e-31
+// stddev(f - f_Boost): 3.9984492281012430e-16
 const testcase_ellint_3<double>
 data067[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.59999999999999998, 
+  { 0.0000000000000000, -0.29999999999999993, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17356592428950823, -0.30000000000000004, 0.59999999999999998, 
+  { 0.17568166052076745, -0.29999999999999993, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34169984536697379, -0.30000000000000004, 0.59999999999999998, 
+  { 0.35839189074731181, -0.29999999999999993, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50055748266498457, -0.30000000000000004, 0.59999999999999998, 
+  { 0.55583724744367558, -0.29999999999999993, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.64854298527106768, -0.30000000000000004, 0.59999999999999998, 
+  { 0.77703498090888223, -0.29999999999999993, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.78599329284207431, -0.30000000000000004, 0.59999999999999998, 
+  { 1.0326772113675962, -0.29999999999999993, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.91445452089128199, -0.30000000000000004, 0.59999999999999998, 
+  { 1.3345139983717369, -0.29999999999999993, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0360412952290587, -0.30000000000000004, 0.59999999999999998, 
+  { 1.6921742922838403, -0.29999999999999993, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1530473919778641, -0.30000000000000004, 0.59999999999999998, 
+  { 2.1056608968472186, -0.29999999999999993, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.2677758800420669, -0.30000000000000004, 0.59999999999999998, 
+  { 2.5560975528589061, -0.29999999999999993, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler067 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.69999999999999996.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.2239502844122443e-16
+// Test data for k=-0.29999999999999993, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.0088945789059381e-16
+// mean(f - f_Boost): 1.6653345369377348e-16
+// variance(f - f_Boost): 3.1994213989721786e-31
+// stddev(f - f_Boost): 5.6563428104846852e-16
 const testcase_ellint_3<double>
 data068[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.69999999999999996, 
+  { 0.0000000000000000, -0.29999999999999993, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17339370613812224, -0.30000000000000004, 0.69999999999999996, 
+  { 0.17586219053197988, -0.29999999999999993, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34042975138455933, -0.30000000000000004, 0.69999999999999996, 
+  { 0.35991891074557669, -0.29999999999999993, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.49676568368075985, -0.30000000000000004, 0.69999999999999996, 
+  { 0.56149538019961731, -0.29999999999999993, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.64080774055753720, -0.30000000000000004, 0.69999999999999996, 
+  { 0.79232303189667685, -0.29999999999999993, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.77318507779667278, -0.30000000000000004, 0.69999999999999996, 
+  { 1.0679345542878826, -0.29999999999999993, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.89579782346548609, -0.30000000000000004, 0.69999999999999996, 
+  { 1.4084400085913955, -0.29999999999999993, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0110573286052202, -0.30000000000000004, 0.69999999999999996, 
+  { 1.8357382859296454, -0.29999999999999993, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1214710972949635, -0.30000000000000004, 0.69999999999999996, 
+  { 2.3604197996171519, -0.29999999999999993, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2294913236274982, -0.30000000000000004, 0.69999999999999996, 
+  { 2.9562123549913872, -0.29999999999999993, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler068 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.80000000000000004.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.4358357000101250e-16
+// Test data for k=-0.29999999999999993, nu=0.80000000000000004.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.1197887707781618e-16
+// mean(f - f_Boost): 3.4416913763379854e-16
+// variance(f - f_Boost): 4.3461914185990199e-31
+// stddev(f - f_Boost): 6.5925650687718054e-16
 const testcase_ellint_3<double>
 data069[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.80000000000000004, 
+  { 0.0000000000000000, -0.29999999999999993, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17322209907520358, -0.30000000000000004, 0.80000000000000004, 
+  { 0.17604338956191670, -0.29999999999999993, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.33917623046949996, -0.30000000000000004, 0.80000000000000004, 
+  { 0.36146952517410791, -0.29999999999999993, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49307204894329176, -0.30000000000000004, 0.80000000000000004, 
+  { 0.56736453393774644, -0.29999999999999993, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.63337802830291734, -0.30000000000000004, 0.80000000000000004, 
+  { 0.80873149979001091, -0.29999999999999993, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.76104540997689407, -0.30000000000000004, 0.80000000000000004, 
+  { 1.1077903069860620, -0.29999999999999993, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.87832009635450714, -0.30000000000000004, 0.80000000000000004, 
+  { 1.4985874311132998, -0.29999999999999993, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 0.98787879723171790, -0.30000000000000004, 0.80000000000000004, 
+  { 2.0298167266724954, -0.29999999999999993, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.0924036340069339, -0.30000000000000004, 0.80000000000000004, 
+  { 2.7483929054985432, -0.29999999999999993, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.1944567571590048, -0.30000000000000004, 0.80000000000000004, 
+  { 3.6283050484567170, -0.29999999999999993, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler069 = 2.5000000000000020e-13;
 
-// Test data for k=-0.30000000000000004, nu=0.90000000000000002.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.6419688299804087e-16
+// Test data for k=-0.29999999999999993, nu=0.90000000000000002.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.1301806687926828e-16
+// mean(f - f_Boost): 4.1633363423443370e-16
+// variance(f - f_Boost): 2.2835347143080263e-31
+// stddev(f - f_Boost): 4.7786344433405093e-16
 const testcase_ellint_3<double>
 data070[10] =
 {
-  { 0.0000000000000000, -0.30000000000000004, 0.90000000000000002, 
+  { 0.0000000000000000, -0.29999999999999993, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17305109924485945, -0.30000000000000004, 0.90000000000000002, 
+  { 0.17622526204962433, -0.29999999999999993, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33793890239556984, -0.30000000000000004, 0.90000000000000002, 
+  { 0.36304439230777141, -0.29999999999999993, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.48947218005089738, -0.30000000000000004, 0.90000000000000002, 
+  { 0.57345914744719195, -0.29999999999999993, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.62623332340775151, -0.30000000000000004, 0.90000000000000002, 
+  { 0.82641512928845162, -0.29999999999999993, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.74951596581511148, -0.30000000000000004, 0.90000000000000002, 
+  { 1.1534256210757743, -0.29999999999999993, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.86189886597755994, -0.30000000000000004, 0.90000000000000002, 
+  { 1.6124900353411677, -0.29999999999999993, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.96629451153092005, -0.30000000000000004, 0.90000000000000002, 
+  { 2.3165905514845089, -0.29999999999999993, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.0655269133492682, -0.30000000000000004, 0.90000000000000002, 
+  { 3.4625619526539824, -0.29999999999999993, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.1622376896064914, -0.30000000000000004, 0.90000000000000002, 
+  { 5.1479514944016787, -0.29999999999999993, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler070 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.0000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2156475739151676e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 4.2156475739151676e-16
+// mean(f - f_Boost): -5.2735593669694933e-17
+// variance(f - f_Boost): 3.0473442641042680e-32
+// stddev(f - f_Boost): 1.7456644190978597e-16
 const testcase_ellint_3<double>
 data071[10] =
 {
   { 0.0000000000000000, -0.19999999999999996, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17456817290292809, -0.19999999999999996, 0.0000000000000000, 
+  { 0.17456817290292806, -0.19999999999999996, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.34934315932086801, -0.19999999999999996, 0.0000000000000000, 
+  { 0.34934315932086796, -0.19999999999999996, 0.0000000000000000, 
 	  0.34906585039886590 },
   { 0.52450880529443988, -0.19999999999999996, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.70020491009844876, -0.19999999999999996, 0.0000000000000000, 
+  { 0.70020491009844887, -0.19999999999999996, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.87651006649967955, -0.19999999999999996, 0.0000000000000000, 
+  { 0.87651006649967977, -0.19999999999999996, 0.0000000000000000, 
 	  0.87266462599716477 },
   { 1.0534305870298994, -0.19999999999999996, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2308975521670784, -0.19999999999999996, 0.0000000000000000, 
+  { 1.2308975521670789, -0.19999999999999996, 0.0000000000000000, 
 	  1.2217304763960306 },
   { 1.4087733584990738, -0.19999999999999996, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.5868678474541660, -0.19999999999999996, 0.0000000000000000, 
+  { 1.5868678474541662, -0.19999999999999996, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler071 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.10000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3374593253183472e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 4.0890622182605400e-16
+// mean(f - f_Boost): -3.8857805861880476e-17
+// variance(f - f_Boost): 2.8794792590749608e-32
+// stddev(f - f_Boost): 1.6969028431454054e-16
 const testcase_ellint_3<double>
 data072[10] =
 {
   { 0.0000000000000000, -0.19999999999999996, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17439228502691748, -0.19999999999999996, 0.10000000000000001, 
+  { 0.17474469953608965, -0.19999999999999996, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34796731137565740, -0.19999999999999996, 0.10000000000000001, 
+  { 0.35073860234984255, -0.19999999999999996, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52003370294544848, -0.19999999999999996, 0.10000000000000001, 
+  { 0.52912258712951521, -0.19999999999999996, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.69012222258631462, -0.19999999999999996, 0.10000000000000001, 
+  { 0.71081701558898069, -0.19999999999999996, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.85803491465566772, -0.19999999999999996, 0.10000000000000001, 
+  { 0.89640758521169384, -0.19999999999999996, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0238463961099364, -0.19999999999999996, 0.10000000000000001, 
+  { 1.0860417038089853, -0.19999999999999996, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.1878691059202153, -0.19999999999999996, 0.10000000000000001, 
+  { 1.2793599255528623, -0.19999999999999996, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.3505985031831940, -0.19999999999999996, 0.10000000000000001, 
+  { 1.4754938544089076, -0.19999999999999996, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.5126513474261087, -0.19999999999999996, 0.10000000000000001, 
+  { 1.6731552050562593, -0.19999999999999996, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler072 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.20000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.4549984059502760e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 3.9570963716579749e-16
+// mean(f - f_Boost): -5.8286708792820721e-17
+// variance(f - f_Boost): 3.1158217732380362e-32
+// stddev(f - f_Boost): 1.7651690494788412e-16
 const testcase_ellint_3<double>
 data073[10] =
 {
   { 0.0000000000000000, -0.19999999999999996, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17421703179583747, -0.19999999999999996, 0.20000000000000001, 
+  { 0.17492186907740698, -0.19999999999999996, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34661057411998791, -0.19999999999999996, 0.20000000000000001, 
+  { 0.35215414286134267, -0.19999999999999996, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.51569006052647393, -0.19999999999999996, 0.20000000000000001, 
+  { 0.53388285615182440, -0.19999999999999996, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.68052412821107244, -0.19999999999999996, 0.20000000000000001, 
+  { 0.72200960282688265, -0.19999999999999996, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.84081341263313825, -0.19999999999999996, 0.20000000000000001, 
+  { 0.91793087614428526, -0.19999999999999996, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 0.99683359988842890, -0.19999999999999996, 0.20000000000000001, 
+  { 1.1222602841587976, -0.19999999999999996, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1493086715118852, -0.19999999999999996, 0.20000000000000001, 
+  { 1.3345489407496247, -0.19999999999999996, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.2992699693957541, -0.19999999999999996, 0.20000000000000001, 
+  { 1.5531225705475502, -0.19999999999999996, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.4479323932249564, -0.19999999999999996, 0.20000000000000001, 
+  { 1.7751816279738935, -0.19999999999999996, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler073 = 2.5000000000000020e-13;
 
-// Test data for k=-0.19999999999999996, nu=0.29999999999999999.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.3140668101543467e-16
+// Test data for k=-0.19999999999999996, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.6785817924053817e-16
+// mean(f - f_Boost): -1.1102230246251566e-17
+// variance(f - f_Boost): 9.9840208317034302e-32
+// stddev(f - f_Boost): 3.1597501217190311e-16
 const testcase_ellint_3<double>
 data074[10] =
 {
-  { 0.0000000000000000, -0.19999999999999996, 0.29999999999999999, 
+  { 0.0000000000000000, -0.19999999999999996, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17404240913577704, -0.19999999999999996, 0.29999999999999999, 
+  { 0.17509968571715159, -0.19999999999999996, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34527248032587193, -0.19999999999999996, 0.29999999999999999, 
+  { 0.35359030214835629, -0.19999999999999996, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51147118981668416, -0.19999999999999996, 0.29999999999999999, 
+  { 0.53879807274537084, -0.19999999999999996, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.67137107867777601, -0.19999999999999996, 0.29999999999999999, 
+  { 0.73384116418059731, -0.19999999999999996, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.82470418188668893, -0.19999999999999996, 0.29999999999999999, 
+  { 0.94132799329524031, -0.19999999999999996, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 0.97202873223594299, -0.19999999999999996, 0.29999999999999999, 
+  { 1.1628407021801439, -0.19999999999999996, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1144773569375266, -0.19999999999999996, 0.29999999999999999, 
+  { 1.3982440216739438, -0.19999999999999996, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.2535292433701000, -0.19999999999999996, 0.29999999999999999, 
+  { 1.6450634983653640, -0.19999999999999996, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.3908453514752477, -0.19999999999999996, 0.29999999999999999, 
+  { 1.8983924169967099, -0.19999999999999996, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler074 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.6788709752760483e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3298410018355870e-16
+// mean(f - f_Boost): 1.3877787807814457e-17
+// variance(f - f_Boost): 9.4370567274974557e-32
+// stddev(f - f_Boost): 3.0719792850046133e-16
 const testcase_ellint_3<double>
 data075[10] =
 {
   { 0.0000000000000000, -0.19999999999999996, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17386841301066674, -0.19999999999999996, 0.40000000000000002, 
+  { 0.17527815368535152, -0.19999999999999996, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34395257914113253, -0.19999999999999996, 0.40000000000000002, 
+  { 0.35504762134297801, -0.19999999999999996, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.50737088376869466, -0.19999999999999996, 0.40000000000000002, 
+  { 0.54387742353211344, -0.19999999999999996, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.66262801717277631, -0.19999999999999996, 0.40000000000000002, 
+  { 0.74637910471804259, -0.19999999999999996, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.80958766645079094, -0.19999999999999996, 0.40000000000000002, 
+  { 0.96690539714174639, -0.19999999999999996, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.94913754236162040, -0.19999999999999996, 0.40000000000000002, 
+  { 1.2087859420184757, -0.19999999999999996, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.0827985514222997, -0.19999999999999996, 0.40000000000000002, 
+  { 1.4729799844168852, -0.19999999999999996, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2124212429050478, -0.19999999999999996, 0.40000000000000002, 
+  { 1.7564445064596661, -0.19999999999999996, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.3400002519661005, -0.19999999999999996, 0.40000000000000002, 
+  { 2.0512956926676802, -0.19999999999999996, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler075 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.50000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.7788201301356829e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3841806057292116e-16
+// mean(f - f_Boost): 8.0491169285323847e-17
+// variance(f - f_Boost): 8.0538110429953348e-32
+// stddev(f - f_Boost): 2.8379237204328335e-16
 const testcase_ellint_3<double>
 data076[10] =
 {
   { 0.0000000000000000, -0.19999999999999996, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17369503942181799, -0.19999999999999996, 0.50000000000000000, 
+  { 0.17545727725228877, -0.19999999999999996, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34265043534362660, -0.19999999999999996, 0.50000000000000000, 
+  { 0.35652666242062175, -0.19999999999999996, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50338337208655415, -0.19999999999999996, 0.50000000000000000, 
+  { 0.54913090549102406, -0.19999999999999996, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.65426373297163609, -0.19999999999999996, 0.50000000000000000, 
+  { 0.75970161209211551, -0.19999999999999996, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.79536193036145808, -0.19999999999999996, 0.50000000000000000, 
+  { 0.99504737401590326, -0.19999999999999996, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.92791875910061605, -0.19999999999999996, 0.50000000000000000, 
+  { 1.2614666007124373, -0.19999999999999996, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0538145052725829, -0.19999999999999996, 0.50000000000000000, 
+  { 1.5625255355205496, -0.19999999999999996, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.1752060022875899, -0.19999999999999996, 0.50000000000000000, 
+  { 1.8954460255613343, -0.19999999999999996, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.2943374404397372, -0.19999999999999996, 0.50000000000000000, 
+  { 2.2481046259421302, -0.19999999999999996, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler076 = 2.5000000000000020e-13;
 
-// Test data for k=-0.19999999999999996, nu=0.59999999999999998.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.8899223779598256e-16
+// Test data for k=-0.19999999999999996, nu=0.60000000000000009.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5317584994994743e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 1.0045745697575397e-31
+// stddev(f - f_Boost): 3.1695024369095219e-16
 const testcase_ellint_3<double>
 data077[10] =
 {
-  { 0.0000000000000000, -0.19999999999999996, 0.59999999999999998, 
+  { 0.0000000000000000, -0.19999999999999996, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17352228440746925, -0.19999999999999996, 0.59999999999999998, 
+  { 0.17563706072900442, -0.19999999999999996, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34136562863713626, -0.19999999999999996, 0.59999999999999998, 
+  { 0.35802800926807238, -0.19999999999999996, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.49950328177638481, -0.19999999999999996, 0.59999999999999998, 
+  { 0.55456942250515051, -0.19999999999999996, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.64625032705690799, -0.19999999999999996, 0.59999999999999998, 
+  { 0.77390003828438203, -0.19999999999999996, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.78193941198403083, -0.19999999999999996, 0.59999999999999998, 
+  { 1.0262441366366397, -0.19999999999999996, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.90817230934317128, -0.19999999999999996, 0.59999999999999998, 
+  { 1.3228192988439669, -0.19999999999999996, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0271563751276462, -0.19999999999999996, 0.59999999999999998, 
+  { 1.6728005754680795, -0.19999999999999996, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1412999379040518, -0.19999999999999996, 0.59999999999999998, 
+  { 2.0761587107468511, -0.19999999999999996, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.2530330675914556, -0.19999999999999996, 0.59999999999999998, 
+  { 2.5148333891629315, -0.19999999999999996, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler077 = 2.5000000000000020e-13;
 
-// Test data for k=-0.19999999999999996, nu=0.69999999999999996.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.9999318361775115e-16
+// Test data for k=-0.19999999999999996, nu=0.70000000000000007.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.1818454249546518e-16
+// mean(f - f_Boost): 3.6082248300317589e-17
+// variance(f - f_Boost): 8.9638010532618564e-32
+// stddev(f - f_Boost): 2.9939607634806868e-16
 const testcase_ellint_3<double>
 data078[10] =
 {
-  { 0.0000000000000000, -0.19999999999999996, 0.69999999999999996, 
+  { 0.0000000000000000, -0.19999999999999996, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17335014404233895, -0.19999999999999996, 0.69999999999999996, 
+  { 0.17581750846781172, -0.19999999999999996, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34009775298617811, -0.19999999999999996, 0.69999999999999996, 
+  { 0.35955226882028513, -0.19999999999999996, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.49572560201923810, -0.19999999999999996, 0.69999999999999996, 
+  { 0.56020489659466499, -0.19999999999999996, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.63856276669886503, -0.19999999999999996, 0.69999999999999996, 
+  { 0.78908196988531487, -0.19999999999999996, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.76924438644867565, -0.19999999999999996, 0.69999999999999996, 
+  { 1.0611336754143517, -0.19999999999999996, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.88973060843856466, -0.19999999999999996, 0.69999999999999996, 
+  { 1.3956969951058884, -0.19999999999999996, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0025230471636377, -0.19999999999999996, 0.69999999999999996, 
+  { 1.8138131612209609, -0.19999999999999996, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1102356376093103, -0.19999999999999996, 0.69999999999999996, 
+  { 2.3256365528879561, -0.19999999999999996, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2154356555075863, -0.19999999999999996, 0.69999999999999996, 
+  { 2.9058704854500963, -0.19999999999999996, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler078 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 5.0901276230707249e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.9866614515542431e-16
+// mean(f - f_Boost): 1.8318679906315082e-16
+// variance(f - f_Boost): 3.1335688610218711e-31
+// stddev(f - f_Boost): 5.5978289193417400e-16
 const testcase_ellint_3<double>
 data079[10] =
 {
   { 0.0000000000000000, -0.19999999999999996, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17317861443718538, -0.19999999999999996, 0.80000000000000004, 
+  { 0.17599862486281712, -0.19999999999999996, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.33884641598718701, -0.19999999999999996, 0.80000000000000004, 
+  { 0.36110007227128776, -0.19999999999999996, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49204565281259494, -0.19999999999999996, 0.80000000000000004, 
+  { 0.56605039658567224, -0.19999999999999996, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.63117851188220320, -0.19999999999999996, 0.80000000000000004, 
+  { 0.80537523874517691, -0.19999999999999996, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.75721095949544170, -0.19999999999999996, 0.80000000000000004, 
+  { 1.1005662342414086, -0.19999999999999996, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.87245201443919118, -0.19999999999999996, 0.80000000000000004, 
+  { 1.4845340298105778, -0.19999999999999996, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 0.97966584238831089, -0.19999999999999996, 0.80000000000000004, 
+  { 2.0043332244969392, -0.19999999999999996, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.0816336325174360, -0.19999999999999996, 0.80000000000000004, 
+  { 2.7052856676744761, -0.19999999999999996, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.1810223448909909, -0.19999999999999996, 0.80000000000000004, 
+  { 3.5622166386422629, -0.19999999999999996, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler079 = 2.5000000000000020e-13;
 
 // Test data for k=-0.19999999999999996, nu=0.90000000000000002.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 6.4833128442756722e-16
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.2817178727913890e-16
+// mean(f - f_Boost): 3.4694469519536142e-16
+// variance(f - f_Boost): 6.6311432369155086e-31
+// stddev(f - f_Boost): 8.1431831840598485e-16
 const testcase_ellint_3<double>
 data080[10] =
 {
   { 0.0000000000000000, -0.19999999999999996, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17300769173837277, -0.19999999999999996, 0.90000000000000002, 
+  { 0.17618041435044951, -0.19999999999999996, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33761123827372508, -0.19999999999999996, 0.90000000000000002, 
+  { 0.36267207636502929, -0.19999999999999996, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.48845905690769426, -0.19999999999999996, 0.90000000000000002, 
+  { 0.57212028758237743, -0.19999999999999996, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.62407720017324952, -0.19999999999999996, 0.90000000000000002, 
+  { 0.82293323876704483, -0.19999999999999996, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.74578146525124289, -0.19999999999999996, 0.90000000000000002, 
+  { 1.1457077279880385, -0.19999999999999996, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.85621583540073076, -0.19999999999999996, 0.90000000000000002, 
+  { 1.5967346899325681, -0.19999999999999996, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.95837725988001199, -0.19999999999999996, 0.90000000000000002, 
+  { 2.2856537353421724, -0.19999999999999996, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.0551821412633928, -0.19999999999999996, 0.90000000000000002, 
+  { 3.4034714304613902, -0.19999999999999996, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.1493679916141861, -0.19999999999999996, 0.90000000000000002, 
+  { 5.0448269356200361, -0.19999999999999996, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler080 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.0000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.1735566504509650e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.1735566504509645e-16
+// mean(f - f_Boost): -3.6082248300317589e-17
+// variance(f - f_Boost): 8.2258607846939269e-33
+// stddev(f - f_Boost): 9.0696531271564778e-17
 const testcase_ellint_3<double>
 data081[10] =
 {
   { 0.0000000000000000, -0.099999999999999978, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17454173353063659, -0.099999999999999978, 0.0000000000000000, 
+  { 0.17454173353063662, -0.099999999999999978, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.34913506721468091, -0.099999999999999978, 0.0000000000000000, 
+  { 0.34913506721468096, -0.099999999999999978, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.52382550016538942, -0.099999999999999978, 0.0000000000000000, 
+  { 0.52382550016538953, -0.099999999999999978, 0.0000000000000000, 
 	  0.52359877559829882 },
   { 0.69864700854177020, -0.099999999999999978, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.87361792586964870, -0.099999999999999978, 0.0000000000000000, 
+  { 0.87361792586964859, -0.099999999999999978, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.0487386319621683, -0.099999999999999978, 0.0000000000000000, 
+  { 1.0487386319621685, -0.099999999999999978, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2239913752078757, -0.099999999999999978, 0.0000000000000000, 
+  { 1.2239913752078759, -0.099999999999999978, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.3993423113684049, -0.099999999999999978, 0.0000000000000000, 
+  { 1.3993423113684051, -0.099999999999999978, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.5747455615173562, -0.099999999999999978, 0.0000000000000000, 
+  { 1.5747455615173558, -0.099999999999999978, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler081 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.10000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3097339877269682e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.0305747373482148e-16
+// mean(f - f_Boost): -3.0531133177191807e-17
+// variance(f - f_Boost): 1.1508025840536076e-34
+// stddev(f - f_Boost): 1.0727546709539920e-17
 const testcase_ellint_3<double>
 data082[10] =
 {
   { 0.0000000000000000, -0.099999999999999978, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17436589347616613, -0.099999999999999978, 0.10000000000000001, 
+  { 0.17471821213559732, -0.099999999999999978, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34776067871237359, -0.099999999999999978, 0.10000000000000001, 
+  { 0.35052902610011138, -0.099999999999999978, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.51936064354727796, -0.099999999999999978, 0.10000000000000001, 
+  { 0.52842865990255727, -0.099999999999999978, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.68860303749364349, -0.099999999999999978, 0.10000000000000001, 
+  { 0.70921799731166713, -0.099999999999999978, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.85524561882332051, -0.099999999999999978, 0.10000000000000001, 
+  { 0.89340330535868662, -0.099999999999999978, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0193708301908335, -0.099999999999999978, 0.10000000000000001, 
+  { 1.0811075784236857, -0.099999999999999978, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.1813474067123044, -0.099999999999999978, 0.10000000000000001, 
+  { 1.2720133232666426, -0.099999999999999978, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.3417670770424983, -0.099999999999999978, 0.10000000000000001, 
+  { 1.4653630031861395, -0.099999999999999978, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.5013711111199950, -0.099999999999999978, 0.10000000000000001, 
+  { 1.6600374067558428, -0.099999999999999978, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler082 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.20000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.4399947764827574e-16
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 1.6736714959992433e-16
+// mean(f - f_Boost): 5.5511151231257830e-18
+// variance(f - f_Boost): 3.8043060629871325e-36
+// stddev(f - f_Boost): 1.9504630380981673e-18
 const testcase_ellint_3<double>
 data083[10] =
 {
   { 0.0000000000000000, -0.099999999999999978, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17419068786141340, -0.099999999999999978, 0.20000000000000001, 
+  { 0.17489533344059083, -0.099999999999999978, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34640537686230133, -0.099999999999999978, 0.20000000000000001, 
+  { 0.35194305707815038, -0.099999999999999978, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.51502689171753946, -0.099999999999999978, 0.20000000000000001, 
+  { 0.53317790741512527, -0.099999999999999978, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.67904147863672715, -0.099999999999999978, 0.20000000000000001, 
+  { 0.72036681615081222, -0.099999999999999978, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.83811885126105179, -0.099999999999999978, 0.20000000000000001, 
+  { 0.91480372268244303, -0.099999999999999978, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 0.99255278555742787, -0.099999999999999978, 0.20000000000000001, 
+  { 1.1170528708071514, -0.099999999999999978, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1431260546194930, -0.099999999999999978, 0.20000000000000001, 
+  { 1.3266916802718358, -0.099999999999999978, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.2909589656532101, -0.099999999999999978, 0.20000000000000001, 
+  { 1.5421622241831547, -0.099999999999999978, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.4373749386463430, -0.099999999999999978, 0.20000000000000001, 
+  { 1.7608656115083421, -0.099999999999999978, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler083 = 2.5000000000000020e-13;
 
-// Test data for k=-0.099999999999999978, nu=0.29999999999999999.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.5650492137236872e-16
+// Test data for k=-0.099999999999999978, nu=0.30000000000000004.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 1.9186071760326645e-16
+// mean(f - f_Boost): -1.6653345369377347e-17
+// variance(f - f_Boost): 3.4238754566884194e-35
+// stddev(f - f_Boost): 5.8513891142945016e-18
 const testcase_ellint_3<double>
 data084[10] =
 {
-  { 0.0000000000000000, -0.099999999999999978, 0.29999999999999999, 
+  { 0.0000000000000000, -0.099999999999999978, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17401611261390104, -0.099999999999999978, 0.29999999999999999, 
+  { 0.17507310163441189, -0.099999999999999978, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34506869507511773, -0.099999999999999978, 0.29999999999999999, 
+  { 0.35337768072524217, -0.099999999999999978, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51081757604259859, -0.099999999999999978, 0.29999999999999999, 
+  { 0.53808167801629170, -0.099999999999999978, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.66992297597712303, -0.099999999999999978, 0.29999999999999999, 
+  { 0.73215166755955019, -0.099999999999999978, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.82209722856174228, -0.099999999999999978, 0.29999999999999999, 
+  { 0.93806546000201219, -0.099999999999999978, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 0.96792430487669590, -0.099999999999999978, 0.29999999999999999, 
+  { 1.1573218723395986, -0.099999999999999978, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1085964108954092, -0.099999999999999978, 0.29999999999999999, 
+  { 1.3897859679542097, -0.099999999999999978, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.2456748370836999, -0.099999999999999978, 0.29999999999999999, 
+  { 1.6331009404328622, -0.099999999999999978, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.3809159606704959, -0.099999999999999978, 0.29999999999999999, 
+  { 1.8826015946315438, -0.099999999999999978, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler084 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.6854758534459740e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0338059536914377e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 9.5107651574678308e-35
+// stddev(f - f_Boost): 9.7523151904908362e-18
 const testcase_ellint_3<double>
 data085[10] =
 {
   { 0.0000000000000000, -0.099999999999999978, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17384216369897931, -0.099999999999999978, 0.40000000000000002, 
+  { 0.17525152094559704, -0.099999999999999978, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34375018311376787, -0.099999999999999978, 0.40000000000000002, 
+  { 0.35483343742825979, -0.099999999999999978, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.50672650758380455, -0.099999999999999978, 0.40000000000000002, 
+  { 0.54314913099505446, -0.099999999999999978, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.66121264213337616, -0.099999999999999978, 0.40000000000000002, 
+  { 0.74463962034766862, -0.099999999999999978, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.80706202005774441, -0.099999999999999978, 0.40000000000000002, 
+  { 0.96349276837570441, -0.099999999999999978, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.94519376138245870, -0.099999999999999978, 0.40000000000000002, 
+  { 1.2029081382746343, -0.099999999999999978, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.0771880300759584, -0.099999999999999978, 0.40000000000000002, 
+  { 1.4638022887050806, -0.099999999999999978, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2049711557188272, -0.099999999999999978, 0.40000000000000002, 
+  { 1.7432413830105224, -0.099999999999999978, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.3306223265207477, -0.099999999999999978, 0.40000000000000002, 
+  { 2.0336367403076760, -0.099999999999999978, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler085 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.50000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8017534281650347e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.9864616042835278e-16
+// mean(f - f_Boost): 1.0547118733938987e-16
+// variance(f - f_Boost): 7.5633408838247182e-32
+// stddev(f - f_Boost): 2.7501528837184157e-16
 const testcase_ellint_3<double>
 data086[10] =
 {
   { 0.0000000000000000, -0.099999999999999978, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17366883711936548, -0.099999999999999978, 0.50000000000000000, 
+  { 0.17543059564292182, -0.099999999999999978, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34244940634881882, -0.099999999999999978, 0.50000000000000000, 
+  { 0.35631088838721664, -0.099999999999999978, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50274793281634367, -0.099999999999999978, 0.50000000000000000, 
+  { 0.54839023346436444, -0.099999999999999978, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.65287941633275082, -0.099999999999999978, 0.50000000000000000, 
+  { 0.75790846946088830, -0.099999999999999978, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.79291198790315398, -0.099999999999999978, 0.50000000000000000, 
+  { 0.99146713686720678, -0.099999999999999978, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.92412201537880323, -0.099999999999999978, 0.50000000000000000, 
+  { 1.2551692247937198, -0.099999999999999978, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0484480076799372, -0.099999999999999978, 0.50000000000000000, 
+  { 1.5524660788146873, -0.099999999999999978, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.1681168130475206, -0.099999999999999978, 0.50000000000000000, 
+  { 1.8806578570830670, -0.099999999999999978, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.2854480708580160, -0.099999999999999978, 0.50000000000000000, 
+  { 2.2279868912966849, -0.099999999999999978, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler086 = 2.5000000000000020e-13;
 
-// Test data for k=-0.099999999999999978, nu=0.59999999999999998.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.9142834151672032e-16
+// Test data for k=-0.099999999999999978, nu=0.60000000000000009.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.6726146516228014e-16
+// mean(f - f_Boost): -3.6082248300317589e-17
+// variance(f - f_Boost): 1.6073193116120635e-34
+// stddev(f - f_Boost): 1.2678009747638087e-17
 const testcase_ellint_3<double>
 data087[10] =
 {
-  { 0.0000000000000000, -0.099999999999999978, 0.59999999999999998, 
+  { 0.0000000000000000, -0.099999999999999978, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17349612891469013, -0.099999999999999978, 0.59999999999999998, 
+  { 0.17561033003590576, -0.099999999999999978, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34116594505539444, -0.099999999999999978, 0.59999999999999998, 
+  { 0.35781061668171932, -0.099999999999999978, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.49887649430466674, -0.099999999999999978, 0.59999999999999998, 
+  { 0.55381585659629196, -0.099999999999999978, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.64489553282165146, -0.099999999999999978, 0.59999999999999998, 
+  { 0.77204910484575640, -0.099999999999999978, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.77956016553782437, -0.099999999999999978, 0.59999999999999998, 
+  { 1.0224751740393108, -0.099999999999999978, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.90451074530096287, -0.099999999999999978, 0.59999999999999998, 
+  { 1.3160230906351114, -0.099999999999999978, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0220113666961632, -0.099999999999999978, 0.59999999999999998, 
+  { 1.6616282844233206, -0.099999999999999978, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1345351441065563, -0.099999999999999978, 0.59999999999999998, 
+  { 2.0592555664850392, -0.099999999999999978, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.2445798942989255, -0.099999999999999978, 0.59999999999999998, 
+  { 2.4913004919173822, -0.099999999999999978, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler087 = 2.5000000000000020e-13;
 
-// Test data for k=-0.099999999999999978, nu=0.69999999999999996.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.5172091551439012e-16
+// Test data for k=-0.099999999999999978, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 2.1004074871280821e-16
+// mean(f - f_Boost): 3.3306690738754695e-17
+// variance(f - f_Boost): 1.3695501826753678e-34
+// stddev(f - f_Boost): 1.1702778228589003e-17
 const testcase_ellint_3<double>
 data088[10] =
 {
-  { 0.0000000000000000, -0.099999999999999978, 0.69999999999999996, 
+  { 0.0000000000000000, -0.099999999999999978, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17332403516105047, -0.099999999999999978, 0.69999999999999996, 
+  { 0.17579072847532518, -0.099999999999999978, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.33989939374896883, -0.099999999999999978, 0.69999999999999996, 
+  { 0.35933322840606297, -0.099999999999999978, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.49510719568614070, -0.099999999999999978, 0.69999999999999996, 
+  { 0.55943788649460324, -0.099999999999999978, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.63723607776354974, -0.099999999999999978, 0.69999999999999996, 
+  { 0.78716856504031707, -0.099999999999999978, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.76693133887935327, -0.099999999999999978, 0.69999999999999996, 
+  { 1.0571501305617423, -0.099999999999999978, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.88619382078823805, -0.099999999999999978, 0.69999999999999996, 
+  { 1.3882948301743525, -0.099999999999999978, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 0.99758012018676490, -0.099999999999999978, 0.69999999999999996, 
+  { 1.8011785680114223, -0.099999999999999978, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1037642270814410, -0.099999999999999978, 0.69999999999999996, 
+  { 2.3057268183616464, -0.099999999999999978, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2073745911083185, -0.099999999999999978, 0.69999999999999996, 
+  { 2.8771910188009739, -0.099999999999999978, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler088 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1294144515772258e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.3133043868392355e-16
+// mean(f - f_Boost): 1.8041124150158794e-16
+// variance(f - f_Boost): 6.1843750436434569e-32
+// stddev(f - f_Boost): 2.4868403735751633e-16
 const testcase_ellint_3<double>
 data089[10] =
 {
   { 0.0000000000000000, -0.099999999999999978, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17315255197057014, -0.099999999999999978, 0.80000000000000004, 
+  { 0.17597179535373417, -0.099999999999999978, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.33864936055747991, -0.099999999999999978, 0.80000000000000004, 
+  { 0.36087935387831499, -0.099999999999999978, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49143537041117613, -0.099999999999999978, 0.80000000000000004, 
+  { 0.56526935244526444, -0.099999999999999978, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.62987861760047492, -0.099999999999999978, 0.80000000000000004, 
+  { 0.80339402590612397, -0.099999999999999978, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.75496005490917517, -0.099999999999999978, 0.80000000000000004, 
+  { 1.0963358646374459, -0.099999999999999978, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.86903081862701881, -0.099999999999999978, 0.80000000000000004, 
+  { 1.4763748483246868, -0.099999999999999978, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 0.97490814820725591, -0.099999999999999978, 0.80000000000000004, 
+  { 1.9896610222794102, -0.099999999999999978, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.0754290107171083, -0.099999999999999978, 0.80000000000000004, 
+  { 2.6806423920122024, -0.099999999999999978, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.1733158866987732, -0.099999999999999978, 0.80000000000000004, 
+  { 3.5246199613295612, -0.099999999999999978, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler089 = 2.5000000000000020e-13;
 
 // Test data for k=-0.099999999999999978, nu=0.90000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2325599449457852e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5624826890976725e-16
+// mean(f - f_Boost): 2.3314683517128288e-16
+// variance(f - f_Boost): 2.9401198977189756e-31
+// stddev(f - f_Boost): 5.4222872459129045e-16
 const testcase_ellint_3<double>
 data090[10] =
 {
   { 0.0000000000000000, -0.099999999999999978, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17298167549096563, -0.099999999999999978, 0.90000000000000002, 
+  { 0.17615353510599349, -0.099999999999999978, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33741546662741589, -0.099999999999999978, 0.90000000000000002, 
+  { 0.36244964892922371, -0.099999999999999978, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.48785665376856868, -0.099999999999999978, 0.90000000000000002, 
+  { 0.57132457590110530, -0.099999999999999978, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.62280288554518959, -0.099999999999999978, 0.90000000000000002, 
+  { 0.82087808820385000, -0.099999999999999978, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.74358903115455188, -0.099999999999999978, 0.90000000000000002, 
+  { 1.1411894342144451, -0.099999999999999978, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.85290207679298335, -0.099999999999999978, 0.90000000000000002, 
+  { 1.5875929286844597, -0.099999999999999978, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.95379006645397379, -0.099999999999999978, 0.90000000000000002, 
+  { 2.2678622986596659, -0.099999999999999978, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.0492213119872327, -0.099999999999999978, 0.90000000000000002, 
+  { 3.3697528941897903, -0.099999999999999978, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.1419839485283374, -0.099999999999999978, 0.90000000000000002, 
+  { 4.9862890417305499, -0.099999999999999978, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler090 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.0000000000000000.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 2.1203697876423452e-16
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.1203697876423447e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
 const testcase_ellint_3<double>
 data091[10] =
 {
   { 0.0000000000000000, 0.0000000000000000, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17453292519943292, 0.0000000000000000, 0.0000000000000000, 
+  { 0.17453292519943295, 0.0000000000000000, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.34906585039886584, 0.0000000000000000, 0.0000000000000000, 
+  { 0.34906585039886590, 0.0000000000000000, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.52359877559829870, 0.0000000000000000, 0.0000000000000000, 
+  { 0.52359877559829882, 0.0000000000000000, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.69813170079773168, 0.0000000000000000, 0.0000000000000000, 
+  { 0.69813170079773179, 0.0000000000000000, 0.0000000000000000, 
 	  0.69813170079773179 },
   { 0.87266462599716477, 0.0000000000000000, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.0471975511965974, 0.0000000000000000, 0.0000000000000000, 
+  { 1.0471975511965976, 0.0000000000000000, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2217304763960304, 0.0000000000000000, 0.0000000000000000, 
+  { 1.2217304763960306, 0.0000000000000000, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.3962634015954631, 0.0000000000000000, 0.0000000000000000, 
+  { 1.3962634015954636, 0.0000000000000000, 0.0000000000000000, 
 	  1.3962634015954636 },
   { 1.5707963267948966, 0.0000000000000000, 0.0000000000000000, 
 	  1.5707963267948966 },
@@ -2678,849 +2950,939 @@
 const double toler091 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.10000000000000001.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 2.1813975824747021e-16
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.1019052604815601e-16
+// mean(f - f_Boost): 2.7755575615628915e-18
+// variance(f - f_Boost): 9.5107651574678312e-37
+// stddev(f - f_Boost): 9.7523151904908366e-19
 const testcase_ellint_3<double>
 data092[10] =
 {
   { 0.0000000000000000, 0.0000000000000000, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17435710107516605, 0.0000000000000000, 0.10000000000000001, 
+  { 0.17470938780535167, 0.0000000000000000, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34769194715329604, 0.0000000000000000, 0.10000000000000001, 
+  { 0.35045931581655582, 0.0000000000000000, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.51913731575866107, 0.0000000000000000, 0.10000000000000001, 
+  { 0.52819841383849875, 0.0000000000000000, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.68810051897078450, 0.0000000000000000, 0.10000000000000001, 
+  { 0.70868910807992958, 0.0000000000000000, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.85432615661706823, 0.0000000000000000, 0.10000000000000001, 
+  { 0.89241311307249638, 0.0000000000000000, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0179006647340794, 0.0000000000000000, 0.10000000000000001, 
+  { 1.0794871444666669, 0.0000000000000000, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.1792120640746322, 0.0000000000000000, 0.10000000000000001, 
+  { 1.2696086247356864, 0.0000000000000000, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.3388834245070498, 0.0000000000000000, 0.10000000000000001, 
+  { 1.4620562617494721, 0.0000000000000000, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.4976955329233277, 0.0000000000000000, 0.10000000000000001, 
+  { 1.6557647109660167, 0.0000000000000000, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler092 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.20000000000000001.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 2.2402804784409065e-16
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.0831888697465320e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
 const testcase_ellint_3<double>
 data093[10] =
 {
   { 0.0000000000000000, 0.0000000000000000, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17418191132226074, 0.0000000000000000, 0.20000000000000001, 
+  { 0.17488649304197776, 0.0000000000000000, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34633712256943405, 0.0000000000000000, 0.20000000000000001, 
+  { 0.35187284488675424, 0.0000000000000000, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.51480684302043700, 0.0000000000000000, 0.20000000000000001, 
+  { 0.53294400750146131, 0.0000000000000000, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.67855102942481937, 0.0000000000000000, 0.20000000000000001, 
+  { 0.71982347021822823, 0.0000000000000000, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.83723056090326253, 0.0000000000000000, 0.20000000000000001, 
+  { 0.91377311030258745, 0.0000000000000000, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 0.99114645269578161, 0.0000000000000000, 0.20000000000000001, 
+  { 1.1153429007215137, 0.0000000000000000, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1411014627915537, 0.0000000000000000, 0.20000000000000001, 
+  { 1.3241202847784086, 0.0000000000000000, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.2882448138013969, 0.0000000000000000, 0.20000000000000001, 
+  { 1.5385854914338242, 0.0000000000000000, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.4339343023863691, 0.0000000000000000, 0.20000000000000001, 
+  { 1.7562036827601815, 0.0000000000000000, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler093 = 2.5000000000000020e-13;
 
-// Test data for k=0.0000000000000000, nu=0.29999999999999999.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 2.2972291118632678e-16
+// Test data for k=0.0000000000000000, nu=0.30000000000000004.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.0642101770923591e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
 const testcase_ellint_3<double>
 data094[10] =
 {
-  { 0.0000000000000000, 0.0000000000000000, 0.29999999999999999, 
+  { 0.0000000000000000, 0.0000000000000000, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17400735186871724, 0.0000000000000000, 0.29999999999999999, 
+  { 0.17506424509761404, 0.0000000000000000, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34500091027020219, 0.0000000000000000, 0.29999999999999999, 
+  { 0.35330695794774630, 0.0000000000000000, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51060069523901530, 0.0000000000000000, 0.29999999999999999, 
+  { 0.53784398359522367, 0.0000000000000000, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.66944393961375448, 0.0000000000000000, 0.29999999999999999, 
+  { 0.73159289408687844, 0.0000000000000000, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.82123776744538157, 0.0000000000000000, 0.29999999999999999, 
+  { 0.93699031797084975, 0.0000000000000000, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 0.96657579245516501, 0.0000000000000000, 0.29999999999999999, 
+  { 1.1555098909390267, 0.0000000000000000, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1066703663542414, 0.0000000000000000, 0.29999999999999999, 
+  { 1.3870184960144325, 0.0000000000000000, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.2431094251944901, 0.0000000000000000, 0.29999999999999999, 
+  { 1.6291980835772994, 0.0000000000000000, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.3776795151134889, 0.0000000000000000, 0.29999999999999999, 
+  { 1.8774607092226381, 0.0000000000000000, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler094 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.40000000000000002.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 2.3524218164111537e-16
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.0449580089795878e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
 const testcase_ellint_3<double>
 data095[10] =
 {
   { 0.0000000000000000, 0.0000000000000000, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17383341868035862, 0.0000000000000000, 0.40000000000000002, 
+  { 0.17524264820030025, 0.0000000000000000, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34368286022299821, 0.0000000000000000, 0.40000000000000002, 
+  { 0.35476219513871499, 0.0000000000000000, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.50651268947499395, 0.0000000000000000, 0.40000000000000002, 
+  { 0.54290749235440094, 0.0000000000000000, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.66074441806097539, 0.0000000000000000, 0.40000000000000002, 
+  { 0.74406433757109913, 0.0000000000000000, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.80622931670113474, 0.0000000000000000, 0.40000000000000002, 
+  { 0.96236826162553313, 0.0000000000000000, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.94389791565435210, 0.0000000000000000, 0.40000000000000002, 
+  { 1.2009785880262487, 0.0000000000000000, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.0753503387899728, 0.0000000000000000, 0.40000000000000002, 
+  { 1.4608000106167567, 0.0000000000000000, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2025374759127518, 0.0000000000000000, 0.40000000000000002, 
+  { 1.7389349574753439, 0.0000000000000000, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.3275651989026320, 0.0000000000000000, 0.40000000000000002, 
+  { 2.0278893379868057, 0.0000000000000000, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler095 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.50000000000000000.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.6090167266677240e-16
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.0254203825026289e-16
+// mean(f - f_Boost): -1.9428902930940238e-17
+// variance(f - f_Boost): 4.6602749271592373e-35
+// stddev(f - f_Boost): 6.8266206333435850e-18
 const testcase_ellint_3<double>
 data096[10] =
 {
   { 0.0000000000000000, 0.0000000000000000, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17366010776037044, 0.0000000000000000, 0.50000000000000000, 
+  { 0.17542170661831016, 0.0000000000000000, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34238253799539309, 0.0000000000000000, 0.50000000000000000, 
+  { 0.35623911740195419, 0.0000000000000000, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50253707775976397, 0.0000000000000000, 0.50000000000000000, 
+  { 0.54814449099863127, 0.0000000000000000, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.65242145347295766, 0.0000000000000000, 0.50000000000000000, 
+  { 0.75731546607718081, 0.0000000000000000, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.79210420018698058, 0.0000000000000000, 0.50000000000000000, 
+  { 0.99028751188233310, 0.0000000000000000, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.92287437995632171, 0.0000000000000000, 0.50000000000000000, 
+  { 1.2531022857760581, 0.0000000000000000, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0466900550798659, 0.0000000000000000, 0.50000000000000000, 
+  { 1.5491761777615785, 0.0000000000000000, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.1658007366618623, 0.0000000000000000, 0.50000000000000000, 
+  { 1.8758359693666533, 0.0000000000000000, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.2825498301618641, 0.0000000000000000, 0.50000000000000000, 
+  { 2.2214414690791831, 0.0000000000000000, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler096 = 2.5000000000000020e-13;
 
-// Test data for k=0.0000000000000000, nu=0.59999999999999998.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 2.4581288258006758e-16
+// Test data for k=0.0000000000000000, nu=0.60000000000000009.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 2.1742785192400269e-16
+// mean(f - f_Boost): 1.3877787807814457e-17
+// variance(f - f_Boost): 2.3776912893669577e-35
+// stddev(f - f_Boost): 4.8761575952454181e-18
 const testcase_ellint_3<double>
 data097[10] =
 {
-  { 0.0000000000000000, 0.0000000000000000, 0.59999999999999998, 
+  { 0.0000000000000000, 0.0000000000000000, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17348741514884700, 0.0000000000000000, 0.59999999999999998, 
+  { 0.17560142466065651, 0.0000000000000000, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34109952405241289, 0.0000000000000000, 0.59999999999999998, 
+  { 0.35773830754879005, 0.0000000000000000, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.49866850781226285, 0.0000000000000000, 0.59999999999999998, 
+  { 0.55356583986445973, 0.0000000000000000, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.64444732407062499, 0.0000000000000000, 0.59999999999999998, 
+  { 0.77143701715151514, 0.0000000000000000, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.77877564686544720, 0.0000000000000000, 0.59999999999999998, 
+  { 1.0212334940541210, 0.0000000000000000, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.90330743691883475, 0.0000000000000000, 0.59999999999999998, 
+  { 1.3137928444460387, 0.0000000000000000, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0203257987604104, 0.0000000000000000, 0.59999999999999998, 
+  { 1.6579755004159076, 0.0000000000000000, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1323247918768629, 0.0000000000000000, 0.59999999999999998, 
+  { 2.0537461418295506, 0.0000000000000000, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.2418235332245127, 0.0000000000000000, 0.59999999999999998, 
+  { 2.4836470664490253, 0.0000000000000000, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler097 = 2.5000000000000020e-13;
 
-// Test data for k=0.0000000000000000, nu=0.69999999999999996.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 2.5088894797856263e-16
+// Test data for k=0.0000000000000000, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 4
+// max(|f - f_Boost| / |f_Boost|): 3.0903019454022601e-16
+// mean(f - f_Boost): -6.9388939039072284e-17
+// variance(f - f_Boost): 5.9442282234173945e-34
+// stddev(f - f_Boost): 2.4380787976227090e-17
 const testcase_ellint_3<double>
 data098[10] =
 {
-  { 0.0000000000000000, 0.0000000000000000, 0.69999999999999996, 
+  { 0.0000000000000000, 0.0000000000000000, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17331533692234474, 0.0000000000000000, 0.69999999999999996, 
+  { 0.17578180667760368, 0.0000000000000000, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.33983341309265935, 0.0000000000000000, 0.69999999999999996, 
+  { 0.35926037139410999, 0.0000000000000000, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.49490198805931979, 0.0000000000000000, 0.69999999999999996, 
+  { 0.55918341315855080, 0.0000000000000000, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.63679715525145297, 0.0000000000000000, 0.69999999999999996, 
+  { 0.78653584856932546, 0.0000000000000000, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.76616861049481944, 0.0000000000000000, 0.69999999999999996, 
+  { 1.0558379029273324, 0.0000000000000000, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.88503143209004198, 0.0000000000000000, 0.69999999999999996, 
+  { 1.3858662544850615, 0.0000000000000000, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 0.99596060249112173, 0.0000000000000000, 0.69999999999999996, 
+  { 1.7970491170359040, 0.0000000000000000, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1016495050260424, 0.0000000000000000, 0.69999999999999996, 
+  { 2.2992404490153917, 0.0000000000000000, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2047457872617382, 0.0000000000000000, 0.69999999999999996, 
+  { 2.8678686047727382, 0.0000000000000000, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler098 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.80000000000000004.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8375904358197891e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.2373744057922657e-16
+// mean(f - f_Boost): 1.0269562977782698e-16
+// variance(f - f_Boost): 1.4388836606733082e-32
+// stddev(f - f_Boost): 1.1995347684303728e-16
 const testcase_ellint_3<double>
 data099[10] =
 {
   { 0.0000000000000000, 0.0000000000000000, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17314386919344210, 0.0000000000000000, 0.80000000000000004, 
+  { 0.17596285706118869, 0.0000000000000000, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.33858381342073240, 0.0000000000000000, 0.80000000000000004, 
+  { 0.36080593896484231, 0.0000000000000000, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49123285640844727, 0.0000000000000000, 0.80000000000000004, 
+  { 0.56501022706967863, 0.0000000000000000, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.62944854858904509, 0.0000000000000000, 0.80000000000000004, 
+  { 0.80273891984116930, 0.0000000000000000, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.75421778305499343, 0.0000000000000000, 0.80000000000000004, 
+  { 1.0949425007763358, 0.0000000000000000, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.86790634112156617, 0.0000000000000000, 0.80000000000000004, 
+  { 1.4736985692253419, 0.0000000000000000, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 0.97334918087427558, 0.0000000000000000, 0.80000000000000004, 
+  { 1.9848676587180696, 0.0000000000000000, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.0734012615283985, 0.0000000000000000, 0.80000000000000004, 
+  { 2.6726187823193546, 0.0000000000000000, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.1708024551734544, 0.0000000000000000, 0.80000000000000004, 
+  { 3.5124073655203634, 0.0000000000000000, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler099 = 2.5000000000000020e-13;
 
 // Test data for k=0.0000000000000000, nu=0.90000000000000002.
-// max(|f - f_GSL|): 1.1102230246251565e-16
-// max(|f - f_GSL| / |f_GSL|): 1.7838310376154469e-16
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 6.6108624815885066e-16
+// mean(f - f_Boost): 2.1371793224034264e-16
+// variance(f - f_Boost): 5.6389326618626776e-33
+// stddev(f - f_Boost): 7.5092826966779442e-17
 const testcase_ellint_3<double>
 data100[10] =
 {
   { 0.0000000000000000, 0.0000000000000000, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17297300811030597, 0.0000000000000000, 0.90000000000000002, 
+  { 0.17614458024574997, 0.0000000000000000, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33735034635360817, 0.0000000000000000, 0.90000000000000002, 
+  { 0.36237566578821978, 0.0000000000000000, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.48765675230233130, 0.0000000000000000, 0.90000000000000002, 
+  { 0.57106058859196640, 0.0000000000000000, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.62238126886123568, 0.0000000000000000, 0.90000000000000002, 
+  { 0.82019857015755915, 0.0000000000000000, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.74286600807269243, 0.0000000000000000, 0.90000000000000002, 
+  { 1.1397014388908147, 0.0000000000000000, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.85181283909264949, 0.0000000000000000, 0.90000000000000002, 
+  { 1.5845952415154960, 0.0000000000000000, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.95228683995371133, 0.0000000000000000, 0.90000000000000002, 
+  { 2.2620531413370775, 0.0000000000000000, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.0472730487412552, 0.0000000000000000, 0.90000000000000002, 
+  { 3.3587842061975066, 0.0000000000000000, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.1395754288497419, 0.0000000000000000, 0.90000000000000002, 
+  { 4.9672941328980507, 0.0000000000000000, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler100 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.0000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.1735566504509650e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.1735566504509645e-16
+// mean(f - f_Boost): -5.8286708792820721e-17
+// variance(f - f_Boost): 4.1942474344433133e-34
+// stddev(f - f_Boost): 2.0479861900030756e-17
 const testcase_ellint_3<double>
 data101[10] =
 {
   { 0.0000000000000000, 0.10000000000000009, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17454173353063659, 0.10000000000000009, 0.0000000000000000, 
+  { 0.17454173353063662, 0.10000000000000009, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.34913506721468091, 0.10000000000000009, 0.0000000000000000, 
+  { 0.34913506721468096, 0.10000000000000009, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.52382550016538942, 0.10000000000000009, 0.0000000000000000, 
+  { 0.52382550016538953, 0.10000000000000009, 0.0000000000000000, 
 	  0.52359877559829882 },
   { 0.69864700854177020, 0.10000000000000009, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.87361792586964870, 0.10000000000000009, 0.0000000000000000, 
+  { 0.87361792586964859, 0.10000000000000009, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.0487386319621683, 0.10000000000000009, 0.0000000000000000, 
+  { 1.0487386319621685, 0.10000000000000009, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2239913752078757, 0.10000000000000009, 0.0000000000000000, 
+  { 1.2239913752078759, 0.10000000000000009, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.3993423113684049, 0.10000000000000009, 0.0000000000000000, 
+  { 1.3993423113684051, 0.10000000000000009, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.5747455615173562, 0.10000000000000009, 0.0000000000000000, 
+  { 1.5747455615173560, 0.10000000000000009, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler101 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.10000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3097339877269682e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.0305747373482148e-16
+// mean(f - f_Boost): -3.0531133177191807e-17
+// variance(f - f_Boost): 1.1508025840536076e-34
+// stddev(f - f_Boost): 1.0727546709539920e-17
 const testcase_ellint_3<double>
 data102[10] =
 {
   { 0.0000000000000000, 0.10000000000000009, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17436589347616613, 0.10000000000000009, 0.10000000000000001, 
+  { 0.17471821213559732, 0.10000000000000009, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34776067871237359, 0.10000000000000009, 0.10000000000000001, 
+  { 0.35052902610011138, 0.10000000000000009, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.51936064354727796, 0.10000000000000009, 0.10000000000000001, 
+  { 0.52842865990255727, 0.10000000000000009, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.68860303749364349, 0.10000000000000009, 0.10000000000000001, 
+  { 0.70921799731166713, 0.10000000000000009, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.85524561882332051, 0.10000000000000009, 0.10000000000000001, 
+  { 0.89340330535868662, 0.10000000000000009, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0193708301908335, 0.10000000000000009, 0.10000000000000001, 
+  { 1.0811075784236857, 0.10000000000000009, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.1813474067123044, 0.10000000000000009, 0.10000000000000001, 
+  { 1.2720133232666426, 0.10000000000000009, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.3417670770424983, 0.10000000000000009, 0.10000000000000001, 
+  { 1.4653630031861395, 0.10000000000000009, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.5013711111199950, 0.10000000000000009, 0.10000000000000001, 
+  { 1.6600374067558428, 0.10000000000000009, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler102 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.20000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.4399947764827574e-16
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 1.6736714959992433e-16
+// mean(f - f_Boost): 5.5511151231257830e-18
+// variance(f - f_Boost): 3.8043060629871325e-36
+// stddev(f - f_Boost): 1.9504630380981673e-18
 const testcase_ellint_3<double>
 data103[10] =
 {
   { 0.0000000000000000, 0.10000000000000009, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17419068786141340, 0.10000000000000009, 0.20000000000000001, 
+  { 0.17489533344059083, 0.10000000000000009, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34640537686230133, 0.10000000000000009, 0.20000000000000001, 
+  { 0.35194305707815038, 0.10000000000000009, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.51502689171753946, 0.10000000000000009, 0.20000000000000001, 
+  { 0.53317790741512527, 0.10000000000000009, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.67904147863672715, 0.10000000000000009, 0.20000000000000001, 
+  { 0.72036681615081222, 0.10000000000000009, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.83811885126105179, 0.10000000000000009, 0.20000000000000001, 
+  { 0.91480372268244303, 0.10000000000000009, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 0.99255278555742787, 0.10000000000000009, 0.20000000000000001, 
+  { 1.1170528708071514, 0.10000000000000009, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1431260546194930, 0.10000000000000009, 0.20000000000000001, 
+  { 1.3266916802718358, 0.10000000000000009, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.2909589656532101, 0.10000000000000009, 0.20000000000000001, 
+  { 1.5421622241831547, 0.10000000000000009, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.4373749386463430, 0.10000000000000009, 0.20000000000000001, 
+  { 1.7608656115083421, 0.10000000000000009, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler103 = 2.5000000000000020e-13;
 
-// Test data for k=0.10000000000000009, nu=0.29999999999999999.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.5650492137236872e-16
+// Test data for k=0.10000000000000009, nu=0.30000000000000004.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 1.9186071760326645e-16
+// mean(f - f_Boost): -1.6653345369377347e-17
+// variance(f - f_Boost): 3.4238754566884194e-35
+// stddev(f - f_Boost): 5.8513891142945016e-18
 const testcase_ellint_3<double>
 data104[10] =
 {
-  { 0.0000000000000000, 0.10000000000000009, 0.29999999999999999, 
+  { 0.0000000000000000, 0.10000000000000009, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17401611261390104, 0.10000000000000009, 0.29999999999999999, 
+  { 0.17507310163441189, 0.10000000000000009, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34506869507511773, 0.10000000000000009, 0.29999999999999999, 
+  { 0.35337768072524217, 0.10000000000000009, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51081757604259859, 0.10000000000000009, 0.29999999999999999, 
+  { 0.53808167801629170, 0.10000000000000009, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.66992297597712303, 0.10000000000000009, 0.29999999999999999, 
+  { 0.73215166755955019, 0.10000000000000009, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.82209722856174228, 0.10000000000000009, 0.29999999999999999, 
+  { 0.93806546000201219, 0.10000000000000009, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 0.96792430487669590, 0.10000000000000009, 0.29999999999999999, 
+  { 1.1573218723395986, 0.10000000000000009, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1085964108954092, 0.10000000000000009, 0.29999999999999999, 
+  { 1.3897859679542097, 0.10000000000000009, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.2456748370836999, 0.10000000000000009, 0.29999999999999999, 
+  { 1.6331009404328622, 0.10000000000000009, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.3809159606704959, 0.10000000000000009, 0.29999999999999999, 
+  { 1.8826015946315438, 0.10000000000000009, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler104 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.6854758534459740e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0338059536914377e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 9.5107651574678308e-35
+// stddev(f - f_Boost): 9.7523151904908362e-18
 const testcase_ellint_3<double>
 data105[10] =
 {
   { 0.0000000000000000, 0.10000000000000009, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17384216369897931, 0.10000000000000009, 0.40000000000000002, 
+  { 0.17525152094559704, 0.10000000000000009, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34375018311376787, 0.10000000000000009, 0.40000000000000002, 
+  { 0.35483343742825979, 0.10000000000000009, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.50672650758380455, 0.10000000000000009, 0.40000000000000002, 
+  { 0.54314913099505446, 0.10000000000000009, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.66121264213337616, 0.10000000000000009, 0.40000000000000002, 
+  { 0.74463962034766862, 0.10000000000000009, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.80706202005774441, 0.10000000000000009, 0.40000000000000002, 
+  { 0.96349276837570441, 0.10000000000000009, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.94519376138245870, 0.10000000000000009, 0.40000000000000002, 
+  { 1.2029081382746343, 0.10000000000000009, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.0771880300759584, 0.10000000000000009, 0.40000000000000002, 
+  { 1.4638022887050806, 0.10000000000000009, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2049711557188272, 0.10000000000000009, 0.40000000000000002, 
+  { 1.7432413830105224, 0.10000000000000009, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.3306223265207477, 0.10000000000000009, 0.40000000000000002, 
+  { 2.0336367403076760, 0.10000000000000009, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler105 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.50000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8017534281650347e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.9864616042835278e-16
+// mean(f - f_Boost): 9.4368957093138303e-17
+// variance(f - f_Boost): 7.7794254682023874e-32
+// stddev(f - f_Boost): 2.7891621444803792e-16
 const testcase_ellint_3<double>
 data106[10] =
 {
   { 0.0000000000000000, 0.10000000000000009, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17366883711936548, 0.10000000000000009, 0.50000000000000000, 
+  { 0.17543059564292182, 0.10000000000000009, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34244940634881882, 0.10000000000000009, 0.50000000000000000, 
+  { 0.35631088838721664, 0.10000000000000009, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50274793281634367, 0.10000000000000009, 0.50000000000000000, 
+  { 0.54839023346436455, 0.10000000000000009, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.65287941633275082, 0.10000000000000009, 0.50000000000000000, 
+  { 0.75790846946088830, 0.10000000000000009, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.79291198790315398, 0.10000000000000009, 0.50000000000000000, 
+  { 0.99146713686720678, 0.10000000000000009, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.92412201537880323, 0.10000000000000009, 0.50000000000000000, 
+  { 1.2551692247937198, 0.10000000000000009, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0484480076799372, 0.10000000000000009, 0.50000000000000000, 
+  { 1.5524660788146873, 0.10000000000000009, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.1681168130475206, 0.10000000000000009, 0.50000000000000000, 
+  { 1.8806578570830670, 0.10000000000000009, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.2854480708580160, 0.10000000000000009, 0.50000000000000000, 
+  { 2.2279868912966849, 0.10000000000000009, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler106 = 2.5000000000000020e-13;
 
-// Test data for k=0.10000000000000009, nu=0.59999999999999998.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.9142834151672032e-16
+// Test data for k=0.10000000000000009, nu=0.60000000000000009.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.6726146516228014e-16
+// mean(f - f_Boost): -3.6082248300317589e-17
+// variance(f - f_Boost): 1.6073193116120635e-34
+// stddev(f - f_Boost): 1.2678009747638087e-17
 const testcase_ellint_3<double>
 data107[10] =
 {
-  { 0.0000000000000000, 0.10000000000000009, 0.59999999999999998, 
+  { 0.0000000000000000, 0.10000000000000009, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17349612891469013, 0.10000000000000009, 0.59999999999999998, 
+  { 0.17561033003590576, 0.10000000000000009, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34116594505539444, 0.10000000000000009, 0.59999999999999998, 
+  { 0.35781061668171932, 0.10000000000000009, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.49887649430466674, 0.10000000000000009, 0.59999999999999998, 
+  { 0.55381585659629196, 0.10000000000000009, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.64489553282165146, 0.10000000000000009, 0.59999999999999998, 
+  { 0.77204910484575640, 0.10000000000000009, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.77956016553782437, 0.10000000000000009, 0.59999999999999998, 
+  { 1.0224751740393108, 0.10000000000000009, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.90451074530096287, 0.10000000000000009, 0.59999999999999998, 
+  { 1.3160230906351114, 0.10000000000000009, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0220113666961632, 0.10000000000000009, 0.59999999999999998, 
+  { 1.6616282844233206, 0.10000000000000009, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1345351441065563, 0.10000000000000009, 0.59999999999999998, 
+  { 2.0592555664850392, 0.10000000000000009, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.2445798942989255, 0.10000000000000009, 0.59999999999999998, 
+  { 2.4913004919173822, 0.10000000000000009, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler107 = 2.5000000000000020e-13;
 
-// Test data for k=0.10000000000000009, nu=0.69999999999999996.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.5172091551439012e-16
+// Test data for k=0.10000000000000009, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-16 at index 5
+// max(|f - f_Boost| / |f_Boost|): 2.1004074871280821e-16
+// mean(f - f_Boost): 3.3306690738754695e-17
+// variance(f - f_Boost): 1.3695501826753678e-34
+// stddev(f - f_Boost): 1.1702778228589003e-17
 const testcase_ellint_3<double>
 data108[10] =
 {
-  { 0.0000000000000000, 0.10000000000000009, 0.69999999999999996, 
+  { 0.0000000000000000, 0.10000000000000009, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17332403516105047, 0.10000000000000009, 0.69999999999999996, 
+  { 0.17579072847532518, 0.10000000000000009, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.33989939374896883, 0.10000000000000009, 0.69999999999999996, 
+  { 0.35933322840606297, 0.10000000000000009, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.49510719568614070, 0.10000000000000009, 0.69999999999999996, 
+  { 0.55943788649460324, 0.10000000000000009, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.63723607776354974, 0.10000000000000009, 0.69999999999999996, 
+  { 0.78716856504031707, 0.10000000000000009, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.76693133887935327, 0.10000000000000009, 0.69999999999999996, 
+  { 1.0571501305617423, 0.10000000000000009, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.88619382078823805, 0.10000000000000009, 0.69999999999999996, 
+  { 1.3882948301743525, 0.10000000000000009, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 0.99758012018676490, 0.10000000000000009, 0.69999999999999996, 
+  { 1.8011785680114223, 0.10000000000000009, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1037642270814410, 0.10000000000000009, 0.69999999999999996, 
+  { 2.3057268183616464, 0.10000000000000009, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2073745911083185, 0.10000000000000009, 0.69999999999999996, 
+  { 2.8771910188009739, 0.10000000000000009, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler108 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1294144515772258e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.3133043868392355e-16
+// mean(f - f_Boost): 1.8041124150158794e-16
+// variance(f - f_Boost): 6.1843750436434569e-32
+// stddev(f - f_Boost): 2.4868403735751633e-16
 const testcase_ellint_3<double>
 data109[10] =
 {
   { 0.0000000000000000, 0.10000000000000009, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17315255197057014, 0.10000000000000009, 0.80000000000000004, 
+  { 0.17597179535373417, 0.10000000000000009, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.33864936055747991, 0.10000000000000009, 0.80000000000000004, 
+  { 0.36087935387831499, 0.10000000000000009, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49143537041117613, 0.10000000000000009, 0.80000000000000004, 
+  { 0.56526935244526444, 0.10000000000000009, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.62987861760047492, 0.10000000000000009, 0.80000000000000004, 
+  { 0.80339402590612397, 0.10000000000000009, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.75496005490917517, 0.10000000000000009, 0.80000000000000004, 
+  { 1.0963358646374459, 0.10000000000000009, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.86903081862701881, 0.10000000000000009, 0.80000000000000004, 
+  { 1.4763748483246868, 0.10000000000000009, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 0.97490814820725591, 0.10000000000000009, 0.80000000000000004, 
+  { 1.9896610222794102, 0.10000000000000009, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.0754290107171083, 0.10000000000000009, 0.80000000000000004, 
+  { 2.6806423920122024, 0.10000000000000009, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.1733158866987732, 0.10000000000000009, 0.80000000000000004, 
+  { 3.5246199613295612, 0.10000000000000009, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler109 = 2.5000000000000020e-13;
 
 // Test data for k=0.10000000000000009, nu=0.90000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2325599449457852e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5624826890976725e-16
+// mean(f - f_Boost): 2.3314683517128288e-16
+// variance(f - f_Boost): 2.9401198977189756e-31
+// stddev(f - f_Boost): 5.4222872459129045e-16
 const testcase_ellint_3<double>
 data110[10] =
 {
   { 0.0000000000000000, 0.10000000000000009, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17298167549096563, 0.10000000000000009, 0.90000000000000002, 
+  { 0.17615353510599349, 0.10000000000000009, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33741546662741589, 0.10000000000000009, 0.90000000000000002, 
+  { 0.36244964892922371, 0.10000000000000009, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.48785665376856868, 0.10000000000000009, 0.90000000000000002, 
+  { 0.57132457590110530, 0.10000000000000009, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.62280288554518959, 0.10000000000000009, 0.90000000000000002, 
+  { 0.82087808820385000, 0.10000000000000009, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.74358903115455188, 0.10000000000000009, 0.90000000000000002, 
+  { 1.1411894342144451, 0.10000000000000009, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.85290207679298335, 0.10000000000000009, 0.90000000000000002, 
+  { 1.5875929286844597, 0.10000000000000009, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.95379006645397379, 0.10000000000000009, 0.90000000000000002, 
+  { 2.2678622986596659, 0.10000000000000009, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.0492213119872327, 0.10000000000000009, 0.90000000000000002, 
+  { 3.3697528941897903, 0.10000000000000009, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.1419839485283374, 0.10000000000000009, 0.90000000000000002, 
+  { 4.9862890417305499, 0.10000000000000009, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler110 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.0000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2156475739151676e-16
+// Test data for k=0.20000000000000018, nu=0.0000000000000000.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 4.2156475739151676e-16
+// mean(f - f_Boost): -5.2735593669694933e-17
+// variance(f - f_Boost): 3.0473442641042680e-32
+// stddev(f - f_Boost): 1.7456644190978597e-16
 const testcase_ellint_3<double>
 data111[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.0000000000000000, 
+  { 0.0000000000000000, 0.20000000000000018, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17456817290292809, 0.19999999999999996, 0.0000000000000000, 
+  { 0.17456817290292806, 0.20000000000000018, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.34934315932086801, 0.19999999999999996, 0.0000000000000000, 
+  { 0.34934315932086796, 0.20000000000000018, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.52450880529443988, 0.19999999999999996, 0.0000000000000000, 
+  { 0.52450880529443988, 0.20000000000000018, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.70020491009844876, 0.19999999999999996, 0.0000000000000000, 
+  { 0.70020491009844887, 0.20000000000000018, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.87651006649967955, 0.19999999999999996, 0.0000000000000000, 
+  { 0.87651006649967977, 0.20000000000000018, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.0534305870298994, 0.19999999999999996, 0.0000000000000000, 
+  { 1.0534305870298994, 0.20000000000000018, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2308975521670784, 0.19999999999999996, 0.0000000000000000, 
+  { 1.2308975521670789, 0.20000000000000018, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.4087733584990738, 0.19999999999999996, 0.0000000000000000, 
+  { 1.4087733584990738, 0.20000000000000018, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.5868678474541660, 0.19999999999999996, 0.0000000000000000, 
+  { 1.5868678474541662, 0.20000000000000018, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler111 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.10000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3374593253183472e-16
+// Test data for k=0.20000000000000018, nu=0.10000000000000001.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 4.0890622182605400e-16
+// mean(f - f_Boost): -3.8857805861880476e-17
+// variance(f - f_Boost): 2.8794792590749608e-32
+// stddev(f - f_Boost): 1.6969028431454054e-16
 const testcase_ellint_3<double>
 data112[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.10000000000000001, 
+  { 0.0000000000000000, 0.20000000000000018, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17439228502691748, 0.19999999999999996, 0.10000000000000001, 
+  { 0.17474469953608965, 0.20000000000000018, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34796731137565740, 0.19999999999999996, 0.10000000000000001, 
+  { 0.35073860234984255, 0.20000000000000018, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52003370294544848, 0.19999999999999996, 0.10000000000000001, 
+  { 0.52912258712951521, 0.20000000000000018, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.69012222258631462, 0.19999999999999996, 0.10000000000000001, 
+  { 0.71081701558898069, 0.20000000000000018, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.85803491465566772, 0.19999999999999996, 0.10000000000000001, 
+  { 0.89640758521169384, 0.20000000000000018, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0238463961099364, 0.19999999999999996, 0.10000000000000001, 
+  { 1.0860417038089853, 0.20000000000000018, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.1878691059202153, 0.19999999999999996, 0.10000000000000001, 
+  { 1.2793599255528623, 0.20000000000000018, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.3505985031831940, 0.19999999999999996, 0.10000000000000001, 
+  { 1.4754938544089076, 0.20000000000000018, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.5126513474261087, 0.19999999999999996, 0.10000000000000001, 
+  { 1.6731552050562593, 0.20000000000000018, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler112 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.20000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.4549984059502760e-16
+// Test data for k=0.20000000000000018, nu=0.20000000000000001.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 3.9570963716579749e-16
+// mean(f - f_Boost): -5.8286708792820721e-17
+// variance(f - f_Boost): 3.1158217732380362e-32
+// stddev(f - f_Boost): 1.7651690494788412e-16
 const testcase_ellint_3<double>
 data113[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.20000000000000001, 
+  { 0.0000000000000000, 0.20000000000000018, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17421703179583747, 0.19999999999999996, 0.20000000000000001, 
+  { 0.17492186907740698, 0.20000000000000018, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34661057411998791, 0.19999999999999996, 0.20000000000000001, 
+  { 0.35215414286134267, 0.20000000000000018, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.51569006052647393, 0.19999999999999996, 0.20000000000000001, 
+  { 0.53388285615182440, 0.20000000000000018, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.68052412821107244, 0.19999999999999996, 0.20000000000000001, 
+  { 0.72200960282688265, 0.20000000000000018, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.84081341263313825, 0.19999999999999996, 0.20000000000000001, 
+  { 0.91793087614428526, 0.20000000000000018, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 0.99683359988842890, 0.19999999999999996, 0.20000000000000001, 
+  { 1.1222602841587976, 0.20000000000000018, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1493086715118852, 0.19999999999999996, 0.20000000000000001, 
+  { 1.3345489407496247, 0.20000000000000018, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.2992699693957541, 0.19999999999999996, 0.20000000000000001, 
+  { 1.5531225705475502, 0.20000000000000018, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.4479323932249564, 0.19999999999999996, 0.20000000000000001, 
+  { 1.7751816279738935, 0.20000000000000018, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler113 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.29999999999999999.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.3140668101543467e-16
+// Test data for k=0.20000000000000018, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.6785817924053817e-16
+// mean(f - f_Boost): -1.1102230246251566e-17
+// variance(f - f_Boost): 9.9840208317034302e-32
+// stddev(f - f_Boost): 3.1597501217190311e-16
 const testcase_ellint_3<double>
 data114[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.29999999999999999, 
+  { 0.0000000000000000, 0.20000000000000018, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17404240913577704, 0.19999999999999996, 0.29999999999999999, 
+  { 0.17509968571715159, 0.20000000000000018, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34527248032587193, 0.19999999999999996, 0.29999999999999999, 
+  { 0.35359030214835629, 0.20000000000000018, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51147118981668416, 0.19999999999999996, 0.29999999999999999, 
+  { 0.53879807274537084, 0.20000000000000018, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.67137107867777601, 0.19999999999999996, 0.29999999999999999, 
+  { 0.73384116418059731, 0.20000000000000018, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.82470418188668893, 0.19999999999999996, 0.29999999999999999, 
+  { 0.94132799329524031, 0.20000000000000018, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 0.97202873223594299, 0.19999999999999996, 0.29999999999999999, 
+  { 1.1628407021801439, 0.20000000000000018, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1144773569375266, 0.19999999999999996, 0.29999999999999999, 
+  { 1.3982440216739438, 0.20000000000000018, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.2535292433701000, 0.19999999999999996, 0.29999999999999999, 
+  { 1.6450634983653640, 0.20000000000000018, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.3908453514752477, 0.19999999999999996, 0.29999999999999999, 
+  { 1.8983924169967099, 0.20000000000000018, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler114 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.6788709752760483e-16
+// Test data for k=0.20000000000000018, nu=0.40000000000000002.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 6
+// max(|f - f_Boost| / |f_Boost|): 3.6738449250038925e-16
+// mean(f - f_Boost): -3.0531133177191807e-17
+// variance(f - f_Boost): 2.7810428396951687e-32
+// stddev(f - f_Boost): 1.6676458975739331e-16
 const testcase_ellint_3<double>
 data115[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.40000000000000002, 
+  { 0.0000000000000000, 0.20000000000000018, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17386841301066674, 0.19999999999999996, 0.40000000000000002, 
+  { 0.17527815368535152, 0.20000000000000018, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34395257914113253, 0.19999999999999996, 0.40000000000000002, 
+  { 0.35504762134297801, 0.20000000000000018, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.50737088376869466, 0.19999999999999996, 0.40000000000000002, 
+  { 0.54387742353211344, 0.20000000000000018, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.66262801717277631, 0.19999999999999996, 0.40000000000000002, 
+  { 0.74637910471804259, 0.20000000000000018, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.80958766645079094, 0.19999999999999996, 0.40000000000000002, 
+  { 0.96690539714174639, 0.20000000000000018, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.94913754236162040, 0.19999999999999996, 0.40000000000000002, 
+  { 1.2087859420184757, 0.20000000000000018, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.0827985514222997, 0.19999999999999996, 0.40000000000000002, 
+  { 1.4729799844168852, 0.20000000000000018, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2124212429050478, 0.19999999999999996, 0.40000000000000002, 
+  { 1.7564445064596661, 0.20000000000000018, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.3400002519661005, 0.19999999999999996, 0.40000000000000002, 
+  { 2.0512956926676806, 0.20000000000000018, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler115 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.50000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.7788201301356829e-16
+// Test data for k=0.20000000000000018, nu=0.50000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3841806057292116e-16
+// mean(f - f_Boost): 3.6082248300317589e-17
+// variance(f - f_Boost): 8.9638010532618564e-32
+// stddev(f - f_Boost): 2.9939607634806868e-16
 const testcase_ellint_3<double>
 data116[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.50000000000000000, 
+  { 0.0000000000000000, 0.20000000000000018, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17369503942181799, 0.19999999999999996, 0.50000000000000000, 
+  { 0.17545727725228877, 0.20000000000000018, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34265043534362660, 0.19999999999999996, 0.50000000000000000, 
+  { 0.35652666242062175, 0.20000000000000018, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50338337208655415, 0.19999999999999996, 0.50000000000000000, 
+  { 0.54913090549102406, 0.20000000000000018, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.65426373297163609, 0.19999999999999996, 0.50000000000000000, 
+  { 0.75970161209211551, 0.20000000000000018, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.79536193036145808, 0.19999999999999996, 0.50000000000000000, 
+  { 0.99504737401590326, 0.20000000000000018, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.92791875910061605, 0.19999999999999996, 0.50000000000000000, 
+  { 1.2614666007124373, 0.20000000000000018, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0538145052725829, 0.19999999999999996, 0.50000000000000000, 
+  { 1.5625255355205498, 0.20000000000000018, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.1752060022875899, 0.19999999999999996, 0.50000000000000000, 
+  { 1.8954460255613346, 0.20000000000000018, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.2943374404397372, 0.19999999999999996, 0.50000000000000000, 
+  { 2.2481046259421302, 0.20000000000000018, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler116 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.59999999999999998.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.8899223779598256e-16
+// Test data for k=0.20000000000000018, nu=0.60000000000000009.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.5317584994994743e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 1.0045745697575397e-31
+// stddev(f - f_Boost): 3.1695024369095219e-16
 const testcase_ellint_3<double>
 data117[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.59999999999999998, 
+  { 0.0000000000000000, 0.20000000000000018, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17352228440746925, 0.19999999999999996, 0.59999999999999998, 
+  { 0.17563706072900442, 0.20000000000000018, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34136562863713626, 0.19999999999999996, 0.59999999999999998, 
+  { 0.35802800926807238, 0.20000000000000018, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.49950328177638481, 0.19999999999999996, 0.59999999999999998, 
+  { 0.55456942250515051, 0.20000000000000018, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.64625032705690799, 0.19999999999999996, 0.59999999999999998, 
+  { 0.77390003828438203, 0.20000000000000018, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.78193941198403083, 0.19999999999999996, 0.59999999999999998, 
+  { 1.0262441366366397, 0.20000000000000018, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.90817230934317128, 0.19999999999999996, 0.59999999999999998, 
+  { 1.3228192988439669, 0.20000000000000018, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0271563751276462, 0.19999999999999996, 0.59999999999999998, 
+  { 1.6728005754680795, 0.20000000000000018, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1412999379040518, 0.19999999999999996, 0.59999999999999998, 
+  { 2.0761587107468511, 0.20000000000000018, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.2530330675914556, 0.19999999999999996, 0.59999999999999998, 
+  { 2.5148333891629315, 0.20000000000000018, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler117 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.69999999999999996.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 5.9999318361775115e-16
+// Test data for k=0.20000000000000018, nu=0.70000000000000007.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.2209418045118284e-16
+// mean(f - f_Boost): 2.4980018054066023e-17
+// variance(f - f_Boost): 9.1989071679544611e-32
+// stddev(f - f_Boost): 3.0329700242426498e-16
 const testcase_ellint_3<double>
 data118[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.69999999999999996, 
+  { 0.0000000000000000, 0.20000000000000018, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17335014404233895, 0.19999999999999996, 0.69999999999999996, 
+  { 0.17581750846781172, 0.20000000000000018, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34009775298617811, 0.19999999999999996, 0.69999999999999996, 
+  { 0.35955226882028513, 0.20000000000000018, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.49572560201923810, 0.19999999999999996, 0.69999999999999996, 
+  { 0.56020489659466499, 0.20000000000000018, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.63856276669886503, 0.19999999999999996, 0.69999999999999996, 
+  { 0.78908196988531498, 0.20000000000000018, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.76924438644867565, 0.19999999999999996, 0.69999999999999996, 
+  { 1.0611336754143517, 0.20000000000000018, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.88973060843856466, 0.19999999999999996, 0.69999999999999996, 
+  { 1.3956969951058884, 0.20000000000000018, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0025230471636377, 0.19999999999999996, 0.69999999999999996, 
+  { 1.8138131612209609, 0.20000000000000018, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1102356376093103, 0.19999999999999996, 0.69999999999999996, 
+  { 2.3256365528879561, 0.20000000000000018, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2154356555075863, 0.19999999999999996, 0.69999999999999996, 
+  { 2.9058704854500963, 0.20000000000000018, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler118 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 5.0901276230707249e-16
+// Test data for k=0.20000000000000018, nu=0.80000000000000004.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.7399960886656824e-16
+// mean(f - f_Boost): 1.3877787807814457e-16
+// variance(f - f_Boost): 1.7585404776158019e-31
+// stddev(f - f_Boost): 4.1934955319110593e-16
 const testcase_ellint_3<double>
 data119[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.80000000000000004, 
+  { 0.0000000000000000, 0.20000000000000018, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17317861443718538, 0.19999999999999996, 0.80000000000000004, 
+  { 0.17599862486281712, 0.20000000000000018, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.33884641598718701, 0.19999999999999996, 0.80000000000000004, 
+  { 0.36110007227128776, 0.20000000000000018, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49204565281259494, 0.19999999999999996, 0.80000000000000004, 
+  { 0.56605039658567224, 0.20000000000000018, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.63117851188220320, 0.19999999999999996, 0.80000000000000004, 
+  { 0.80537523874517691, 0.20000000000000018, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.75721095949544170, 0.19999999999999996, 0.80000000000000004, 
+  { 1.1005662342414086, 0.20000000000000018, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.87245201443919118, 0.19999999999999996, 0.80000000000000004, 
+  { 1.4845340298105778, 0.20000000000000018, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 0.97966584238831089, 0.19999999999999996, 0.80000000000000004, 
+  { 2.0043332244969392, 0.20000000000000018, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.0816336325174360, 0.19999999999999996, 0.80000000000000004, 
+  { 2.7052856676744761, 0.20000000000000018, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.1810223448909909, 0.19999999999999996, 0.80000000000000004, 
+  { 3.5622166386422633, 0.20000000000000018, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler119 = 2.5000000000000020e-13;
 
-// Test data for k=0.19999999999999996, nu=0.90000000000000002.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 6.4833128442756722e-16
+// Test data for k=0.20000000000000018, nu=0.90000000000000002.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1718503329017390e-16
+// mean(f - f_Boost): 2.3592239273284576e-16
+// variance(f - f_Boost): 2.9295534376290287e-31
+// stddev(f - f_Boost): 5.4125349307224141e-16
 const testcase_ellint_3<double>
 data120[10] =
 {
-  { 0.0000000000000000, 0.19999999999999996, 0.90000000000000002, 
+  { 0.0000000000000000, 0.20000000000000018, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17300769173837277, 0.19999999999999996, 0.90000000000000002, 
+  { 0.17618041435044951, 0.20000000000000018, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33761123827372508, 0.19999999999999996, 0.90000000000000002, 
+  { 0.36267207636502929, 0.20000000000000018, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.48845905690769426, 0.19999999999999996, 0.90000000000000002, 
+  { 0.57212028758237743, 0.20000000000000018, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.62407720017324952, 0.19999999999999996, 0.90000000000000002, 
+  { 0.82293323876704483, 0.20000000000000018, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.74578146525124289, 0.19999999999999996, 0.90000000000000002, 
+  { 1.1457077279880388, 0.20000000000000018, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.85621583540073076, 0.19999999999999996, 0.90000000000000002, 
+  { 1.5967346899325681, 0.20000000000000018, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.95837725988001199, 0.19999999999999996, 0.90000000000000002, 
+  { 2.2856537353421724, 0.20000000000000018, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.0551821412633928, 0.19999999999999996, 0.90000000000000002, 
+  { 3.4034714304613902, 0.20000000000000018, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.1493679916141861, 0.19999999999999996, 0.90000000000000002, 
+  { 5.0448269356200370, 0.20000000000000018, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler120 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.0000000000000000.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.3361874537309281e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.2241249691539529e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 2.1399221604302621e-32
+// stddev(f - f_Boost): 1.4628472785736254e-16
 const testcase_ellint_3<double>
 data121[10] =
 {
@@ -3528,19 +3890,19 @@
 	  0.0000000000000000 },
   { 0.17461228653000099, 0.30000000000000004, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.34969146102798415, 0.30000000000000004, 0.0000000000000000, 
+  { 0.34969146102798421, 0.30000000000000004, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.52565822873726320, 0.30000000000000004, 0.0000000000000000, 
+  { 0.52565822873726309, 0.30000000000000004, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.70284226512408532, 0.30000000000000004, 0.0000000000000000, 
+  { 0.70284226512408543, 0.30000000000000004, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.88144139195111182, 0.30000000000000004, 0.0000000000000000, 
+  { 0.88144139195111171, 0.30000000000000004, 0.0000000000000000, 
 	  0.87266462599716477 },
   { 1.0614897067260520, 0.30000000000000004, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2428416824174218, 0.30000000000000004, 0.0000000000000000, 
+  { 1.2428416824174220, 0.30000000000000004, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.4251795877015927, 0.30000000000000004, 0.0000000000000000, 
+  { 1.4251795877015929, 0.30000000000000004, 0.0000000000000000, 
 	  1.3962634015954636 },
   { 1.6080486199305128, 0.30000000000000004, 0.0000000000000000, 
 	  1.5707963267948966 },
@@ -3548,559 +3910,619 @@
 const double toler121 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.10000000000000001.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.3908043711907203e-16
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1872304407982844e-16
+// mean(f - f_Boost): 7.2164496600635178e-17
+// variance(f - f_Boost): 4.3555500115139682e-32
+// stddev(f - f_Boost): 2.0869954507650391e-16
 const testcase_ellint_3<double>
 data122[10] =
 {
   { 0.0000000000000000, 0.30000000000000004, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17443631884814376, 0.30000000000000004, 0.10000000000000001, 
+  { 0.17478889331392972, 0.30000000000000004, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34831316835124926, 0.30000000000000004, 0.10000000000000001, 
+  { 0.35108939018329183, 0.30000000000000004, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52116586276523857, 0.30000000000000004, 0.10000000000000001, 
+  { 0.53028990896115835, 0.30000000000000004, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.69269385837910036, 0.30000000000000004, 0.10000000000000001, 
+  { 0.71352417052371409, 0.30000000000000004, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.86279023163070856, 0.30000000000000004, 0.10000000000000001, 
+  { 0.90153086032405894, 0.30000000000000004, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0315321461438263, 0.30000000000000004, 0.10000000000000001, 
+  { 1.0945187977283313, 0.30000000000000004, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.1991449111869024, 0.30000000000000004, 0.10000000000000001, 
+  { 1.2920699268385683, 0.30000000000000004, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.3659561780923213, 0.30000000000000004, 0.10000000000000001, 
+  { 1.4931243665896394, 0.30000000000000004, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.5323534693557528, 0.30000000000000004, 0.10000000000000001, 
+  { 1.6960848815118226, 0.30000000000000004, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler122 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.20000000000000001.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.4447238179454079e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.2247497610332889e-16
+// mean(f - f_Boost): 6.6613381477509390e-17
+// variance(f - f_Boost): 1.7591111235252501e-32
+// stddev(f - f_Boost): 1.3263148659067538e-16
 const testcase_ellint_3<double>
 data123[10] =
 {
   { 0.0000000000000000, 0.30000000000000004, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17426098615372088, 0.30000000000000004, 0.20000000000000001, 
+  { 0.17496614335337535, 0.30000000000000004, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34695402664689923, 0.30000000000000004, 0.20000000000000001, 
+  { 0.35250745937139372, 0.30000000000000004, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.51680555567038933, 0.30000000000000004, 0.20000000000000001, 
+  { 0.53506875002836884, 0.30000000000000004, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.68303375225260210, 0.30000000000000004, 0.20000000000000001, 
+  { 0.72479106622248191, 0.30000000000000004, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.84540662891295026, 0.30000000000000004, 0.20000000000000001, 
+  { 0.92326451535891607, 0.30000000000000004, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0041834051646927, 0.30000000000000004, 0.20000000000000001, 
+  { 1.1312092060698349, 0.30000000000000004, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1599952702345711, 0.30000000000000004, 0.20000000000000001, 
+  { 1.3481473154592321, 0.30000000000000004, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.3137179520499165, 0.30000000000000004, 0.20000000000000001, 
+  { 1.5722049569662750, 0.30000000000000004, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.4663658145259877, 0.30000000000000004, 0.20000000000000001, 
+  { 1.8002173372290500, 0.30000000000000004, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler123 = 2.5000000000000020e-13;
 
-// Test data for k=0.30000000000000004, nu=0.29999999999999999.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.4979715256503266e-16
+// Test data for k=0.30000000000000004, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.1678685180047551e-16
+// mean(f - f_Boost): 1.0547118733938987e-16
+// variance(f - f_Boost): 7.5633408838247182e-32
+// stddev(f - f_Boost): 2.7501528837184157e-16
 const testcase_ellint_3<double>
 data124[10] =
 {
-  { 0.0000000000000000, 0.30000000000000004, 0.29999999999999999, 
+  { 0.0000000000000000, 0.30000000000000004, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17408628437042842, 0.30000000000000004, 0.29999999999999999, 
+  { 0.17514404084107435, 0.30000000000000004, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34561356761638401, 0.30000000000000004, 0.29999999999999999, 
+  { 0.35394619108645647, 0.30000000000000004, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51257058617875850, 0.30000000000000004, 0.29999999999999999, 
+  { 0.54000325463372689, 0.30000000000000004, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.67382207124602878, 0.30000000000000004, 0.29999999999999999, 
+  { 0.73670193794067651, 0.30000000000000004, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.82914751587825131, 0.30000000000000004, 0.29999999999999999, 
+  { 0.94689345491722177, 0.30000000000000004, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 0.97907434814374938, 0.30000000000000004, 0.29999999999999999, 
+  { 1.1723274608389140, 0.30000000000000004, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1246399297351584, 0.30000000000000004, 0.29999999999999999, 
+  { 1.4128880552936287, 0.30000000000000004, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.2671793970398149, 0.30000000000000004, 0.29999999999999999, 
+  { 1.6659010047449661, 0.30000000000000004, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.4081767433479091, 0.30000000000000004, 0.29999999999999999, 
+  { 1.9260216862473254, 0.30000000000000004, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler124 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.40000000000000002.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.5505716921759864e-16
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.3983279132797385e-16
+// mean(f - f_Boost): 1.1657341758564144e-16
+// variance(f - f_Boost): 1.8245832308692586e-31
+// stddev(f - f_Boost): 4.2715140534349863e-16
 const testcase_ellint_3<double>
 data125[10] =
 {
   { 0.0000000000000000, 0.30000000000000004, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17391220945982727, 0.30000000000000004, 0.40000000000000002, 
+  { 0.17532259000954434, 0.30000000000000004, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34429133937639689, 0.30000000000000004, 0.40000000000000002, 
+  { 0.35540612770983693, 0.30000000000000004, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.50845471668581632, 0.30000000000000004, 0.40000000000000002, 
+  { 0.54510265552938919, 0.30000000000000004, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.66502347027873854, 0.30000000000000004, 0.40000000000000002, 
+  { 0.74932476310965057, 0.30000000000000004, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.81389191978012254, 0.30000000000000004, 0.40000000000000002, 
+  { 0.97272793583093109, 0.30000000000000004, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.95590618002140570, 0.30000000000000004, 0.40000000000000002, 
+  { 1.2188928987074241, 0.30000000000000004, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.0924915195213121, 0.30000000000000004, 0.40000000000000002, 
+  { 1.4888771674085941, 0.30000000000000004, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2253651604038061, 0.30000000000000004, 0.40000000000000002, 
+  { 1.7794558498219191, 0.30000000000000004, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.3563643538969763, 0.30000000000000004, 0.40000000000000002, 
+  { 2.0822121773175528, 0.30000000000000004, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler125 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.50000000000000000.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.7807908859023716e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.0516138451673425e-16
+// mean(f - f_Boost): 4.7184478546569152e-17
+// variance(f - f_Boost): 1.9448563670505968e-32
+// stddev(f - f_Boost): 1.3945810722401896e-16
 const testcase_ellint_3<double>
 data126[10] =
 {
   { 0.0000000000000000, 0.30000000000000004, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17373875742088232, 0.30000000000000004, 0.50000000000000000, 
+  { 0.17550179513158179, 0.30000000000000004, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34298690571124157, 0.30000000000000004, 0.50000000000000000, 
+  { 0.35688783251681200, 0.30000000000000004, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50445214859646936, 0.30000000000000004, 0.50000000000000000, 
+  { 0.55037700010142798, 0.30000000000000004, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.65660648352418516, 0.30000000000000004, 0.50000000000000000, 
+  { 0.76273839789895992, 0.30000000000000004, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.79953670639287289, 0.30000000000000004, 0.50000000000000000, 
+  { 1.0011570518830419, 0.30000000000000004, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.93443393926588536, 0.30000000000000004, 0.50000000000000000, 
+  { 1.2722987414055109, 0.30000000000000004, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0630838369016911, 0.30000000000000004, 0.50000000000000000, 
+  { 1.5799590511080066, 0.30000000000000004, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.1875197325653029, 0.30000000000000004, 0.50000000000000000, 
+  { 1.9212367220124293, 0.30000000000000004, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.3098448759814962, 0.30000000000000004, 0.50000000000000000, 
+  { 2.2833505881933971, 0.30000000000000004, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler126 = 2.5000000000000020e-13;
 
-// Test data for k=0.30000000000000004, nu=0.59999999999999998.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.0057999499931649e-16
+// Test data for k=0.30000000000000004, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.2121157428443725e-16
+// mean(f - f_Boost): 1.9428902930940239e-16
+// variance(f - f_Boost): 1.5987596229703424e-31
+// stddev(f - f_Boost): 3.9984492281012430e-16
 const testcase_ellint_3<double>
 data127[10] =
 {
-  { 0.0000000000000000, 0.30000000000000004, 0.59999999999999998, 
+  { 0.0000000000000000, 0.30000000000000004, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17356592428950823, 0.30000000000000004, 0.59999999999999998, 
+  { 0.17568166052076745, 0.30000000000000004, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34169984536697379, 0.30000000000000004, 0.59999999999999998, 
+  { 0.35839189074731181, 0.30000000000000004, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50055748266498457, 0.30000000000000004, 0.59999999999999998, 
+  { 0.55583724744367558, 0.30000000000000004, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.64854298527106768, 0.30000000000000004, 0.59999999999999998, 
+  { 0.77703498090888223, 0.30000000000000004, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.78599329284207431, 0.30000000000000004, 0.59999999999999998, 
+  { 1.0326772113675962, 0.30000000000000004, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.91445452089128199, 0.30000000000000004, 0.59999999999999998, 
+  { 1.3345139983717369, 0.30000000000000004, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0360412952290587, 0.30000000000000004, 0.59999999999999998, 
+  { 1.6921742922838403, 0.30000000000000004, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1530473919778641, 0.30000000000000004, 0.59999999999999998, 
+  { 2.1056608968472186, 0.30000000000000004, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.2677758800420669, 0.30000000000000004, 0.59999999999999998, 
+  { 2.5560975528589061, 0.30000000000000004, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler127 = 2.5000000000000020e-13;
 
-// Test data for k=0.30000000000000004, nu=0.69999999999999996.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.2239502844122443e-16
+// Test data for k=0.30000000000000004, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.0088945789059381e-16
+// mean(f - f_Boost): 2.1094237467877973e-16
+// variance(f - f_Boost): 3.0253363535298873e-31
+// stddev(f - f_Boost): 5.5003057674368314e-16
 const testcase_ellint_3<double>
 data128[10] =
 {
-  { 0.0000000000000000, 0.30000000000000004, 0.69999999999999996, 
+  { 0.0000000000000000, 0.30000000000000004, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17339370613812224, 0.30000000000000004, 0.69999999999999996, 
+  { 0.17586219053197988, 0.30000000000000004, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34042975138455933, 0.30000000000000004, 0.69999999999999996, 
+  { 0.35991891074557669, 0.30000000000000004, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.49676568368075985, 0.30000000000000004, 0.69999999999999996, 
+  { 0.56149538019961731, 0.30000000000000004, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.64080774055753720, 0.30000000000000004, 0.69999999999999996, 
+  { 0.79232303189667685, 0.30000000000000004, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.77318507779667278, 0.30000000000000004, 0.69999999999999996, 
+  { 1.0679345542878826, 0.30000000000000004, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.89579782346548609, 0.30000000000000004, 0.69999999999999996, 
+  { 1.4084400085913955, 0.30000000000000004, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0110573286052202, 0.30000000000000004, 0.69999999999999996, 
+  { 1.8357382859296454, 0.30000000000000004, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1214710972949635, 0.30000000000000004, 0.69999999999999996, 
+  { 2.3604197996171519, 0.30000000000000004, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2294913236274982, 0.30000000000000004, 0.69999999999999996, 
+  { 2.9562123549913872, 0.30000000000000004, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler128 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.80000000000000004.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.4358357000101250e-16
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 6.1197887707781618e-16
+// mean(f - f_Boost): 3.4416913763379854e-16
+// variance(f - f_Boost): 4.3461914185990199e-31
+// stddev(f - f_Boost): 6.5925650687718054e-16
 const testcase_ellint_3<double>
 data129[10] =
 {
   { 0.0000000000000000, 0.30000000000000004, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17322209907520358, 0.30000000000000004, 0.80000000000000004, 
+  { 0.17604338956191670, 0.30000000000000004, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.33917623046949996, 0.30000000000000004, 0.80000000000000004, 
+  { 0.36146952517410791, 0.30000000000000004, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49307204894329176, 0.30000000000000004, 0.80000000000000004, 
+  { 0.56736453393774644, 0.30000000000000004, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.63337802830291734, 0.30000000000000004, 0.80000000000000004, 
+  { 0.80873149979001091, 0.30000000000000004, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.76104540997689407, 0.30000000000000004, 0.80000000000000004, 
+  { 1.1077903069860620, 0.30000000000000004, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.87832009635450714, 0.30000000000000004, 0.80000000000000004, 
+  { 1.4985874311132998, 0.30000000000000004, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 0.98787879723171790, 0.30000000000000004, 0.80000000000000004, 
+  { 2.0298167266724954, 0.30000000000000004, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.0924036340069339, 0.30000000000000004, 0.80000000000000004, 
+  { 2.7483929054985432, 0.30000000000000004, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.1944567571590048, 0.30000000000000004, 0.80000000000000004, 
+  { 3.6283050484567170, 0.30000000000000004, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler129 = 2.5000000000000020e-13;
 
 // Test data for k=0.30000000000000004, nu=0.90000000000000002.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.6419688299804087e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 5.1301806687926828e-16
+// mean(f - f_Boost): 4.1633363423443370e-16
+// variance(f - f_Boost): 2.2835347143080263e-31
+// stddev(f - f_Boost): 4.7786344433405093e-16
 const testcase_ellint_3<double>
 data130[10] =
 {
   { 0.0000000000000000, 0.30000000000000004, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17305109924485945, 0.30000000000000004, 0.90000000000000002, 
+  { 0.17622526204962433, 0.30000000000000004, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33793890239556984, 0.30000000000000004, 0.90000000000000002, 
+  { 0.36304439230777141, 0.30000000000000004, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.48947218005089738, 0.30000000000000004, 0.90000000000000002, 
+  { 0.57345914744719195, 0.30000000000000004, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.62623332340775151, 0.30000000000000004, 0.90000000000000002, 
+  { 0.82641512928845162, 0.30000000000000004, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.74951596581511148, 0.30000000000000004, 0.90000000000000002, 
+  { 1.1534256210757743, 0.30000000000000004, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.86189886597755994, 0.30000000000000004, 0.90000000000000002, 
+  { 1.6124900353411677, 0.30000000000000004, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.96629451153092005, 0.30000000000000004, 0.90000000000000002, 
+  { 2.3165905514845089, 0.30000000000000004, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.0655269133492682, 0.30000000000000004, 0.90000000000000002, 
+  { 3.4625619526539824, 0.30000000000000004, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.1622376896064914, 0.30000000000000004, 0.90000000000000002, 
+  { 5.1479514944016787, 0.30000000000000004, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler130 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.0000000000000000.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 5.4157225142938039e-16
+// Test data for k=0.40000000000000013, nu=0.0000000000000000.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.0831445028587608e-15
+// mean(f - f_Boost): 1.7486012637846215e-16
+// variance(f - f_Boost): 3.1664095331106078e-31
+// stddev(f - f_Boost): 5.6270858649132121e-16
 const testcase_ellint_3<double>
 data131[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.0000000000000000, 
+  { 0.0000000000000000, 0.40000000000000013, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17467414669441528, 0.39999999999999991, 0.0000000000000000, 
+  { 0.17467414669441528, 0.40000000000000013, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35018222772483443, 0.39999999999999991, 0.0000000000000000, 
+  { 0.35018222772483443, 0.40000000000000013, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.52729015917508737, 0.39999999999999991, 0.0000000000000000, 
+  { 0.52729015917508748, 0.40000000000000013, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.70662374407341244, 0.39999999999999991, 0.0000000000000000, 
+  { 0.70662374407341244, 0.40000000000000013, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.88859210497602170, 0.39999999999999991, 0.0000000000000000, 
+  { 0.88859210497602159, 0.40000000000000013, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.0733136290471379, 0.39999999999999991, 0.0000000000000000, 
+  { 1.0733136290471381, 0.40000000000000013, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2605612170157061, 0.39999999999999991, 0.0000000000000000, 
+  { 1.2605612170157066, 0.40000000000000013, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.4497513956433439, 0.39999999999999991, 0.0000000000000000, 
+  { 1.4497513956433439, 0.40000000000000013, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.6399998658645112, 0.39999999999999991, 0.0000000000000000, 
+  { 1.6399998658645112, 0.40000000000000013, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler131 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.10000000000000001.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 5.6859551010103832e-16
+// Test data for k=0.40000000000000013, nu=0.10000000000000001.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.0263824105456986e-15
+// mean(f - f_Boost): 1.7486012637846215e-16
+// variance(f - f_Boost): 3.1664095331106078e-31
+// stddev(f - f_Boost): 5.6270858649132121e-16
 const testcase_ellint_3<double>
 data132[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.10000000000000001, 
+  { 0.0000000000000000, 0.40000000000000013, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17449806706684670, 0.39999999999999991, 0.10000000000000001, 
+  { 0.17485086590796767, 0.40000000000000013, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34880048623856075, 0.39999999999999991, 0.10000000000000001, 
+  { 0.35158366412506992, 0.40000000000000013, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52277322065757392, 0.39999999999999991, 0.10000000000000001, 
+  { 0.53194731675711726, 0.40000000000000013, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.69638072056918365, 0.39999999999999991, 0.10000000000000001, 
+  { 0.71740615528010931, 0.40000000000000013, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.86968426619831540, 0.39999999999999991, 0.10000000000000001, 
+  { 0.90896157773487030, 0.40000000000000013, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0428044206578095, 0.39999999999999991, 0.10000000000000001, 
+  { 1.1069605483834348, 0.40000000000000013, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.2158651158274378, 0.39999999999999991, 0.10000000000000001, 
+  { 1.3109353428823001, 0.40000000000000013, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.3889447129893324, 0.39999999999999991, 0.10000000000000001, 
+  { 1.5195460789903450, 0.40000000000000013, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.5620566886683604, 0.39999999999999991, 0.10000000000000001, 
+  { 1.7306968836847190, 0.40000000000000013, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler132 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.20000000000000001.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 5.9444065952225719e-16
+// Test data for k=0.40000000000000013, nu=0.20000000000000001.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.6644296021947179e-16
+// mean(f - f_Boost): 2.0816681711721685e-16
+// variance(f - f_Boost): 3.0360740073926687e-31
+// stddev(f - f_Boost): 5.5100580826273227e-16
 const testcase_ellint_3<double>
 data133[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.20000000000000001, 
+  { 0.0000000000000000, 0.40000000000000013, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17432262290723397, 0.39999999999999991, 0.20000000000000001, 
+  { 0.17502822886437389, 0.40000000000000013, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34743795258968596, 0.39999999999999991, 0.20000000000000001, 
+  { 0.35300530062530805, 0.40000000000000013, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.51838919472805112, 0.39999999999999991, 0.20000000000000001, 
+  { 0.53675259548210896, 0.40000000000000013, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.68663134739057907, 0.39999999999999991, 0.20000000000000001, 
+  { 0.72878006428676934, 0.40000000000000013, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.85206432981833979, 0.39999999999999991, 0.20000000000000001, 
+  { 0.93100219010583574, 0.40000000000000013, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0149595349004430, 0.39999999999999991, 0.20000000000000001, 
+  { 1.1443487271187611, 0.40000000000000013, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1758349405464676, 0.39999999999999991, 0.20000000000000001, 
+  { 1.3683427764108813, 0.40000000000000013, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.3353337673882637, 0.39999999999999991, 0.20000000000000001, 
+  { 1.6008221459300933, 0.40000000000000013, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.4941414344266770, 0.39999999999999991, 0.20000000000000001, 
+  { 1.8380358826317627, 0.40000000000000013, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler133 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.29999999999999999.
-// max(|f - f_GSL|): 1.1102230246251565e-15
-// max(|f - f_GSL| / |f_GSL|): 7.7406350888907249e-16
+// Test data for k=0.40000000000000013, nu=0.30000000000000004.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0271556462838835e-16
+// mean(f - f_Boost): 2.0816681711721685e-16
+// variance(f - f_Boost): 3.0360740073926687e-31
+// stddev(f - f_Boost): 5.5100580826273227e-16
 const testcase_ellint_3<double>
 data134[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.29999999999999999, 
+  { 0.0000000000000000, 0.40000000000000013, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17414781013591540, 0.39999999999999991, 0.29999999999999999, 
+  { 0.17520623975982899, 0.40000000000000013, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34609415696777285, 0.39999999999999991, 0.29999999999999999, 
+  { 0.35444766141612105, 0.40000000000000013, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51413131295862535, 0.39999999999999991, 0.29999999999999999, 
+  { 0.54171455841536009, 0.40000000000000013, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.67733527622935630, 0.39999999999999991, 0.29999999999999999, 
+  { 0.74080517001084012, 0.40000000000000013, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.83558675182733266, 0.39999999999999991, 0.29999999999999999, 
+  { 0.95496950509296574, 0.40000000000000013, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 0.98940140808865906, 0.39999999999999991, 0.29999999999999999, 
+  { 1.1862627879844718, 0.40000000000000013, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1396968797728058, 0.39999999999999991, 0.29999999999999999, 
+  { 1.4346501803799458, 0.40000000000000013, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.2875920037865090, 0.39999999999999991, 0.29999999999999999, 
+  { 1.6971744798077699, 0.40000000000000013, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.4342789859950078, 0.39999999999999991, 0.29999999999999999, 
+  { 1.9677924132520139, 0.40000000000000013, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler134 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.40000000000000002.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.4314214811441816e-16
+// Test data for k=0.40000000000000013, nu=0.40000000000000002.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3436329231972794e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 2.9507053793392374e-31
+// stddev(f - f_Boost): 5.4320395611033958e-16
 const testcase_ellint_3<double>
 data135[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.40000000000000002, 
+  { 0.0000000000000000, 0.40000000000000013, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17397362471112707, 0.39999999999999991, 0.40000000000000002, 
+  { 0.17538490283034375, 0.40000000000000013, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34476864603333196, 0.39999999999999991, 0.40000000000000002, 
+  { 0.35591129064319948, 0.40000000000000013, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.50999329415379346, 0.39999999999999991, 0.40000000000000002, 
+  { 0.54684250413264535, 0.40000000000000013, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.66845674551396006, 0.39999999999999991, 0.40000000000000002, 
+  { 0.75355027742668290, 0.40000000000000013, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.82012848346231748, 0.39999999999999991, 0.40000000000000002, 
+  { 0.98117935026780634, 0.40000000000000013, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.96582449258349057, 0.39999999999999991, 0.40000000000000002, 
+  { 1.2337464222030736, 0.40000000000000013, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.1068473749476286, 0.39999999999999991, 0.40000000000000002, 
+  { 1.5125183419289221, 0.40000000000000013, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2447132729159989, 0.39999999999999991, 0.40000000000000002, 
+  { 1.8140224451130313, 0.40000000000000013, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.3809986210732901, 0.39999999999999991, 0.40000000000000002, 
+  { 2.1289968719280026, 0.40000000000000013, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler135 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.50000000000000000.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.6621057007519435e-16
+// Test data for k=0.40000000000000013, nu=0.50000000000000000.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.7013794022122431e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 1.4989821857033475e-31
+// stddev(f - f_Boost): 3.8716691306248618e-16
 const testcase_ellint_3<double>
 data136[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.50000000000000000, 
+  { 0.0000000000000000, 0.40000000000000013, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17380006262854136, 0.39999999999999991, 0.50000000000000000, 
+  { 0.17556422235224273, 0.40000000000000013, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34346098216756610, 0.39999999999999991, 0.50000000000000000, 
+  { 0.35739675341763921, 0.40000000000000013, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50596929935059420, 0.39999999999999991, 0.50000000000000000, 
+  { 0.55214655195037188, 0.40000000000000013, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.65996392089131251, 0.39999999999999991, 0.50000000000000000, 
+  { 0.76709520942047438, 0.40000000000000013, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.80558463511364786, 0.39999999999999991, 0.50000000000000000, 
+  { 1.0100278761577499, 0.40000000000000013, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.94397834522857704, 0.39999999999999991, 0.50000000000000000, 
+  { 1.2882265661384342, 0.40000000000000013, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0768075114108115, 0.39999999999999991, 0.50000000000000000, 
+  { 1.6059059780051876, 0.40000000000000013, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.2059184624251333, 0.39999999999999991, 0.50000000000000000, 
+  { 1.9600182740224081, 0.40000000000000013, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.3331797176377398, 0.39999999999999991, 0.50000000000000000, 
+  { 2.3367461373176512, 0.40000000000000013, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler136 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.59999999999999998.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 6.8853630717730749e-16
+// Test data for k=0.40000000000000013, nu=0.60000000000000009.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.4792115132836117e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 4.8893797490374802e-31
+// stddev(f - f_Boost): 6.9924099915819294e-16
 const testcase_ellint_3<double>
 data137[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.59999999999999998, 
+  { 0.0000000000000000, 0.40000000000000013, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17362711992081245, 0.39999999999999991, 0.59999999999999998, 
+  { 0.17574420264267029, 0.40000000000000013, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34217074276403953, 0.39999999999999991, 0.59999999999999998, 
+  { 0.35890463689046265, 0.40000000000000013, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50205389185761606, 0.39999999999999991, 0.59999999999999998, 
+  { 0.55763773975194486, 0.40000000000000013, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.65182834920372734, 0.39999999999999991, 0.59999999999999998, 
+  { 0.78153324227761267, 0.40000000000000013, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.79186512820565136, 0.39999999999999991, 0.59999999999999998, 
+  { 1.0420205885765887, 0.40000000000000013, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.92365535916287134, 0.39999999999999991, 0.59999999999999998, 
+  { 1.3517205230381770, 0.40000000000000013, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0491915663957907, 0.39999999999999991, 0.59999999999999998, 
+  { 1.7210360970313896, 0.40000000000000013, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1705934291745106, 0.39999999999999991, 0.59999999999999998, 
+  { 2.1500780510169246, 0.40000000000000013, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.2899514672527024, 0.39999999999999991, 0.59999999999999998, 
+  { 2.6186940209850191, 0.40000000000000013, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler137 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.69999999999999996.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.1018730557776469e-16
+// Test data for k=0.40000000000000013, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.8573292020719759e-16
+// mean(f - f_Boost): 2.2759572004815707e-16
+// variance(f - f_Boost): 2.9613098824898137e-31
+// stddev(f - f_Boost): 5.4417918762938862e-16
 const testcase_ellint_3<double>
 data138[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.69999999999999996, 
+  { 0.0000000000000000, 0.40000000000000013, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17345479265712868, 0.39999999999999991, 0.69999999999999996, 
+  { 0.17592484806010436, 0.40000000000000013, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34089751955950354, 0.39999999999999991, 0.69999999999999996, 
+  { 0.36043555139631439, 0.40000000000000013, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.49824200167361332, 0.39999999999999991, 0.69999999999999996, 
+  { 0.56332813669944881, 0.40000000000000013, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.64402450341199402, 0.39999999999999991, 0.69999999999999996, 
+  { 0.79697424562157548, 0.40000000000000013, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.77889207804122873, 0.39999999999999991, 0.69999999999999996, 
+  { 1.0778155987523672, 0.40000000000000013, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.90468169720957992, 0.39999999999999991, 0.69999999999999996, 
+  { 1.4272018169896268, 0.40000000000000013, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0236847823692916, 0.39999999999999991, 0.69999999999999996, 
+  { 1.8684377907453382, 0.40000000000000013, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1382465247425166, 0.39999999999999991, 0.69999999999999996, 
+  { 2.4128677409207473, 0.40000000000000013, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2506255923253344, 0.39999999999999991, 0.69999999999999996, 
+  { 3.0327078743873246, 0.40000000000000013, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler138 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.80000000000000004.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.3122171115555478e-16
+// Test data for k=0.40000000000000013, nu=0.80000000000000004.
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.5273712585384737e-16
+// mean(f - f_Boost): 4.5241588253475131e-16
+// variance(f - f_Boost): 1.1866477068555882e-30
+// stddev(f - f_Boost): 1.0893336067778265e-15
 const testcase_ellint_3<double>
 data139[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.80000000000000004, 
+  { 0.0000000000000000, 0.40000000000000013, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17328307694277154, 0.39999999999999991, 0.80000000000000004, 
+  { 0.17610616300487833, 0.40000000000000013, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.33964091800132007, 0.39999999999999991, 0.80000000000000004, 
+  { 0.36199013167171978, 0.40000000000000013, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49452889372467440, 0.39999999999999991, 0.80000000000000004, 
+  { 0.56923097361842434, 0.40000000000000013, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.63652940095937316, 0.39999999999999991, 0.80000000000000004, 
+  { 0.81354878456624347, 0.40000000000000013, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.76659772511159097, 0.39999999999999991, 0.80000000000000004, 
+  { 1.1182902719261825, 0.40000000000000013, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.88691047977338111, 0.39999999999999991, 0.80000000000000004, 
+  { 1.5192950589409022, 0.40000000000000013, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.0000273200611638, 0.39999999999999991, 0.80000000000000004, 
+  { 2.0678761710223981, 0.40000000000000013, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.1084787902188009, 0.39999999999999991, 0.80000000000000004, 
+  { 2.8135222249879788, 0.40000000000000013, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.2146499565727209, 0.39999999999999991, 0.80000000000000004, 
+  { 3.7289548002199902, 0.40000000000000013, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler139 = 2.5000000000000020e-13;
 
-// Test data for k=0.39999999999999991, nu=0.90000000000000002.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 7.5168974431077345e-16
+// Test data for k=0.40000000000000013, nu=0.90000000000000002.
+// max(|f - f_Boost|): 6.2172489379008766e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.1718379478872251e-15
+// mean(f - f_Boost): 8.4099394115355610e-16
+// variance(f - f_Boost): 3.5684096037099424e-30
+// stddev(f - f_Boost): 1.8890234523980751e-15
 const testcase_ellint_3<double>
 data140[10] =
 {
-  { 0.0000000000000000, 0.39999999999999991, 0.90000000000000002, 
+  { 0.0000000000000000, 0.40000000000000013, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17311196891868127, 0.39999999999999991, 0.90000000000000002, 
+  { 0.17628815191971123, 0.40000000000000013, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33840055664911906, 0.39999999999999991, 0.90000000000000002, 
+  { 0.36356903815378772, 0.40000000000000013, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.49091013944075329, 0.39999999999999991, 0.90000000000000002, 
+  { 0.57536079447000310, 0.40000000000000013, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.62932228186809580, 0.39999999999999991, 0.90000000000000002, 
+  { 0.83141355850172571, 0.40000000000000013, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.75492278323019801, 0.39999999999999991, 0.90000000000000002, 
+  { 1.1646481598721361, 0.40000000000000013, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.87021659043854294, 0.39999999999999991, 0.90000000000000002, 
+  { 1.6357275034001995, 0.40000000000000013, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.97800245228239246, 0.39999999999999991, 0.90000000000000002, 
+  { 2.3628787566572402, 0.40000000000000013, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.0809625773173697, 0.39999999999999991, 0.90000000000000002, 
+  { 3.5521010369134962, 0.40000000000000013, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.1815758115929846, 0.39999999999999991, 0.90000000000000002, 
+  { 5.3055535102872513, 0.40000000000000013, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler140 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.0000000000000000.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.1201497220602069e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.4551389361831220e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 2.5893058141206173e-32
+// stddev(f - f_Boost): 1.6091320064309879e-16
 const testcase_ellint_3<double>
 data141[10] =
 {
@@ -4108,289 +4530,319 @@
 	  0.0000000000000000 },
   { 0.17475385514035785, 0.50000000000000000, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35081868470101585, 0.50000000000000000, 0.0000000000000000, 
+  { 0.35081868470101579, 0.50000000000000000, 0.0000000000000000, 
 	  0.34906585039886590 },
   { 0.52942862705190574, 0.50000000000000000, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.71164727562630314, 0.50000000000000000, 0.0000000000000000, 
+  { 0.71164727562630326, 0.50000000000000000, 0.0000000000000000, 
 	  0.69813170079773179 },
   { 0.89824523594227768, 0.50000000000000000, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.0895506700518851, 0.50000000000000000, 0.0000000000000000, 
+  { 1.0895506700518853, 0.50000000000000000, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.2853005857432931, 0.50000000000000000, 0.0000000000000000, 
+  { 1.2853005857432933, 0.50000000000000000, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.4845545520549484, 0.50000000000000000, 0.0000000000000000, 
+  { 1.4845545520549488, 0.50000000000000000, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.6857503548125963, 0.50000000000000000, 0.0000000000000000, 
+  { 1.6857503548125961, 0.50000000000000000, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler141 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.10000000000000001.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.1662857256911530e-16
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.7416868347177582e-16
+// mean(f - f_Boost): 2.7755575615628915e-18
+// variance(f - f_Boost): 5.4326441655972001e-32
+// stddev(f - f_Boost): 2.3308033305273100e-16
 const testcase_ellint_3<double>
 data142[10] =
 {
   { 0.0000000000000000, 0.50000000000000000, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17457763120814676, 0.50000000000000000, 0.10000000000000001, 
+  { 0.17493071928248824, 0.50000000000000000, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.34943246340849154, 0.50000000000000000, 0.10000000000000001, 
+  { 0.35222467688034798, 0.50000000000000000, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52487937869610790, 0.50000000000000000, 0.10000000000000001, 
+  { 0.53411928652008112, 0.50000000000000000, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.70127785096388384, 0.50000000000000000, 0.10000000000000001, 
+  { 0.72256398117177589, 0.50000000000000000, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.87898815988624479, 0.50000000000000000, 0.10000000000000001, 
+  { 0.91899583232771009, 0.50000000000000000, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0582764576094172, 0.50000000000000000, 0.10000000000000001, 
+  { 1.1240549163055360, 0.50000000000000000, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.2391936844060205, 0.50000000000000000, 0.10000000000000001, 
+  { 1.3372938086286021, 0.50000000000000000, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.4214793542995841, 0.50000000000000000, 0.10000000000000001, 
+  { 1.5570024469132429, 0.50000000000000000, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.6045524936084892, 0.50000000000000000, 0.10000000000000001, 
+  { 1.7803034946545480, 0.50000000000000000, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler142 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.20000000000000001.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.2114786773102175e-16
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.1198767993730867e-16
+// mean(f - f_Boost): 2.7755575615628914e-17
+// variance(f - f_Boost): 5.0311947683004831e-32
+// stddev(f - f_Boost): 2.2430324938128922e-16
 const testcase_ellint_3<double>
 data143[10] =
 {
   { 0.0000000000000000, 0.50000000000000000, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17440204336345433, 0.50000000000000000, 0.20000000000000001, 
+  { 0.17510822779582402, 0.50000000000000000, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34806552388338824, 0.50000000000000000, 0.20000000000000001, 
+  { 0.35365094725531487, 0.50000000000000000, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.52046416757129810, 0.50000000000000000, 0.20000000000000001, 
+  { 0.53895933237328697, 0.50000000000000000, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.69140924550993865, 0.50000000000000000, 0.20000000000000001, 
+  { 0.73408090840070794, 0.50000000000000000, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.86104678636125520, 0.50000000000000000, 0.20000000000000001, 
+  { 0.94145442818535396, 0.50000000000000000, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0297439459053981, 0.50000000000000000, 0.20000000000000001, 
+  { 1.1624120186296487, 0.50000000000000000, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.1979214112912033, 0.50000000000000000, 0.20000000000000001, 
+  { 1.3965823372867114, 0.50000000000000000, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.3659033858648930, 0.50000000000000000, 0.20000000000000001, 
+  { 1.6414308440430099, 0.50000000000000000, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.5338490483665983, 0.50000000000000000, 0.20000000000000001, 
+  { 1.8922947612264018, 0.50000000000000000, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler143 = 2.5000000000000020e-13;
 
-// Test data for k=0.50000000000000000, nu=0.29999999999999999.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.2557837230041312e-16
+// Test data for k=0.50000000000000000, nu=0.30000000000000004.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.3800262770228813e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 8.5027191584278157e-32
+// stddev(f - f_Boost): 2.9159422419567599e-16
 const testcase_ellint_3<double>
 data144[10] =
 {
-  { 0.0000000000000000, 0.50000000000000000, 0.29999999999999999, 
+  { 0.0000000000000000, 0.50000000000000000, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17422708752228896, 0.50000000000000000, 0.29999999999999999, 
+  { 0.17528638488102041, 0.50000000000000000, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34671739434855858, 0.50000000000000000, 0.29999999999999999, 
+  { 0.35509802222332720, 0.50000000000000000, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51617616305641878, 0.50000000000000000, 0.29999999999999999, 
+  { 0.54395740731866193, 0.50000000000000000, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.68200047612545167, 0.50000000000000000, 0.29999999999999999, 
+  { 0.74625871438752667, 0.50000000000000000, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.84427217869498372, 0.50000000000000000, 0.29999999999999999, 
+  { 0.96588271186092023, 0.50000000000000000, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.0035637821389782, 0.50000000000000000, 0.29999999999999999, 
+  { 1.2054319584357329, 0.50000000000000000, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1606800483933111, 0.50000000000000000, 0.29999999999999999, 
+  { 1.4651077994832871, 0.50000000000000000, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.3164407134643459, 0.50000000000000000, 0.29999999999999999, 
+  { 1.7416018368052644, 0.50000000000000000, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.4715681939859637, 0.50000000000000000, 0.29999999999999999, 
+  { 2.0277924458111314, 0.50000000000000000, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler144 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.40000000000000002.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.2992508582900068e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.0439932918341581e-16
+// mean(f - f_Boost): 3.0531133177191807e-17
+// variance(f - f_Boost): 9.0809736800018602e-32
+// stddev(f - f_Boost): 3.0134653938616686e-16
 const testcase_ellint_3<double>
 data145[10] =
 {
   { 0.0000000000000000, 0.50000000000000000, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17405275963859917, 0.50000000000000000, 0.40000000000000002, 
+  { 0.17546519477859268, 0.50000000000000000, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34538761957029329, 0.50000000000000000, 0.40000000000000002, 
+  { 0.35656644822531680, 0.50000000000000000, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.51200902646603907, 0.50000000000000000, 0.40000000000000002, 
+  { 0.54912289677411319, 0.50000000000000000, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.67301522212868792, 0.50000000000000000, 0.40000000000000002, 
+  { 0.75916731611690047, 0.50000000000000000, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.82853844466313320, 0.50000000000000000, 0.40000000000000002, 
+  { 0.99260415631328214, 0.50000000000000000, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.97942097862681488, 0.50000000000000000, 0.40000000000000002, 
+  { 1.2541925856918670, 0.50000000000000000, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.1268429801220614, 0.50000000000000000, 0.40000000000000002, 
+  { 1.5456393705347609, 0.50000000000000000, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.2720406704533922, 0.50000000000000000, 0.40000000000000002, 
+  { 1.8631904972952076, 0.50000000000000000, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.4161679518465340, 0.50000000000000000, 0.40000000000000002, 
+  { 2.1962905366178065, 0.50000000000000000, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler145 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.50000000000000000.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3419255755184137e-16
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.6797816859260978e-16
+// mean(f - f_Boost): 9.4368957093138303e-17
+// variance(f - f_Boost): 7.7794254682023874e-32
+// stddev(f - f_Boost): 2.7891621444803792e-16
 const testcase_ellint_3<double>
 data146[10] =
 {
   { 0.0000000000000000, 0.50000000000000000, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17387905570381157, 0.50000000000000000, 0.50000000000000000, 
+  { 0.17564466176941509, 0.50000000000000000, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34407576010465207, 0.50000000000000000, 0.50000000000000000, 
+  { 0.35805679276065394, 0.50000000000000000, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.50795686560160824, 0.50000000000000000, 0.50000000000000000, 
+  { 0.55446601496200032, 0.50000000000000000, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.66442115453330164, 0.50000000000000000, 0.50000000000000000, 
+  { 0.77288783578259013, 0.50000000000000000, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.81373829119355345, 0.50000000000000000, 0.50000000000000000, 
+  { 1.0220246013918972, 0.50000000000000000, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.95705743313235825, 0.50000000000000000, 0.50000000000000000, 
+  { 1.3101681612463965, 0.50000000000000000, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.0959131991362554, 0.50000000000000000, 0.50000000000000000, 
+  { 1.6422994881851025, 0.50000000000000000, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.2318900529754597, 0.50000000000000000, 0.50000000000000000, 
+  { 2.0152636030998816, 0.50000000000000000, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.3664739530045971, 0.50000000000000000, 0.50000000000000000, 
+  { 2.4136715042011945, 0.50000000000000000, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler146 = 2.5000000000000020e-13;
 
-// Test data for k=0.50000000000000000, nu=0.59999999999999998.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3838494104749599e-16
+// Test data for k=0.50000000000000000, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.9178421578645735e-16
+// mean(f - f_Boost): 1.3322676295501878e-16
+// variance(f - f_Boost): 1.7749370367472766e-31
+// stddev(f - f_Boost): 4.2130001622920411e-16
 const testcase_ellint_3<double>
 data147[10] =
 {
-  { 0.0000000000000000, 0.50000000000000000, 0.59999999999999998, 
+  { 0.0000000000000000, 0.50000000000000000, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17370597174637581, 0.50000000000000000, 0.59999999999999998, 
+  { 0.17582479017522740, 0.50000000000000000, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34278139158591414, 0.50000000000000000, 0.59999999999999998, 
+  { 0.35956964546660036, 0.50000000000000000, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50401419439302708, 0.50000000000000000, 0.59999999999999998, 
+  { 0.55999790372984193, 0.50000000000000000, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.65618938076167210, 0.50000000000000000, 0.59999999999999998, 
+  { 0.78751507911209895, 0.50000000000000000, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.79977959248855424, 0.50000000000000000, 0.59999999999999998, 
+  { 1.0546620505035220, 0.50000000000000000, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.93625925190753545, 0.50000000000000000, 0.59999999999999998, 
+  { 1.3754438357425935, 0.50000000000000000, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0674905658379708, 0.50000000000000000, 0.59999999999999998, 
+  { 1.7615727400820127, 0.50000000000000000, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.1953481298023050, 0.50000000000000000, 0.59999999999999998, 
+  { 2.2134638067565242, 0.50000000000000000, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.3215740290190876, 0.50000000000000000, 0.59999999999999998, 
+  { 2.7090491861753558, 0.50000000000000000, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler147 = 2.5000000000000020e-13;
 
-// Test data for k=0.50000000000000000, nu=0.69999999999999996.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 3.4250604066951477e-16
+// Test data for k=0.50000000000000000, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.0745105182189226e-16
+// mean(f - f_Boost): 4.1633363423443370e-17
+// variance(f - f_Boost): 1.9996383743576116e-32
+// stddev(f - f_Boost): 1.4140857026211713e-16
 const testcase_ellint_3<double>
 data148[10] =
 {
-  { 0.0000000000000000, 0.50000000000000000, 0.69999999999999996, 
+  { 0.0000000000000000, 0.50000000000000000, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17353350383131641, 0.50000000000000000, 0.69999999999999996, 
+  { 0.17600558435914915, 0.50000000000000000, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34150410405436771, 0.50000000000000000, 0.69999999999999996, 
+  { 0.36110561926726259, 0.50000000000000000, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.50017589696443487, 0.50000000000000000, 0.69999999999999996, 
+  { 0.56573074641137111, 0.50000000000000000, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.64829398188419951, 0.50000000000000000, 0.69999999999999996, 
+  { 0.80316073084237205, 0.50000000000000000, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.78658270782402073, 0.50000000000000000, 0.69999999999999996, 
+  { 1.0911910688131461, 0.50000000000000000, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.91684738336675053, 0.50000000000000000, 0.69999999999999996, 
+  { 1.4530946406380640, 0.50000000000000000, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0412486789555935, 0.50000000000000000, 0.69999999999999996, 
+  { 1.9144386536785372, 0.50000000000000000, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1619021847612001, 0.50000000000000000, 0.69999999999999996, 
+  { 2.4878788958234970, 0.50000000000000000, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.2807475181182502, 0.50000000000000000, 0.69999999999999996, 
+  { 3.1433945297859225, 0.50000000000000000, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler148 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.5715240651179632e-16
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.4380477375534667e-16
+// mean(f - f_Boost): 2.3037127760972000e-16
+// variance(f - f_Boost): 1.4989821857033475e-31
+// stddev(f - f_Boost): 3.8716691306248618e-16
 const testcase_ellint_3<double>
 data149[10] =
 {
   { 0.0000000000000000, 0.50000000000000000, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17336164805979126, 0.50000000000000000, 0.80000000000000004, 
+  { 0.17618704872620228, 0.50000000000000000, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34024350132086773, 0.50000000000000000, 0.80000000000000004, 
+  { 0.36266535159745827, 0.50000000000000000, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49643719555734073, 0.50000000000000000, 0.80000000000000004, 
+  { 0.57167789954529158, 0.50000000000000000, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.64071162456976150, 0.50000000000000000, 0.80000000000000004, 
+  { 0.81995752984315018, 0.50000000000000000, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.77407836177211908, 0.50000000000000000, 0.80000000000000004, 
+  { 1.1325112162158122, 0.50000000000000000, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.89867058251905652, 0.50000000000000000, 0.80000000000000004, 
+  { 1.5479055930718042, 0.50000000000000000, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.0169181822134910, 0.50000000000000000, 0.80000000000000004, 
+  { 2.1215243941010486, 0.50000000000000000, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.1311363312779448, 0.50000000000000000, 0.80000000000000004, 
+  { 2.9069405767650132, 0.50000000000000000, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.2434165408189539, 0.50000000000000000, 0.80000000000000004, 
+  { 3.8750701888108066, 0.50000000000000000, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler149 = 2.5000000000000020e-13;
 
 // Test data for k=0.50000000000000000, nu=0.90000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.4664649039489274e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 3.6192315188521289e-16
+// mean(f - f_Boost): 3.5249581031848718e-16
+// variance(f - f_Boost): 2.5029385557256515e-31
+// stddev(f - f_Boost): 5.0029376927217987e-16
 const testcase_ellint_3<double>
 data150[10] =
 {
   { 0.0000000000000000, 0.50000000000000000, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17319040056865681, 0.50000000000000000, 0.90000000000000002, 
+  { 0.17636918772384180, 0.50000000000000000, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33899920036578557, 0.50000000000000000, 0.90000000000000002, 
+  { 0.36424950570740700, 0.50000000000000000, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.49279362182695174, 0.50000000000000000, 0.90000000000000002, 
+  { 0.57785404590231426, 0.50000000000000000, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.63342123379746151, 0.50000000000000000, 0.90000000000000002, 
+  { 0.83806480521716531, 0.50000000000000000, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.76220595179550321, 0.50000000000000000, 0.90000000000000002, 
+  { 1.1798568683069752, 0.50000000000000000, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.88160004743532294, 0.50000000000000000, 0.90000000000000002, 
+  { 1.6678766243739607, 0.50000000000000000, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 0.99427448642310123, 0.50000000000000000, 0.90000000000000002, 
+  { 2.4282976450693483, 0.50000000000000000, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.1027091512470095, 0.50000000000000000, 0.90000000000000002, 
+  { 3.6810787666126656, 0.50000000000000000, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.2091116095504744, 0.50000000000000000, 0.90000000000000002, 
+  { 5.5355132096026454, 0.50000000000000000, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler150 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.0000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3664899092028927e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.3664899092028927e-16
+// mean(f - f_Boost): 3.0531133177191807e-17
+// variance(f - f_Boost): 7.8758646268991113e-33
+// stddev(f - f_Boost): 8.8746068233466605e-17
 const testcase_ellint_3<double>
 data151[10] =
 {
@@ -4398,19 +4850,19 @@
 	  0.0000000000000000 },
   { 0.17485154362988359, 0.60000000000000009, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35160509865544326, 0.60000000000000009, 0.0000000000000000, 
+  { 0.35160509865544320, 0.60000000000000009, 0.0000000000000000, 
 	  0.34906585039886590 },
   { 0.53210652578446138, 0.60000000000000009, 0.0000000000000000, 
 	  0.52359877559829882 },
   { 0.71805304664485659, 0.60000000000000009, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.91082759030195970, 0.60000000000000009, 0.0000000000000000, 
+  { 0.91082759030195981, 0.60000000000000009, 0.0000000000000000, 
 	  0.87266462599716477 },
   { 1.1112333229323361, 0.60000000000000009, 0.0000000000000000, 
 	  1.0471975511965976 },
   { 1.3191461190365270, 0.60000000000000009, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.5332022105084775, 0.60000000000000009, 0.0000000000000000, 
+  { 1.5332022105084779, 0.60000000000000009, 0.0000000000000000, 
 	  1.3962634015954636 },
   { 1.7507538029157526, 0.60000000000000009, 0.0000000000000000, 
 	  1.5707963267948966 },
@@ -4418,559 +4870,619 @@
 const double toler151 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.10000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.4937942733669112e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.2335247010355137e-16
+// mean(f - f_Boost): 8.6042284408449634e-17
+// variance(f - f_Boost): 2.2835347143080263e-33
+// stddev(f - f_Boost): 4.7786344433405099e-17
 const testcase_ellint_3<double>
 data152[10] =
 {
   { 0.0000000000000000, 0.60000000000000009, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17467514275022011, 0.60000000000000009, 0.10000000000000001, 
+  { 0.17502858548476194, 0.60000000000000009, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.35021333086258255, 0.60000000000000009, 0.10000000000000001, 
+  { 0.35301673150537388, 0.60000000000000009, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.52751664092962691, 0.60000000000000009, 0.10000000000000001, 
+  { 0.53683932476326812, 0.60000000000000009, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.70752126971957874, 0.60000000000000009, 0.10000000000000001, 
+  { 0.72914228589586771, 0.60000000000000009, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.89111058756112871, 0.60000000000000009, 0.10000000000000001, 
+  { 0.93208036718354692, 0.60000000000000009, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.0789241202877768, 0.60000000000000009, 0.10000000000000001, 
+  { 1.1468984688863377, 0.60000000000000009, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.2710800210399946, 0.60000000000000009, 0.10000000000000001, 
+  { 1.3733904977062528, 0.60000000000000009, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.4669060574440276, 0.60000000000000009, 0.10000000000000001, 
+  { 1.6094225663372157, 0.60000000000000009, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.6648615773343014, 0.60000000000000009, 0.10000000000000001, 
+  { 1.8508766487100685, 0.60000000000000009, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler152 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.20000000000000001.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1891472451898755e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.2547200163366559e-16
+// mean(f - f_Boost): -2.4980018054066023e-17
+// variance(f - f_Boost): 2.1685495635542404e-32
+// stddev(f - f_Boost): 1.4725995937641163e-16
 const testcase_ellint_3<double>
 data153[10] =
 {
   { 0.0000000000000000, 0.60000000000000009, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17449937871800650, 0.60000000000000009, 0.20000000000000001, 
+  { 0.17520627248155893, 0.60000000000000009, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34884093647346553, 0.60000000000000009, 0.20000000000000001, 
+  { 0.35444873935437748, 0.60000000000000009, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.52306221119844087, 0.60000000000000009, 0.20000000000000001, 
+  { 0.54172310557682524, 0.60000000000000009, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.69749955678982223, 0.60000000000000009, 0.20000000000000001, 
+  { 0.74084300280734672, 0.60000000000000009, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.87274610682416853, 0.60000000000000009, 0.20000000000000001, 
+  { 0.95509001527006121, 0.60000000000000009, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0494620540750792, 0.60000000000000009, 0.20000000000000001, 
+  { 1.1865688084431796, 0.60000000000000009, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.2280847305507339, 0.60000000000000009, 0.20000000000000001, 
+  { 1.4352978868932600, 0.60000000000000009, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.4085436279696888, 0.60000000000000009, 0.20000000000000001, 
+  { 1.6983400371331818, 0.60000000000000009, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.5901418016279374, 0.60000000000000009, 0.20000000000000001, 
+  { 1.9695980282802217, 0.60000000000000009, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler153 = 2.5000000000000020e-13;
 
-// Test data for k=0.60000000000000009, nu=0.29999999999999999.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.7339932380431439e-16
+// Test data for k=0.60000000000000009, nu=0.30000000000000004.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.9470074709717020e-16
+// mean(f - f_Boost): 3.0531133177191807e-17
+// variance(f - f_Boost): 1.1508025840536076e-34
+// stddev(f - f_Boost): 1.0727546709539920e-17
 const testcase_ellint_3<double>
 data154[10] =
 {
-  { 0.0000000000000000, 0.60000000000000009, 0.29999999999999999, 
+  { 0.0000000000000000, 0.60000000000000009, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17432424744393932, 0.60000000000000009, 0.29999999999999999, 
+  { 0.17538460882640122, 0.60000000000000009, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34748744127146447, 0.60000000000000009, 0.29999999999999999, 
+  { 0.35590165133735557, 0.60000000000000009, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.51873632743924825, 0.60000000000000009, 0.29999999999999999, 
+  { 0.54676661152254535, 0.60000000000000009, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.68794610396313116, 0.60000000000000009, 0.29999999999999999, 
+  { 0.75321709418305305, 0.60000000000000009, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.85558070175468726, 0.60000000000000009, 0.29999999999999999, 
+  { 0.98012637808992920, 0.60000000000000009, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.0224416343605653, 0.60000000000000009, 0.29999999999999999, 
+  { 1.2310891277158875, 0.60000000000000009, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.1893144457936788, 0.60000000000000009, 0.29999999999999999, 
+  { 1.5069157924585623, 0.60000000000000009, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.3566435377982575, 0.60000000000000009, 0.29999999999999999, 
+  { 1.8039583598337940, 0.60000000000000009, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.5243814243493585, 0.60000000000000009, 0.29999999999999999, 
+  { 2.1134154405060599, 0.60000000000000009, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler154 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.40000000000000002.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.5440898085101625e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 2.8974839914337670e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 2.2849613290816465e-32
+// stddev(f - f_Boost): 1.5116088545260797e-16
 const testcase_ellint_3<double>
 data155[10] =
 {
   { 0.0000000000000000, 0.60000000000000009, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17414974487670717, 0.60000000000000009, 0.40000000000000002, 
+  { 0.17556359876533037, 0.60000000000000009, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34615238767335027, 0.60000000000000009, 0.40000000000000002, 
+  { 0.35737601674244679, 0.60000000000000009, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.51453257838108557, 0.60000000000000009, 0.40000000000000002, 
+  { 0.55197933771320218, 0.60000000000000009, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.67882386787534399, 0.60000000000000009, 0.40000000000000002, 
+  { 0.76633591620002905, 0.60000000000000009, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.83948470233173578, 0.60000000000000009, 0.40000000000000002, 
+  { 1.0075231136019616, 0.60000000000000009, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 0.99753496200073977, 0.60000000000000009, 0.40000000000000002, 
+  { 1.2815842073813450, 0.60000000000000009, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.1541101404388487, 0.60000000000000009, 0.40000000000000002, 
+  { 1.5911666941449827, 0.60000000000000009, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.3100911323398816, 0.60000000000000009, 0.40000000000000002, 
+  { 1.9323227566025762, 0.60000000000000009, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.4659345278069984, 0.60000000000000009, 0.40000000000000002, 
+  { 2.2925036420985130, 0.60000000000000009, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler155 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.50000000000000000.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 4.7124937590522226e-16
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 2.1397785842303966e-16
+// mean(f - f_Boost): 9.1593399531575410e-17
+// variance(f - f_Boost): 1.5339913122479866e-32
+// stddev(f - f_Boost): 1.2385440291923362e-16
 const testcase_ellint_3<double>
 data156[10] =
 {
   { 0.0000000000000000, 0.60000000000000009, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17397586700252807, 0.60000000000000009, 0.50000000000000000, 
+  { 0.17574324658480217, 0.60000000000000009, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34483533397138516, 0.60000000000000009, 0.50000000000000000, 
+  { 0.35887240603169313, 0.60000000000000009, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.51044500461706477, 0.60000000000000009, 0.50000000000000000, 
+  { 0.55737161826345261, 0.60000000000000009, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.67009988034712664, 0.60000000000000009, 0.50000000000000000, 
+  { 0.78028227313077458, 0.60000000000000009, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.82434762375735193, 0.60000000000000009, 0.50000000000000000, 
+  { 1.0376989776486290, 0.60000000000000009, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.97447346702798998, 0.60000000000000009, 0.50000000000000000, 
+  { 1.3395933991042928, 0.60000000000000009, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.1219494000522143, 0.60000000000000009, 0.50000000000000000, 
+  { 1.6924049626591784, 0.60000000000000009, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.2680242605954486, 0.60000000000000009, 0.50000000000000000, 
+  { 2.0931011856518920, 0.60000000000000009, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.4135484285693078, 0.60000000000000009, 0.50000000000000000, 
+  { 2.5239007084492711, 0.60000000000000009, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler156 = 2.5000000000000020e-13;
 
-// Test data for k=0.60000000000000009, nu=0.59999999999999998.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.0652177678695900e-16
+// Test data for k=0.60000000000000009, nu=0.60000000000000009.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.6651378277398083e-16
+// mean(f - f_Boost): 1.1934897514720432e-16
+// variance(f - f_Boost): 1.7585404776158019e-33
+// stddev(f - f_Boost): 4.1934955319110598e-17
 const testcase_ellint_3<double>
 data157[10] =
 {
-  { 0.0000000000000000, 0.60000000000000009, 0.59999999999999998, 
+  { 0.0000000000000000, 0.60000000000000009, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17380260984469353, 0.60000000000000009, 0.59999999999999998, 
+  { 0.17592355661219386, 0.60000000000000009, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34353585361777839, 0.60000000000000009, 0.59999999999999998, 
+  { 0.36039141192661606, 0.60000000000000009, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50646805774321380, 0.60000000000000009, 0.59999999999999998, 
+  { 0.56295472636903854, 0.60000000000000009, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.66174468108625506, 0.60000000000000009, 0.59999999999999998, 
+  { 0.79515295130165986, 0.60000000000000009, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.81007462280278408, 0.60000000000000009, 0.59999999999999998, 
+  { 1.0711886441942242, 0.60000000000000009, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.95303466945718729, 0.60000000000000009, 0.59999999999999998, 
+  { 1.4072952835139891, 0.60000000000000009, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.0924118588677505, 0.60000000000000009, 0.59999999999999998, 
+  { 1.8174863977376825, 0.60000000000000009, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.2297640574847937, 0.60000000000000009, 0.59999999999999998, 
+  { 2.3029921578542232, 0.60000000000000009, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.3662507535812816, 0.60000000000000009, 0.59999999999999998, 
+  { 2.8388723099514972, 0.60000000000000009, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler157 = 2.5000000000000020e-13;
 
-// Test data for k=0.60000000000000009, nu=0.69999999999999996.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1692457486457856e-16
+// Test data for k=0.60000000000000009, nu=0.70000000000000007.
+// max(|f - f_Boost|): 4.4408920985006262e-16 at index 9
+// max(|f - f_Boost| / |f_Boost|): 2.0027679235921772e-16
+// mean(f - f_Boost): -1.3877787807814457e-17
+// variance(f - f_Boost): 2.2849613290816465e-32
+// stddev(f - f_Boost): 1.5116088545260797e-16
 const testcase_ellint_3<double>
 data158[10] =
 {
-  { 0.0000000000000000, 0.60000000000000009, 0.69999999999999996, 
+  { 0.0000000000000000, 0.60000000000000009, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17362996946312007, 0.60000000000000009, 0.69999999999999996, 
+  { 0.17610453321631936, 0.60000000000000009, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34225353454870588, 0.60000000000000009, 0.69999999999999996, 
+  { 0.36193365056369764, 0.60000000000000009, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.50259656397799524, 0.60000000000000009, 0.69999999999999996, 
+  { 0.56874098962268527, 0.60000000000000009, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.65373184496628933, 0.60000000000000009, 0.69999999999999996, 
+  { 0.81106198671477181, 0.60000000000000009, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.79658372884056439, 0.60000000000000009, 0.69999999999999996, 
+  { 1.1086886419010082, 0.60000000000000009, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.93303240100245421, 0.60000000000000009, 0.69999999999999996, 
+  { 1.4879048567239257, 0.60000000000000009, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0651547944716557, 0.60000000000000009, 0.69999999999999996, 
+  { 1.9780310073615925, 0.60000000000000009, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.1947676204853441, 0.60000000000000009, 0.69999999999999996, 
+  { 2.5941545586772712, 0.60000000000000009, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.3232737468822813, 0.60000000000000009, 0.69999999999999996, 
+  { 3.3029735898397159, 0.60000000000000009, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler158 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2705175719241326e-16
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 7.3044933435043190e-16
+// mean(f - f_Boost): 2.6367796834847468e-16
+// variance(f - f_Boost): 8.5834655546147173e-33
+// stddev(f - f_Boost): 9.2646994309662939e-17
 const testcase_ellint_3<double>
 data159[10] =
 {
   { 0.0000000000000000, 0.60000000000000009, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17345794195390685, 0.60000000000000009, 0.80000000000000004, 
+  { 0.17628618080795252, 0.60000000000000009, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34098797854531027, 0.60000000000000009, 0.80000000000000004, 
+  { 0.36349976272521012, 0.60000000000000009, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.49882569168826213, 0.60000000000000009, 0.80000000000000004, 
+  { 0.57474392342151914, 0.60000000000000009, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.64603758566475511, 0.60000000000000009, 0.80000000000000004, 
+  { 0.82814493499158170, 0.60000000000000009, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.78380365594769730, 0.60000000000000009, 0.80000000000000004, 
+  { 1.1511281795998280, 0.60000000000000009, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.91430946255611190, 0.60000000000000009, 0.80000000000000004, 
+  { 1.5864286332503075, 0.60000000000000009, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.0398955217270607, 0.60000000000000009, 0.80000000000000004, 
+  { 2.1958944866494527, 0.60000000000000009, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.1625948314277679, 0.60000000000000009, 0.80000000000000004, 
+  { 3.0398358172574604, 0.60000000000000009, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.2840021261752192, 0.60000000000000009, 0.80000000000000004, 
+  { 4.0867036409261832, 0.60000000000000009, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler159 = 2.5000000000000020e-13;
 
 // Test data for k=0.60000000000000009, nu=0.90000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.5585887739668036e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.5952142720718732e-16
+// mean(f - f_Boost): 4.6351811278100284e-16
+// variance(f - f_Boost): 2.1278339779151204e-31
+// stddev(f - f_Boost): 4.6128450851021651e-16
 const testcase_ellint_3<double>
 data160[10] =
 {
   { 0.0000000000000000, 0.60000000000000009, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17328652344890030, 0.60000000000000009, 0.90000000000000002, 
+  { 0.17646850384035848, 0.60000000000000009, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.33973880062929018, 0.60000000000000009, 0.90000000000000002, 
+  { 0.36509041515134105, 0.60000000000000009, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.49515092233122743, 0.60000000000000009, 0.90000000000000002, 
+  { 0.58097838596260631, 0.60000000000000009, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.63864042139737043, 0.60000000000000009, 0.90000000000000002, 
+  { 0.84656453396163722, 0.60000000000000009, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.77167205646538850, 0.60000000000000009, 0.90000000000000002, 
+  { 1.1997828426963724, 0.60000000000000009, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.89673202848034383, 0.60000000000000009, 0.90000000000000002, 
+  { 1.7112436789225605, 0.60000000000000009, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 1.0163984492661304, 0.60000000000000009, 0.90000000000000002, 
+  { 2.5193168553672312, 0.60000000000000009, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.1328845785162431, 0.60000000000000009, 0.90000000000000002, 
+  { 3.8656670488606690, 0.60000000000000009, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.2479362973851873, 0.60000000000000009, 0.90000000000000002, 
+  { 5.8709993116265604, 0.60000000000000009, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler160 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.0000000000000000.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.5930208052157665e-16
+// Test data for k=0.70000000000000018, nu=0.0000000000000000.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.1569224977685422e-16
+// mean(f - f_Boost): 7.7715611723760953e-17
+// variance(f - f_Boost): 1.6571557210371951e-32
+// stddev(f - f_Boost): 1.2873056051447903e-16
 const testcase_ellint_3<double>
 data161[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.0000000000000000, 
+  { 0.0000000000000000, 0.70000000000000018, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17496737466916723, 0.69999999999999996, 0.0000000000000000, 
+  { 0.17496737466916723, 0.70000000000000018, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35254687535677925, 0.69999999999999996, 0.0000000000000000, 
+  { 0.35254687535677931, 0.70000000000000018, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.53536740275997119, 0.69999999999999996, 0.0000000000000000, 
+  { 0.53536740275997130, 0.70000000000000018, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.72603797651684454, 0.69999999999999996, 0.0000000000000000, 
+  { 0.72603797651684454, 0.70000000000000018, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.92698296348313458, 0.69999999999999996, 0.0000000000000000, 
+  { 0.92698296348313447, 0.70000000000000018, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.1400447527693316, 0.69999999999999996, 0.0000000000000000, 
+  { 1.1400447527693318, 0.70000000000000018, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.3657668117194073, 0.69999999999999996, 0.0000000000000000, 
+  { 1.3657668117194073, 0.70000000000000018, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.6024686895959159, 0.69999999999999996, 0.0000000000000000, 
+  { 1.6024686895959164, 0.70000000000000018, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.8456939983747236, 0.69999999999999996, 0.0000000000000000, 
+  { 1.8456939983747236, 0.70000000000000018, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler161 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.10000000000000001.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.6735282577377367e-16
+// Test data for k=0.70000000000000018, nu=0.10000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.9552278747527691e-16
+// mean(f - f_Boost): 1.1102230246251565e-16
+// variance(f - f_Boost): 1.3695501826753678e-32
+// stddev(f - f_Boost): 1.1702778228589004e-16
 const testcase_ellint_3<double>
 data162[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.10000000000000001, 
+  { 0.0000000000000000, 0.70000000000000018, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17479076384884684, 0.69999999999999996, 0.10000000000000001, 
+  { 0.17514462737300920, 0.70000000000000018, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.35114844900396364, 0.69999999999999996, 0.10000000000000001, 
+  { 0.35396527997470451, 0.70000000000000018, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.53072776947527001, 0.69999999999999996, 0.10000000000000001, 
+  { 0.54015179589433981, 0.70000000000000018, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.71530198262386235, 0.69999999999999996, 0.10000000000000001, 
+  { 0.73734430854477728, 0.70000000000000018, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.90666760677828306, 0.69999999999999996, 0.10000000000000001, 
+  { 0.94888950796697047, 0.70000000000000018, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.1063366517438080, 0.69999999999999996, 0.10000000000000001, 
+  { 1.1772807959736322, 0.70000000000000018, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.3149477243092149, 0.69999999999999996, 0.10000000000000001, 
+  { 1.4231796401075834, 0.70000000000000018, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.5314886725038925, 0.69999999999999996, 0.10000000000000001, 
+  { 1.6841856799887471, 0.70000000000000018, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.7528050171757608, 0.69999999999999996, 0.10000000000000001, 
+  { 1.9541347343119564, 0.70000000000000018, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler162 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.20000000000000001.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.7517969287516802e-16
+// Test data for k=0.70000000000000018, nu=0.20000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.7430437016285820e-16
+// mean(f - f_Boost): 3.3306690738754695e-17
+// variance(f - f_Boost): 1.3695501826753678e-34
+// stddev(f - f_Boost): 1.1702778228589003e-17
 const testcase_ellint_3<double>
 data163[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.20000000000000001, 
+  { 0.0000000000000000, 0.70000000000000018, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17461479077791475, 0.69999999999999996, 0.20000000000000001, 
+  { 0.17532252613350796, 0.70000000000000018, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.34976950621407538, 0.69999999999999996, 0.20000000000000001, 
+  { 0.35540417596807522, 0.70000000000000018, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.52622533231350177, 0.69999999999999996, 0.20000000000000001, 
+  { 0.54508913033361928, 0.70000000000000018, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.70508774017895215, 0.69999999999999996, 0.20000000000000001, 
+  { 0.74927635777718415, 0.70000000000000018, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.88775302531730294, 0.69999999999999996, 0.20000000000000001, 
+  { 0.97261706337936338, 0.70000000000000018, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.0756195476149006, 0.69999999999999996, 0.20000000000000001, 
+  { 1.2187303976209327, 0.70000000000000018, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.2695349716654374, 0.69999999999999996, 0.20000000000000001, 
+  { 1.4887796709222487, 0.70000000000000018, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.4690814617070540, 0.69999999999999996, 0.20000000000000001, 
+  { 1.7796581281839214, 0.70000000000000018, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.6721098780092145, 0.69999999999999996, 0.20000000000000001, 
+  { 2.0829290325820207, 0.70000000000000018, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler163 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.29999999999999999.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8280039841080712e-16
+// Test data for k=0.70000000000000018, nu=0.30000000000000004.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.2570807706941696e-16
+// mean(f - f_Boost): 8.8817841970012528e-17
+// variance(f - f_Boost): 1.5582437633995295e-32
+// stddev(f - f_Boost): 1.2482963443828271e-16
 const testcase_ellint_3<double>
 data164[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.29999999999999999, 
+  { 0.0000000000000000, 0.70000000000000018, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17443945136076175, 0.69999999999999996, 0.29999999999999999, 
+  { 0.17550107516328570, 0.70000000000000018, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34840956983535287, 0.69999999999999996, 0.29999999999999999, 
+  { 0.35686409576571965, 0.70000000000000018, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.52185308551329168, 0.69999999999999996, 0.29999999999999999, 
+  { 0.55018827316513352, 0.70000000000000018, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.69535240431168255, 0.69999999999999996, 0.29999999999999999, 
+  { 0.76189759494390275, 0.70000000000000018, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.87007983473964923, 0.69999999999999996, 0.29999999999999999, 
+  { 0.99844623430885626, 0.70000000000000018, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.0474657975577066, 0.69999999999999996, 0.29999999999999999, 
+  { 1.2652862989039833, 0.70000000000000018, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.2286225419931891, 0.69999999999999996, 0.29999999999999999, 
+  { 1.5647666808691361, 0.70000000000000018, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.4136490671013271, 0.69999999999999996, 0.29999999999999999, 
+  { 1.8932499694938165, 0.70000000000000018, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.6011813647733213, 0.69999999999999996, 0.29999999999999999, 
+  { 2.2392290510988535, 0.70000000000000018, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler164 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3472957053482092e-16
+// Test data for k=0.70000000000000018, nu=0.40000000000000002.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.3719045096496910e-16
+// mean(f - f_Boost): 1.3600232051658169e-16
+// variance(f - f_Boost): 1.1718213750516114e-32
+// stddev(f - f_Boost): 1.0825069861444829e-16
 const testcase_ellint_3<double>
 data165[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.40000000000000002, 
+  { 0.0000000000000000, 0.70000000000000018, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17426474153983229, 0.69999999999999996, 0.40000000000000002, 
+  { 0.17568027871494424, 0.70000000000000018, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34706817945773732, 0.69999999999999996, 0.40000000000000002, 
+  { 0.35834559208180261, 0.70000000000000018, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.51760452851738148, 0.69999999999999996, 0.40000000000000002, 
+  { 0.55545885451190613, 0.70000000000000018, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.68605801534722755, 0.69999999999999996, 0.40000000000000002, 
+  { 0.77528120402568113, 0.70000000000000018, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.85351339387296532, 0.69999999999999996, 0.40000000000000002, 
+  { 1.0267241287600322, 0.70000000000000018, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 1.0215297967969539, 0.69999999999999996, 0.40000000000000002, 
+  { 1.3181380338980246, 0.70000000000000018, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.1915051074460530, 0.69999999999999996, 0.40000000000000002, 
+  { 1.6542840785132087, 0.70000000000000018, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.3639821911744707, 0.69999999999999996, 0.40000000000000002, 
+  { 2.0315595131131823, 0.70000000000000018, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.5382162002954762, 0.69999999999999996, 0.40000000000000002, 
+  { 2.4342502915307880, 0.70000000000000018, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler165 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.50000000000000000.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 3.9748346743390620e-16
+// Test data for k=0.70000000000000018, nu=0.50000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.0277361210295499e-16
+// mean(f - f_Boost): 1.6930901125533636e-16
+// variance(f - f_Boost): 6.3799163752809956e-32
+// stddev(f - f_Boost): 2.5258496343371268e-16
 const testcase_ellint_3<double>
 data166[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.50000000000000000, 
+  { 0.0000000000000000, 0.70000000000000018, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17409065729516096, 0.69999999999999996, 0.50000000000000000, 
+  { 0.17586014108156545, 0.70000000000000018, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34574489064986091, 0.69999999999999996, 0.50000000000000000, 
+  { 0.35984923894341653, 0.70000000000000018, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.51347361925579782, 0.69999999999999996, 0.50000000000000000, 
+  { 0.56091135606739995, 0.70000000000000018, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.67717079489579279, 0.69999999999999996, 0.50000000000000000, 
+  { 0.78951212635197054, 0.70000000000000018, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.83793902055292280, 0.69999999999999996, 0.50000000000000000, 
+  { 1.0578865732938731, 0.70000000000000018, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 0.99752863545289705, 0.69999999999999996, 0.50000000000000000, 
+  { 1.3789149005151722, 0.70000000000000018, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.1576240080401501, 0.69999999999999996, 0.50000000000000000, 
+  { 1.7620212286086228, 0.70000000000000018, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.3191464023923762, 0.69999999999999996, 0.50000000000000000, 
+  { 2.2051554347435589, 0.70000000000000018, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.4818433192178544, 0.69999999999999996, 0.50000000000000000, 
+  { 2.6868019968236996, 0.70000000000000018, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler166 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.59999999999999998.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 4.0457157538295173e-16
+// Test data for k=0.70000000000000018, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.8597454441867134e-16
+// mean(f - f_Boost): 2.5535129566378598e-16
+// variance(f - f_Boost): 2.8561208198482198e-31
+// stddev(f - f_Boost): 5.3442687243889785e-16
 const testcase_ellint_3<double>
 data167[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.59999999999999998, 
+  { 0.0000000000000000, 0.70000000000000018, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17391719464391614, 0.69999999999999996, 0.59999999999999998, 
+  { 0.17604066659721918, 0.70000000000000018, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34443927423869031, 0.69999999999999996, 0.59999999999999998, 
+  { 0.36137563278353424, 0.70000000000000018, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.50945473266486063, 0.69999999999999996, 0.59999999999999998, 
+  { 0.56655721272747606, 0.70000000000000018, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.66866056326513812, 0.69999999999999996, 0.59999999999999998, 
+  { 0.80468966552978305, 0.70000000000000018, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.82325830002337352, 0.69999999999999996, 0.59999999999999998, 
+  { 1.0924902943683852, 0.70000000000000018, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 0.97522808245669368, 0.69999999999999996, 0.59999999999999998, 
+  { 1.4499247992499800, 0.70000000000000018, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.1265300613705285, 0.69999999999999996, 0.59999999999999998, 
+  { 1.8953714382113818, 0.70000000000000018, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.2784066076152001, 0.69999999999999996, 0.59999999999999998, 
+  { 2.4323229949248670, 0.70000000000000018, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.4309994736080540, 0.69999999999999996, 0.59999999999999998, 
+  { 3.0314573496746746, 0.70000000000000018, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler167 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.69999999999999996.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 5.4867405596732161e-16
+// Test data for k=0.70000000000000018, nu=0.70000000000000007.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 8
+// max(|f - f_Boost| / |f_Boost|): 3.2316852368580916e-16
+// mean(f - f_Boost): 7.7715611723760953e-17
+// variance(f - f_Boost): 7.4564398834547797e-34
+// stddev(f - f_Boost): 2.7306482533374340e-17
 const testcase_ellint_3<double>
 data168[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.69999999999999996, 
+  { 0.0000000000000000, 0.70000000000000018, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17374434963995031, 0.69999999999999996, 0.69999999999999996, 
+  { 0.17622185963747933, 0.70000000000000018, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34315091562900674, 0.69999999999999996, 0.69999999999999996, 
+  { 0.36292539360435261, 0.70000000000000018, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.50554262375653347, 0.69999999999999996, 0.69999999999999996, 
+  { 0.57240892970150015, 0.70000000000000018, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.66050025406305801, 0.69999999999999996, 0.69999999999999996, 
+  { 0.82093084713182629, 0.70000000000000018, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.80938620118847404, 0.69999999999999996, 0.69999999999999996, 
+  { 1.1312609022179871, 0.70000000000000018, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.95443223855852144, 0.69999999999999996, 0.69999999999999996, 
+  { 1.5345768067715795, 0.70000000000000018, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.0978573207128304, 0.69999999999999996, 0.69999999999999996, 
+  { 2.0668847445934424, 0.70000000000000018, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.2411754575007123, 0.69999999999999996, 0.69999999999999996, 
+  { 2.7483444537551245, 0.70000000000000018, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.3848459188329196, 0.69999999999999996, 0.69999999999999996, 
+  { 3.5408408771788569, 0.70000000000000018, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler168 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1829502028913879e-16
+// Test data for k=0.70000000000000018, nu=0.80000000000000004.
+// max(|f - f_Boost|): 1.3322676295501878e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.1198716111867353e-16
+// mean(f - f_Boost): 2.2482016248659419e-16
+// variance(f - f_Boost): 5.4326441655972001e-32
+// stddev(f - f_Boost): 2.3308033305273100e-16
 const testcase_ellint_3<double>
 data169[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.80000000000000004, 
+  { 0.0000000000000000, 0.70000000000000018, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17357211837335740, 0.69999999999999996, 0.80000000000000004, 
+  { 0.17640372461994805, 0.70000000000000018, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34187941416012108, 0.69999999999999996, 0.80000000000000004, 
+  { 0.36449916621651091, 0.70000000000000018, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.50173239465478259, 0.69999999999999996, 0.80000000000000004, 
+  { 0.57848021800372584, 0.70000000000000018, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.65266550725988315, 0.69999999999999996, 0.80000000000000004, 
+  { 0.83837480968392586, 0.70000000000000018, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.79624879865249298, 0.69999999999999996, 0.80000000000000004, 
+  { 1.1751669030061143, 0.70000000000000018, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.93497577043296920, 0.69999999999999996, 0.80000000000000004, 
+  { 1.6381851899173603, 0.70000000000000018, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.0713041566930750, 0.69999999999999996, 0.80000000000000004, 
+  { 2.3002065924302197, 0.70000000000000018, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.2069772023255654, 0.69999999999999996, 0.80000000000000004, 
+  { 3.2337600665337871, 0.70000000000000018, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.3427110650397531, 0.69999999999999996, 0.80000000000000004, 
+  { 4.4042405729076970, 0.70000000000000018, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler169 = 2.5000000000000020e-13;
 
-// Test data for k=0.69999999999999996, nu=0.90000000000000002.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2494869624129105e-16
+// Test data for k=0.70000000000000018, nu=0.90000000000000002.
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 8.5869439826269878e-16
+// mean(f - f_Boost): 7.4384942649885490e-16
+// variance(f - f_Boost): 9.7403930714297352e-31
+// stddev(f - f_Boost): 9.8693429727767263e-16
 const testcase_ellint_3<double>
 data170[10] =
 {
-  { 0.0000000000000000, 0.69999999999999996, 0.90000000000000002, 
+  { 0.0000000000000000, 0.70000000000000018, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17340049697003637, 0.69999999999999996, 0.90000000000000002, 
+  { 0.17658626600478800, 0.70000000000000018, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.34062438249741556, 0.69999999999999996, 0.90000000000000002, 
+  { 0.36609762156017206, 0.70000000000000018, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.49801946510076867, 0.69999999999999996, 0.90000000000000002, 
+  { 0.58478615187842409, 0.70000000000000018, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.64513432604750476, 0.69999999999999996, 0.90000000000000002, 
+  { 0.85718862878291846, 0.70000000000000018, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.78378145487573758, 0.69999999999999996, 0.90000000000000002, 
+  { 1.2255385617397643, 0.70000000000000018, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.91671799500854623, 0.69999999999999996, 0.90000000000000002, 
+  { 1.7696521899992941, 0.70000000000000018, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 1.0466193579463123, 0.69999999999999996, 0.90000000000000002, 
+  { 2.6476314987883507, 0.70000000000000018, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.1754218079199146, 0.69999999999999996, 0.90000000000000002, 
+  { 4.1373434902898083, 0.70000000000000018, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.3040500499695913, 0.69999999999999996, 0.90000000000000002, 
+  { 6.3796094177887763, 0.70000000000000018, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler170 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.0000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1175183168766718e-16
+// max(|f - f_Boost|): 1.5543122344752192e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.7898565163847540e-16
+// mean(f - f_Boost): 2.3869795029440865e-16
+// variance(f - f_Boost): 2.1368406725192426e-31
+// stddev(f - f_Boost): 4.6225974002926564e-16
 const testcase_ellint_3<double>
 data171[10] =
 {
@@ -4978,596 +5490,654 @@
 	  0.0000000000000000 },
   { 0.17510154241338899, 0.80000000000000004, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35365068839779390, 0.80000000000000004, 0.0000000000000000, 
+  { 0.35365068839779396, 0.80000000000000004, 0.0000000000000000, 
 	  0.34906585039886590 },
   { 0.53926804409084550, 0.80000000000000004, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.73587926028070361, 0.80000000000000004, 0.0000000000000000, 
+  { 0.73587926028070372, 0.80000000000000004, 0.0000000000000000, 
 	  0.69813170079773179 },
   { 0.94770942970071170, 0.80000000000000004, 0.0000000000000000, 
 	  0.87266462599716477 },
   { 1.1789022995388236, 0.80000000000000004, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.4323027881876009, 0.80000000000000004, 0.0000000000000000, 
+  { 1.4323027881876012, 0.80000000000000004, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.7069629739121674, 0.80000000000000004, 0.0000000000000000, 
+  { 1.7069629739121677, 0.80000000000000004, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 1.9953027776647296, 0.80000000000000004, 0.0000000000000000, 
+  { 1.9953027776647294, 0.80000000000000004, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler171 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.10000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1537164503193145e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3898786942190374e-16
+// mean(f - f_Boost): 2.3869795029440865e-16
+// variance(f - f_Boost): 2.9190059990693968e-31
+// stddev(f - f_Boost): 5.4027826155319237e-16
 const testcase_ellint_3<double>
 data172[10] =
 {
   { 0.0000000000000000, 0.80000000000000004, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17492468824017163, 0.80000000000000004, 0.10000000000000001, 
+  { 0.17527903952342144, 0.80000000000000004, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.35224443521476911, 0.80000000000000004, 0.10000000000000001, 
+  { 0.35507705313548549, 0.80000000000000004, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.53456851853226950, 0.80000000000000004, 0.10000000000000001, 
+  { 0.54411455987643553, 0.80000000000000004, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.72488875602364922, 0.80000000000000004, 0.10000000000000001, 
+  { 0.74745625666804383, 0.80000000000000004, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.92661354274638952, 0.80000000000000004, 0.10000000000000001, 
+  { 0.97046953684238557, 0.80000000000000004, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.1432651144499075, 0.80000000000000004, 0.10000000000000001, 
+  { 1.2183080025184605, 0.80000000000000004, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.3774479927211429, 0.80000000000000004, 0.10000000000000001, 
+  { 1.4943711151994405, 0.80000000000000004, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.6287092337196041, 0.80000000000000004, 0.10000000000000001, 
+  { 1.7972401309544201, 0.80000000000000004, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 1.8910755418379521, 0.80000000000000004, 0.10000000000000001, 
+  { 2.1172616484005085, 0.80000000000000004, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler172 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.20000000000000001.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1894552974436829e-16
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.8513740186068518e-16
+// mean(f - f_Boost): 2.8310687127941490e-16
+// variance(f - f_Boost): 2.7528339102381189e-31
+// stddev(f - f_Boost): 5.2467455724840699e-16
 const testcase_ellint_3<double>
 data173[10] =
 {
   { 0.0000000000000000, 0.80000000000000004, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17474847286224940, 0.80000000000000004, 0.20000000000000001, 
+  { 0.17545718375086419, 0.80000000000000004, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.35085779529084682, 0.80000000000000004, 0.20000000000000001, 
+  { 0.35652404627248163, 0.80000000000000004, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.53000829263059146, 0.80000000000000004, 0.20000000000000001, 
+  { 0.54911638512920913, 0.80000000000000004, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.71443466027453384, 0.80000000000000004, 0.20000000000000001, 
+  { 0.75967684282131176, 0.80000000000000004, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.90698196872715420, 0.80000000000000004, 0.20000000000000001, 
+  { 0.99513526893543769, 0.80000000000000004, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.1108198200558579, 0.80000000000000004, 0.20000000000000001, 
+  { 1.2622192109995993, 0.80000000000000004, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.3284988909963957, 0.80000000000000004, 0.20000000000000001, 
+  { 1.5654106676347741, 0.80000000000000004, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.5600369318140328, 0.80000000000000004, 0.20000000000000001, 
+  { 1.9029531718534984, 0.80000000000000004, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 1.8007226661734588, 0.80000000000000004, 0.20000000000000001, 
+  { 2.2624789434186798, 0.80000000000000004, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler173 = 2.5000000000000020e-13;
 
-// Test data for k=0.80000000000000004, nu=0.29999999999999999.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2247517409029886e-16
+// Test data for k=0.80000000000000004, nu=0.30000000000000004.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.2825261583337354e-16
+// mean(f - f_Boost): 2.6367796834847468e-16
+// variance(f - f_Boost): 2.8249350208968825e-31
+// stddev(f - f_Boost): 5.3150117788175054e-16
 const testcase_ellint_3<double>
 data174[10] =
 {
-  { 0.0000000000000000, 0.80000000000000004, 0.29999999999999999, 
+  { 0.0000000000000000, 0.80000000000000004, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17457289217669889, 0.80000000000000004, 0.29999999999999999, 
+  { 0.17563597931587369, 0.80000000000000004, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.34949028801501258, 0.80000000000000004, 0.29999999999999999, 
+  { 0.35799220412005128, 0.80000000000000004, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.52558024362769307, 0.80000000000000004, 0.29999999999999999, 
+  { 0.55428253691111318, 0.80000000000000004, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.70447281740094891, 0.80000000000000004, 0.29999999999999999, 
+  { 0.77260647376977365, 0.80000000000000004, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.88864745641528986, 0.80000000000000004, 0.29999999999999999, 
+  { 1.0220015271210958, 0.80000000000000004, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.0811075819341462, 0.80000000000000004, 0.29999999999999999, 
+  { 1.3115965312302671, 0.80000000000000004, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.2844589654082377, 0.80000000000000004, 0.29999999999999999, 
+  { 1.6478518468813512, 0.80000000000000004, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.4991461361277847, 0.80000000000000004, 0.29999999999999999, 
+  { 2.0290458414203481, 0.80000000000000004, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.7214611048717301, 0.80000000000000004, 0.29999999999999999, 
+  { 2.4392042002725693, 0.80000000000000004, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler174 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.40000000000000002.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2596216594752862e-16
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 8.3462748389836647e-16
+// mean(f - f_Boost): 3.3861802251067273e-16
+// variance(f - f_Boost): 4.3719465706454422e-31
+// stddev(f - f_Boost): 6.6120696991527871e-16
 const testcase_ellint_3<double>
 data175[10] =
 {
   { 0.0000000000000000, 0.80000000000000004, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17439794211872175, 0.80000000000000004, 0.40000000000000002, 
+  { 0.17581543047866136, 0.80000000000000004, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34814144964568972, 0.80000000000000004, 0.40000000000000002, 
+  { 0.35948208343061633, 0.80000000000000004, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.52127776285273064, 0.80000000000000004, 0.40000000000000002, 
+  { 0.55962280893702021, 0.80000000000000004, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.69496411438966588, 0.80000000000000004, 0.40000000000000002, 
+  { 0.78632063889234116, 0.80000000000000004, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.87146878427509589, 0.80000000000000004, 0.40000000000000002, 
+  { 1.0514333069550323, 0.80000000000000004, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 1.0537579024937762, 0.80000000000000004, 0.40000000000000002, 
+  { 1.3677213138838757, 0.80000000000000004, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.2445534387922637, 0.80000000000000004, 0.40000000000000002, 
+  { 1.7451736773665165, 0.80000000000000004, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.4446769766361993, 0.80000000000000004, 0.40000000000000002, 
+  { 2.1830100424586831, 0.80000000000000004, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.6512267838651289, 0.80000000000000004, 0.40000000000000002, 
+  { 2.6604037035529724, 0.80000000000000004, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler175 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.50000000000000000.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.2940800093915668e-16
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0388243828581744e-16
+// mean(f - f_Boost): 3.8580250105724191e-16
+// variance(f - f_Boost): 6.4106456575047741e-31
+// stddev(f - f_Boost): 8.0066507713929764e-16
 const testcase_ellint_3<double>
 data176[10] =
 {
   { 0.0000000000000000, 0.80000000000000004, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17422361866118044, 0.80000000000000004, 0.50000000000000000, 
+  { 0.17599554153999472, 0.80000000000000004, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34681083254170475, 0.80000000000000004, 0.50000000000000000, 
+  { 0.36099426243351540, 0.80000000000000004, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.51709470815494440, 0.80000000000000004, 0.50000000000000000, 
+  { 0.56514786174780673, 0.80000000000000004, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.68587375344080237, 0.80000000000000004, 0.50000000000000000, 
+  { 0.80090697622371010, 0.80000000000000004, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.85532571852810624, 0.80000000000000004, 0.50000000000000000, 
+  { 1.0838891627679339, 0.80000000000000004, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 1.0284677391874903, 0.80000000000000004, 0.50000000000000000, 
+  { 1.4323506654466280, 0.80000000000000004, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.2081693942686225, 0.80000000000000004, 0.50000000000000000, 
+  { 1.8625761085390575, 0.80000000000000004, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.3955803006426311, 0.80000000000000004, 0.50000000000000000, 
+  { 2.3768757305654766, 0.80000000000000004, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.5884528947755532, 0.80000000000000004, 0.50000000000000000, 
+  { 2.9478781158239746, 0.80000000000000004, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler176 = 2.5000000000000020e-13;
 
-// Test data for k=0.80000000000000004, nu=0.59999999999999998.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3281408974056389e-16
+// Test data for k=0.80000000000000004, nu=0.60000000000000009.
+// max(|f - f_Boost|): 3.5527136788005009e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 1.0631099169042069e-15
+// mean(f - f_Boost): 4.8294701571194306e-16
+// variance(f - f_Boost): 1.1633910328160319e-30
+// stddev(f - f_Boost): 1.0786060600682865e-15
 const testcase_ellint_3<double>
 data177[10] =
 {
-  { 0.0000000000000000, 0.80000000000000004, 0.59999999999999998, 
+  { 0.0000000000000000, 0.80000000000000004, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17404991781414089, 0.80000000000000004, 0.59999999999999998, 
+  { 0.17617631684170665, 0.80000000000000004, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34549800443625167, 0.80000000000000004, 0.59999999999999998, 
+  { 0.36252934193666231, 0.80000000000000004, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.51302536167001545, 0.80000000000000004, 0.59999999999999998, 
+  { 0.57086932622945163, 0.80000000000000004, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.67717065003912236, 0.80000000000000004, 0.59999999999999998, 
+  { 0.81646796740150973, 0.80000000000000004, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.84011512421134416, 0.80000000000000004, 0.59999999999999998, 
+  { 1.1199552158519064, 0.80000000000000004, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 1.0049863847088740, 0.80000000000000004, 0.59999999999999998, 
+  { 1.5079766673336394, 0.80000000000000004, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.1748145941898920, 0.80000000000000004, 0.59999999999999998, 
+  { 2.0082747447038165, 0.80000000000000004, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.3510319699755071, 0.80000000000000004, 0.59999999999999998, 
+  { 2.6315146066775523, 0.80000000000000004, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.5319262547427865, 0.80000000000000004, 0.59999999999999998, 
+  { 3.3418121892288051, 0.80000000000000004, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler177 = 2.5000000000000020e-13;
 
-// Test data for k=0.80000000000000004, nu=0.69999999999999996.
-// max(|f - f_GSL|): 2.2204460492503131e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3618176466061808e-16
+// Test data for k=0.80000000000000004, nu=0.70000000000000007.
+// max(|f - f_Boost|): 2.2204460492503131e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.6544679145741375e-16
+// mean(f - f_Boost): 3.2751579226442120e-16
+// variance(f - f_Boost): 4.4236851331020672e-31
+// stddev(f - f_Boost): 6.6510789599147505e-16
 const testcase_ellint_3<double>
 data178[10] =
 {
-  { 0.0000000000000000, 0.80000000000000004, 0.69999999999999996, 
+  { 0.0000000000000000, 0.80000000000000004, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17387683562442199, 0.80000000000000004, 0.69999999999999996, 
+  { 0.17635776076721221, 0.80000000000000004, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34420254775101611, 0.80000000000000004, 0.69999999999999996, 
+  { 0.36408794649916976, 0.80000000000000004, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.50906439222143673, 0.80000000000000004, 0.69999999999999996, 
+  { 0.57679992290624138, 0.80000000000000004, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.66882693152688422, 0.80000000000000004, 0.69999999999999996, 
+  { 0.83312441418142813, 0.80000000000000004, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.82574792844091316, 0.80000000000000004, 0.69999999999999996, 
+  { 1.1603958891464856, 0.80000000000000004, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 0.98310431309490931, 0.80000000000000004, 0.69999999999999996, 
+  { 1.5982855143796213, 0.80000000000000004, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.1440884535113258, 0.80000000000000004, 0.69999999999999996, 
+  { 2.1962484408371821, 0.80000000000000004, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.3103743938952537, 0.80000000000000004, 0.69999999999999996, 
+  { 2.9873281786111869, 0.80000000000000004, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.4806912324625332, 0.80000000000000004, 0.69999999999999996, 
+  { 3.9268876980046397, 0.80000000000000004, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler178 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3951228558314112e-16
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 9.0176949165011079e-16
+// mean(f - f_Boost): 7.0499162063697436e-16
+// variance(f - f_Boost): 1.7230805408026989e-30
+// stddev(f - f_Boost): 1.3126616246400665e-15
 const testcase_ellint_3<double>
 data179[10] =
 {
   { 0.0000000000000000, 0.80000000000000004, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17370436817515203, 0.80000000000000004, 0.80000000000000004, 
+  { 0.17653987774203392, 0.80000000000000004, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34292405894783395, 0.80000000000000004, 0.80000000000000004, 
+  { 0.36567072568046877, 0.80000000000000004, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.50520682176250076, 0.80000000000000004, 0.80000000000000004, 
+  { 0.58295359996558616, 0.80000000000000004, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.66081751679736178, 0.80000000000000004, 0.80000000000000004, 
+  { 0.85101998309176108, 0.80000000000000004, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.81214672249355102, 0.80000000000000004, 0.80000000000000004, 
+  { 1.2062322059736537, 0.80000000000000004, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 0.96264481387685552, 0.80000000000000004, 0.80000000000000004, 
+  { 1.7090321420917429, 0.80000000000000004, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.1156611352656258, 0.80000000000000004, 0.80000000000000004, 
+  { 2.4529058049405066, 0.80000000000000004, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.2730756225143889, 0.80000000000000004, 0.80000000000000004, 
+  { 3.5368893360106948, 0.80000000000000004, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.4339837018309471, 0.80000000000000004, 0.80000000000000004, 
+  { 4.9246422058196062, 0.80000000000000004, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler179 = 2.5000000000000020e-13;
 
 // Test data for k=0.80000000000000004, nu=0.90000000000000002.
-// max(|f - f_GSL|): 3.3306690738754696e-16
-// max(|f - f_GSL| / |f_GSL|): 4.4280684534289690e-16
+// max(|f - f_Boost|): 4.4408920985006262e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 7.7782721357365268e-16
+// mean(f - f_Boost): 8.9928064994637676e-16
+// variance(f - f_Boost): 1.5485199571025344e-30
+// stddev(f - f_Boost): 1.2443954183066307e-15
 const testcase_ellint_3<double>
 data180[10] =
 {
   { 0.0000000000000000, 0.80000000000000004, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17353251158533151, 0.80000000000000004, 0.90000000000000002, 
+  { 0.17672267223433513, 0.80000000000000004, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.34166214791545768, 0.80000000000000004, 0.90000000000000002, 
+  { 0.36727835537196063, 0.80000000000000004, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.50144799535130569, 0.80000000000000004, 0.90000000000000002, 
+  { 0.58934569363716649, 0.80000000000000004, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.65311976193814425, 0.80000000000000004, 0.90000000000000002, 
+  { 0.87032723471138851, 0.80000000000000004, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.79924384892320866, 0.80000000000000004, 0.90000000000000002, 
+  { 1.2588676111323349, 0.80000000000000004, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.94345762353365603, 0.80000000000000004, 0.90000000000000002, 
+  { 1.8498731900660019, 0.80000000000000004, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 1.0892582069219161, 0.80000000000000004, 0.90000000000000002, 
+  { 2.8368381299300420, 0.80000000000000004, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.2387000876610268, 0.80000000000000004, 0.90000000000000002, 
+  { 4.5674844191654058, 0.80000000000000004, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.3911845406776222, 0.80000000000000004, 0.90000000000000002, 
+  { 7.2263259298637115, 0.80000000000000004, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler180 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.0000000000000000.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8945813740035884e-16
+// Test data for k=0.90000000000000013, nu=0.0000000000000000.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.3381508715713360e-16
+// mean(f - f_Boost): 5.8286708792820721e-17
+// variance(f - f_Boost): 4.1942474344433133e-34
+// stddev(f - f_Boost): 2.0479861900030756e-17
 const testcase_ellint_3<double>
 data181[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.0000000000000000, 
+  { 0.0000000000000000, 0.90000000000000013, 0.0000000000000000, 
 	  0.0000000000000000 },
-  { 0.17525427376115024, 0.89999999999999991, 0.0000000000000000, 
+  { 0.17525427376115027, 0.90000000000000013, 0.0000000000000000, 
 	  0.17453292519943295 },
-  { 0.35492464591297446, 0.89999999999999991, 0.0000000000000000, 
+  { 0.35492464591297446, 0.90000000000000013, 0.0000000000000000, 
 	  0.34906585039886590 },
-  { 0.54388221416157112, 0.89999999999999991, 0.0000000000000000, 
+  { 0.54388221416157123, 0.90000000000000013, 0.0000000000000000, 
 	  0.52359877559829882 },
-  { 0.74797400423532490, 0.89999999999999991, 0.0000000000000000, 
+  { 0.74797400423532512, 0.90000000000000013, 0.0000000000000000, 
 	  0.69813170079773179 },
-  { 0.97463898451966458, 0.89999999999999991, 0.0000000000000000, 
+  { 0.97463898451966446, 0.90000000000000013, 0.0000000000000000, 
 	  0.87266462599716477 },
-  { 1.2334463254523440, 0.89999999999999991, 0.0000000000000000, 
+  { 1.2334463254523440, 0.90000000000000013, 0.0000000000000000, 
 	  1.0471975511965976 },
-  { 1.5355247765594910, 0.89999999999999991, 0.0000000000000000, 
+  { 1.5355247765594915, 0.90000000000000013, 0.0000000000000000, 
 	  1.2217304763960306 },
-  { 1.8882928567775117, 0.89999999999999991, 0.0000000000000000, 
+  { 1.8882928567775128, 0.90000000000000013, 0.0000000000000000, 
 	  1.3962634015954636 },
-  { 2.2805491384227703, 0.89999999999999991, 0.0000000000000000, 
+  { 2.2805491384227707, 0.90000000000000013, 0.0000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler181 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.10000000000000001.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 4.1237990617685137e-16
+// Test data for k=0.90000000000000013, nu=0.10000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.1500594295134815e-16
+// mean(f - f_Boost): 9.1593399531575410e-17
+// variance(f - f_Boost): 1.0357223256482469e-33
+// stddev(f - f_Boost): 3.2182640128619758e-17
 const testcase_ellint_3<double>
 data182[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.10000000000000001, 
+  { 0.0000000000000000, 0.90000000000000013, 0.10000000000000001, 
 	  0.0000000000000000 },
-  { 0.17507714233254656, 0.89999999999999991, 0.10000000000000001, 
+  { 0.17543204932716244, 0.90000000000000013, 0.10000000000000001, 
 	  0.17453292519943295 },
-  { 0.35350932904326521, 0.89999999999999991, 0.10000000000000001, 
+  { 0.35636022898551184, 0.90000000000000013, 0.10000000000000001, 
 	  0.34906585039886590 },
-  { 0.53911129989870976, 0.89999999999999991, 0.10000000000000001, 
+  { 0.54880278898382595, 0.90000000000000013, 0.10000000000000001, 
 	  0.52359877559829882 },
-  { 0.73666644254508395, 0.89999999999999991, 0.10000000000000001, 
+  { 0.75988834774529268, 0.90000000000000013, 0.10000000000000001, 
 	  0.69813170079773179 },
-  { 0.95250736612100195, 0.89999999999999991, 0.10000000000000001, 
+  { 0.99853303003568117, 0.90000000000000013, 0.10000000000000001, 
 	  0.87266462599716477 },
-  { 1.1950199550905594, 0.89999999999999991, 0.10000000000000001, 
+  { 1.2759958823999022, 0.90000000000000013, 0.10000000000000001, 
 	  1.0471975511965976 },
-  { 1.4741687286340848, 0.89999999999999991, 0.10000000000000001, 
+  { 1.6051187364639401, 0.90000000000000013, 0.10000000000000001, 
 	  1.2217304763960306 },
-  { 1.7968678183506053, 0.89999999999999991, 0.10000000000000001, 
+  { 1.9941406879519474, 0.90000000000000013, 0.10000000000000001, 
 	  1.3962634015954636 },
-  { 2.1537868513875287, 0.89999999999999991, 0.10000000000000001, 
+  { 2.4295011187834890, 0.90000000000000013, 0.10000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler182 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.20000000000000001.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3446165733924066e-16
+// Test data for k=0.90000000000000013, nu=0.20000000000000001.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.9533518431433547e-16
+// mean(f - f_Boost): 1.0269562977782698e-16
+// variance(f - f_Boost): 1.4388836606733082e-32
+// stddev(f - f_Boost): 1.1995347684303728e-16
 const testcase_ellint_3<double>
 data183[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.20000000000000001, 
+  { 0.0000000000000000, 0.90000000000000013, 0.20000000000000001, 
 	  0.0000000000000000 },
-  { 0.17490065089140927, 0.89999999999999991, 0.20000000000000001, 
+  { 0.17561047321968409, 0.90000000000000013, 0.20000000000000001, 
 	  0.17453292519943295 },
-  { 0.35211377590661436, 0.89999999999999991, 0.20000000000000001, 
+  { 0.35781659944356109, 0.90000000000000013, 0.20000000000000001, 
 	  0.34906585039886590 },
-  { 0.53448220334204100, 0.89999999999999991, 0.20000000000000001, 
+  { 0.55388150905215283, 0.90000000000000013, 0.20000000000000001, 
 	  0.52359877559829882 },
-  { 0.72591368943179579, 0.89999999999999991, 0.20000000000000001, 
+  { 0.77246874123251441, 0.90000000000000013, 0.20000000000000001, 
 	  0.69813170079773179 },
-  { 0.93192539780038763, 0.89999999999999991, 0.20000000000000001, 
+  { 1.0244466254771925, 0.90000000000000013, 0.20000000000000001, 
 	  0.87266462599716477 },
-  { 1.1600809679692683, 0.89999999999999991, 0.20000000000000001, 
+  { 1.3234824077640801, 0.90000000000000013, 0.20000000000000001, 
 	  1.0471975511965976 },
-  { 1.4195407225882508, 0.89999999999999991, 0.20000000000000001, 
+  { 1.6849848968804240, 0.90000000000000013, 0.20000000000000001, 
 	  1.2217304763960306 },
-  { 1.7168966476424521, 0.89999999999999991, 0.20000000000000001, 
+  { 2.1185749045502278, 0.90000000000000013, 0.20000000000000001, 
 	  1.3962634015954636 },
-  { 2.0443194576468895, 0.89999999999999991, 0.20000000000000001, 
+  { 2.6076835743348417, 0.90000000000000013, 0.20000000000000001, 
 	  1.5707963267948966 },
 };
 const double toler183 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.29999999999999999.
-// max(|f - f_GSL|): 1.1102230246251565e-15
-// max(|f - f_GSL| / |f_GSL|): 5.6974600067013622e-16
+// Test data for k=0.90000000000000013, nu=0.30000000000000004.
+// max(|f - f_Boost|): 6.6613381477509392e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 3.9712691025502371e-16
+// mean(f - f_Boost): 6.9388939039072284e-17
+// variance(f - f_Boost): 5.9442282234173945e-34
+// stddev(f - f_Boost): 2.4380787976227090e-17
 const testcase_ellint_3<double>
 data184[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.29999999999999999, 
+  { 0.0000000000000000, 0.90000000000000013, 0.30000000000000004, 
 	  0.0000000000000000 },
-  { 0.17472479532647531, 0.89999999999999991, 0.29999999999999999, 
+  { 0.17578954966746221, 0.90000000000000013, 0.30000000000000004, 
 	  0.17453292519943295 },
-  { 0.35073750187374114, 0.89999999999999991, 0.29999999999999999, 
+  { 0.35929429810867447, 0.90000000000000013, 0.30000000000000004, 
 	  0.34906585039886590 },
-  { 0.52998766129466957, 0.89999999999999991, 0.29999999999999999, 
+  { 0.55912757154240822, 0.90000000000000013, 0.30000000000000004, 
 	  0.52359877559829882 },
-  { 0.71566993548699553, 0.89999999999999991, 0.29999999999999999, 
+  { 0.78578314722025389, 0.90000000000000013, 0.30000000000000004, 
 	  0.69813170079773179 },
-  { 0.91271517762560195, 0.89999999999999991, 0.29999999999999999, 
+  { 1.0526941001131365, 0.90000000000000013, 0.30000000000000004, 
 	  0.87266462599716477 },
-  { 1.1281241199843370, 0.89999999999999991, 0.29999999999999999, 
+  { 1.3769682234538601, 0.90000000000000013, 0.30000000000000004, 
 	  1.0471975511965976 },
-  { 1.3704929576917448, 0.89999999999999991, 0.29999999999999999, 
+  { 1.7779437432911240, 0.90000000000000013, 0.30000000000000004, 
 	  1.2217304763960306 },
-  { 1.6461981511487711, 0.89999999999999991, 0.29999999999999999, 
+  { 2.2676509341813635, 0.90000000000000013, 0.30000000000000004, 
 	  1.3962634015954636 },
-  { 1.9486280260314426, 0.89999999999999991, 0.29999999999999999, 
+  { 2.8256506968858517, 0.90000000000000013, 0.30000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler184 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.40000000000000002.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 4.7646208744449464e-16
+// Test data for k=0.90000000000000013, nu=0.40000000000000002.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.7042235432234642e-16
+// mean(f - f_Boost): 1.8041124150158794e-16
+// variance(f - f_Boost): 8.5834655546147173e-33
+// stddev(f - f_Boost): 9.2646994309662939e-17
 const testcase_ellint_3<double>
 data185[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.40000000000000002, 
+  { 0.0000000000000000, 0.90000000000000013, 0.40000000000000002, 
 	  0.0000000000000000 },
-  { 0.17454957156468837, 0.89999999999999991, 0.40000000000000002, 
+  { 0.17596928293938452, 0.90000000000000013, 0.40000000000000002, 
 	  0.17453292519943295 },
-  { 0.34938003933330430, 0.89999999999999991, 0.40000000000000002, 
+  { 0.36079388642472821, 0.90000000000000013, 0.40000000000000002, 
 	  0.34906585039886590 },
-  { 0.52562093533067433, 0.89999999999999991, 0.40000000000000002, 
+  { 0.56455096667115612, 0.90000000000000013, 0.40000000000000002, 
 	  0.52359877559829882 },
-  { 0.70589461324915670, 0.89999999999999991, 0.40000000000000002, 
+  { 0.79990996997869435, 0.90000000000000013, 0.40000000000000002, 
 	  0.69813170079773179 },
-  { 0.89472658511942849, 0.89999999999999991, 0.40000000000000002, 
+  { 1.0836647913872215, 0.90000000000000013, 0.40000000000000002, 
 	  0.87266462599716477 },
-  { 1.0987419542323440, 0.89999999999999991, 0.40000000000000002, 
+  { 1.4378726836091849, 0.90000000000000013, 0.40000000000000002, 
 	  1.0471975511965976 },
-  { 1.3261349565496301, 0.89999999999999991, 0.40000000000000002, 
+  { 1.8880446720682853, 0.90000000000000013, 0.40000000000000002, 
 	  1.2217304763960306 },
-  { 1.5831293909853763, 0.89999999999999991, 0.40000000000000002, 
+  { 2.4505848932025232, 0.90000000000000013, 0.40000000000000002, 
 	  1.3962634015954636 },
-  { 1.8641114227238351, 0.89999999999999991, 0.40000000000000002, 
+  { 3.1000689868578624, 0.90000000000000013, 0.40000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler185 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.50000000000000000.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 4.9652155758573562e-16
+// Test data for k=0.90000000000000013, nu=0.50000000000000000.
+// max(|f - f_Boost|): 8.8817841970012523e-16 at index 7
+// max(|f - f_Boost| / |f_Boost|): 4.3939646155354115e-16
+// mean(f - f_Boost): 1.5820678100908481e-16
+// variance(f - f_Boost): 1.0089970755557622e-32
+// stddev(f - f_Boost): 1.0044884646205561e-16
 const testcase_ellint_3<double>
 data186[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.50000000000000000, 
+  { 0.0000000000000000, 0.90000000000000013, 0.50000000000000000, 
 	  0.0000000000000000 },
-  { 0.17437497557073334, 0.89999999999999991, 0.50000000000000000, 
+  { 0.17614967734498183, 0.90000000000000013, 0.50000000000000000, 
 	  0.17453292519943295 },
-  { 0.34804093691586013, 0.89999999999999991, 0.50000000000000000, 
+  { 0.36231594750319435, 0.90000000000000013, 0.50000000000000000, 
 	  0.34906585039886590 },
-  { 0.52137576320372891, 0.89999999999999991, 0.50000000000000000, 
+  { 0.57016256984349567, 0.90000000000000013, 0.50000000000000000, 
 	  0.52359877559829882 },
-  { 0.69655163996912262, 0.89999999999999991, 0.50000000000000000, 
+  { 0.81494025918293422, 0.90000000000000013, 0.50000000000000000, 
 	  0.69813170079773179 },
-  { 0.87783188683054236, 0.89999999999999991, 0.50000000000000000, 
+  { 1.1178482279283477, 0.90000000000000013, 0.50000000000000000, 
 	  0.87266462599716477 },
-  { 1.0716015959755185, 0.89999999999999991, 0.50000000000000000, 
+  { 1.5081455873012106, 0.90000000000000013, 0.50000000000000000, 
 	  1.0471975511965976 },
-  { 1.2857636916026749, 0.89999999999999991, 0.50000000000000000, 
+  { 2.0213599730863998, 0.90000000000000013, 0.50000000000000000, 
 	  1.2217304763960306 },
-  { 1.5264263913252358, 0.89999999999999991, 0.50000000000000000, 
+  { 2.6822467012926832, 0.90000000000000013, 0.50000000000000000, 
 	  1.3962634015954636 },
-  { 1.7888013241937863, 0.89999999999999991, 0.50000000000000000, 
+  { 3.4591069002104686, 0.90000000000000013, 0.50000000000000000, 
 	  1.5707963267948966 },
 };
 const double toler186 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.59999999999999998.
-// max(|f - f_GSL|): 6.6613381477509392e-16
-// max(|f - f_GSL| / |f_GSL|): 3.8702201113622378e-16
+// Test data for k=0.90000000000000013, nu=0.60000000000000009.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 4.4914274070443813e-16
+// mean(f - f_Boost): 3.4694469519536142e-16
+// variance(f - f_Boost): 2.5224926888894056e-31
+// stddev(f - f_Boost): 5.0224423231027804e-16
 const testcase_ellint_3<double>
 data187[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.59999999999999998, 
+  { 0.0000000000000000, 0.90000000000000013, 0.60000000000000009, 
 	  0.0000000000000000 },
-  { 0.17420100334657812, 0.89999999999999991, 0.59999999999999998, 
+  { 0.17633073723493825, 0.90000000000000013, 0.60000000000000009, 
 	  0.17453292519943295 },
-  { 0.34671975876122157, 0.89999999999999991, 0.59999999999999998, 
+  { 0.36386108723492810, 0.90000000000000013, 0.60000000000000009, 
 	  0.34906585039886590 },
-  { 0.51724631570707946, 0.89999999999999991, 0.59999999999999998, 
+  { 0.57597424744716241, 0.90000000000000013, 0.60000000000000009, 
 	  0.52359877559829882 },
-  { 0.68760879113743023, 0.89999999999999991, 0.59999999999999998, 
+  { 0.83098051948501150, 0.90000000000000013, 0.60000000000000009, 
 	  0.69813170079773179 },
-  { 0.86192157779698364, 0.89999999999999991, 0.59999999999999998, 
+  { 1.1558706545698916, 0.90000000000000013, 0.60000000000000009, 
 	  0.87266462599716477 },
-  { 1.0464279696166354, 0.89999999999999991, 0.59999999999999998, 
+  { 1.5905576379415669, 0.90000000000000013, 0.60000000000000009, 
 	  1.0471975511965976 },
-  { 1.2488156247094004, 0.89999999999999991, 0.59999999999999998, 
+  { 2.1875186010215084, 0.90000000000000013, 0.60000000000000009, 
 	  1.2217304763960306 },
-  { 1.4750988777188470, 0.89999999999999991, 0.59999999999999998, 
+  { 2.9885767771316853, 0.90000000000000013, 0.60000000000000009, 
 	  1.3962634015954636 },
-  { 1.7211781128919525, 0.89999999999999991, 0.59999999999999998, 
+  { 3.9549939883570238, 0.90000000000000013, 0.60000000000000009, 
 	  1.5707963267948966 },
 };
 const double toler187 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.69999999999999996.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 4.3410843563834748e-16
+// Test data for k=0.90000000000000013, nu=0.70000000000000007.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 9
+// max(|f - f_Boost| / |f_Boost|): 5.5442489886293633e-16
+// mean(f - f_Boost): 4.3576253716537392e-16
+// variance(f - f_Boost): 2.2187568928205130e-31
+// stddev(f - f_Boost): 4.7103682370070737e-16
 const testcase_ellint_3<double>
 data188[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.69999999999999996, 
+  { 0.0000000000000000, 0.90000000000000013, 0.70000000000000007, 
 	  0.0000000000000000 },
-  { 0.17402765093102207, 0.89999999999999991, 0.69999999999999996, 
+  { 0.17651246700160939, 0.90000000000000013, 0.70000000000000007, 
 	  0.17453292519943295 },
-  { 0.34541608382635131, 0.89999999999999991, 0.69999999999999996, 
+  { 0.36542993547358982, 0.90000000000000013, 0.70000000000000007, 
 	  0.34906585039886590 },
-  { 0.51322715827061682, 0.89999999999999991, 0.69999999999999996, 
+  { 0.58199897877674867, 0.90000000000000013, 0.70000000000000007, 
 	  0.52359877559829882 },
-  { 0.67903717872440272, 0.89999999999999991, 0.69999999999999996, 
+  { 0.84815633587352857, 0.90000000000000013, 0.70000000000000007, 
 	  0.69813170079773179 },
-  { 0.84690113601682671, 0.89999999999999991, 0.69999999999999996, 
+  { 1.1985495623872375, 0.90000000000000013, 0.70000000000000007, 
 	  0.87266462599716477 },
-  { 1.0229914311548418, 0.89999999999999991, 0.69999999999999996, 
+  { 1.6892158134027691, 0.90000000000000013, 0.70000000000000007, 
 	  1.0471975511965976 },
-  { 1.2148329639709381, 0.89999999999999991, 0.69999999999999996, 
+  { 2.4029722191094236, 0.90000000000000013, 0.70000000000000007, 
 	  1.2217304763960306 },
-  { 1.4283586501307799, 0.89999999999999991, 0.69999999999999996, 
+  { 3.4201084941340061, 0.90000000000000013, 0.70000000000000007, 
 	  1.3962634015954636 },
-  { 1.6600480747670940, 0.89999999999999991, 0.69999999999999996, 
+  { 4.6985482312992444, 0.90000000000000013, 0.70000000000000007, 
 	  1.5707963267948966 },
 };
 const double toler188 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.80000000000000004.
-// max(|f - f_GSL|): 4.4408920985006262e-16
-// max(|f - f_GSL| / |f_GSL|): 3.3100928058463168e-16
+// Test data for k=0.90000000000000013, nu=0.80000000000000004.
+// max(|f - f_Boost|): 1.7763568394002505e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.9362432595976420e-16
+// mean(f - f_Boost): 3.0531133177191805e-16
+// variance(f - f_Boost): 1.1508025840536076e-32
+// stddev(f - f_Boost): 1.0727546709539920e-16
 const testcase_ellint_3<double>
 data189[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.80000000000000004, 
+  { 0.0000000000000000, 0.90000000000000013, 0.80000000000000004, 
 	  0.0000000000000000 },
-  { 0.17385491439925146, 0.89999999999999991, 0.80000000000000004, 
+  { 0.17669487107954862, 0.90000000000000013, 0.80000000000000004, 
 	  0.17453292519943295 },
-  { 0.34412950523113928, 0.89999999999999991, 0.80000000000000004, 
+  { 0.36702314729628421, 0.90000000000000013, 0.80000000000000004, 
 	  0.34906585039886590 },
-  { 0.50931321668729590, 0.89999999999999991, 0.80000000000000004, 
+  { 0.58825099711365492, 0.90000000000000013, 0.80000000000000004, 
 	  0.52359877559829882 },
-  { 0.67081081392296327, 0.89999999999999991, 0.80000000000000004, 
+  { 0.86661711422209031, 0.90000000000000013, 0.80000000000000004, 
 	  0.69813170079773179 },
-  { 0.83268846097293259, 0.89999999999999991, 0.80000000000000004, 
+  { 1.2469779109884802, 0.90000000000000013, 0.80000000000000004, 
 	  0.87266462599716477 },
-  { 1.0010985015814027, 0.89999999999999991, 0.80000000000000004, 
+  { 1.8105469760531578, 0.90000000000000013, 0.80000000000000004, 
 	  1.0471975511965976 },
-  { 1.1834394045489678, 0.89999999999999991, 0.80000000000000004, 
+  { 2.6989505165893752, 0.90000000000000013, 0.80000000000000004, 
 	  1.2217304763960306 },
-  { 1.3855695891683182, 0.89999999999999991, 0.80000000000000004, 
+  { 4.0935213267757433, 0.90000000000000013, 0.80000000000000004, 
 	  1.3962634015954636 },
-  { 1.6044591960982202, 0.89999999999999991, 0.80000000000000004, 
+  { 5.9820740813645727, 0.90000000000000013, 0.80000000000000004, 
 	  1.5707963267948966 },
 };
 const double toler189 = 2.5000000000000020e-13;
 
-// Test data for k=0.89999999999999991, nu=0.90000000000000002.
-// max(|f - f_GSL|): 8.8817841970012523e-16
-// max(|f - f_GSL| / |f_GSL|): 5.7167507456081732e-16
+// Test data for k=0.90000000000000013, nu=0.90000000000000002.
+// max(|f - f_Boost|): 2.6645352591003757e-15 at index 8
+// max(|f - f_Boost| / |f_Boost|): 4.9577148062669782e-16
+// mean(f - f_Boost): 5.9119376061289588e-16
+// variance(f - f_Boost): 1.7340883003959522e-31
+// stddev(f - f_Boost): 4.1642385863395872e-16
 const testcase_ellint_3<double>
 data190[10] =
 {
-  { 0.0000000000000000, 0.89999999999999991, 0.90000000000000002, 
+  { 0.0000000000000000, 0.90000000000000013, 0.90000000000000002, 
 	  0.0000000000000000 },
-  { 0.17368278986240135, 0.89999999999999991, 0.90000000000000002, 
+  { 0.17687795394604169, 0.90000000000000013, 0.90000000000000002, 
 	  0.17453292519943295 },
-  { 0.34285962963961397, 0.89999999999999991, 0.90000000000000002, 
+  { 0.36864140434751286, 0.90000000000000013, 0.90000000000000002, 
 	  0.34906585039886590 },
-  { 0.50549974644993312, 0.89999999999999991, 0.90000000000000002, 
+  { 0.59474595366817051, 0.90000000000000013, 0.90000000000000002, 
 	  0.52359877559829882 },
-  { 0.66290623857720876, 0.89999999999999991, 0.90000000000000002, 
+  { 0.88654237226056665, 0.90000000000000013, 0.90000000000000002, 
 	  0.69813170079773179 },
-  { 0.81921183128847175, 0.89999999999999991, 0.90000000000000002, 
+  { 1.3026595810616726, 0.90000000000000013, 0.90000000000000002, 
 	  0.87266462599716477 },
-  { 0.98058481956066390, 0.89999999999999991, 0.90000000000000002, 
+  { 1.9653635459278080, 0.90000000000000013, 0.90000000000000002, 
 	  1.0471975511965976 },
-  { 1.1543223520473569, 0.89999999999999991, 0.90000000000000002, 
+  { 3.1451407527189468, 0.90000000000000013, 0.90000000000000002, 
 	  1.2217304763960306 },
-  { 1.3462119782292934, 0.89999999999999991, 0.90000000000000002, 
+  { 5.3745230680316132, 0.90000000000000013, 0.90000000000000002, 
 	  1.3962634015954636 },
-  { 1.5536420236310948, 0.89999999999999991, 0.90000000000000002, 
+  { 8.9942562031858717, 0.90000000000000013, 0.90000000000000002, 
 	  1.5707963267948966 },
 };
 const double toler190 = 2.5000000000000020e-13;
 
-template<typename Tp, unsigned int Num>
+template<typename Ret, unsigned int Num>
   void
-  test(const testcase_ellint_3<Tp> (&data)[Num], Tp toler)
+  test(const testcase_ellint_3<Ret> (&data)[Num], Ret toler)
   {
-    const Tp eps = std::numeric_limits<Tp>::epsilon();
-    Tp max_abs_diff = -Tp(1);
-    Tp max_abs_frac = -Tp(1);
+    bool test __attribute__((unused)) = true;
+    const Ret eps = std::numeric_limits<Ret>::epsilon();
+    Ret max_abs_diff = -Ret(1);
+    Ret max_abs_frac = -Ret(1);
     unsigned int num_datum = Num;
     for (unsigned int i = 0; i < num_datum; ++i)
   	 {
-	const Tp f = std::ellint_3(data[i].k, data[i].nu,
+	const Ret f = std::ellint_3(data[i].k, data[i].nu,
 		     data[i].phi);
-	const Tp f0 = data[i].f0;
-	const Tp diff = f - f0;
+	const Ret f0 = data[i].f0;
+	const Ret diff = f - f0;
 	if (std::abs(diff) > max_abs_diff)
 	  max_abs_diff = std::abs(diff);
-	if (std::abs(f0) > Tp(10) * eps
-	 && std::abs(f) > Tp(10) * eps)
+	if (std::abs(f0) > Ret(10) * eps
+	 && std::abs(f) > Ret(10) * eps)
 	  {
-	    const Tp frac = diff / f0;
+	    const Ret frac = diff / f0;
 	    if (std::abs(frac) > max_abs_frac)
 	      max_abs_frac = std::abs(frac);
 	  }
Index: libstdc++-v3/testsuite/23_containers/set/modifiers/node_swap.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/23_containers/set/modifiers/node_swap.cc b/libstdc++-v3/testsuite/23_containers/set/modifiers/node_swap.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/23_containers/set/modifiers/node_swap.cc	(revision 262353)
@@ -0,0 +1,48 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++1z } }
+
+#include <set>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  // PR libstdc++/82966
+  std::set<int>::node_type n1, n2;
+  n1.swap(n2);
+  VERIFY( n1.empty() );
+  VERIFY( n2.empty() );
+}
+
+void
+test02()
+{
+  std::set<int> s{1, 2};
+  std::set<int>::node_type n1 = s.extract(1), n2;
+  swap(n1, n2);
+  VERIFY( n1.empty() );
+  VERIFY( !n2.empty() );
+}
+
+int main()
+{
+  test01();
+  test02();
+}
Index: libstdc++-v3/testsuite/27_io/ios_base/storage/2.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/27_io/ios_base/storage/2.cc b/libstdc++-v3/testsuite/27_io/ios_base/storage/2.cc
--- a/libstdc++-v3/testsuite/27_io/ios_base/storage/2.cc	(revision 262353)
+++ b/libstdc++-v3/testsuite/27_io/ios_base/storage/2.cc	(revision 262353)
@@ -50,18 +50,11 @@
   ios.pword(1) = v;
   VERIFY( ios.pword(1) == v );
 
-  // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
   try
     {
       v = ios.pword(max);
     }
-  catch(exception_type&)
+  catch(std::ios_base::failure&)
     {
       // Ok.
       VERIFY( ios.bad() );
@@ -80,7 +73,7 @@
     {
       v = ios.pword(std::numeric_limits<int>::max());
     }
-  catch(exception_type&)
+  catch(std::ios_base::failure&)
     {
       // Ok.
       VERIFY( ios.bad() );
@@ -99,7 +92,7 @@
     {
       l = ios.iword(max);
     }
-  catch(exception_type&)
+  catch(std::ios_base::failure&)
     {
       // Ok.
       VERIFY( ios.bad() );
@@ -118,7 +111,7 @@
     {
       l = ios.iword(std::numeric_limits<int>::max());
     }
-  catch(exception_type&)
+  catch(std::ios_base::failure&)
     {
       // Ok.
       VERIFY( ios.bad() );
Index: libstdc++-v3/testsuite/27_io/ios_base/failure/dual_abi.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/27_io/ios_base/failure/dual_abi.cc b/libstdc++-v3/testsuite/27_io/ios_base/failure/dual_abi.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/27_io/ios_base/failure/dual_abi.cc	(revision 262353)
@@ -0,0 +1,99 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-D_GLIBCXX_USE_CXX11_ABI=0" }
+// { dg-do run { target c++11 } }
+
+#include <fstream>
+#include <system_error>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  using std::ios;
+  bool caught_ios_failure = false;
+  bool rethrown = false;
+  bool caught_system_error = false;
+  try {
+    std::ifstream f;
+    f.exceptions(ios::failbit | ios::badbit | ios::eofbit);
+    try {
+      f.get();
+    }
+    catch (const ios::failure&) // catch as old ABI type
+    {
+      caught_ios_failure = true;
+#if _GLIBCXX_USE_DUAL_ABI || _GLIBCXX_USE_CXX11_ABI == 1
+      rethrown = true;
+      throw; // re-throw, to catch as new ABI type
+#endif
+    }
+  }
+  catch (const std::system_error& e)
+  {
+    caught_system_error = true;
+  }
+
+  VERIFY( caught_ios_failure );
+  if (rethrown)
+    VERIFY( caught_system_error );
+}
+
+void
+test02()
+{
+  using std::ios;
+  const std::exception* p = nullptr;
+  bool caught_ios_failure = false;
+  bool caught_exception = false;
+  try {
+    std::ifstream f;
+    f.exceptions(ios::failbit | ios::badbit | ios::eofbit);
+    try {
+      f.get();
+    }
+    catch (const std::exception& e1)
+    {
+      caught_exception = true;
+      p = &e1;
+      throw;
+    }
+  }
+  catch (const ios::failure& e2)
+  {
+    caught_ios_failure = true;
+#if _GLIBCXX_USE_DUAL_ABI
+    // If the Dual ABI is active the library throws the new type,
+    // so e1 was an object of that new type and so &e1 != &e2.
+    VERIFY( p != &e2 );
+#else
+    // Otherwise there's only one type of ios::failure, so &e1 == &e2.
+    VERIFY( p == &e2 );
+#endif
+  }
+
+  VERIFY( caught_exception );
+  VERIFY( caught_ios_failure );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
Index: libstdc++-v3/testsuite/27_io/basic_ios/copyfmt/char/1.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/27_io/basic_ios/copyfmt/char/1.cc b/libstdc++-v3/testsuite/27_io/basic_ios/copyfmt/char/1.cc
--- a/libstdc++-v3/testsuite/27_io/basic_ios/copyfmt/char/1.cc	(revision 262353)
+++ b/libstdc++-v3/testsuite/27_io/basic_ios/copyfmt/char/1.cc	(revision 262353)
@@ -46,13 +46,6 @@
   }
 
   {
-    // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
     std::ios ios_01(0);
     std::ios ios_02(0);
     ios_01.clear(std::ios_base::eofbit);
@@ -62,7 +55,7 @@
       ios_01.copyfmt(ios_02);
       VERIFY( false );
     }
-    catch(exception_type&) {
+    catch(std::ios_base::failure&) {
       VERIFY( true );
     }
     catch(...) {
Index: libstdc++-v3/testsuite/27_io/basic_ios/exceptions/char/1.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/27_io/basic_ios/exceptions/char/1.cc b/libstdc++-v3/testsuite/27_io/basic_ios/exceptions/char/1.cc
--- a/libstdc++-v3/testsuite/27_io/basic_ios/exceptions/char/1.cc	(revision 262353)
+++ b/libstdc++-v3/testsuite/27_io/basic_ios/exceptions/char/1.cc	(revision 262353)
@@ -50,13 +50,6 @@
   }
 
   {
-    // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
     std::ios ios_01(0);
     ios_01.clear(std::ios_base::eofbit);
     try {
@@ -63,7 +56,7 @@
       ios_01.exceptions(std::ios_base::eofbit);
       VERIFY( false );
     }
-    catch(exception_type&) {
+    catch(std::ios_base::failure&) {
       iostate02 = ios_01.exceptions();
       VERIFY( static_cast<bool>(iostate02 & std::ios_base::eofbit) );
     }
Index: libstdc++-v3/testsuite/27_io/basic_istream/sentry/wchar_t/12297.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/27_io/basic_istream/sentry/wchar_t/12297.cc b/libstdc++-v3/testsuite/27_io/basic_istream/sentry/wchar_t/12297.cc
--- a/libstdc++-v3/testsuite/27_io/basic_istream/sentry/wchar_t/12297.cc	(revision 262353)
+++ b/libstdc++-v3/testsuite/27_io/basic_istream/sentry/wchar_t/12297.cc	(revision 262353)
@@ -26,19 +26,12 @@
   wistringstream stream;
   stream.exceptions(ios_base::eofbit);
 
-  // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
   try
     {
       wistream::sentry sentry(stream, false);
       VERIFY( false );
     }
-  catch (exception_type&)
+  catch (std::ios_base::failure&)
     {
       VERIFY( stream.rdstate() == (ios_base::eofbit | ios_base::failbit) );
     }
Index: libstdc++-v3/testsuite/27_io/basic_istream/sentry/char/12297.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/27_io/basic_istream/sentry/char/12297.cc b/libstdc++-v3/testsuite/27_io/basic_istream/sentry/char/12297.cc
--- a/libstdc++-v3/testsuite/27_io/basic_istream/sentry/char/12297.cc	(revision 262353)
+++ b/libstdc++-v3/testsuite/27_io/basic_istream/sentry/char/12297.cc	(revision 262353)
@@ -26,19 +26,12 @@
   istringstream stream;
   stream.exceptions(ios_base::eofbit);
 
-  // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
   try
     {
       istream::sentry sentry(stream, false);
       VERIFY( false );
     }
-  catch (exception_type&)
+  catch (std::ios_base::failure&)
     {
       VERIFY( stream.rdstate() == (ios_base::eofbit | ios_base::failbit) );
     }
Index: libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/wchar_t/exceptions_null.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/wchar_t/exceptions_null.cc b/libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/wchar_t/exceptions_null.cc
--- a/libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/wchar_t/exceptions_null.cc	(revision 262353)
+++ b/libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/wchar_t/exceptions_null.cc	(revision 262353)
@@ -35,19 +35,12 @@
   wistringstream stream;
   stream.exceptions(ios_base::failbit);
 
-  // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
   try
     {
       stream >> static_cast<wstreambuf*>(0);
       VERIFY( false );
     }
-  catch (exception_type&)
+  catch (std::ios_base::failure&)
     {
     }
 
Index: libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/char/exceptions_null.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/char/exceptions_null.cc b/libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/char/exceptions_null.cc
--- a/libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/char/exceptions_null.cc	(revision 262353)
+++ b/libstdc++-v3/testsuite/27_io/basic_istream/extractors_other/char/exceptions_null.cc	(revision 262353)
@@ -35,19 +35,12 @@
   istringstream stream;
   stream.exceptions(ios_base::failbit);
 
-  // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
   try
     {
       stream >> static_cast<streambuf*>(0);
       VERIFY(false);
     }
-  catch (exception_type&)
+  catch (std::ios_base::failure&)
     {
     }
 
Index: libstdc++-v3/testsuite/27_io/basic_istream/extractors_arithmetic/wchar_t/exceptions_failbit.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/27_io/basic_istream/extractors_arithmetic/wchar_t/exceptions_failbit.cc b/libstdc++-v3/testsuite/27_io/basic_istream/extractors_arithmetic/wchar_t/exceptions_failbit.cc
--- a/libstdc++-v3/testsuite/27_io/basic_istream/extractors_arithmetic/wchar_t/exceptions_failbit.cc	(revision 262353)
+++ b/libstdc++-v3/testsuite/27_io/basic_istream/extractors_arithmetic/wchar_t/exceptions_failbit.cc	(revision 262353)
@@ -27,13 +27,6 @@
   wistringstream stream(L"jaylib - champion sound");
   stream.exceptions(ios_base::failbit);
 
-  // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
   try
     {
       T i;
@@ -40,7 +33,7 @@
       stream >> i;
       VERIFY( false );
     }
-  catch (const exception_type&)
+  catch (const std::ios_base::failure&)
     {
       // stream should set failbit and throw ios_base::failure.
       VERIFY( stream.fail() );
Index: libstdc++-v3/testsuite/27_io/basic_istream/extractors_arithmetic/char/exceptions_failbit.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/27_io/basic_istream/extractors_arithmetic/char/exceptions_failbit.cc b/libstdc++-v3/testsuite/27_io/basic_istream/extractors_arithmetic/char/exceptions_failbit.cc
--- a/libstdc++-v3/testsuite/27_io/basic_istream/extractors_arithmetic/char/exceptions_failbit.cc	(revision 262353)
+++ b/libstdc++-v3/testsuite/27_io/basic_istream/extractors_arithmetic/char/exceptions_failbit.cc	(revision 262353)
@@ -27,13 +27,6 @@
   istringstream stream("jaylib - champion sound");
   stream.exceptions(ios_base::failbit);
 
-  // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
   try
     {
       T i;
@@ -40,7 +33,7 @@
       stream >> i;
       VERIFY( false );
     }
-  catch (const exception_type&)
+  catch (const std::ios_base::failure&)
     {
       // stream should set failbit and throw ios_base::failure.
       VERIFY( stream.fail() );
Index: libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/wchar_t/exceptions_null.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/wchar_t/exceptions_null.cc b/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/wchar_t/exceptions_null.cc
--- a/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/wchar_t/exceptions_null.cc	(revision 262353)
+++ b/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/wchar_t/exceptions_null.cc	(revision 262353)
@@ -37,19 +37,12 @@
   wostringstream stream;
   stream.exceptions(ios_base::badbit);
 
-  // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
   try
     {
       stream << static_cast<wstreambuf*>(0);
       VERIFY( false );
     }
-  catch (exception_type&)
+  catch (std::ios_base::failure&)
     {
     }
 
Index: libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/char/exceptions_null.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/char/exceptions_null.cc b/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/char/exceptions_null.cc
--- a/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/char/exceptions_null.cc	(revision 262353)
+++ b/libstdc++-v3/testsuite/27_io/basic_ostream/inserters_other/char/exceptions_null.cc	(revision 262353)
@@ -37,19 +37,12 @@
   ostringstream stream;
   stream.exceptions(ios_base::badbit);
 
-  // The library throws the new definition of std::ios::failure
-#if _GLIBCXX_USE_CXX11_ABI
-    typedef std::ios_base::failure exception_type;
-#else
-    typedef std::exception exception_type;
-#endif
-
   try
     {
       stream << static_cast<streambuf*>(0);
       VERIFY( false );
     }
-  catch (exception_type&)
+  catch (std::ios_base::failure&)
     {
     }
 
Index: libstdc++-v3/testsuite/21_strings/basic_string/operations/data/char/86169.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/operations/data/char/86169.cc b/libstdc++-v3/testsuite/21_strings/basic_string/operations/data/char/86169.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/operations/data/char/86169.cc	(revision 262353)
@@ -0,0 +1,37 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++1z } }
+
+// PR libstdc++/86169
+
+#ifndef _GLIBCXX_USE_CXX11_ABI
+# define _GLIBCXX_USE_CXX11_ABI 0
+#endif
+
+#include <string>
+#include <testsuite_hooks.h>
+
+int main()
+{
+  const std::string s0{"hello world"};
+  std::string s1 {s0};
+  char* p = s1.data();
+  *p = ' ';
+  VERIFY(s0.compare("hello world") == 0);
+}
Index: libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/86138.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/86138.cc b/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/86138.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/cons/wchar_t/86138.cc	(revision 262353)
@@ -0,0 +1,30 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do compile { target c++1z } }
+// { dg-final { scan-assembler-not "_ZNSbIwSt11char_traitsIwESaIwEE4_Rep20_S_empty_rep_storageE:" } }
+
+#undef _GLIBCXX_USE_CXX11_ABI
+#define _GLIBCXX_USE_CXX11_ABI 0
+#include <string>
+
+void
+test01(std::wstring* s)
+{
+  s->~basic_string();
+}
Index: libstdc++-v3/testsuite/21_strings/basic_string/cons/char/86138.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/86138.cc b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/86138.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/21_strings/basic_string/cons/char/86138.cc	(revision 262353)
@@ -0,0 +1,30 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do compile { target c++1z } }
+// { dg-final { scan-assembler-not "_ZNSs4_Rep20_S_empty_rep_storageE:" } }
+
+#undef _GLIBCXX_USE_CXX11_ABI
+#define _GLIBCXX_USE_CXX11_ABI 0
+#include <string>
+
+void
+test01(std::string* s)
+{
+  s->~basic_string();
+}
Index: libstdc++-v3/testsuite/26_numerics/random/chi_squared_distribution/83833.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/26_numerics/random/chi_squared_distribution/83833.cc b/libstdc++-v3/testsuite/26_numerics/random/chi_squared_distribution/83833.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/26_numerics/random/chi_squared_distribution/83833.cc	(revision 262353)
@@ -0,0 +1,40 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do run { target c++11 } }
+// { dg-additional-options "-ffloat-store" { target { m68*-*-* || ia32 } } }
+
+#include <random>
+#include <testsuite_hooks.h>
+
+void
+test01()
+{
+  std::default_random_engine r1, r2;
+  using chi = std::chi_squared_distribution<double>;
+  chi::param_type p(5);
+  chi d1(p);
+  chi d2;
+  d2.param(p);
+  VERIFY( d1(r1) == d2(r2) ); // PR libstdc++/83833
+}
+
+int
+main()
+{
+  test01();
+}
Index: libstdc++-v3/testsuite/experimental/memory_resource/resource_adaptor.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/experimental/memory_resource/resource_adaptor.cc b/libstdc++-v3/testsuite/experimental/memory_resource/resource_adaptor.cc
--- a/libstdc++-v3/testsuite/experimental/memory_resource/resource_adaptor.cc	(revision 262353)
+++ b/libstdc++-v3/testsuite/experimental/memory_resource/resource_adaptor.cc	(revision 262353)
@@ -1,4 +1,5 @@
 // { dg-do run { target c++14 } }
+// { dg-xfail-run-if "PR libstdc++/77691" { { i?86-*-solaris2.* x86_64-*-solaris2.* } && ilp32 } }
 
 // Copyright (C) 2016-2017 Free Software Foundation, Inc.
 //
Index: libstdc++-v3/testsuite/experimental/filesystem/operations/space.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/experimental/filesystem/operations/space.cc b/libstdc++-v3/testsuite/experimental/filesystem/operations/space.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/experimental/filesystem/operations/space.cc	(revision 262353)
@@ -0,0 +1,57 @@
+// Copyright (C) 2017-2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-DUSE_FILESYSTEM_TS -lstdc++fs" }
+// { dg-do run { target c++11 } }
+// { dg-require-filesystem-ts "" }
+
+// 30.10.14.3 Permissions [fs.op.space]
+
+#include <experimental/filesystem>
+#include <testsuite_fs.h>
+#include <testsuite_hooks.h>
+
+namespace fs = std::experimental::filesystem;
+
+void
+test01()
+{
+  fs::space_info s = fs::space("/");
+  std::error_code ec = make_error_code(std::errc::invalid_argument);
+  s = fs::space("/", ec);
+  VERIFY( !ec );
+
+  s = fs::space(__gnu_test::nonexistent_path(), ec);
+  VERIFY( ec );
+  VERIFY( s.capacity ==  static_cast<uintmax_t>(-1) );
+  VERIFY( s.free ==  static_cast<uintmax_t>(-1) );
+  VERIFY( s.available ==  static_cast<uintmax_t>(-1) );
+}
+
+void
+test02()
+{
+  fs::space_info s = fs::space(".");
+  VERIFY( s.capacity >= s.free );
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
Index: libstdc++-v3/testsuite/20_util/duration/literals/84671.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/20_util/duration/literals/84671.cc b/libstdc++-v3/testsuite/20_util/duration/literals/84671.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/20_util/duration/literals/84671.cc	(revision 262353)
@@ -0,0 +1,26 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-do compile { target c++14 } }
+
+#include <chrono>
+
+// PR libstdc++/84671
+using namespace std::literals::chrono_literals;
+constexpr auto ns_ok = 12113ns;
+constexpr auto ns_fail = 12'11'3ns;
+static_assert(ns_ok == ns_fail, "digit separators work in duration literals");
Index: libstdc++-v3/testsuite/20_util/any/modifiers/83658.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/20_util/any/modifiers/83658.cc b/libstdc++-v3/testsuite/20_util/any/modifiers/83658.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libstdc++-v3/testsuite/20_util/any/modifiers/83658.cc	(revision 262353)
@@ -0,0 +1,74 @@
+// Copyright (C) 2018 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 3, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING3.  If not see
+// <http://www.gnu.org/licenses/>.
+
+// { dg-options "-std=gnu++17" }
+// { dg-do run { target c++1z } }
+
+#include <any>
+#include <new>
+#include <testsuite_hooks.h>
+
+struct E : std::bad_alloc { };
+
+struct X
+{
+    X() = default;
+    X(std::initializer_list<int>) { }
+
+    // Prevents small-object optimization:
+    X(const X&) noexcept(false) { }
+
+    static void* operator new(std::size_t) { throw E{}; }
+    static void operator delete(void*, std::size_t) noexcept { }
+};
+
+void
+test01()
+{
+  std::any a;
+  try
+  {
+    a.emplace<X>();
+    VERIFY(false);
+  }
+  catch (const E&)
+  {
+    VERIFY( !a.has_value() );
+  }
+}
+
+void
+test02()
+{
+  std::any a;
+  try
+  {
+    a.emplace<X>(std::initializer_list<int>{});
+    VERIFY(false);
+  }
+  catch (const E&)
+  {
+    VERIFY( !a.has_value() );
+  }
+}
+
+int
+main()
+{
+  test01();
+  test02();
+}
Index: libstdc++-v3/testsuite/20_util/any/misc/any_cast_neg.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/20_util/any/misc/any_cast_neg.cc b/libstdc++-v3/testsuite/20_util/any/misc/any_cast_neg.cc
--- a/libstdc++-v3/testsuite/20_util/any/misc/any_cast_neg.cc	(revision 262353)
+++ b/libstdc++-v3/testsuite/20_util/any/misc/any_cast_neg.cc	(revision 262353)
@@ -26,5 +26,5 @@
   using std::any_cast;
 
   const any y(1);
-  any_cast<int&>(y); // { dg-error "invalid static_cast" "" { target { *-*-* } } 461 }
+  any_cast<int&>(y); // { dg-error "invalid static_cast" "" { target { *-*-* } } 460 }
 }
Index: libstdc++-v3/testsuite/20_util/has_unique_object_representations/value.cc
===================================================================
diff --git a/libstdc++-v3/testsuite/20_util/has_unique_object_representations/value.cc b/libstdc++-v3/testsuite/20_util/has_unique_object_representations/value.cc
--- a/libstdc++-v3/testsuite/20_util/has_unique_object_representations/value.cc	(revision 262353)
+++ b/libstdc++-v3/testsuite/20_util/has_unique_object_representations/value.cc	(revision 262353)
@@ -108,3 +108,17 @@
   static_assert(test_category<has_unique_object_representations,
 		Aligned[][1]>(false), "");
 }
+
+void
+test02()
+{
+  using std::has_unique_object_representations;
+  using std::has_unique_object_representations_v;
+
+  static_assert(has_unique_object_representations_v<int>
+		== has_unique_object_representations<int>::value);
+  static_assert(has_unique_object_representations_v<void>
+		== has_unique_object_representations<void>::value);
+  static_assert(has_unique_object_representations_v<float>
+		== has_unique_object_representations<float>::value);
+}
Index: libstdc++-v3/crossconfig.m4
===================================================================
diff --git a/libstdc++-v3/crossconfig.m4 b/libstdc++-v3/crossconfig.m4
--- a/libstdc++-v3/crossconfig.m4	(revision 262353)
+++ b/libstdc++-v3/crossconfig.m4	(revision 262353)
@@ -133,6 +133,7 @@
       AC_DEFINE(HAVE_ISNANL)
     fi
     AC_CHECK_FUNCS(__cxa_thread_atexit)
+    AC_CHECK_FUNCS(aligned_alloc posix_memalign memalign _aligned_malloc)
     ;;
 
   *-fuchsia*)
@@ -197,6 +198,7 @@
     GLIBCXX_CHECK_LINKER_FEATURES
     GLIBCXX_CHECK_MATH_SUPPORT
     GLIBCXX_CHECK_STDLIB_SUPPORT
+    AC_CHECK_FUNCS(aligned_alloc posix_memalign memalign _aligned_malloc)
     ;;
   *-netbsd*)
     SECTION_FLAGS='-ffunction-sections -fdata-sections'
Index: libstdc++-v3/config/abi/post/x86_64-linux-gnu/baseline_symbols.txt
===================================================================
diff --git a/libstdc++-v3/config/abi/post/x86_64-linux-gnu/baseline_symbols.txt b/libstdc++-v3/config/abi/post/x86_64-linux-gnu/baseline_symbols.txt
--- a/libstdc++-v3/config/abi/post/x86_64-linux-gnu/baseline_symbols.txt	(revision 262353)
+++ b/libstdc++-v3/config/abi/post/x86_64-linux-gnu/baseline_symbols.txt	(revision 262353)
@@ -4004,6 +4004,7 @@
 OBJECT:0:GLIBCXX_3.4.21
 OBJECT:0:GLIBCXX_3.4.22
 OBJECT:0:GLIBCXX_3.4.23
+OBJECT:0:GLIBCXX_3.4.24
 OBJECT:0:GLIBCXX_3.4.3
 OBJECT:0:GLIBCXX_3.4.4
 OBJECT:0:GLIBCXX_3.4.5
Index: ChangeLog
===================================================================
diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog	(revision 262353)
+++ b/ChangeLog	(revision 262353)
@@ -1,3 +1,11 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
Index: libatomic/configure
===================================================================
diff --git a/libatomic/configure b/libatomic/configure
--- a/libatomic/configure	(revision 262353)
+++ b/libatomic/configure	(revision 262353)
@@ -12333,6 +12333,7 @@
 
 
 
+
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for __atomic_load/store for size 2" >&5
 $as_echo_n "checking for __atomic_load/store for size 2... " >&6; }
 if test "${libat_cv_have_at_ldst_2+set}" = set; then :
@@ -12400,6 +12401,7 @@
 
 
 
+
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for __atomic_load/store for size 4" >&5
 $as_echo_n "checking for __atomic_load/store for size 4... " >&6; }
 if test "${libat_cv_have_at_ldst_4+set}" = set; then :
@@ -12467,6 +12469,7 @@
 
 
 
+
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for __atomic_load/store for size 8" >&5
 $as_echo_n "checking for __atomic_load/store for size 8... " >&6; }
 if test "${libat_cv_have_at_ldst_8+set}" = set; then :
@@ -12534,6 +12537,7 @@
 
 
 
+
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for __atomic_load/store for size 16" >&5
 $as_echo_n "checking for __atomic_load/store for size 16... " >&6; }
 if test "${libat_cv_have_at_ldst_16+set}" = set; then :
@@ -12602,6 +12606,7 @@
 
 
 
+
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking for __atomic_test_and_set for size 1" >&5
 $as_echo_n "checking for __atomic_test_and_set for size 1... " >&6; }
 if test "${libat_cv_have_at_tas_1+set}" = set; then :
@@ -15267,7 +15272,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
Index: libatomic/configure.tgt
===================================================================
diff --git a/libatomic/configure.tgt b/libatomic/configure.tgt
--- a/libatomic/configure.tgt	(revision 262353)
+++ b/libatomic/configure.tgt	(revision 262353)
@@ -114,6 +114,11 @@
 	config_path="${config_path} linux/arm posix"
 	;;
 
+  s390*-*-linux*)
+	# OS support for atomic primitives.
+	config_path="${config_path} s390 posix"
+	;;
+
   *-*-linux* | *-*-gnu* | *-*-k*bsd*-gnu \
   | *-*-netbsd* | *-*-freebsd* | *-*-openbsd* | *-*-dragonfly* \
   | *-*-solaris2* | *-*-sysv4* | *-*-irix6* | *-*-osf* | *-*-hpux11* \
Index: libatomic/ChangeLog
===================================================================
diff --git a/libatomic/ChangeLog b/libatomic/ChangeLog
--- a/libatomic/ChangeLog	(revision 262353)
+++ b/libatomic/ChangeLog	(revision 262353)
@@ -1,3 +1,19 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
+2018-03-09  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-03-09  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/exch_n.c: New file.
+	* configure.tgt: Add the config directory for s390.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
Index: libatomic/config/s390/exch_n.c
===================================================================
diff --git a/libatomic/config/s390/exch_n.c b/libatomic/config/s390/exch_n.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/libatomic/config/s390/exch_n.c	(revision 262353)
@@ -0,0 +1,69 @@
+/* Copyright (C) 2018 Free Software Foundation, Inc.
+   Contributed by Andreas Krebbel <krebbel@linux.vnet.ibm.com>
+
+   This file is part of the GNU Atomic Library (libatomic).
+
+   Libatomic is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   Libatomic is distributed in the hope that it will be useful, but WITHOUT ANY
+   WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+   FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+   more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <libatomic_i.h>
+
+
+/* The compiler builtin will use the hardware instruction cdsg if the
+   memory operand is properly aligned and will fall back to the
+   library call otherwise.
+
+   In case the compiler for one part is able to detect that the
+   location is aligned and fails to do so for another usage of the hw
+   instruction and the sw fall back would be mixed on the same memory
+   location.  To avoid this the library fall back also has to use the
+   hardware instruction if possible.  */
+
+#if !DONE && N == 16
+UTYPE
+SIZE(libat_exchange) (UTYPE *mptr, UTYPE newval, int smodel UNUSED)
+{
+  if (!((uintptr_t)mptr & 0xf))
+    {
+      /* Use the builtin only if the memory operand is 16 byte
+	 aligned.  */
+      return __atomic_exchange_n ((UTYPE *)__builtin_assume_aligned (mptr, 16),
+				  newval, __ATOMIC_SEQ_CST);
+    }
+  else
+    {
+      UTYPE oldval;
+      UWORD magic;
+
+      pre_seq_barrier (smodel);
+      magic = protect_start (mptr);
+
+      oldval = *mptr;
+      *mptr = newval;
+
+      protect_end (mptr, magic);
+      post_seq_barrier (smodel);
+
+      return oldval;
+    }
+}
+#define DONE 1
+#endif /* N == 16 */
+
+#include "../../exch_n.c"
Index: config/ChangeLog
===================================================================
diff --git a/config/ChangeLog b/config/ChangeLog
--- a/config/ChangeLog	(revision 262353)
+++ b/config/ChangeLog	(revision 262353)
@@ -1,3 +1,11 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* acx.m4 (GCC_BASE_VER): Remove \$\$ from sed expression.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
Index: config/acx.m4
===================================================================
diff --git a/config/acx.m4 b/config/acx.m4
--- a/config/acx.m4	(revision 262353)
+++ b/config/acx.m4	(revision 262353)
@@ -246,7 +246,7 @@
   [AS_HELP_STRING([--with-gcc-major-version-only], [use only GCC major number in filesystem paths])],
   [if test x$with_gcc_major_version_only = xyes ; then
     changequote(,)dnl
-    get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+    get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
     changequote([,])dnl
   fi
   ])
Index: configure
===================================================================
diff --git a/configure b/configure
--- a/configure	(revision 262353)
+++ b/configure	(revision 262353)
@@ -6620,7 +6620,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
Index: libgcc/ChangeLog
===================================================================
diff --git a/libgcc/ChangeLog b/libgcc/ChangeLog
--- a/libgcc/ChangeLog	(revision 262353)
+++ b/libgcc/ChangeLog	(revision 262353)
@@ -1,3 +1,54 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
+2018-06-22  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backport from mainline
+	2018-05-17  Jerome Lambourg  <lambourg@adacore.com>
+
+	* config/arm/cmse.c (cmse_check_address_range): Replace
+	UINTPTR_MAX with __UINTPTR_MAX__ and uintptr_t with __UINTPTR_TYPE__.
+
+2018-04-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-03-29  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/85100
+	* config/i386/cpuinfo.c (XCR_XFEATURE_ENABLED_MASK): New.
+	(XSTATE_FP): Likewise.
+	(XSTATE_SSE): Likewise.
+	(XSTATE_YMM): Likewise.
+	(XSTATE_OPMASK): Likewise.
+	(XSTATE_ZMM): Likewise.
+	(XSTATE_HI_ZMM): Likewise.
+	(XCR_AVX_ENABLED_MASK): Likewise.
+	(XCR_AVX512F_ENABLED_MASK): Likewise.
+	(get_available_features): Enable AVX and AVX512 features only
+	if their states are supported by OSXSAVE.
+
+2018-03-11  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2018-03-06  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/fptr.c (_dl_read_access_allowed): New.
+	(__canonicalize_funcptr_for_compare): Use it.
+	
+2018-02-20  Max Filippov  <jcmvbkbc@gmail.com>
+
+	Backport from mainline
+	2018-02-20  Max Filippov  <jcmvbkbc@gmail.com>
+
+	* config/xtensa/ieee754-df.S (__adddf3_aux): Add
+	.literal_position directive.
+	* config/xtensa/ieee754-sf.S (__addsf3_aux): Likewise.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
Index: libgcc/config/i386/cpuinfo.c
===================================================================
diff --git a/libgcc/config/i386/cpuinfo.c b/libgcc/config/i386/cpuinfo.c
--- a/libgcc/config/i386/cpuinfo.c	(revision 262353)
+++ b/libgcc/config/i386/cpuinfo.c	(revision 262353)
@@ -220,6 +220,40 @@
 
   unsigned int features = 0;
 
+  /* Get XCR_XFEATURE_ENABLED_MASK register with xgetbv.  */
+#define XCR_XFEATURE_ENABLED_MASK	0x0
+#define XSTATE_FP			0x1
+#define XSTATE_SSE			0x2
+#define XSTATE_YMM			0x4
+#define XSTATE_OPMASK			0x20
+#define XSTATE_ZMM			0x40
+#define XSTATE_HI_ZMM			0x80
+
+#define XCR_AVX_ENABLED_MASK \
+  (XSTATE_SSE | XSTATE_YMM)
+#define XCR_AVX512F_ENABLED_MASK \
+  (XSTATE_SSE | XSTATE_YMM | XSTATE_OPMASK | XSTATE_ZMM | XSTATE_HI_ZMM)
+
+  /* Check if AVX and AVX512 are usable.  */
+  int avx_usable = 0;
+  int avx512_usable = 0;
+  if ((ecx & bit_OSXSAVE))
+    {
+      /* Check if XMM, YMM, OPMASK, upper 256 bits of ZMM0-ZMM15 and
+         ZMM16-ZMM31 states are supported by OSXSAVE.  */
+      unsigned int xcrlow;
+      unsigned int xcrhigh;
+      asm (".byte 0x0f, 0x01, 0xd0"
+	   : "=a" (xcrlow), "=d" (xcrhigh)
+	   : "c" (XCR_XFEATURE_ENABLED_MASK));
+      if ((xcrlow & XCR_AVX_ENABLED_MASK) == XCR_AVX_ENABLED_MASK)
+	{
+	  avx_usable = 1;
+	  avx512_usable = ((xcrlow & XCR_AVX512F_ENABLED_MASK)
+			   == XCR_AVX512F_ENABLED_MASK);
+	}
+    }
+
   if (edx & bit_CMOV)
     features |= (1 << FEATURE_CMOV);
   if (edx & bit_MMX)
@@ -242,10 +276,13 @@
     features |= (1 << FEATURE_SSE4_1);
   if (ecx & bit_SSE4_2)
     features |= (1 << FEATURE_SSE4_2);
-  if (ecx & bit_AVX)
-    features |= (1 << FEATURE_AVX);
-  if (ecx & bit_FMA)
-    features |= (1 << FEATURE_FMA);
+  if (avx_usable)
+    {
+      if (ecx & bit_AVX)
+	features |= (1 << FEATURE_AVX);
+      if (ecx & bit_FMA)
+	features |= (1 << FEATURE_FMA);
+    }
 
   /* Get Advanced Features at level 7 (eax = 7, ecx = 0). */
   if (max_cpuid_level >= 7)
@@ -253,34 +290,40 @@
       __cpuid_count (7, 0, eax, ebx, ecx, edx);
       if (ebx & bit_BMI)
         features |= (1 << FEATURE_BMI);
-      if (ebx & bit_AVX2)
-	features |= (1 << FEATURE_AVX2);
+      if (avx_usable)
+	{
+	  if (ebx & bit_AVX2)
+	    features |= (1 << FEATURE_AVX2);
+	}
       if (ebx & bit_BMI2)
         features |= (1 << FEATURE_BMI2);
-      if (ebx & bit_AVX512F)
-	features |= (1 << FEATURE_AVX512F);
-      if (ebx & bit_AVX512VL)
-	features |= (1 << FEATURE_AVX512VL);
-      if (ebx & bit_AVX512BW)
-	features |= (1 << FEATURE_AVX512BW);
-      if (ebx & bit_AVX512DQ)
-	features |= (1 << FEATURE_AVX512DQ);
-      if (ebx & bit_AVX512CD)
-	features |= (1 << FEATURE_AVX512CD);
-      if (ebx & bit_AVX512PF)
-	features |= (1 << FEATURE_AVX512PF);
-      if (ebx & bit_AVX512ER)
-	features |= (1 << FEATURE_AVX512ER);
-      if (ebx & bit_AVX512IFMA)
-	features |= (1 << FEATURE_AVX512IFMA);
-      if (ecx & bit_AVX512VBMI)
-	features |= (1 << FEATURE_AVX512VBMI);
-      if (ecx & bit_AVX512VPOPCNTDQ)
-	features |= (1 << FEATURE_AVX512VPOPCNTDQ);
-      if (edx & bit_AVX5124VNNIW)
-	features |= (1 << FEATURE_AVX5124VNNIW);
-      if (edx & bit_AVX5124FMAPS)
-	features |= (1 << FEATURE_AVX5124FMAPS);
+      if (avx512_usable)
+	{
+	  if (ebx & bit_AVX512F)
+	    features |= (1 << FEATURE_AVX512F);
+	  if (ebx & bit_AVX512VL)
+	    features |= (1 << FEATURE_AVX512VL);
+	  if (ebx & bit_AVX512BW)
+	    features |= (1 << FEATURE_AVX512BW);
+	  if (ebx & bit_AVX512DQ)
+	    features |= (1 << FEATURE_AVX512DQ);
+	  if (ebx & bit_AVX512CD)
+	    features |= (1 << FEATURE_AVX512CD);
+	  if (ebx & bit_AVX512PF)
+	    features |= (1 << FEATURE_AVX512PF);
+	  if (ebx & bit_AVX512ER)
+	    features |= (1 << FEATURE_AVX512ER);
+	  if (ebx & bit_AVX512IFMA)
+	    features |= (1 << FEATURE_AVX512IFMA);
+	  if (ecx & bit_AVX512VBMI)
+	    features |= (1 << FEATURE_AVX512VBMI);
+	  if (ecx & bit_AVX512VPOPCNTDQ)
+	    features |= (1 << FEATURE_AVX512VPOPCNTDQ);
+	  if (edx & bit_AVX5124VNNIW)
+	    features |= (1 << FEATURE_AVX5124VNNIW);
+	  if (edx & bit_AVX5124FMAPS)
+	    features |= (1 << FEATURE_AVX5124FMAPS);
+	}
     }
 
   /* Check cpuid level of extended features.  */
@@ -292,10 +335,13 @@
 
       if (ecx & bit_SSE4a)
 	features |= (1 << FEATURE_SSE4_A);
-      if (ecx & bit_FMA4)
-	features |= (1 << FEATURE_FMA4);
-      if (ecx & bit_XOP)
-	features |= (1 << FEATURE_XOP);
+      if (avx_usable)
+	{
+	  if (ecx & bit_FMA4)
+	    features |= (1 << FEATURE_FMA4);
+	  if (ecx & bit_XOP)
+	    features |= (1 << FEATURE_XOP);
+	}
     }
     
   __cpu_model.__cpu_features[0] = features;
Index: libgcc/config/arm/cmse.c
===================================================================
diff --git a/libgcc/config/arm/cmse.c b/libgcc/config/arm/cmse.c
--- a/libgcc/config/arm/cmse.c	(revision 262353)
+++ b/libgcc/config/arm/cmse.c	(revision 262353)
@@ -36,7 +36,7 @@
   char *pb = (char *) p, *pe;
 
   /* Check if the range wraps around.  */
-  if (UINTPTR_MAX - (uintptr_t) p < size)
+  if (__UINTPTR_MAX__ - (__UINTPTR_TYPE__) p < size)
     return NULL;
 
   /* Check if an unknown flag is present.  */
@@ -51,7 +51,8 @@
 
   /* Execute the right variant of the TT instructions.  */
   pe = pb + size - 1;
-  const int singleCheck = (((uintptr_t) pb ^ (uintptr_t) pe) < 32);
+  const int singleCheck
+    = (((__UINTPTR_TYPE__) pb ^ (__UINTPTR_TYPE__) pe) < 32);
   switch (flags & known_secure_level)
     {
     case 0:
Index: libgcc/config/pa/fptr.c
===================================================================
diff --git a/libgcc/config/pa/fptr.c b/libgcc/config/pa/fptr.c
--- a/libgcc/config/pa/fptr.c	(revision 262353)
+++ b/libgcc/config/pa/fptr.c	(revision 262353)
@@ -52,6 +52,16 @@
 typedef int (*fixup_t) (struct link_map *, unsigned int);
 extern unsigned int _GLOBAL_OFFSET_TABLE_;
 
+static inline int
+_dl_read_access_allowed (unsigned int *addr)
+{
+  int result;
+
+  asm ("proberi (%1),3,%0" : "=r" (result) : "r" (addr) : );
+
+  return result;
+}
+
 /* __canonicalize_funcptr_for_compare must be hidden so that it is not
    placed in the dynamic symbol table.  Like millicode functions, it
    must be linked into all binaries in order access the got table of 
@@ -82,6 +92,16 @@
      The second word in the plabel contains the relocation offset for the
      function.  */
   plabel = (unsigned int *) ((unsigned int) fptr & ~3);
+  if (!_dl_read_access_allowed (plabel))
+    return (unsigned int) fptr;
+
+  /* Load first word of candidate descriptor.  It should be a pointer
+     with word alignment and point to memory that can be read.  */
+  got = (unsigned int *) plabel[0];
+  if (((unsigned int) got & 3) != 0
+      || !_dl_read_access_allowed (got))
+    return (unsigned int) fptr;
+
   got = (unsigned int *) (plabel[0] + GOT_FROM_PLT_STUB);
 
   /* Return the address of the function if the plabel has been resolved.  */
Index: libgcc/config/xtensa/ieee754-df.S
===================================================================
diff --git a/libgcc/config/xtensa/ieee754-df.S b/libgcc/config/xtensa/ieee754-df.S
--- a/libgcc/config/xtensa/ieee754-df.S	(revision 262353)
+++ b/libgcc/config/xtensa/ieee754-df.S	(revision 262353)
@@ -55,6 +55,7 @@
 
 #ifdef L_addsubdf3
 
+	.literal_position
 	/* Addition */
 __adddf3_aux:
 	
Index: libgcc/config/xtensa/ieee754-sf.S
===================================================================
diff --git a/libgcc/config/xtensa/ieee754-sf.S b/libgcc/config/xtensa/ieee754-sf.S
--- a/libgcc/config/xtensa/ieee754-sf.S	(revision 262353)
+++ b/libgcc/config/xtensa/ieee754-sf.S	(revision 262353)
@@ -55,6 +55,7 @@
 
 #ifdef L_addsubsf3
 
+	.literal_position
 	/* Addition */
 __addsf3_aux:
 
Index: libgcc/configure
===================================================================
diff --git a/libgcc/configure b/libgcc/configure
--- a/libgcc/configure	(revision 262353)
+++ b/libgcc/configure	(revision 262353)
@@ -5298,7 +5298,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
Index: gcc/tree-vrp.c
===================================================================
diff --git a/gcc/tree-vrp.c b/gcc/tree-vrp.c
--- a/gcc/tree-vrp.c	(revision 262353)
+++ b/gcc/tree-vrp.c	(revision 262353)
@@ -8671,9 +8671,9 @@
 	  if (TREE_CODE (*vr0min) == INTEGER_CST)
 	    {
 	      *vr0type = vr1type;
-	      *vr0min = vr1min;
 	      *vr0max = int_const_binop (MINUS_EXPR, *vr0min,
 					 build_int_cst (TREE_TYPE (*vr0min), 1));
+	      *vr0min = vr1min;
 	    }
 	  else
 	    goto give_up;
Index: gcc/shrink-wrap.c
===================================================================
diff --git a/gcc/shrink-wrap.c b/gcc/shrink-wrap.c
--- a/gcc/shrink-wrap.c	(revision 262353)
+++ b/gcc/shrink-wrap.c	(revision 262353)
@@ -157,7 +157,7 @@
 			   struct dead_debug_local *debug)
 {
   rtx set, src, dest;
-  bitmap live_out, live_in, bb_uses, bb_defs;
+  bitmap live_out, live_in, bb_uses = NULL, bb_defs = NULL;
   unsigned int i, dregno, end_dregno;
   unsigned int sregno = FIRST_PSEUDO_REGISTER;
   unsigned int end_sregno = FIRST_PSEUDO_REGISTER;
@@ -330,8 +330,11 @@
       /* Check whether BB uses DEST or clobbers DEST.  We need to add
 	 INSN to BB if so.  Either way, DEST is no longer live on entry,
 	 except for any part that overlaps SRC (next loop).  */
-      bb_uses = &DF_LR_BB_INFO (bb)->use;
-      bb_defs = &DF_LR_BB_INFO (bb)->def;
+      if (!*split_p)
+	{
+	  bb_uses = &DF_LR_BB_INFO (bb)->use;
+	  bb_defs = &DF_LR_BB_INFO (bb)->def;
+	}
       if (df_live)
 	{
 	  for (i = dregno; i < end_dregno; i++)
@@ -1374,6 +1377,8 @@
       bitmap_clear_bit (seen, bb->index);
     }
 
+  todo.release ();
+
   /* Finally, mark everything not not needed both forwards and backwards.  */
 
   FOR_EACH_BB_FN (bb, cfun)
Index: gcc/doc/extend.texi
===================================================================
diff --git a/gcc/doc/extend.texi b/gcc/doc/extend.texi
--- a/gcc/doc/extend.texi	(revision 262353)
+++ b/gcc/doc/extend.texi	(revision 262353)
@@ -1,4 +1,4 @@
-@c Copyright (C) 1988-2017 Free Software Foundation, Inc.
+@c Copyright (C) 1988-2018 Free Software Foundation, Inc.
 
 @c This is part of the GCC manual.
 @c For copying conditions, see the file gcc.texi.
@@ -15165,21 +15165,16 @@
 @smallexample
 long __builtin_bpermd (long, long);
 int __builtin_divwe (int, int);
-int __builtin_divweo (int, int);
 unsigned int __builtin_divweu (unsigned int, unsigned int);
-unsigned int __builtin_divweuo (unsigned int, unsigned int);
 long __builtin_divde (long, long);
-long __builtin_divdeo (long, long);
 unsigned long __builtin_divdeu (unsigned long, unsigned long);
-unsigned long __builtin_divdeuo (unsigned long, unsigned long);
 unsigned int cdtbcd (unsigned int);
 unsigned int cbcdtd (unsigned int);
 unsigned int addg6s (unsigned int, unsigned int);
 @end smallexample
 
-The @code{__builtin_divde}, @code{__builtin_divdeo},
-@code{__builtin_divdeu}, @code{__builtin_divdeou} functions require a
-64-bit environment support ISA 2.06 or later.
+The @code{__builtin_divde} and @code{__builtin_divdeu} functions
+require a 64-bit environment supporting ISA 2.06 or later.
 
 The following built-in functions are available for the PowerPC family
 of processors, starting with ISA 3.0 or later (@option{-mcpu=power9}):
@@ -18124,14 +18119,11 @@
 vector int vec_vctzw (vector int);
 vector unsigned int vec_vctzw (vector int);
 
-long long vec_vextract4b (const vector signed char, const int);
-long long vec_vextract4b (const vector unsigned char, const int);
-
-vector signed char vec_insert4b (vector int, vector signed char, const int);
+long long vec_extract4b (const vector unsigned char, const int);
+vector unsigned char vec_insert4b (vector signed int, vector unsigned char,
+                                   const int);
 vector unsigned char vec_insert4b (vector unsigned int, vector unsigned char,
                                    const int);
-vector signed char vec_insert4b (long long, vector signed char, const int);
-vector unsigned char vec_insert4b (long long, vector unsigned char, const int);
 
 vector int vec_vprtyb (vector int);
 vector unsigned int vec_vprtyb (vector unsigned int);
Index: gcc/doc/install.texi2html
===================================================================
diff --git a/gcc/doc/install.texi2html b/gcc/doc/install.texi2html
--- a/gcc/doc/install.texi2html	(revision 262353)
+++ b/gcc/doc/install.texi2html	(revision 262353)
@@ -52,7 +52,10 @@
 do
     define=`echo $x | sed -e 's/\.//g'`
     echo "define = $define"
-    $MAKEINFO --no-number-sections -I $SOURCEDIR -I $SOURCEDIR/include -I $DESTDIR $SOURCEDIR/install.texi --html --no-split -D$define -o$DESTDIR/$x
+    $MAKEINFO --no-number-sections -I $SOURCEDIR -I $SOURCEDIR/include -I $DESTDIR $SOURCEDIR/install.texi --html --no-split -D$define -o$DESTDIR/temp.html
+    # Use sed to work around makeinfo 4.7 brokenness.
+    sed -e 's/_002d/-/g' -e 's/_002a/*/g' $DESTDIR/temp.html > $DESTDIR/$x
+    rm $DESTDIR/temp.html
 done
 
 rm $DESTDIR/gcc-vers.texi
Index: gcc/doc/tm.texi
===================================================================
diff --git a/gcc/doc/tm.texi b/gcc/doc/tm.texi
--- a/gcc/doc/tm.texi	(revision 262353)
+++ b/gcc/doc/tm.texi	(revision 262353)
@@ -10645,8 +10645,12 @@
 
 @defmac WORD_REGISTER_OPERATIONS
 Define this macro to 1 if operations between registers with integral mode
-smaller than a word are always performed on the entire register.
-Most RISC machines have this property and most CISC machines do not.
+smaller than a word are always performed on the entire register.  To be
+more explicit, if you start with a pair of @code{word_mode} registers with
+known values and you do a subword, for example @code{QImode}, addition on
+the low part of the registers, then the compiler may consider that the
+result has a known value in @code{word_mode} too if the macro is defined
+to 1.  Most RISC machines have this property and most CISC machines do not.
 @end defmac
 
 @deftypefn {Target Hook} {unsigned int} TARGET_MIN_ARITHMETIC_PRECISION (void)
Index: gcc/doc/tm.texi.in
===================================================================
diff --git a/gcc/doc/tm.texi.in b/gcc/doc/tm.texi.in
--- a/gcc/doc/tm.texi.in	(revision 262353)
+++ b/gcc/doc/tm.texi.in	(revision 262353)
@@ -7581,8 +7581,12 @@
 
 @defmac WORD_REGISTER_OPERATIONS
 Define this macro to 1 if operations between registers with integral mode
-smaller than a word are always performed on the entire register.
-Most RISC machines have this property and most CISC machines do not.
+smaller than a word are always performed on the entire register.  To be
+more explicit, if you start with a pair of @code{word_mode} registers with
+known values and you do a subword, for example @code{QImode}, addition on
+the low part of the registers, then the compiler may consider that the
+result has a known value in @code{word_mode} too if the macro is defined
+to 1.  Most RISC machines have this property and most CISC machines do not.
 @end defmac
 
 @hook TARGET_MIN_ARITHMETIC_PRECISION
Index: gcc/doc/invoke.texi
===================================================================
diff --git a/gcc/doc/invoke.texi b/gcc/doc/invoke.texi
--- a/gcc/doc/invoke.texi	(revision 262353)
+++ b/gcc/doc/invoke.texi	(revision 262353)
@@ -1025,7 +1025,7 @@
 -mfloat-gprs=yes  -mfloat-gprs=no  -mfloat-gprs=single  -mfloat-gprs=double @gol
 -mprototype  -mno-prototype @gol
 -msim  -mmvme  -mads  -myellowknife  -memb  -msdata @gol
--msdata=@var{opt}  -mvxworks  -G @var{num} @gol
+-msdata=@var{opt}  -mreadonly-in-sdata  -mvxworks  -G @var{num} @gol
 -mrecip  -mrecip=@var{opt}  -mno-recip  -mrecip-precision @gol
 -mno-recip-precision @gol
 -mveclibabi=@var{type}  -mfriz  -mno-friz @gol
@@ -1211,7 +1211,7 @@
 -mavx256-split-unaligned-load  -mavx256-split-unaligned-store @gol
 -malign-data=@var{type}  -mstack-protector-guard=@var{guard} @gol
 -mmitigate-rop  -mgeneral-regs-only @gol
--mindirect-branch=@var{choice} -mfunction-return==@var{choice} @gol
+-mindirect-branch=@var{choice} -mfunction-return=@var{choice} @gol
 -mindirect-branch-register}
 
 @emph{x86 Windows Options}
@@ -5171,6 +5171,9 @@
 may end in one of the standard suffixes designating a multiple of bytes
 such as @code{kB} and @code{KiB} for kilobyte and kibibyte, respectively,
 @code{MB} and @code{MiB} for megabyte and mebibyte, and so on.
+@option{-Walloc-size-larger-than=}@var{PTRDIFF_MAX} is enabled by default.
+Warnings controlled by the option can be disabled by specifying @var{n}
+of @var{SIZE_MAX} or more.
 @xref{Function Attributes}.
 
 @item -Walloca
@@ -8132,7 +8135,7 @@
 
 @item -fisolate-erroneous-paths-attribute
 @opindex fisolate-erroneous-paths-attribute
-Detect paths that trigger erroneous or undefined behavior due a null value
+Detect paths that trigger erroneous or undefined behavior due to a null value
 being used in a way forbidden by a @code{returns_nonnull} or @code{nonnull}
 attribute.  Isolate those paths from the main control flow and turn the
 statement with erroneous or undefined behavior into a trap.  This is not
@@ -8690,6 +8693,7 @@
 in that case, it is rounded up.
 
 If @var{n} is not specified or is zero, use a machine-dependent default.
+The maximum allowed @var{n} option value is 65536.
 
 Enabled at levels @option{-O2}, @option{-O3}.
 
@@ -8715,6 +8719,7 @@
 
 If @var{n} is not specified or is zero, use a machine-dependent default
 which is very likely to be @samp{1}, meaning no alignment.
+The maximum allowed @var{n} option value is 65536.
 
 Enabled at levels @option{-O2}, @option{-O3}.
 
@@ -8728,6 +8733,7 @@
 
 @option{-fno-align-loops} and @option{-falign-loops=1} are
 equivalent and mean that loops are not aligned.
+The maximum allowed @var{n} option value is 65536.
 
 If @var{n} is not specified or is zero, use a machine-dependent default.
 
@@ -8745,6 +8751,7 @@
 equivalent and mean that loops are not aligned.
 
 If @var{n} is not specified or is zero, use a machine-dependent default.
+The maximum allowed @var{n} option value is 65536.
 
 Enabled at levels @option{-O2}, @option{-O3}.
 
@@ -22070,6 +22077,13 @@
 in the @code{.data} section, and all uninitialized data in the
 @code{.bss} section.
 
+@item -mreadonly-in-sdata
+@itemx -mreadonly-in-sdata
+@opindex mreadonly-in-sdata
+@opindex mno-readonly-in-sdata
+Put read-only objects in the @code{.sdata} section as well.  This is the
+default.
+
 @item -mblock-move-inline-limit=@var{num}
 @opindex mblock-move-inline-limit
 Inline all block moves (such as calls to @code{memcpy} or structure
@@ -25091,8 +25105,8 @@
 @itemx -mpclmul
 @opindex mpclmul
 @need 200
-@itemx -mclfushopt
-@opindex mclfushopt
+@itemx -mclflushopt
+@opindex mclflushopt
 @need 200
 @itemx -mfsgsbase
 @opindex mfsgsbase
Index: gcc/doc/gcov.texi
===================================================================
diff --git a/gcc/doc/gcov.texi b/gcc/doc/gcov.texi
--- a/gcc/doc/gcov.texi	(revision 262353)
+++ b/gcc/doc/gcov.texi	(revision 262353)
@@ -322,7 +322,7 @@
 Additional block information may succeed each line, when requested by
 command line option.  The @var{execution_count} is @samp{-} for lines
 containing no code.  Unexecuted lines are marked @samp{#####} or
-@samp{====}, depending on whether they are reachable by
+@samp{=====}, depending on whether they are reachable by
 non-exceptional paths or only exceptional paths such as C++ exception
 handlers, respectively. Given @samp{-a} option, unexecuted blocks are
 marked @samp{$$$$$} or @samp{%%%%%}, depending on whether a basic block
@@ -618,6 +618,8 @@
 to invoke the @code{__gcov_dump} function. Thus @code{__gcov_dump}
 is executed after all user defined static destructors,
 as well as handlers registered with @code{atexit}.
+If an executable loads a dynamic shared object via dlopen functionality,
+@option{-Wl,--dynamic-list-data} is needed to dump all profile data.
 
 @c man end
 
Index: gcc/doc/rtl.texi
===================================================================
diff --git a/gcc/doc/rtl.texi b/gcc/doc/rtl.texi
--- a/gcc/doc/rtl.texi	(revision 262353)
+++ b/gcc/doc/rtl.texi	(revision 262353)
@@ -1291,10 +1291,11 @@
 @findex CDImode
 @findex CTImode
 @findex COImode
-@item CQImode, CHImode, CSImode, CDImode, CTImode, COImode
+@findex CPSImode
+@item CQImode, CHImode, CSImode, CDImode, CTImode, COImode, CPSImode
 These modes stand for a complex number represented as a pair of integer
 values.  The integer values are in @code{QImode}, @code{HImode},
-@code{SImode}, @code{DImode}, @code{TImode}, and @code{OImode},
+@code{SImode}, @code{DImode}, @code{TImode}, @code{OImode}, and @code{PSImode},
 respectively.
 
 @findex BND32mode
Index: gcc/dwarf2asm.c
===================================================================
diff --git a/gcc/dwarf2asm.c b/gcc/dwarf2asm.c
--- a/gcc/dwarf2asm.c	(revision 262353)
+++ b/gcc/dwarf2asm.c	(revision 262353)
@@ -33,6 +33,7 @@
 #include "dwarf2.h"
 #include "function.h"
 #include "emit-rtl.h"
+#include "fold-const.h"
 
 #ifndef XCOFF_DEBUGGING_INFO
 #define XCOFF_DEBUGGING_INFO 0
@@ -925,7 +926,7 @@
   SET_DECL_ASSEMBLER_NAME (decl, id);
   DECL_ARTIFICIAL (decl) = 1;
   DECL_IGNORED_P (decl) = 1;
-  DECL_INITIAL (decl) = decl;
+  DECL_INITIAL (decl) = build_fold_addr_expr (decl);
   TREE_READONLY (decl) = 1;
   TREE_STATIC (decl) = 1;
 
@@ -938,8 +939,23 @@
     }
 
   sym_ref = gen_rtx_SYMBOL_REF (Pmode, sym);
+  /* Disable ASan for decl because redzones cause ABI breakage between GCC and
+     libstdc++ for `.LDFCM*' variables.  See PR 78651 for details.  */
+  unsigned int save_flag_sanitize = flag_sanitize;
+  flag_sanitize &= ~(SANITIZE_ADDRESS | SANITIZE_USER_ADDRESS
+		     | SANITIZE_KERNEL_ADDRESS);
+  /* And also temporarily disable -fsection-anchors.  These indirect constants
+     are never referenced from code, so it doesn't make any sense to aggregate
+     them in blocks.  */
+  int save_flag_section_anchors = flag_section_anchors;
+  flag_section_anchors = 0;
   assemble_variable (decl, 1, 1, 1);
+  flag_section_anchors = save_flag_section_anchors;
+  flag_sanitize = save_flag_sanitize;
   assemble_integer (sym_ref, POINTER_SIZE_UNITS, POINTER_SIZE, 1);
+  /* The following is a hack recognized by use_blocks_for_decl_p to disable
+     section anchor handling of the decl.  */
+  DECL_INITIAL (decl) = decl;
 
   return 0;
 }
Index: gcc/tree-ssa-tail-merge.c
===================================================================
diff --git a/gcc/tree-ssa-tail-merge.c b/gcc/tree-ssa-tail-merge.c
--- a/gcc/tree-ssa-tail-merge.c	(revision 262353)
+++ b/gcc/tree-ssa-tail-merge.c	(revision 262353)
@@ -1454,7 +1454,8 @@
       /* TODO: handle blocks with phi-nodes.  We'll have to find corresponding
 	 phi-nodes in bb1 and bb2, with the same alternatives for the same
 	 preds.  */
-      if (bb_has_non_vop_phi (bb1) || bb_has_eh_pred (bb1))
+      if (bb_has_non_vop_phi (bb1) || bb_has_eh_pred (bb1)
+	  || bb_has_abnormal_pred (bb1))
 	continue;
 
       nr_comparisons = 0;
@@ -1462,7 +1463,8 @@
 	{
 	  bb2 = BASIC_BLOCK_FOR_FN (cfun, j);
 
-	  if (bb_has_non_vop_phi (bb2) || bb_has_eh_pred (bb2))
+	  if (bb_has_non_vop_phi (bb2) || bb_has_eh_pred (bb2)
+	      || bb_has_abnormal_pred (bb2))
 	    continue;
 
 	  if (BB_CLUSTER (bb1) != NULL && BB_CLUSTER (bb1) == BB_CLUSTER (bb2))
Index: gcc/tree-ssa-loop-niter.c
===================================================================
diff --git a/gcc/tree-ssa-loop-niter.c b/gcc/tree-ssa-loop-niter.c
--- a/gcc/tree-ssa-loop-niter.c	(revision 262353)
+++ b/gcc/tree-ssa-loop-niter.c	(revision 262353)
@@ -2320,11 +2320,11 @@
 
   tree iv0_niters = NULL_TREE;
   if (!simple_iv_with_niters (loop, loop_containing_stmt (stmt),
-			      op0, &iv0, &iv0_niters, false))
+			      op0, &iv0, safe ? &iv0_niters : NULL, false))
     return false;
   tree iv1_niters = NULL_TREE;
   if (!simple_iv_with_niters (loop, loop_containing_stmt (stmt),
-			      op1, &iv1, &iv1_niters, false))
+			      op1, &iv1, safe ? &iv1_niters : NULL, false))
     return false;
   /* Give up on complicated case.  */
   if (iv0_niters && iv1_niters)
Index: gcc/c-family/c-cppbuiltin.c
===================================================================
diff --git a/gcc/c-family/c-cppbuiltin.c b/gcc/c-family/c-cppbuiltin.c
--- a/gcc/c-family/c-cppbuiltin.c	(revision 262353)
+++ b/gcc/c-family/c-cppbuiltin.c	(revision 262353)
@@ -1119,7 +1119,7 @@
 	       floatn_nx_types[i].extended ? "X" : "");
       sprintf (csuffix, "F%d%s", floatn_nx_types[i].n,
 	       floatn_nx_types[i].extended ? "x" : "");
-      builtin_define_float_constants (prefix, csuffix, "%s", NULL,
+      builtin_define_float_constants (prefix, ggc_strdup (csuffix), "%s", NULL,
 				      FLOATN_NX_TYPE_NODE (i));
     }
 
@@ -1566,7 +1566,14 @@
   int digits;
   const char *fp_suffix;
 };
-static GTY(()) struct lazy_hex_fp_value_struct lazy_hex_fp_values[12];
+/* Number of the expensive to compute macros we should evaluate lazily.
+   Each builtin_define_float_constants invocation calls
+   builtin_define_with_hex_fp_value 4 times and builtin_define_float_constants
+   is called for FLT, DBL, LDBL and up to NUM_FLOATN_NX_TYPES times for
+   FLTNN*.  */ 
+#define LAZY_HEX_FP_VALUES_CNT (4 * (3 + NUM_FLOATN_NX_TYPES))
+static GTY(()) struct lazy_hex_fp_value_struct
+  lazy_hex_fp_values[LAZY_HEX_FP_VALUES_CNT];
 static GTY(()) int lazy_hex_fp_value_count;
 
 static bool
@@ -1611,7 +1618,7 @@
   char dec_str[64], buf1[256], buf2[256];
 
   /* This is very expensive, so if possible expand them lazily.  */
-  if (lazy_hex_fp_value_count < 12
+  if (lazy_hex_fp_value_count < LAZY_HEX_FP_VALUES_CNT
       && flag_dump_macros == 0
       && !cpp_get_options (parse_in)->traditional)
     {
Index: gcc/c-family/c-gimplify.c
===================================================================
diff --git a/gcc/c-family/c-gimplify.c b/gcc/c-family/c-gimplify.c
--- a/gcc/c-family/c-gimplify.c	(revision 262353)
+++ b/gcc/c-family/c-gimplify.c	(revision 262353)
@@ -244,7 +244,9 @@
 				    unsigned_type_node)
 	    && !types_compatible_p (TYPE_MAIN_VARIANT (TREE_TYPE (*op1_p)),
 				    integer_type_node))
-	  *op1_p = convert (unsigned_type_node, *op1_p);
+	  /* Make sure to unshare the result, tree sharing is invalid
+	     during gimplification.  */
+	  *op1_p = unshare_expr (convert (unsigned_type_node, *op1_p));
 	break;
       }
 
Index: gcc/c-family/ChangeLog
===================================================================
diff --git a/gcc/c-family/ChangeLog b/gcc/c-family/ChangeLog
--- a/gcc/c-family/ChangeLog	(revision 262353)
+++ b/gcc/c-family/ChangeLog	(revision 262353)
@@ -1,3 +1,56 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-06-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/86210
+	* c-common.c (check_nonnull_arg): Use fold_for_warn.  Adjust obsolete
+	comment.
+
+	2018-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/85696
+	* c-omp.c (c_omp_predetermined_sharing): Return
+	OMP_CLAUSE_DEFAULT_SHARED for artificial vars with integral type.
+
+	2018-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85662
+	* c-common.h (fold_offsetof_1): Removed.
+	(fold_offsetof): Add TYPE argument defaulted to size_type_node and
+	CTX argument defaulted to ERROR_MARK.
+	* c-common.c (fold_offsetof_1): Renamed to ...
+	(fold_offsetof): ... this.  Remove wrapper function.  Add TYPE
+	argument, convert the pointer constant to TYPE and use size_binop
+	with PLUS_EXPR instead of fold_build_pointer_plus if type is not
+	a pointer type.  Adjust recursive calls.
+
+2018-04-26  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-03-16  Richard Biener  <rguenther@suse.de>
+
+	PR c/84873
+	* c-gimplify.c (c_gimplify_expr): Revert previous change.  Instead
+	unshare the possibly folded expression.
+
+	2018-03-15  Richard Biener  <rguenther@suse.de>
+
+	PR c/84873
+	* c-gimplify.c (c_gimplify_expr): Do not fold expressions.
+
+2018-03-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-01-27  Jakub Jelinek  <jakub@redhat.com>
+
+	* c-cppbuiltin.c (c_cpp_builtins): Use ggc_strdup for the fp_suffix
+	argument.
+	(LAZY_HEX_FP_VALUES_CNT): Define.
+	(lazy_hex_fp_values): Allow up to LAZY_HEX_FP_VALUES_CNT lazy hex fp
+	values rather than just 12.
+	(builtin_define_with_hex_fp_value): Likewise.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
Index: gcc/c-family/c-common.c
===================================================================
diff --git a/gcc/c-family/c-common.c b/gcc/c-family/c-common.c
--- a/gcc/c-family/c-common.c	(revision 262353)
+++ b/gcc/c-family/c-common.c	(revision 262353)
@@ -5434,10 +5434,8 @@
   if (TREE_CODE (TREE_TYPE (param)) != POINTER_TYPE)
     return;
 
-  /* When not optimizing diagnose the simple cases of null arguments.
-     When optimization is enabled defer the checking until expansion
-     when more cases can be detected.  */
-  if (integer_zerop (param))
+  /* Diagnose the simple cases of null arguments.  */
+  if (integer_zerop (fold_for_warn (param)))
     {
       warning_at (pctx->loc, OPT_Wnonnull, "null argument where non-null "
 		  "required (argument %lu)", (unsigned long) param_num);
@@ -6253,10 +6251,11 @@
 
 /* Fold an offsetof-like expression.  EXPR is a nested sequence of component
    references with an INDIRECT_REF of a constant at the bottom; much like the
-   traditional rendering of offsetof as a macro.  Return the folded result.  */
+   traditional rendering of offsetof as a macro.  TYPE is the desired type of
+   the whole expression.  Return the folded result.  */
 
 tree
-fold_offsetof_1 (tree expr, enum tree_code ctx)
+fold_offsetof (tree expr, tree type, enum tree_code ctx)
 {
   tree base, off, t;
   tree_code code = TREE_CODE (expr);
@@ -6281,10 +6280,10 @@
 	  error ("cannot apply %<offsetof%> to a non constant address");
 	  return error_mark_node;
 	}
-      return TREE_OPERAND (expr, 0);
+      return convert (type, TREE_OPERAND (expr, 0));
 
     case COMPONENT_REF:
-      base = fold_offsetof_1 (TREE_OPERAND (expr, 0), code);
+      base = fold_offsetof (TREE_OPERAND (expr, 0), type, code);
       if (base == error_mark_node)
 	return base;
 
@@ -6301,7 +6300,7 @@
       break;
 
     case ARRAY_REF:
-      base = fold_offsetof_1 (TREE_OPERAND (expr, 0), code);
+      base = fold_offsetof (TREE_OPERAND (expr, 0), type, code);
       if (base == error_mark_node)
 	return base;
 
@@ -6358,23 +6357,16 @@
       /* Handle static members of volatile structs.  */
       t = TREE_OPERAND (expr, 1);
       gcc_assert (VAR_P (t));
-      return fold_offsetof_1 (t);
+      return fold_offsetof (t, type);
 
     default:
       gcc_unreachable ();
     }
 
+  if (!POINTER_TYPE_P (type))
+    return size_binop (PLUS_EXPR, base, convert (type, off));
   return fold_build_pointer_plus (base, off);
 }
-
-/* Likewise, but convert it to the return type of offsetof.  */
-
-tree
-fold_offsetof (tree expr)
-{
-  return convert (size_type_node, fold_offsetof_1 (expr));
-}
-
 
 /* *PTYPE is an incomplete array.  Complete it with a domain based on
    INITIAL_VALUE.  If INITIAL_VALUE is not present, use 1 if DO_DEFAULT
Index: gcc/c-family/c-omp.c
===================================================================
diff --git a/gcc/c-family/c-omp.c b/gcc/c-family/c-omp.c
--- a/gcc/c-family/c-omp.c	(revision 262353)
+++ b/gcc/c-family/c-omp.c	(revision 262353)
@@ -1540,5 +1540,13 @@
   if (TREE_READONLY (decl))
     return OMP_CLAUSE_DEFAULT_SHARED;
 
+  /* Predetermine artificial variables holding integral values, those
+     are usually result of gimplify_one_sizepos or SAVE_EXPR
+     gimplification.  */
+  if (VAR_P (decl)
+      && DECL_ARTIFICIAL (decl)
+      && INTEGRAL_TYPE_P (TREE_TYPE (decl)))
+    return OMP_CLAUSE_DEFAULT_SHARED;
+
   return OMP_CLAUSE_DEFAULT_UNSPECIFIED;
 }
Index: gcc/c-family/c-common.h
===================================================================
diff --git a/gcc/c-family/c-common.h b/gcc/c-family/c-common.h
--- a/gcc/c-family/c-common.h	(revision 262353)
+++ b/gcc/c-family/c-common.h	(revision 262353)
@@ -1053,8 +1053,8 @@
 
 extern void verify_sequence_points (tree);
 
-extern tree fold_offsetof_1 (tree, tree_code ctx = ERROR_MARK);
-extern tree fold_offsetof (tree);
+extern tree fold_offsetof (tree, tree = size_type_node,
+			   tree_code ctx = ERROR_MARK);
 
 extern int complete_array_type (tree *, tree, bool);
 
Index: gcc/c/c-fold.c
===================================================================
diff --git a/gcc/c/c-fold.c b/gcc/c/c-fold.c
--- a/gcc/c/c-fold.c	(revision 262353)
+++ b/gcc/c/c-fold.c	(revision 262353)
@@ -403,7 +403,7 @@
 	  && (op1 = get_base_address (op0)) != NULL_TREE
 	  && INDIRECT_REF_P (op1)
 	  && TREE_CONSTANT (TREE_OPERAND (op1, 0)))
-	ret = fold_convert_loc (loc, TREE_TYPE (expr), fold_offsetof_1 (op0));
+	ret = fold_offsetof (op0, TREE_TYPE (expr));
       else if (op0 != orig_op0 || in_init)
 	ret = in_init
 	  ? fold_build1_initializer_loc (loc, code, TREE_TYPE (expr), op0)
Index: gcc/c/ChangeLog
===================================================================
diff --git a/gcc/c/ChangeLog b/gcc/c/ChangeLog
--- a/gcc/c/ChangeLog	(revision 262353)
+++ b/gcc/c/ChangeLog	(revision 262353)
@@ -1,3 +1,35 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/85696
+	* c-typeck.c (c_finish_omp_clauses): Don't use
+	c_omp_predetermined_sharing, instead just check TREE_READONLY.
+
+	2018-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85662
+	* c-fold.c (c_fully_fold_internal): Use fold_offsetof rather than
+	fold_offsetof_1, pass TREE_TYPE (expr) as TYPE to it and drop the
+	fold_convert_loc.
+	* c-typeck.c (build_unary_op): Use fold_offsetof rather than
+	fold_offsetof_1, pass argtype as TYPE to it and drop the
+	fold_convert_loc.
+
+	2018-03-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/84999
+	* c-typeck.c (build_binary_op): If c_common_type_for_size fails when
+	building vector comparison, diagnose it and return error_mark_node.
+
+	2018-03-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/84853
+	* c-typeck.c (build_binary_op) <case RSHIFT_EXPR, case LSHIFT_EXPR>:
+	If code1 is INTEGER_TYPE, only allow code0 VECTOR_TYPE if it has
+	INTEGER_TYPE element type.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
Index: gcc/c/c-typeck.c
===================================================================
diff --git a/gcc/c/c-typeck.c b/gcc/c/c-typeck.c
--- a/gcc/c/c-typeck.c	(revision 262353)
+++ b/gcc/c/c-typeck.c	(revision 262353)
@@ -4638,7 +4638,7 @@
       if (val && INDIRECT_REF_P (val)
           && TREE_CONSTANT (TREE_OPERAND (val, 0)))
 	{
-	  ret = fold_convert_loc (location, argtype, fold_offsetof_1 (arg));
+	  ret = fold_offsetof (arg, argtype);
 	  goto return_build_unary_op;
 	}
 
@@ -11150,7 +11150,8 @@
 	  converted = 1;
 	}
       else if ((code0 == INTEGER_TYPE || code0 == FIXED_POINT_TYPE
-		|| code0 == VECTOR_TYPE)
+		|| (code0 == VECTOR_TYPE
+		    && TREE_CODE (TREE_TYPE (type0)) == INTEGER_TYPE))
 	       && code1 == INTEGER_TYPE)
 	{
 	  doing_shift = true;
@@ -11207,7 +11208,8 @@
 	  converted = 1;
 	}
       else if ((code0 == INTEGER_TYPE || code0 == FIXED_POINT_TYPE
-		|| code0 == VECTOR_TYPE)
+		|| (code0 == VECTOR_TYPE
+		    && TREE_CODE (TREE_TYPE (type0)) == INTEGER_TYPE))
 	       && code1 == INTEGER_TYPE)
 	{
 	  doing_shift = true;
@@ -11299,6 +11301,13 @@
           /* Always construct signed integer vector type.  */
           intt = c_common_type_for_size (GET_MODE_BITSIZE
 					   (TYPE_MODE (TREE_TYPE (type0))), 0);
+	  if (!intt)
+	    {
+	      error_at (location, "could not find an integer type "
+				  "of the same size as %qT",
+			TREE_TYPE (type0));
+	      return error_mark_node;
+	    }
           result_type = build_opaque_vector_type (intt,
 						  TYPE_VECTOR_SUBPARTS (type0));
           converted = 1;
@@ -11458,6 +11467,13 @@
           /* Always construct signed integer vector type.  */
           intt = c_common_type_for_size (GET_MODE_BITSIZE
 					   (TYPE_MODE (TREE_TYPE (type0))), 0);
+	  if (!intt)
+	    {
+	      error_at (location, "could not find an integer type "
+				  "of the same size as %qT",
+			TREE_TYPE (type0));
+	      return error_mark_node;
+	    }
           result_type = build_opaque_vector_type (intt,
 						  TYPE_VECTOR_SUBPARTS (type0));
           converted = 1;
@@ -13744,22 +13760,11 @@
 
 	      if (VAR_P (t) && DECL_THREAD_LOCAL_P (t))
 		share_name = "threadprivate";
-	      else switch (c_omp_predetermined_sharing (t))
+	      else if (TREE_READONLY (t))
 		{
-		case OMP_CLAUSE_DEFAULT_UNSPECIFIED:
-		  break;
-		case OMP_CLAUSE_DEFAULT_SHARED:
 		  /* const vars may be specified in firstprivate clause.  */
-		  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_FIRSTPRIVATE
-		      && TREE_READONLY (t))
-		    break;
-		  share_name = "shared";
-		  break;
-		case OMP_CLAUSE_DEFAULT_PRIVATE:
-		  share_name = "private";
-		  break;
-		default:
-		  gcc_unreachable ();
+		  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_FIRSTPRIVATE)
+		    share_name = "shared";
 		}
 	      if (share_name)
 		{
Index: gcc/cgraph.h
===================================================================
diff --git a/gcc/cgraph.h b/gcc/cgraph.h
--- a/gcc/cgraph.h	(revision 262353)
+++ b/gcc/cgraph.h	(revision 262353)
@@ -321,6 +321,9 @@
      or abstract function kept for debug info purposes only.  */
   bool real_symbol_p (void);
 
+  /* Return true when the symbol needs to be output to the LTO symbol table.  */
+  bool output_to_lto_symbol_table_p (void);
+
   /* Determine if symbol declaration is needed.  That is, visible to something
      either outside this translation unit, something magic in the system
      configury. This function is used just during symbol creation.  */
Index: gcc/lra-int.h
===================================================================
diff --git a/gcc/lra-int.h b/gcc/lra-int.h
--- a/gcc/lra-int.h	(revision 262353)
+++ b/gcc/lra-int.h	(revision 262353)
@@ -202,6 +202,10 @@
   const struct operand_alternative *operand_alternative;
 };
 
+/* Negative insn alternative numbers used for special cases.  */
+#define LRA_UNKNOWN_ALT -1
+#define LRA_NON_CLOBBERED_ALT -2
+
 /* LRA internal info about an insn (LRA internal insn
    representation).  */
 struct lra_insn_recog_data
@@ -208,9 +212,10 @@
 {
   /* The insn code.  */
   int icode;
-  /* The alternative should be used for the insn, -1 if invalid, or we
-     should try to use any alternative, or the insn is a debug
-     insn.  */
+  /* The alternative should be used for the insn, LRA_UNKNOWN_ALT if
+     unknown, or we should assume any alternative, or the insn is a
+     debug insn.  LRA_NON_CLOBBERED_ALT means ignoring any earlier
+     clobbers for the insn.  */
   int used_insn_alternative;
   /* SP offset before the insn relative to one at the func start.  */
   HOST_WIDE_INT sp_offset;
Index: gcc/optabs.c
===================================================================
diff --git a/gcc/optabs.c b/gcc/optabs.c
--- a/gcc/optabs.c	(revision 262353)
+++ b/gcc/optabs.c	(revision 262353)
@@ -4294,9 +4294,10 @@
 	  save_pending_stack_adjust (&save);
 	  last = get_last_insn ();
 	  do_pending_stack_adjust ();
+	  machine_mode cmpmode = cmode;
 	  prepare_cmp_insn (XEXP (comparison, 0), XEXP (comparison, 1),
 			    GET_CODE (comparison), NULL_RTX, unsignedp,
-			    OPTAB_WIDEN, &comparison, &cmode);
+			    OPTAB_WIDEN, &comparison, &cmpmode);
 	  if (comparison)
 	    {
 	      struct expand_operand ops[4];
Index: gcc/DATESTAMP
===================================================================
diff --git a/gcc/DATESTAMP b/gcc/DATESTAMP
--- a/gcc/DATESTAMP	(revision 262353)
+++ b/gcc/DATESTAMP	(revision 262353)
@@ -1 +1 @@
-20180125
+20180703
Index: gcc/postreload.c
===================================================================
diff --git a/gcc/postreload.c b/gcc/postreload.c
--- a/gcc/postreload.c	(revision 262353)
+++ b/gcc/postreload.c	(revision 262353)
@@ -1160,11 +1160,13 @@
 	     value in PREV, the constant loading instruction.  */
 	  validate_change (prev, &SET_DEST (prev_set), index_reg, 1);
 	  if (reg_state[regno].offset != const0_rtx)
-	    validate_change (prev,
-			     &SET_SRC (prev_set),
-			     GEN_INT (INTVAL (SET_SRC (prev_set))
-				      + INTVAL (reg_state[regno].offset)),
-			     1);
+	    {
+	      HOST_WIDE_INT c
+		= trunc_int_for_mode (UINTVAL (SET_SRC (prev_set))
+				      + UINTVAL (reg_state[regno].offset),
+				      GET_MODE (index_reg));
+	      validate_change (prev, &SET_SRC (prev_set), GEN_INT (c), 1);
+	    }
 
 	  /* Now for every use of REG that we have recorded, replace REG
 	     with REG_SUM.  */
Index: gcc/lra.c
===================================================================
diff --git a/gcc/lra.c b/gcc/lra.c
--- a/gcc/lra.c	(revision 262353)
+++ b/gcc/lra.c	(revision 262353)
@@ -946,7 +946,7 @@
   data = XNEW (struct lra_insn_recog_data);
   lra_insn_recog_data[uid] = data;
   data->insn = insn;
-  data->used_insn_alternative = -1;
+  data->used_insn_alternative = LRA_UNKNOWN_ALT;
   data->icode = icode;
   data->regs = NULL;
   if (DEBUG_INSN_P (insn))
@@ -1187,7 +1187,7 @@
       return data;
     }
   insn_static_data = data->insn_static_data;
-  data->used_insn_alternative = -1;
+  data->used_insn_alternative = LRA_UNKNOWN_ALT;
   if (DEBUG_INSN_P (insn))
     return data;
   if (data->icode < 0)
Index: gcc/tree-tailcall.c
===================================================================
diff --git a/gcc/tree-tailcall.c b/gcc/tree-tailcall.c
--- a/gcc/tree-tailcall.c	(revision 262353)
+++ b/gcc/tree-tailcall.c	(revision 262353)
@@ -473,7 +473,7 @@
     {
       tree arg;
 
-      for (param = DECL_ARGUMENTS (func), idx = 0;
+      for (param = DECL_ARGUMENTS (current_function_decl), idx = 0;
 	   param && idx < gimple_call_num_args (call);
 	   param = DECL_CHAIN (param), idx ++)
 	{
Index: gcc/tree.c
===================================================================
diff --git a/gcc/tree.c b/gcc/tree.c
--- a/gcc/tree.c	(revision 262353)
+++ b/gcc/tree.c	(revision 262353)
@@ -5454,9 +5454,10 @@
 	 At this point, it is not needed anymore.  */
       DECL_SAVED_TREE (decl) = NULL_TREE;
 
-      /* Clear the abstract origin if it refers to a method.  Otherwise
-         dwarf2out.c will ICE as we clear TYPE_METHODS and thus the
-	 origin will not be output correctly.  */
+      /* Clear the abstract origin if it refers to a method.
+         Otherwise dwarf2out.c will ICE as we splice functions out of
+         TYPE_FIELDS and thus the origin will not be output
+         correctly.  */
       if (DECL_ABSTRACT_ORIGIN (decl)
 	  && DECL_CONTEXT (DECL_ABSTRACT_ORIGIN (decl))
 	  && RECORD_OR_UNION_TYPE_P
@@ -7887,6 +7888,9 @@
       for (i = 0; i < TREE_VEC_LENGTH (t); ++i)
 	inchash::add_expr (TREE_VEC_ELT (t, i), hstate, flags);
       return;
+    case IDENTIFIER_NODE:
+      hstate.add_object (IDENTIFIER_HASH_VALUE (t));
+      return;
     case FUNCTION_DECL:
       /* When referring to a built-in FUNCTION_DECL, use the __builtin__ form.
 	 Otherwise nodes that compare equal according to operand_equal_p might
Index: gcc/ipa-cp.c
===================================================================
diff --git a/gcc/ipa-cp.c b/gcc/ipa-cp.c
--- a/gcc/ipa-cp.c	(revision 262353)
+++ b/gcc/ipa-cp.c	(revision 262353)
@@ -621,6 +621,24 @@
       reason = "calls comdat-local function";
     }
 
+  /* Functions calling BUILT_IN_VA_ARG_PACK and BUILT_IN_VA_ARG_PACK_LEN
+     works only when inlined.  Cloning them may still lead to better code
+     becuase ipa-cp will not give up on cloning further.  If the function is
+     external this however leads to wrong code becuase we may end up producing
+     offline copy of the function.  */
+  if (DECL_EXTERNAL (node->decl))
+    for (cgraph_edge *edge = node->callees; !reason && edge;
+	 edge = edge->next_callee)
+      if (DECL_BUILT_IN (edge->callee->decl)
+	  && DECL_BUILT_IN_CLASS (edge->callee->decl) == BUILT_IN_NORMAL)
+        {
+	  if (DECL_FUNCTION_CODE (edge->callee->decl) == BUILT_IN_VA_ARG_PACK)
+	    reason = "external function which calls va_arg_pack";
+	  if (DECL_FUNCTION_CODE (edge->callee->decl)
+	      == BUILT_IN_VA_ARG_PACK_LEN)
+	    reason = "external function which calls va_arg_pack_len";
+        }
+
   if (reason && dump_file && !node->alias && !node->thunk.thunk_p)
     fprintf (dump_file, "Function %s/%i is not versionable, reason: %s.\n",
 	     node->name (), node->order, reason);
@@ -4009,7 +4027,9 @@
 	  if (aglat->offset - offset == item->offset)
 	    {
 	      gcc_checking_assert (item->value);
-	      if (values_equal_for_ipcp_p (item->value, aglat->values->value))
+	      if (aglat->is_single_const ()
+		  && values_equal_for_ipcp_p (item->value,
+					      aglat->values->value))
 		found = true;
 	      break;
 	    }
Index: gcc/ddg.c
===================================================================
diff --git a/gcc/ddg.c b/gcc/ddg.c
--- a/gcc/ddg.c	(revision 262353)
+++ b/gcc/ddg.c	(revision 262353)
@@ -295,11 +295,14 @@
   /* Create inter-loop true dependences and anti dependences.  */
   for (r_use = DF_REF_CHAIN (last_def); r_use != NULL; r_use = r_use->next)
     {
+      if (DF_REF_BB (r_use->ref) != g->bb)
+	continue;
+
+      gcc_assert (!DF_REF_IS_ARTIFICIAL (r_use->ref)
+		  && DF_REF_INSN_INFO (r_use->ref) != NULL);
+
       rtx_insn *use_insn = DF_REF_INSN (r_use->ref);
 
-      if (BLOCK_FOR_INSN (use_insn) != g->bb)
-	continue;
-
       /* ??? Do not handle uses with DF_REF_IN_NOTE notes.  */
       use_node = get_node_of_insn (g, use_insn);
       gcc_assert (use_node);
Index: gcc/configure
===================================================================
diff --git a/gcc/configure b/gcc/configure
--- a/gcc/configure	(revision 262353)
+++ b/gcc/configure	(revision 262353)
@@ -11871,7 +11871,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
@@ -23571,6 +23571,14 @@
 
 
 fi
+case "$target" in
+  i?86-*-solaris2.10* | x86_64-*-solaris2.10*)
+    # SHF_MERGE support in Solaris 10/x86 ld is broken.
+    if test x"$gnu_ld" = xno; then
+      gcc_cv_as_shf_merge=no
+    fi
+    ;;
+esac
 
 cat >>confdefs.h <<_ACEOF
 #define HAVE_GAS_SHF_MERGE `if test $gcc_cv_as_shf_merge = yes; then echo 1; else echo 0; fi`
@@ -25217,6 +25225,7 @@
 
 fi
 
+
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for SPARC6 instructions" >&5
 $as_echo_n "checking assembler for SPARC6 instructions... " >&6; }
 if test "${gcc_cv_as_sparc_sparc6+set}" = set; then :
@@ -25253,6 +25262,7 @@
 
 fi
 
+
     { $as_echo "$as_me:${as_lineno-$LINENO}: checking assembler for LEON instructions" >&5
 $as_echo_n "checking assembler for LEON instructions... " >&6; }
 if test "${gcc_cv_as_sparc_leon+set}" = set; then :
@@ -29777,8 +29787,10 @@
 
 # Generate gcc-driver-name.h containing GCC_DRIVER_NAME for the benefit
 # of jit/jit-playback.c.
+gcc_driver_version=`eval "${get_gcc_base_ver} $srcdir/BASE-VER"`
+echo "gcc_driver_version: ${gcc_driver_version}"
 cat > gcc-driver-name.h <<EOF
-#define GCC_DRIVER_NAME "${target_noncanonical}-gcc-${gcc_BASEVER}${exeext}"
+#define GCC_DRIVER_NAME "${target_noncanonical}-gcc-${gcc_driver_version}${exeext}"
 EOF
 
 # Check whether --enable-default-pie was given.
Index: gcc/lra-eliminations.c
===================================================================
diff --git a/gcc/lra-eliminations.c b/gcc/lra-eliminations.c
--- a/gcc/lra-eliminations.c	(revision 262353)
+++ b/gcc/lra-eliminations.c	(revision 262353)
@@ -1178,7 +1178,7 @@
     if (bitmap_bit_p (&to_process, INSN_UID (insn)))
       {
 	lra_push_insn (insn);
-	lra_set_used_insn_alternative (insn, -1);
+	lra_set_used_insn_alternative (insn, LRA_UNKNOWN_ALT);
       }
   bitmap_clear (&to_process);
 }
@@ -1409,7 +1409,7 @@
 	}
       lra_update_insn_regno_info (insn);
       lra_push_insn (insn);
-      lra_set_used_insn_alternative (insn, -1);
+      lra_set_used_insn_alternative (insn, LRA_UNKNOWN_ALT);
     }
 }
 
Index: gcc/builtins.c
===================================================================
diff --git a/gcc/builtins.c b/gcc/builtins.c
--- a/gcc/builtins.c	(revision 262353)
+++ b/gcc/builtins.c	(revision 262353)
@@ -7538,8 +7538,7 @@
   const_tree argtype, parmtype;
   const_call_expr_arg_iterator iter;
 
-  if (TREE_CODE (t) != CALL_EXPR
-      || TREE_CODE (CALL_EXPR_FN (t)) != ADDR_EXPR)
+  if (TREE_CODE (t) != CALL_EXPR)
     return END_BUILTINS;
 
   fndecl = get_callee_fndecl (t);
@@ -9271,7 +9270,7 @@
       if (p2[0] == '\0')
 	/* strpbrk(x, "") == NULL.
 	   Evaluate and ignore s1 in case it had side-effects.  */
-	return omit_one_operand_loc (loc, TREE_TYPE (s1), integer_zero_node, s1);
+	return omit_one_operand_loc (loc, type, integer_zero_node, s1);
 
       if (p2[1] != '\0')
 	return NULL_TREE;  /* Really call strpbrk.  */
Index: gcc/final.c
===================================================================
diff --git a/gcc/final.c b/gcc/final.c
--- a/gcc/final.c	(revision 262353)
+++ b/gcc/final.c	(revision 262353)
@@ -906,7 +906,7 @@
   char *varying_length;
   rtx body;
   int uid;
-  rtx align_tab[MAX_CODE_ALIGN];
+  rtx align_tab[MAX_CODE_ALIGN + 1];
 
   /* Compute maximum UID and allocate label_align / uid_shuid.  */
   max_uid = get_max_uid ();
@@ -1015,7 +1015,7 @@
      alignment of n.  */
   uid_align = XCNEWVEC (rtx, max_uid);
 
-  for (i = MAX_CODE_ALIGN; --i >= 0;)
+  for (i = MAX_CODE_ALIGN + 1; --i >= 0;)
     align_tab[i] = NULL_RTX;
   seq = get_last_insn ();
   for (; seq; seq = PREV_INSN (seq))
Index: gcc/gcc.c
===================================================================
diff --git a/gcc/gcc.c b/gcc/gcc.c
--- a/gcc/gcc.c	(revision 262353)
+++ b/gcc/gcc.c	(revision 262353)
@@ -677,7 +677,7 @@
 
 #ifndef LIBASAN_SPEC
 #define STATIC_LIBASAN_LIBS \
-  " %{static-libasan:%:include(libsanitizer.spec)%(link_libasan)}"
+  " %{static-libasan|static:%:include(libsanitizer.spec)%(link_libasan)}"
 #ifdef LIBASAN_EARLY_SPEC
 #define LIBASAN_SPEC STATIC_LIBASAN_LIBS
 #elif defined(HAVE_LD_STATIC_DYNAMIC)
@@ -695,7 +695,7 @@
 
 #ifndef LIBTSAN_SPEC
 #define STATIC_LIBTSAN_LIBS \
-  " %{static-libtsan:%:include(libsanitizer.spec)%(link_libtsan)}"
+  " %{static-libtsan|static:%:include(libsanitizer.spec)%(link_libtsan)}"
 #ifdef LIBTSAN_EARLY_SPEC
 #define LIBTSAN_SPEC STATIC_LIBTSAN_LIBS
 #elif defined(HAVE_LD_STATIC_DYNAMIC)
@@ -713,7 +713,7 @@
 
 #ifndef LIBLSAN_SPEC
 #define STATIC_LIBLSAN_LIBS \
-  " %{static-liblsan:%:include(libsanitizer.spec)%(link_liblsan)}"
+  " %{static-liblsan|static:%:include(libsanitizer.spec)%(link_liblsan)}"
 #ifdef LIBLSAN_EARLY_SPEC
 #define LIBLSAN_SPEC STATIC_LIBLSAN_LIBS
 #elif defined(HAVE_LD_STATIC_DYNAMIC)
@@ -731,7 +731,7 @@
 
 #ifndef LIBUBSAN_SPEC
 #define STATIC_LIBUBSAN_LIBS \
-  " %{static-libubsan:%:include(libsanitizer.spec)%(link_libubsan)}"
+  " %{static-libubsan|static:%:include(libsanitizer.spec)%(link_libubsan)}"
 #ifdef HAVE_LD_STATIC_DYNAMIC
 #define LIBUBSAN_SPEC "%{static-libubsan:" LD_STATIC_OPTION \
 		     "} -lubsan %{static-libubsan:" LD_DYNAMIC_OPTION "}" \
@@ -6970,8 +6970,8 @@
 
     /* In final attempt we append compiler options and preprocesssed code to last
        generated .out file with configuration and backtrace.  */
-    char **output = &temp_stdout_files[RETRY_ICE_ATTEMPTS - 1];
-    do_report_bug (new_argv, nargs, stderr_commented, output);
+    char **err = &temp_stderr_files[RETRY_ICE_ATTEMPTS - 1];
+    do_report_bug (new_argv, nargs, stderr_commented, err);
   }
 
 out:
Index: gcc/tree-emutls.c
===================================================================
diff --git a/gcc/tree-emutls.c b/gcc/tree-emutls.c
--- a/gcc/tree-emutls.c	(revision 262353)
+++ b/gcc/tree-emutls.c	(revision 262353)
@@ -34,6 +34,7 @@
 #include "gimple-walk.h"
 #include "langhooks.h"
 #include "tree-iterator.h"
+#include "gimplify.h"
 
 /* Whenever a target does not support thread-local storage (TLS) natively,
    we can emulate it with some run-time support in libgcc.  This will in
@@ -430,6 +431,20 @@
   return addr;
 }
 
+/* Callback for lower_emutls_1, return non-NULL if there is any TLS
+   VAR_DECL in the subexpressions.  */
+
+static tree
+lower_emutls_2 (tree *ptr, int *walk_subtrees, void *)
+{
+  tree t = *ptr;
+  if (TREE_CODE (t) == VAR_DECL)
+    return DECL_THREAD_LOCAL_P (t) ? t : NULL_TREE;
+  else if (!EXPR_P (t))
+    *walk_subtrees = 0;
+  return NULL_TREE;
+}
+
 /* Callback for walk_gimple_op.  D = WI->INFO is a struct lower_emutls_data.
    Given an operand *PTR within D->STMT, if the operand references a TLS
    variable, then lower the reference to a call to the runtime.  Insert
@@ -456,6 +471,13 @@
 	{
 	  bool save_changed;
 
+	  /* Gimple invariants are shareable trees, so before changing
+	     anything in them if we will need to change anything, unshare
+	     them.  */
+	  if (is_gimple_min_invariant (t)
+	      && walk_tree (&TREE_OPERAND (t, 0), lower_emutls_2, NULL, NULL))
+	    *ptr = t = unshare_expr (t);
+
 	  /* If we're allowed more than just is_gimple_val, continue.  */
 	  if (!wi->val_only)
 	    {
Index: gcc/fold-const.c
===================================================================
diff --git a/gcc/fold-const.c b/gcc/fold-const.c
--- a/gcc/fold-const.c	(revision 262353)
+++ b/gcc/fold-const.c	(revision 262353)
@@ -473,12 +473,15 @@
     case EXACT_DIV_EXPR:
       if (TYPE_UNSIGNED (type))
 	break;
-      if (negate_expr_p (TREE_OPERAND (t, 0)))
+      /* In general we can't negate A in A / B, because if A is INT_MIN and
+         B is not 1 we change the sign of the result.  */
+      if (TREE_CODE (TREE_OPERAND (t, 0)) == INTEGER_CST
+	  && negate_expr_p (TREE_OPERAND (t, 0)))
 	return true;
       /* In general we can't negate B in A / B, because if A is INT_MIN and
 	 B is 1, we may turn this into INT_MIN / -1 which is undefined
 	 and actually traps on some architectures.  */
-      if (! INTEGRAL_TYPE_P (TREE_TYPE (t))
+      if (! ANY_INTEGRAL_TYPE_P (TREE_TYPE (t))
 	  || TYPE_OVERFLOW_WRAPS (TREE_TYPE (t))
 	  || (TREE_CODE (TREE_OPERAND (t, 1)) == INTEGER_CST
 	      && ! integer_onep (TREE_OPERAND (t, 1))))
@@ -652,7 +655,10 @@
     case EXACT_DIV_EXPR:
       if (TYPE_UNSIGNED (type))
 	break;
-      if (negate_expr_p (TREE_OPERAND (t, 0)))
+      /* In general we can't negate A in A / B, because if A is INT_MIN and
+	 B is not 1 we change the sign of the result.  */
+      if (TREE_CODE (TREE_OPERAND (t, 0)) == INTEGER_CST
+	  && negate_expr_p (TREE_OPERAND (t, 0)))
 	return fold_build2_loc (loc, TREE_CODE (t), type,
 				negate_expr (TREE_OPERAND (t, 0)),
 				TREE_OPERAND (t, 1));
@@ -659,7 +665,7 @@
       /* In general we can't negate B in A / B, because if A is INT_MIN and
 	 B is 1, we may turn this into INT_MIN / -1 which is undefined
 	 and actually traps on some architectures.  */
-      if ((! INTEGRAL_TYPE_P (TREE_TYPE (t))
+      if ((! ANY_INTEGRAL_TYPE_P (TREE_TYPE (t))
 	   || TYPE_OVERFLOW_WRAPS (TREE_TYPE (t))
 	   || (TREE_CODE (TREE_OPERAND (t, 1)) == INTEGER_CST
 	       && ! integer_onep (TREE_OPERAND (t, 1))))
@@ -7199,7 +7205,7 @@
 	return 0;
       offset += res;
       if (offset >= len)
-	return offset;
+	return (off == -1 && i < count - 1) ? 0 : offset;
       if (off != -1)
 	off = 0;
     }
@@ -14082,6 +14088,7 @@
     {
       tree op = TREE_OPERAND (sub, 0);
       tree optype = TREE_TYPE (op);
+
       /* *&CONST_DECL -> to the value of the const decl.  */
       if (TREE_CODE (op) == CONST_DECL)
 	return DECL_INITIAL (op);
@@ -14115,12 +14122,13 @@
 	       && type == TREE_TYPE (optype))
 	return fold_build1_loc (loc, REALPART_EXPR, type, op);
       /* *(foo *)&vectorfoo => BIT_FIELD_REF<vectorfoo,...> */
-      else if (TREE_CODE (optype) == VECTOR_TYPE
+      else if (VECTOR_TYPE_P (optype)
 	       && type == TREE_TYPE (optype))
 	{
 	  tree part_width = TYPE_SIZE (type);
 	  tree index = bitsize_int (0);
-	  return fold_build3_loc (loc, BIT_FIELD_REF, type, op, part_width, index);
+	  return fold_build3_loc (loc, BIT_FIELD_REF, type, op, part_width,
+				  index);
 	}
     }
 
@@ -14138,8 +14146,17 @@
 	  op00type = TREE_TYPE (op00);
 
 	  /* ((foo*)&vectorfoo)[1] => BIT_FIELD_REF<vectorfoo,...> */
-	  if (TREE_CODE (op00type) == VECTOR_TYPE
-	      && type == TREE_TYPE (op00type))
+	  if (VECTOR_TYPE_P (op00type)
+	      && type == TREE_TYPE (op00type)
+	      /* POINTER_PLUS_EXPR second operand is sizetype, unsigned,
+		 but we want to treat offsets with MSB set as negative.
+		 For the code below negative offsets are invalid and
+		 TYPE_SIZE of the element is something unsigned, so
+		 check whether op01 fits into HOST_WIDE_INT, which
+		 implies it is from 0 to INTTYPE_MAXIMUM (HOST_WIDE_INT), and
+		 then just use unsigned HOST_WIDE_INT because we want to treat
+		 the value as unsigned.  */
+	      && tree_fits_shwi_p (op01))
 	    {
 	      tree part_width = TYPE_SIZE (type);
 	      unsigned HOST_WIDE_INT max_offset
Index: gcc/lra-spills.c
===================================================================
diff --git a/gcc/lra-spills.c b/gcc/lra-spills.c
--- a/gcc/lra-spills.c	(revision 262353)
+++ b/gcc/lra-spills.c	(revision 262353)
@@ -503,7 +503,7 @@
 			 INSN_UID (insn));
 	      lra_push_insn (insn);
 	      if (lra_reg_spill_p || targetm.different_addr_displacement_p ())
-		lra_set_used_insn_alternative (insn, -1);
+		lra_set_used_insn_alternative (insn, LRA_UNKNOWN_ALT);
 	    }
 	  else if (CALL_P (insn)
 		   /* Presence of any pseudo in CALL_INSN_FUNCTION_USAGE
Index: gcc/omp-low.c
===================================================================
diff --git a/gcc/omp-low.c b/gcc/omp-low.c
--- a/gcc/omp-low.c	(revision 262353)
+++ b/gcc/omp-low.c	(revision 262353)
@@ -3261,6 +3261,43 @@
 
 /* Re-gimplification and code generation routines.  */
 
+/* Remove omp_member_access_dummy_var variables from gimple_bind_vars
+   of BIND if in a method.  */
+
+static void
+maybe_remove_omp_member_access_dummy_vars (gbind *bind)
+{
+  if (DECL_ARGUMENTS (current_function_decl)
+      && DECL_ARTIFICIAL (DECL_ARGUMENTS (current_function_decl))
+      && (TREE_CODE (TREE_TYPE (DECL_ARGUMENTS (current_function_decl)))
+	  == POINTER_TYPE))
+    {
+      tree vars = gimple_bind_vars (bind);
+      for (tree *pvar = &vars; *pvar; )
+	if (omp_member_access_dummy_var (*pvar))
+	  *pvar = DECL_CHAIN (*pvar);
+	else
+	  pvar = &DECL_CHAIN (*pvar);
+      gimple_bind_set_vars (bind, vars);
+    }
+}
+
+/* Remove omp_member_access_dummy_var variables from BLOCK_VARS of
+   block and its subblocks.  */
+
+static void
+remove_member_access_dummy_vars (tree block)
+{
+  for (tree *pvar = &BLOCK_VARS (block); *pvar; )
+    if (omp_member_access_dummy_var (*pvar))
+      *pvar = DECL_CHAIN (*pvar);
+    else
+      pvar = &DECL_CHAIN (*pvar);
+
+  for (block = BLOCK_SUBBLOCKS (block); block; block = BLOCK_CHAIN (block))
+    remove_member_access_dummy_vars (block);
+}
+
 /* If a context was created for STMT when it was scanned, return it.  */
 
 static omp_context *
@@ -7002,6 +7039,7 @@
   pop_gimplify_context (new_stmt);
 
   gimple_bind_append_vars (new_stmt, ctx->block_vars);
+  maybe_remove_omp_member_access_dummy_vars (new_stmt);
   BLOCK_VARS (block) = gimple_bind_vars (new_stmt);
   if (BLOCK_VARS (block))
     TREE_USED (block) = 1;
@@ -7452,6 +7490,7 @@
   /* Declare all the variables created by mapping and the variables
      declared in the scope of the parallel body.  */
   record_vars_into (ctx->block_vars, child_fn);
+  maybe_remove_omp_member_access_dummy_vars (par_bind);
   record_vars_into (gimple_bind_vars (par_bind), child_fn);
 
   if (ctx->record_type)
@@ -7820,6 +7859,7 @@
       /* Declare all the variables created by mapping and the variables
 	 declared in the scope of the target body.  */
       record_vars_into (ctx->block_vars, child_fn);
+      maybe_remove_omp_member_access_dummy_vars (tgt_bind);
       record_vars_into (gimple_bind_vars (tgt_bind), child_fn);
     }
 
@@ -8811,6 +8851,7 @@
       break;
     case GIMPLE_BIND:
       lower_omp (gimple_bind_body_ptr (as_a <gbind *> (stmt)), ctx);
+      maybe_remove_omp_member_access_dummy_vars (as_a <gbind *> (stmt));
       break;
     case GIMPLE_OMP_PARALLEL:
     case GIMPLE_OMP_TASK:
@@ -9015,6 +9056,16 @@
       all_contexts = NULL;
     }
   BITMAP_FREE (task_shared_vars);
+
+  /* If current function is a method, remove artificial dummy VAR_DECL created
+     for non-static data member privatization, they aren't needed for
+     debuginfo nor anything else, have been already replaced everywhere in the
+     IL and cause problems with LTO.  */
+  if (DECL_ARGUMENTS (current_function_decl)
+      && DECL_ARTIFICIAL (DECL_ARGUMENTS (current_function_decl))
+      && (TREE_CODE (TREE_TYPE (DECL_ARGUMENTS (current_function_decl)))
+	  == POINTER_TYPE))
+    remove_member_access_dummy_vars (DECL_INITIAL (current_function_decl));
   return 0;
 }
 
Index: gcc/reorg.c
===================================================================
diff --git a/gcc/reorg.c b/gcc/reorg.c
--- a/gcc/reorg.c	(revision 262353)
+++ b/gcc/reorg.c	(revision 262353)
@@ -1035,7 +1035,8 @@
 
 static void
 steal_delay_list_from_target (rtx_insn *insn, rtx condition, rtx_sequence *seq,
-			      vec<rtx_insn *> *delay_list, resources *sets,
+			      vec<rtx_insn *> *delay_list,
+			      struct resources *sets,
 			      struct resources *needed,
 			      struct resources *other_needed,
 			      int slots_to_fill, int *pslots_filled,
@@ -1048,7 +1049,7 @@
   int used_annul = 0;
   int i;
   struct resources cc_set;
-  bool *redundant;
+  rtx_insn **redundant;
 
   /* We can't do anything if there are more delay slots in SEQ than we
      can handle, or if we don't know that it will be a taken branch.
@@ -1087,7 +1088,7 @@
   if (! targetm.can_follow_jump (insn, seq->insn (0)))
     return;
 
-  redundant = XALLOCAVEC (bool, XVECLEN (seq, 0));
+  redundant = XALLOCAVEC (rtx_insn *, XVECLEN (seq, 0));
   for (i = 1; i < seq->len (); i++)
     {
       rtx_insn *trial = seq->insn (i);
@@ -1151,7 +1152,10 @@
      we therefore decided not to copy.  */
   for (i = 1; i < seq->len (); i++)
     if (redundant[i])
-      update_block (seq->insn (i), insn);
+      {
+	fix_reg_dead_note (redundant[i], insn);
+	update_block (seq->insn (i), insn);
+      }
 
   /* Show the place to which we will be branching.  */
   *pnew_thread = first_active_target_insn (JUMP_LABEL (seq->insn (0)));
@@ -1198,6 +1202,7 @@
   for (i = 1; i < seq->len (); i++)
     {
       rtx_insn *trial = seq->insn (i);
+      rtx_insn *prior_insn;
 
       /* If TRIAL sets CC0, stealing it will move it too far from the use
 	 of CC0.  */
@@ -1209,8 +1214,9 @@
 	break;
 
       /* If this insn was already done, we don't need it.  */
-      if (redundant_insn (trial, insn, *delay_list))
+      if ((prior_insn = redundant_insn (trial, insn, *delay_list)))
 	{
+	  fix_reg_dead_note (prior_insn, insn);
 	  update_block (trial, insn);
 	  delete_from_delay_slot (trial);
 	  continue;
@@ -1790,15 +1796,14 @@
       }
 }
 
-/* Delete any REG_UNUSED notes that exist on INSN but not on REDUNDANT_INSN.
+/* Delete any REG_UNUSED notes that exist on INSN but not on OTHER_INSN.
 
    This handles the case of udivmodXi4 instructions which optimize their
-   output depending on whether any REG_UNUSED notes are present.
-   we must make sure that INSN calculates as many results as REDUNDANT_INSN
-   does.  */
+   output depending on whether any REG_UNUSED notes are present.  We must
+   make sure that INSN calculates as many results as OTHER_INSN does.  */
 
 static void
-update_reg_unused_notes (rtx_insn *insn, rtx redundant_insn)
+update_reg_unused_notes (rtx_insn *insn, rtx other_insn)
 {
   rtx link, next;
 
@@ -1810,8 +1815,7 @@
 	  || !REG_P (XEXP (link, 0)))
 	continue;
 
-      if (! find_regno_note (redundant_insn, REG_UNUSED,
-			     REGNO (XEXP (link, 0))))
+      if (!find_regno_note (other_insn, REG_UNUSED, REGNO (XEXP (link, 0))))
 	remove_note (insn, link);
     }
 }
@@ -2324,9 +2328,8 @@
    taken and THREAD_IF_TRUE is set.  This is used for the branch at the
    end of a loop back up to the top.
 
-   OWN_THREAD and OWN_OPPOSITE_THREAD are true if we are the only user of the
-   thread.  I.e., it is the fallthrough code of our jump or the target of the
-   jump when we are the only jump going there.
+   OWN_THREAD is true if we are the only user of the thread, i.e. it is
+   the target of the jump when we are the only jump going there.
 
    If OWN_THREAD is false, it must be the "true" thread of a jump.  In that
    case, we can only take insns from the head of the thread for our delay
@@ -3117,7 +3120,7 @@
   /* Look at every JUMP_INSN and see if we can improve it.  */
   for (insn = first; insn; insn = next)
     {
-      rtx_insn *other;
+      rtx_insn *other, *prior_insn;
       bool crossing;
 
       next = next_active_insn (insn);
@@ -3223,8 +3226,9 @@
       /* See if the first insn in the delay slot is redundant with some
 	 previous insn.  Remove it from the delay slot if so; then set up
 	 to reprocess this insn.  */
-      if (redundant_insn (pat->insn (1), delay_insn, vNULL))
+      if ((prior_insn = redundant_insn (pat->insn (1), delay_insn, vNULL)))
 	{
+	  fix_reg_dead_note (prior_insn, insn);
 	  update_block (pat->insn (1), insn);
 	  delete_from_delay_slot (pat->insn (1));
 	  next = prev_active_insn (next);
Index: gcc/tree-ssa-sccvn.c
===================================================================
diff --git a/gcc/tree-ssa-sccvn.c b/gcc/tree-ssa-sccvn.c
--- a/gcc/tree-ssa-sccvn.c	(revision 262353)
+++ b/gcc/tree-ssa-sccvn.c	(revision 262353)
@@ -1245,7 +1245,9 @@
 	  return true;
 	}
       if (!addr_base
-	  || TREE_CODE (addr_base) != MEM_REF)
+	  || TREE_CODE (addr_base) != MEM_REF
+	  || (TREE_CODE (TREE_OPERAND (addr_base, 0)) == SSA_NAME
+	      && SSA_NAME_OCCURS_IN_ABNORMAL_PHI (TREE_OPERAND (addr_base, 0))))
 	return false;
 
       off += addr_offset;
@@ -1258,6 +1260,7 @@
       ptr = gimple_assign_rhs1 (def_stmt);
       ptroff = gimple_assign_rhs2 (def_stmt);
       if (TREE_CODE (ptr) != SSA_NAME
+	  || SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ptr)
 	  || TREE_CODE (ptroff) != INTEGER_CST)
 	return false;
 
@@ -1978,8 +1981,9 @@
 	  if (TREE_CODE (rhs) == SSA_NAME)
 	    rhs = SSA_VAL (rhs);
 	  len = native_encode_expr (gimple_assign_rhs1 (def_stmt),
-				    buffer, sizeof (buffer));
-	  if (len > 0)
+				    buffer, sizeof (buffer),
+				    (offset - offset2) / BITS_PER_UNIT);
+	  if (len > 0 && len * BITS_PER_UNIT >= ref->size)
 	    {
 	      tree type = vr->type;
 	      /* Make sure to interpret in a type that has a range
@@ -1988,10 +1992,7 @@
 		  && ref->size != TYPE_PRECISION (vr->type))
 		type = build_nonstandard_integer_type (ref->size,
 						       TYPE_UNSIGNED (type));
-	      tree val = native_interpret_expr (type,
-						buffer
-						+ ((offset - offset2)
-						   / BITS_PER_UNIT),
+	      tree val = native_interpret_expr (type, buffer,
 						ref->size / BITS_PER_UNIT);
 	      /* If we chop off bits because the types precision doesn't
 		 match the memory access size this is ok when optimizing
Index: gcc/ChangeLog
===================================================================
diff --git a/gcc/ChangeLog b/gcc/ChangeLog
--- a/gcc/ChangeLog	(revision 262353)
+++ b/gcc/ChangeLog	(revision 262353)
@@ -1,3 +1,1713 @@
+2018-06-29  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-01-10  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	* lex.c (search_line_fast): Remove illegal coercion of an
+	unaligned pointer value to vector pointer type and replace with
+	use of __builtin_vec_vsx_ld () built-in function, which operates
+	on unaligned pointer values.
+
+2018-06-27  David Edelsohn  <dje.gcc@gmail.com>
+
+	2018-06-19  Tony Reix  <tony.reix@atos.com>
+	    Damien Bergamini  <damien.bergamini@atos.com>
+	    David Edelsohn  <dje.gcc@gmail.com>
+
+	* collect2.c (static_obj): New variable.
+	(static_libs): New variable.
+	(is_in_list): Uncomment declaration.
+	(main): Track AIX libraries linked statically.
+	(is_in_list): Uncomment definition.
+	(scan_prog_file): Don't add AIX shared libraries initializer
+	to constructor list if linking statically.
+
+2018-06-26  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backported from mainline
+	2018-06-20  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	* config/rs6000/rs6000-c.c (altivec_overloaded_builtins): Change
+	behavior of vec_packsu (vector unsigned long long, vector unsigned
+	long long) to match behavior of vec_packs with same signature.
+
+2018-06-26  Robin Dapp  <rdapp@linux.vnet.ibm.com>
+
+	* config/s390/s390.h (enum processor_flags): Do not use
+	default tune parameter when -march was specified.
+
+2018-06-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/86314
+	* config/i386/i386.md (setcc + movzbl to xor + setcc peephole2s):
+	Check reg_overlap_mentioned_p in addition to reg_set_p with the same
+	operands.
+
+2018-06-25  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk
+	2018-04-17  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/85424
+	* config/rs6000/rs6000.md (pack<mode>): Do not try handle a pack
+	where the inputs overlap with the output.
+
+2018-06-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84786
+	* config/i386/sse.md (vshift_count): New mode attr.
+	(<shift_insn><mode>3<mask_name>): Use <vshift_count>N instead of vN
+	as last operand's constraint for VI2_AVX2_AVX512BW shifts.  Use YvN
+	instead of vN as last operand's constraint for VI48_AVX2 shifts.
+
+2018-06-23  Richard Sandiford  <richard.sandiford@linaro.org>
+
+	PR tree-optimization/85989
+	* gimple-ssa-backprop.c (backprop::m_visited_phis): New member
+	variable.
+	(backprop::intersect_uses): Check it when deciding whether this
+	is a backedge reference.
+	(backprop::process_block): Add each phi to m_visited_phis
+	after visiting it, then clear it at the end.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-06-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/86231
+	* tree-vrp.c (union_ranges): For (  [  )  ] or (   )[   ] range and
+	anti-range don't overwrite *vr0min before using it to compute *vr0max.
+
+	2018-06-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/85878
+	* expr.c (expand_assignment): Only call store_expr for halves if the
+	mode is the same.
+
+	2018-06-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/85945
+	* lower-subreg.c (find_decomposable_subregs): Don't decompose float
+	subregs of multi-word pseudos unless the float mode has word size.
+
+	2018-06-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/86025
+	* tree.c (inchash::add_expr): Handle IDENTIFIER_NODE.
+
+	2018-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85659
+	* cfgexpand.c (expand_asm_stmt): Don't create a temporary if
+	the type is addressable.  Don't force op into register if it has
+	BLKmode.
+
+	2018-05-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR web/85578
+	* doc/install.texi2html: Replace _002d with - and _002a with * in
+	generated html files using sed.
+
+	2018-04-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/85529
+	* tree-ssa-reassoc.c (optimize_range_tests_var_bound): Add FIRST_BB
+	argument.  Don't call get_nonzero_bits if opcode is ERROR_MARK_NODE,
+	rhs2 def stmt's bb is dominated by first_bb and it isn't an obvious
+	zero extension or masking of the MSB bit.
+	(optimize_range_tests): Add FIRST_BB argument, pass it through
+	to optimize_range_tests_var_bound.
+	(maybe_optimize_range_tests, reassociate_bb): Adjust
+	optimize_range_tests callers.
+
+	2018-04-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/85446
+	* match.pd ((intptr_t) x eq/ne CST to x eq/ne (typeof x) cst): Require
+	the integral and pointer types to have the same precision.
+
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure.ac (gcc-driver-name.h): Honor --with-gcc-major-version
+	by using gcc_base_ver to generate a gcc_driver_version, and use
+	it when generating GCC_DRIVER_NAME.
+	* configure: Regenerate.
+
+	2018-04-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/85431
+	* dse.c (record_store): Ignore zero width stores.
+
+	PR target/85430
+	* config/i386/i386.md (*ashlqi3_1_slp): Use alu1 type instead of alu.
+
+	2018-04-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/85300
+	* combine.c (subst): Handle subst of CONST_SCALAR_INT_P new_rtx also
+	into FLOAT and UNSIGNED_FLOAT like ZERO_EXTEND, return a CLOBBER if
+	simplify_unary_operation fails.
+
+	2018-04-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/85257
+	* fold-const.c (native_encode_vector): If not all elts could fit
+	and off is -1, return 0 rather than offset.
+	* tree-ssa-sccvn.c (vn_reference_lookup_3): Pass
+	(offset - offset2) / BITS_PER_UNIT as 4th argument to
+	native_encode_expr.  Verify len * BITS_PER_UNIT >= maxsizei.  Don't
+	adjust buffer in native_interpret_expr call.
+
+	2018-04-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/85252
+	* dwarf2out.c (rtl_for_decl_init): For STRING_CST initializer only
+	build CONST_STRING if TYPE_MAX_VALUE is non-NULL and is INTEGER_CST.
+
+	2018-04-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/85167
+	* shrink-wrap.c (move_insn_for_shrink_wrap): Don't set bb_uses and
+	bb_defs if *split_p, instead preinitialize it to NULL.
+
+	2018-03-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/85095
+	* config/i386/i386.md (*add<mode>3_carry_0, *addsi3_carry_zext_0,
+	*sub<mode>3_carry_0, *subsi3_carry_zext_0): New patterns.
+
+	2018-03-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/85022
+	* emit-rtl.c (init_emit_regs): Indicate that VOIDmode MEMs don't have
+	known size by default.
+
+	PR inline-asm/85034
+	* function.c (match_asm_constraints_1): Don't optimize if input
+	doesn't satisfy general_operand predicate for output's mode.
+
+	PR inline-asm/85022
+	* alias.c (write_dependence_p): Don't require for x_canonicalized
+	non-VOIDmode if x has VOIDmode.
+
+	2018-03-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/84941
+	* function.c (match_asm_constraints_1): Don't do the optimization
+	if input isn't a REG, SUBREG, MEM or constant.
+
+	PR sanitizer/85018
+	* dwarf2asm.c (dw2_output_indirect_constant_1): Set
+	DECL_INITIAL (decl) to decl at the end.
+	* varasm.c (use_blocks_for_decl_p): Revert the 2018-03-20 change,
+	adjust the comment.
+
+	2018-03-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/84875
+	* dce.c (delete_unmarked_insns): Don't remove frame related noop moves
+	holding REG_CFA_RESTORE notes, instead turn them into a USE.
+
+	PR c/84953
+	* builtins.c (fold_builtin_strpbrk): For strpbrk(x, "") use type
+	instead of TREE_TYPE (s1) for the return value.
+
+	PR target/84990
+	* dwarf2asm.c (dw2_output_indirect_constant_1): Temporarily turn off
+	flag_section_anchors.
+	* varasm.c (use_blocks_for_decl_p): Remove hack for
+	dw2_force_const_mem.
+
+	2018-03-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/78651
+	* dwarf2asm.c: Include fold-const.c.
+	(dw2_output_indirect_constant_1): Set DECL_INITIAL (decl) to ADDR_EXPR
+	of decl rather than decl itself.
+
+	2018-03-19  Maxim Ostapenko  <m.ostapenko@samsung.com>
+
+	PR sanitizer/78651
+	* dwarf2asm.c (dw2_output_indirect_constant_1): Disable ASan before
+	calling assemble_variable.
+
+	2018-03-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84899
+	* postreload.c (reload_combine_recognize_pattern): Perform
+	INTVAL addition in unsigned HOST_WIDE_INT type to avoid UB and
+	truncate_int_for_mode the result for the destination's mode.
+
+	PR tree-optimization/84841
+	* tree-ssa-reassoc.c (INTEGER_CONST_TYPE): Change to 1 << 4 from
+	1 << 3.
+	(FLOAT_ONE_CONST_TYPE): Define.
+	(constant_type): Return FLOAT_ONE_CONST_TYPE for -1.0 and 1.0.
+	(sort_by_operand_rank): Put entries with higher constant_type last
+	rather than first to match comments.
+
+	2018-03-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/79085
+	* calls.c (expand_call): For TREE_ADDRESSABLE rettype ignore alignment
+	check and use address of target always.
+
+	PR target/84860
+	* optabs.c (emit_conditional_move): Pass address of cmode's copy
+	rather than address of cmode as last argument to prepare_cmp_insn.
+
+	2018-03-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/84834
+	* match.pd ((A & C) != 0 ? D : 0): Use INTEGER_CST@2 instead of
+	integer_pow2p@2 and test integer_pow2p in condition.
+	(A < 0 ? C : 0): Similarly for @1.
+
+	PR target/84827
+	* config/i386/i386.md (round<mode>2): For 387 fancy math, disable
+	pattern if -ftrapping-math -fno-fp-int-builtin-inexact.
+
+	PR target/84786
+	* config/i386/sse.md (sse2_loadhpd): Use Yv constraint rather than v
+	on the last operand.
+
+	2018-03-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84772
+	* config/rs6000/rs6000.c (rs6000_gimplify_va_arg): Mark va_arg_tmp
+	temporary TREE_ADDRESSABLE before gimplification of BUILT_IN_MEMCPY.
+
+	PR c++/84767
+	* tree-inline.c (copy_tree_body_r): For INDIRECT_REF of a remapped
+	decl, use remap_type if we want to use the type.
+
+	2018-03-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/84739
+	* tree-tailcall.c (find_tail_calls): Check call arguments against
+	DECL_ARGUMENTS (current_function_decl) rather than
+	DECL_ARGUMENTS (func) when checking for tail recursion.
+
+	2018-03-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84700
+	* combine.c (combine_simplify_rtx): Don't try to simplify if
+	if_then_else_cond returned non-NULL, but either true_rtx or false_rtx
+	are equal to x.
+
+2018-06-22  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backport from mainline
+	2018-06-05  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	* config/arm/arm_cmse.h (cmse_nsfptr_create): Change typeof to
+	__typeof__.
+	(cmse_check_pointed_object): Likewise.
+
+2018-06-22  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backport from mainline
+	2018-05-17  Jerome Lambourg  <lambourg@adacore.com>
+
+	* config/arm/arm_cmse.h (cmse_nsfptr_create, cmse_is_nsfptr): Remove
+	#include <stdint.h>.  Replace intptr_t with __INTPTR_TYPE__.
+
+2018-06-21  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	Backport from mainline
+	2018-06-15  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* config.gcc (riscv*-*-elf* | riscv*-*-rtems*): Use custom
+	multilibs for *-*-rtems*.
+	* config/riscv/t-rtems: New file.
+
+2018-06-19  Max Filippov  <jcmvbkbc@gmail.com>
+
+	Backport from mainline
+	2018-06-19  Max Filippov  <jcmvbkbc@gmail.com>
+
+	* config/xtensa/xtensa.md (UNSPEC_FRAME_BLOCKAGE): New unspec
+	constant.
+	(allocate_stack, frame_blockage, *frame_blockage): New patterns.
+
+2018-06-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gimplify.c (gimplify_init_constructor): Really never clear for an
+	incomplete constructor if CONSTRUCTOR_NO_CLEARING is set.
+
+2018-06-18  Martin Sebor  <msebor@redhat.com>
+
+        PR middle-end/82063
+        * calls.c (alloc_max_size): Correct a logic error/typo.
+        Treat excessive arguments as infinite.  Warn for invalid arguments.
+        * doc/invoke.texi (-Walloc-size-larger-than): Update.
+
+2018-06-14  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	Backport from mainline
+	2018-06-14  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* config/rtems.h (STDINT_LONG32): Define.
+
+2018-06-11  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-06-08  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/85755
+	* config/rs6000/rs6000.c (mem_operand_gpr): Enable PRE_INC and PRE_DEC
+	addresses.
+
+2018-06-07  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-06-06  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/63177
+	* /config/rs6000/rs6000.h (ASM_CPU_SPEC): Add support for -mpower9.
+	Don't handle -mcpu=power8 if -mpower9-vector is also used.
+
+2018-06-07  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-05-04  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/85588
+	* fold-const.c (negate_expr_p): Restrict negation of operand
+	zero of a division to when we know that can happen without
+	overflow.
+	(fold_negate_expr_1): Likewise.
+
+	2018-05-02  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/85567
+	* gimplify.c (gimplify_save_expr): When in SSA form allow
+	SAVE_EXPRs to compute to SSA vars.
+
+	2018-05-02  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/85597
+	* tree-vect-stmts.c (vectorizable_operation): For ternary SLP
+	do not use split vect_get_vec_defs call but call vect_get_slp_defs
+	directly.
+
+2018-06-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2018-06-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* config/s390/s390-builtin-types.def: Add void function type.
+	* config/s390/s390-builtins.def: Use the function type for the
+	tbeginc builtin.
+
+2018-06-01  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR tree-optimization/85712
+	Backport from mainline:
+	2018-05-23  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR tree-optimization/85712
+	* gimple-ssa-strength-reduction.c (struct slsr_cand_d): Add
+	first_interp field.
+	(alloc_cand_and_find_basis): Initialize first_interp field.
+	(slsr_process_mul): Modify first_interp field.
+	(slsr_process_add): Likewise.
+	(slsr_process_cast): Modify first_interp field for each new
+	interpretation.
+	(slsr_process_copy): Likewise.
+	(dump_candidate): Dump first_interp field.
+	(replace_mult_candidate): Process all interpretations, not just
+	subsequent ones.
+	(replace_rhs_if_not_dup): Likewise.
+	(replace_one_candidate): Likewise.
+
+	Backport from mainline:
+	2018-05-25  Bill Schmidt  <wschmidt@linux.ibm.com>
+
+	PR tree-optimization/85712
+	* gimple-ssa-strength-reduction.c (replace_one_candidate): Skip if
+	this candidate has already been replaced in-situ by a copy.
+
+2018-05-24  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/sse.md (cvtusi2<ssescalarmodesuffix>64<round_name>):
+	Add {q} suffix to insn mnemonic.
+
+2018-05-24  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/85903
+	* config/i386/sse.md (movdi_to_sse): Do not generate pseudo
+	when memory input operand is handled.
+
+2018-05-21  Pat Haugen  <pthaugen@us.ibm.com>
+
+	Backport from mainline
+	2018-05-17  Pat Haugen  <pthaugen@us.ibm.com>
+		    Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/85698
+	* config/rs6000/rs6000.c (rs6000_output_move_128bit): Check
+	dest operand.
+
+2018-05-17  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2018-05-11  Martin Jambor  <mjambor@suse.cz>
+
+	PR ipa/85655
+	* ipa-cp.c (intersect_with_plats): Check that the lattice contains
+	single const.
+
+2018-05-01  Tom de Vries  <tom@codesourcery.com>
+
+	backport from trunk:
+	2018-04-16  Cesar Philippidis  <cesar@codesourcery.com>
+		    Tom de Vries  <tom@codesourcery.com>
+
+	PR middle-end/84955
+	* omp-expand.c (expand_oacc_for): Add dummy false branch for
+	tiled basic blocks without omp continue statements.
+
+2018-04-26  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-04-09  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/85284
+	* tree-ssa-loop-niter.c (number_of_iterations_exit_assumptions):
+	Only use the niter constraining form of simple_iv when the exit
+	is always executed.
+
+	2018-04-06  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/85244
+	* tree-dfa.c (get_ref_base_and_extent): Reset seen_variable_array_ref
+	after seeing a component reference with an adjacent field.  Treat
+	refs to arrays at struct end of external decls similar to
+	refs to unconstrained commons.
+
+	2018-04-04  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/85168
+	* tree-ssa-sccvn.c (vn_reference_maybe_forwprop_address): Avoid
+	propagating abnormals.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-04-17  Martin Liska  <mliska@suse.cz>
+
+	PR lto/85405
+	* ipa-devirt.c (odr_types_equivalent_p): Remove trailing
+	in message, remote space in between '_G' and '('.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-04-17  Jan Hubicka  <jh@suse.cz>
+
+	PR lto/85405
+	* ipa-devirt.c (odr_types_equivalent_p): Handle bit fields.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-03-28  Jakub Jelinek  <jakub@redhat.com>
+		    Martin Liska  <mliska@suse.cz>
+
+	PR sanitizer/85081
+	* gimplify.c (asan_poison_variable): Don't do the check for
+	gimplify_omp_ctxp here.
+	(gimplify_decl_expr): Do it here.
+	(gimplify_target_expr): Likewise.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-03-21  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/84963
+	* ipa-icf.c (sem_item_optimizer::fixup_points_to_sets): Remove
+	not intended return statement.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-03-13  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/84658.
+	* (sem_item_optimizer::sem_item_optimizer): Initialize new
+	vector.
+	(sem_item_optimizer::~sem_item_optimizer): Release it.
+	(sem_item_optimizer::merge_classes): Register variable aliases.
+	(sem_item_optimizer::fixup_pt_set): New function.
+	(sem_item_optimizer::fixup_points_to_sets): Likewise.
+	* ipa-icf.h: Declare new variables and functions.
+
+2018-04-23  Aaron Sawdey  <acsawdey@linux.ibm.com>
+
+	Backport from mainline
+	2018-04-16  Aaron Sawdey  <acsawdey@linux.ibm.com>
+
+	PR target/83660
+	* config/rs6000/rs6000-c.c (altivec_resolve_overloaded_builtin): Mark
+	vec_extract expression as having side effects to make sure it gets
+	a cleanup point.
+
+2018-04-23  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR middle-end/85496
+	* expr.c (store_field): In the bitfield case, if the value comes from
+	a function call and is returned in registers by means of a PARALLEL,
+	do not change the mode of the temporary unless BLKmode and VOIDmode.
+
+2018-04-20  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-03-09  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/83969
+	* config/rs6000/rs6000.c (rs6000_offsettable_memref_p): New prototype.
+	Add strict argument and use it.
+	(rs6000_split_multireg_move): Update for new strict argument.
+	(mem_operand_gpr): Disallow all non-offsettable addresses.
+	* config/rs6000/rs6000.md (*movdi_internal64): Use YZ constraint.
+
+2018-04-18  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2018-04-11  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	PR target/85261
+	* config/arm/arm-builtins.c (arm_expand_builtin): Force input operand
+	into register.
+
+2018-04-12  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-04-12  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/s390.c (s390_output_indirect_thunk_function): Check
+	also for flag_dwarf2_cfi_asm.
+
+2018-04-11  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/alpha/alpha.md (stack_probe_internal): Rename
+	from "probe_stack".  Update all callers.
+
+2018-04-11  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2018-04-04  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	PR target/85203
+	* config/arm/arm-builtins.c (arm_expand_builtin): Change
+	expansion to perform a bitwise AND of the argument followed by a
+	boolean negation of the result.
+
+2018-04-10  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2018-03-08  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/84748
+	* config/aarch64/aarch64.md (*compare_cstore<mode>_insn): Mark pattern
+	as clobbering CC_REGNUM.
+
+2018-04-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR target/85196
+	* config/sparc/sparc.c (sparc_expand_move): Deal with symbolic operands
+	based on LABEL_REF.  Remove useless assertion.
+	(pic_address_needs_scratch): Fix formatting.
+	(sparc_legitimize_pic_address): Minor tweaks.
+	(sparc_delegitimize_address): Adjust assertion accordingly.
+	* config/sparc/sparc.md (movsi_pic_label_ref): Change label_ref_operand
+	into symbolic_operand.
+	(movsi_high_pic_label_ref): Likewise.
+	(movsi_lo_sum_pic_label_ref): Likewise.
+	(movdi_pic_label_ref): Likewise.
+	(movdi_high_pic_label_ref): Likewise.
+	(movdi_lo_sum_pic_label_ref): Likewise.
+
+2018-04-06  Amaan Cheval  <amaan.cheval@gmail.com>
+
+	* config.gcc (x86_64-*-rtems*): Add rtems.h to tm_file for
+	custom LIB_SPEC setup.
+
+2018-04-05  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/85193
+	* config/i386/i386.md (define_attr "memory"): Handle rotate1 type.
+
+2018-04-04  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-04-04  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR rtl-optimization/84878
+	* ddg.c (add_cross_iteration_register_deps): Use DF_REF_BB to determine
+	the basic block.  Assert the use reference is not artificial and that
+	it has an associated insn.
+
+2018-04-03  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/i386.c (emit_i387_cw_initialization): Always use logic
+	instructions when changing rounding bits to preserve precision bits
+	in the x87 control word.
+
+2018-04-03  Cesar Philippidis  <cesar@codesourcery.com>
+
+	Backport from mainline
+	2018-03-27  Cesar Philippidis  <cesar@codesourcery.com>
+
+	PR target/85056
+	* config/nvptx/nvptx.c (nvptx_assemble_decl_begin): Add '[]' to
+	extern array declarations.
+
+2018-04-02  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-03-28  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/84912
+	* config/rs6000/rs6000.h: Update copyright date.
+	(RS6000_BTM_POWERPC64): New define.
+	(RS6000_BTM_COMMON): Add RS6000_BTM_POWERPC64.
+	* config/rs6000/rs6000.c: Update copyright date.
+	(rs6000_builtin_mask_calculate): Add support for RS6000_BTM_POWERPC64.
+	(rs6000_invalid_builtin): Add handling for RS6000_BTM_POWERPC64
+	(rs6000_builtin_mask_names): Add RS6000_BTM_POWERPC64.
+	* config/rs6000/rs6000-builtin.def: Update copyright date.
+	(BU_P7_POWERPC64_MISC_2): New macro definition.
+	(DIVDE): Use it.
+	(DIVDEU): Likewise.
+
+	Backport from mainline
+	2018-03-28  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/84912
+	* config/rs6000/rs6000-builtin.def (DIVWEO): Delete macro expansion.
+	(DIVWEUO): Likewise.
+	(DIVDEO): Likewise.
+	(DIVDEUO): Likewise.
+	* config/rs6000/rs6000.c (builtin_function_type): Remove support for
+	DIVWEUO and DIVDEUO.
+	* config/rs6000/rs6000.md: Update copyright date.
+	(UNSPEC_DIVEO, UNSPEC_DIVEUO): Delete unspecs.
+	(UNSPEC_DIV_EXTEND): Remove deleted unspecs.
+	(div_extend): Likewise.
+	* doc/extend.texi: Update copyright date.
+	(__builtin_divweo): Remove documentation for deleted builtin function.
+	(__builtin_divweuo): Likewise.
+	(__builtin_divdeo): Likewise.
+	(__builtin_divdeuo): Likewise.
+
+2018-04-02  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-03-30  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/80546
+	* config/rs6000/vsx.md (??r): New mode attribute.
+	(*vsx_mov<mode>_64bit): Use it.
+	(*vsx_mov<mode>_32bit): Likewise.
+
+2018-03-29  Sebastian Peryt  <sebastian.peryt@intel.com>
+
+	PR c++/84783
+	* config/i386/avx512vlintrin.h (_mm256_permutexvar_epi64)
+	(_mm256_permutexvar_epi32, _mm256_permutex_epi64): New intrinsics.
+
+2018-03-29  Sudakshina Das  <sudi.das@arm.com>
+
+	Backport from mainline
+	2018-03-22  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/84826
+	* config/arm/arm.h (machine_function): Add static_chain_stack_bytes.
+	* config/arm/arm.c (arm_compute_static_chain_stack_bytes): Avoid
+	re-computing once computed.
+	(arm_expand_prologue): Compute machine->static_chain_stack_bytes.
+	(arm_init_machine_status): Initialize
+	machine->static_chain_stack_bytes.
+
+2018-03-28  Sudakshina Das  <sudi.das@arm.com>
+
+	2018-03-19  Sudakshina Das  <sudi.das@arm.com>
+	PR target/81647
+
+	* config/aarch64/aarch64-simd.md (vec_cmp<mode><v_cmp_result>): Modify
+	instructions for UNLT, UNLE, UNGT, UNGE, UNEQ, UNORDERED and ORDERED.
+
+2018-03-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2018-03-23  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/85026
+	* config/arm/arm.md (unaligned_loadhis): Remove first alternative.
+	Clean up attributes.
+
+2018-03-28  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from mainline
+	2018-03-08  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/82411
+	* config/rs6000/rs6000.c (rs6000_elf_in_small_data_p): Don't put
+	readonly data in sdata, if that is disabled.
+	* config/rs6000/sysv4.opt (mreadonly-in-sdata): New option.
+	* doc/invoke.texi (RS/6000 and PowerPC Options): Document
+	-mreadonly-in-sdata option.
+
+2018-03-27  Sudakshina Das  <sudi.das@arm.com>
+
+	Backport from mainline:
+	2018-03-20  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/82989
+	* config/arm/neon.md (ashldi3_neon): Update ?s for constraints
+	to favor GPR over NEON registers.
+	(<shift>di3_neon): Likewise.
+
+2018-03-27  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2018-03-20  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/82518
+	* config/arm/arm.c (arm_array_mode_supported_p): Return false for
+	BYTES_BIG_ENDIAN.
+
+2018-03-23  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-03-20  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/83789
+	* config/rs6000/altivec.md (altivec_lvx_<mode>_2op): Delete define_insn.
+	(altivec_lvx_<mode>_1op): Likewise.
+	(altivec_stvx_<mode>_2op): Likewise.
+	(altivec_stvx_<mode>_1op): Likewise.
+	(altivec_lvx_<VM2:mode>): New define_expand.
+	(altivec_stvx_<VM2:mode>): Likewise.
+	(altivec_lvx_<VM2:mode>_2op_<P:mptrsize>): New define_insn.
+	(altivec_lvx_<VM2:mode>_1op_<P:mptrsize>): Likewise.
+	(altivec_stvx_<VM2:mode>_2op_<P:mptrsize>): Likewise.
+	(altivec_stvx_<VM2:mode>_1op_<P:mptrsize>): Likewise.
+	* config/rs6000/rs6000.c (altivec_expand_lv_builtin): Likewise.
+	(altivec_expand_stv_builtin): Likewise.
+	(altivec_expand_builtin): Likewise.
+	* config/rs6000/vector.md: Likewise.
+
+2018-03-23  Carl Love  <cel@us.ibm.com>
+
+	Backport from mainline:
+	2018-03-14  Carl Love  <cel@us.ibm.com>
+
+	* config/rs6000/r6000.c (rtx_is_swappable_p): Add case UNSPEC_VPERMXOR.
+
+2018-03-22  Tom de Vries  <tom@codesourcery.com>
+
+	backport from trunk:
+	2018-03-22  Tom de Vries  <tom@codesourcery.com>
+
+	PR tree-optimization/84956
+	* tree-ssa-tail-merge.c (find_clusters_1): Skip bbs with
+	bb_has_abnormal_pred.
+
+2018-03-19  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-03-15  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/84574
+	* config/i386/i386.c (indirect_thunk_needed): Update comments.
+	(indirect_thunk_bnd_needed): Likewise.
+	(indirect_thunks_used): Likewise.
+	(indirect_thunks_bnd_used): Likewise.
+	(indirect_return_needed): New.
+	(indirect_return_bnd_needed): Likewise.
+	(output_indirect_thunk_function): Add a bool argument for
+	function return.
+	(output_indirect_thunk_function): Don't generate alias for
+	function return thunk.
+	(ix86_code_end): Call output_indirect_thunk_function to generate
+	function return thunks.
+	(ix86_output_function_return): Set indirect_return_bnd_needed
+	and indirect_return_needed instead of indirect_thunk_bnd_needed
+	and indirect_thunk_needed.
+
+2018-03-14  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR target/83451
+	* config/pa/pa.c (pa_emit_move_sequence):  Always emit secondary reload
+	insn for floating-point loads and stores.
+
+2018-03-12  Jonathan Wakely  <jwakely@redhat.com>
+
+	* doc/invoke.texi (-mclflushopt): Fix spelling of option.
+
+2018-03-12  Richard Sandiford  <richard.sandiford@linaro.org>
+
+	PR tree-optimization/84485
+	* tree-vect-data-refs.c (vect_analyze_data_ref_dependence): Return
+	true for zero dependence distances if the step might be zero,
+	and if there is no metadata that guarantees correctness.
+	(vect_analyze_data_ref_access): Check safelen as well as
+	force_vectorize.
+
+2018-03-11  John David Anglin  <danglin@gcc.gnu.org>
+
+	Backport from mainline
+	2018-02-14  John David Anglin  <danglin@gcc.gnu.org>
+
+	PR target/83984
+	* config/pa/pa.md: Load address of PIC label using the linkage table
+	if the label is nonlocal.
+
+	Backport from mainline
+	2018-03-06  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.h (ASM_GENERATE_INTERNAL_LABEL): Revise to use
+	sprint_ul.
+	(ASM_OUTPUT_ADDR_VEC_ELT): Revise for above change.
+	(ASM_OUTPUT_ADDR_DIFF_ELT): Likewise.
+	* config/pa/pa64-hpux.h (ASM_GENERATE_INTERNAL_LABEL): Revise as above.
+
+2018-03-09  Kugan Vivekanandarajah  <kuganv@linaro.org>
+
+	Backport from mainline
+	2017-09-13  Kugan Vivekanandarajah  <kuganv@linaro.org>
+
+	* config/aarch64/aarch64.c (aarch64_override_options_after_change_1):
+	Disable pc relative literal load irrespective of TARGET_FIX_ERR_A53_84341
+	for default.
+
+2018-03-06  Denis Chertykov  <chertykov@gmail.com>
+
+	Backport from mainline
+	2018-02-07  Georg-Johann Lay  <avr@gjlay.de>
+
+	PR target/84209
+	* config/avr/avr.h (GENERAL_REGNO_P, GENERAL_REG_P): New macros.
+	* config/avr/avr.md: Only post-reload split REG-REG moves if
+	either register is GENERAL_REG_P.
+
+2018-03-06  Carl Love  <cel@us.ibm.com>
+
+	Backport from mainline
+	2/16/18  commit 257748  Carl Love  <cel@us.ibm.com>
+
+	* config/rs6000/altivec.h: Remove vec_vextract4b and vec_vinsert4b.
+	* config/rs6000/rs6000-builtin.def: Remove macro expansion for
+	VINSERT4B_DI and VINSERT4B.
+	* config/rs6000/rs6000.c: Remove case statements for
+	P9V_BUILTIN_VINSERT4B, P9V_BUILTIN_VINSERT4B_DI,
+	and P9V_BUILTIN_VEC_VINSERT4B.
+	* config/rs6000/rs6000-c.c (altivec_expand_builtin): Remove entries for
+	P9V_BUILTIN_VEC_VEXTRACT4B and P9V_BUILTIN_VEC_VINSERT4B.
+	* config/rs6000/vsx.md:  Remove define_expand vinsert4b,
+	define_insn *vinsert4b_internal, define_insn "*vinsert4b_di_internal.
+	* doc/extend.texi: Remove vec_vextract4b, non ABI definitions for
+	vec_insert4b.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-20  Martin Liska  <mliska@suse.cz>
+
+	PR c/84310
+	PR target/79747
+	* final.c (shorten_branches): Build align_tab array with one
+	more element.
+	* opts.c (finish_options): Add alignment option limit check.
+	(MAX_CODE_ALIGN): Likewise.
+	(MAX_CODE_ALIGN_VALUE): Likewise.
+	* doc/invoke.texi: Document maximum allowed option value for
+	all -falign-* options.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-19  Martin Liska  <mliska@suse.cz>
+
+	PR other/80589
+	* doc/invoke.texi: Fix typo.
+	* params.def (PARAM_MAX_LOOP_HEADER_INSNS): Likewise.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-05  Martin Liska  <mliska@suse.cz>
+
+	PR gcov-profile/84137
+	* doc/gcov.texi: Fix typo in documentation.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-05  Martin Liska  <mliska@suse.cz>
+
+	PR gcov-profile/83879
+	* doc/gcov.texi: Document necessity of --dynamic-list-data when
+	using dlopen functionality.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2017-12-19  Martin Liska  <mliska@suse.cz>
+
+	PR rtl-optimization/82675
+	* loop-unroll.c (unroll_loop_constant_iterations): Allocate one
+	more element in sbitmap.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-03-05  Martin Liska  <mliska@suse.cz>
+
+	* ipa-utils.c (ipa_merge_profiles): Do not merge alias or
+	a function without profile.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-21  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR c/84229
+	* ipa-cp.c (determine_versionability): Do not version functions caling
+	va_arg_pack.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-08  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR ipa/81360
+	* cgraph.h (symtab_node::output_to_lto_symbol_table_p): Declare
+	* symtab.c: Include builtins.h
+	(symtab_node::output_to_lto_symbol_table_p): Move here
+	from lto-streamer-out.c:output_symbol_p.
+	* lto-streamer-out.c (write_symbol): Turn early exit to assert.
+	(output_symbol_p): Move all logic to symtab.c
+	(produce_symtab): Update.
+
+2018-03-06  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-02-22  Vladimir Makarov  <vmakarov@redhat.com>
+
+	PR target/81572
+	* lra-int.h (LRA_UNKNOWN_ALT, LRA_NON_CLOBBERED_ALT): New macros.
+	* lra.c (lra_set_insn_recog_data, lra_update_insn_recog_data): Use
+	LRA_UNKNOWN_ALT.
+	* lra-constraints.c (curr_insn_transform): Set up
+	LRA_NON_CLOBBERED_ALT for moves processed on the fast path.  Use
+	LRA_UNKNOWN_ALT.
+	(remove_inheritance_pseudos): Use LRA_UNKNOWN_ALT.
+	* lra-eliminations.c (spill_pseudos): Ditto.
+	(process_insn_for_elimination): Ditto.
+	* lra-lives.c (reg_early_clobber_p): Use the new macros.
+	* lra-spills.c (spill_pseudos): Use LRA_UNKNOWN_ALT and
+	LRA_NON_CLOBBERED_ALT.
+
+2018-03-06  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-03-05  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/84486
+	* tree-ssa-pre.c (create_expression_by_pieces): Remove dead code.
+	When inserting a __builtin_assume_aligned call set the LHS
+	SSA name alignment info accordingly.
+
+	2018-02-28  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/84607
+	* genmatch.c (capture_info::walk_match): Do not mark
+	captured expressions without operands as expr_p given
+	they act more like predicates and should be subject to
+	"lost tail" side-effect preserving.
+
+2018-03-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84524
+	* config/i386/sse.md (*<code><mode>3): Replace <mask_prefix3> with
+	orig,vex.
+	(*<plusminus_insn><mode>3): Likewise.  Remove <mask_operand3> uses.
+
+2018-03-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-03-02  Jakub Jelinek  <jakub@redhat.com>
+		    Richard Biener  <rguenther@suse.de>
+
+	PR ipa/84628
+	* expr.c (expand_expr_real_1) <case CALL_EXPR>: Don't emit diagnostics
+	for error or warning attributes if CALL_FROM_THUNK_P is set.
+	Formatting fixes.
+
+	2018-03-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/84625
+	* config/i386/i386.c (ix86_print_operand): Use conditional
+	output_operand_lossage instead of gcc_assert if CONST_VECTOR is not
+	zero vector.
+
+	2018-02-23  Jakub Jelinek  <jakub@redhat.com>
+
+	* ipa-prop.c (ipa_vr_ggc_hash_traits::hash): Hash p->min and
+	p->max as pointers rather than using iterative_hash_expr.
+
+	2017-11-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR bootstrap/82916
+	* gimple-ssa-store-merging.c
+	(pass_store_merging::terminate_all_aliasing_chains): For
+	gimple_store_p stmts also call refs_output_dependent_p.
+
+	2018-02-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84444
+	* builtins.c (builtin_mathfn_code): Don't check if CALL_EXPR_FN (t)
+	is ADDR_EXPR.
+
+	2018-02-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR ipa/84425
+	* ipa-inline.c (inline_small_functions): Fix a typo.
+
+	2018-02-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/82210
+	* stor-layout.c (place_field): For variable length fields, adjust
+	offset_align afterwards not just based on the field's alignment,
+	but also on the size.
+
+	2018-02-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/83987
+	* omp-low.c (maybe_remove_omp_member_access_dummy_vars,
+	remove_member_access_dummy_vars): New functions.
+	(lower_omp_for, lower_omp_taskreg, lower_omp_target,
+	lower_omp_1, execute_lower_omp): Use them.
+
+	PR rtl-optimization/84308
+	* shrink-wrap.c (spread_components): Release todo vector.
+
+	2018-02-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/84285
+	* gcc.c (STATIC_LIBASAN_LIBS, STATIC_LIBTSAN_LIBS,
+	STATIC_LIBLSAN_LIBS, STATIC_LIBUBSAN_LIBS): Handle -static like
+	-static-lib*san.
+
+	2018-02-09  Marek Polacek  <polacek@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/83659
+	* fold-const.c (fold_indirect_ref_1): Use VECTOR_TYPE_P macro.
+	Formatting fixes.  Verify first that tree_fits_shwi_p (op01).
+	Sync some changes from cxx_fold_indirect_ref.
+
+	2018-02-07  Jakub Jelinek  <jakub@redhat.com>
+
+	* tree-eh.c (operation_could_trap_helper_p): Ignore honor_trapv for
+	*DIV_EXPR and *MOD_EXPR.
+
+	2018-02-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/81661
+	PR tree-optimization/84117
+	* tree-eh.h (rewrite_to_non_trapping_overflow): Declare.
+	* tree-eh.c: Include gimplify.h.
+	(find_trapping_overflow, replace_trapping_overflow,
+	rewrite_to_non_trapping_overflow): New functions.
+	* tree-vect-loop.c: Include tree-eh.h.
+	(vect_get_loop_niters): Use rewrite_to_non_trapping_overflow.
+
+	2018-01-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/83986
+	* sched-deps.c (sched_analyze_insn): For frame related insns, add anti
+	dependence against last_pending_memory_flush in addition to
+	pending_jump_insns.
+
+	2018-01-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/84040
+	* sched-deps.c (sched_macro_fuse_insns): Return immediately if
+	!insn_set.
+
+	2018-01-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/83977
+	* tree-inline.c (tree_function_versioning): Remove "omp declare simd"
+	attributes from DECL_ATTRIBUTES (new_decl) without affecting
+	DECL_ATTRIBUTES (old_decl).
+
+	2018-01-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/83945
+	* tree-emutls.c: Include gimplify.h.
+	(lower_emutls_2): New function.
+	(lower_emutls_1): If ADDR_EXPR is a gimple invariant and walk_tree
+	with lower_emutls_2 callback finds some TLS decl in it, unshare_expr
+	it before further processing.
+
+	PR target/83930
+	* simplify-rtx.c (simplify_binary_operation_1) <case UMOD>: Use
+	UINTVAL (trueop1) instead of INTVAL (op1).
+
+	2018-01-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/83722
+	* gcc.c (try_generate_repro): Pass
+	&temp_stderr_files[RETRY_ICE_ATTEMPTS - 1] rather than
+	&temp_stdout_files[RETRY_ICE_ATTEMPTS - 1] as last argument to
+	do_report_bug.
+
+	2018-01-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/83605
+	* gimple-ssa-strength-reduction.c: Include tree-eh.h.
+	(find_candidates_dom_walker::before_dom_children): Ignore stmts that
+	can throw.
+
+2018-03-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-02-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/84039
+	* config/i386/constraints.md (Bs): Replace
+	ix86_indirect_branch_register with
+	TARGET_INDIRECT_BRANCH_REGISTER.
+	(Bw): Likewise.
+	* config/i386/i386.md (indirect_jump): Likewise.
+	(tablejump): Likewise.
+	(*sibcall_memory): Likewise.
+	(*sibcall_value_memory): Likewise.
+	Peepholes of indirect call and jump via memory: Likewise.
+	(*sibcall_GOT_32): Disallowed for TARGET_INDIRECT_BRANCH_REGISTER.
+	(*sibcall_value_GOT_32): Likewise.
+	* config/i386/predicates.md (indirect_branch_operand): Likewise.
+	(GOT_memory_operand): Likewise.
+	(call_insn_operand): Likewise.
+	(sibcall_insn_operand): Likewise.
+	(GOT32_symbol_operand): Likewise.
+	* config/i386/i386.h (TARGET_INDIRECT_BRANCH_REGISTER): New.
+
+2018-03-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-02-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* config/i386/i386.c (ix86_output_indirect_jmp): Update comments.
+
+	2018-02-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/84530
+	* config/i386/i386-protos.h (ix86_output_indirect_jmp): Remove
+	the bool argument.
+	(ix86_output_indirect_function_return): New prototype.
+	(ix86_split_simple_return_pop_internal): Likewise.
+	* config/i386/i386.c (indirect_return_via_cx): New.
+	(indirect_return_via_cx_bnd): Likewise.
+	(indirect_thunk_name): Handle return va CX_REG.
+	(output_indirect_thunk_function): Create alias for
+	__x86_return_thunk_[re]cx and __x86_return_thunk_[re]cx_bnd.
+	(ix86_output_indirect_jmp): Remove the bool argument.
+	(ix86_output_indirect_function_return): New function.
+	(ix86_split_simple_return_pop_internal): Likewise.
+	* config/i386/i386.md (*indirect_jump): Don't pass false
+	to ix86_output_indirect_jmp.
+	(*tablejump_1): Likewise.
+	(simple_return_pop_internal): Change it to define_insn_and_split.
+	Call ix86_split_simple_return_pop_internal to split it for
+	-mfunction-return=.
+	(simple_return_indirect_internal): Call
+	ix86_output_indirect_function_return instead of
+	ix86_output_indirect_jmp.
+
+2017-03-02  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backport from trunk r256891:
+	2018-01-19  Cesar Philippidis  <cesar@codesourcery.com>
+
+	PR target/83790
+	* config/nvptx/nvptx.c (output_init_frag): Don't use generic address
+	spaces for function labels.
+
+2018-02-26  Carl Love  <cel@us.ibm.com>
+
+	Backport from mainline: commit 257747 on 2018-02-16.
+
+	* config/rs6000/altivec.h: Add builtin names vec_extract4b
+	vec_insert4b.
+	* config/rs6000/rs6000-builtin.def: Add INSERT4B and EXTRACT4B
+	definitions.
+	* config/rs6000/rs6000-c.c: Add the definitions for
+	P9V_BUILTIN_VEC_EXTRACT4B and P9V_BUILTIN_VEC_INSERT4B.
+	* config/rs6000/rs6000.c (altivec_expand_builtin): Add
+	P9V_BUILTIN_EXTRACT4B and P9V_BUILTIN_INSERT4B case statements.
+	* config/rs6000/vsx.md: Add define_insn extract4b.  Add define_expand
+	definition for insert4b and define insn *insert3b_internal.
+	* doc/extend.texi: Add documentation for vec_extract4b.
+
+2018-02-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/83496
+	* reorg.c (steal_delay_list_from_target): Change REDUNDANT array from
+	booleans to RTXes.  Call fix_reg_dead_note on every non-null element.
+	(steal_delay_list_from_fallthrough): Call fix_reg_dead_note on a
+	redundant insn, if any.
+	(relax_delay_slots): Likewise.
+	(update_reg_unused_notes): Rename REDUNDANT_INSN to OTHER_INSN.
+
+2018-02-22  Sudakshina Das  <sudi.das@arm.com>
+	    Bin Cheng  <bin.cheng@arm.com>
+
+	Backport from mainline:
+	2017-12-14  Sudakshina Das  <sudi.das@arm.com>
+		    Bin Cheng  <bin.cheng@arm.com>
+
+	PR target/81228
+	* config/aarch64/aarch64.c (aarch64_select_cc_mode): Move LTGT to
+	CCFPEmode.
+	* config/aarch64/aarch64-simd.md (vec_cmp<mode><v_cmp_result>): Add
+	LTGT.
+
+2018-02-16  Jozef Lawrynowicz <jozefl.gcc@gmail.com>
+
+	PR target/79242
+	* machmode.def: Define a complex mode for PARTIAL_INT.
+	* genmodes.c (complex_class): Return MODE_COMPLEX_INT for
+	MODE_PARTIAL_INT.
+	* doc/rtl.texi: Document CSPImode.
+	* config/msp430/msp430.c (msp430_hard_regno_nregs): Add CPSImode
+	handling.
+	(msp430_hard_regno_nregs_with_padding): Likewise.
+
+2018-02-16  Sudakshina Das  <sudi.das@arm.com>
+
+	Backport from trunk
+	2018-01-10  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/82096
+	* expmed.c (emit_store_flag_force): Swap if const op0
+	and change VOIDmode to mode of op0.
+
+2018-02-16  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/84190
+	* tree-ssa.c (non_rewritable_mem_ref_base): Do not touch
+	volatile accesses if the decl isn't volatile.
+
+2018-02-15  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk
+	2018-02-07  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/84154
+	* config/rs6000/rs6000.md (fix_trunc<SFDF:mode><QHI:mode>2):
+	Convert from define_expand to be define_insn_and_split.  Rework
+	float/double/_Float128 conversions to QI/HI/SImode to work with
+	both ISA 2.07 (power8) or ISA 3.0 (power9).  Fix regression where
+	conversions to QI/HImode types did a store and then a load to
+	truncate the value.  For conversions to VSX registers, don't split
+	the insn, instead emit the code directly.  Use the code iterator
+	any_fix to combine signed and unsigned conversions.
+	(fix<uns>_trunc<SFDF:mode>si2_p8): Likewise.
+	(fixuns_trunc<SFDF:mode><QHI:mode>2): Likewise.
+	(fix_trunc<IEEE128:mode><QHI:mode>2): Likewise.
+	(fix<uns>_trunc<SFDF:mode><QHI:mode>2): Likewise.
+	(fix_<mode>di2_hw): Likewise.
+	(fixuns_<mode>di2_hw): Likewise.
+	(fix_<mode>si2_hw): Likewise.
+	(fixuns_<mode>si2_hw): Likewise.
+	(fix<uns>_<IEEE128:mode><SDI:mode>2_hw): Likewise.
+	(fix<uns>_trunc<IEEE128:mode><QHI:mode>2): Likewise.
+	(fctiw<u>z_<mode>_smallint): Rename fctiw<u>z_<mode>_smallint to
+	fix<uns>_trunc<SFDF:mode>si2_p8.
+	(fix_trunc<SFDF:mode><QHI:mode>2_internal): Delete, no longer
+	used.
+	(fixuns_trunc<SFDF:mode><QHI:mode>2_internal): Likewise.
+	(fix<uns>_<mode>_mem): Likewise.
+	(fctiw<u>z_<mode>_mem): Likewise.
+	(fix<uns>_<mode>_mem): Likewise.
+	(fix<uns>_trunc<SFDF:mode><QHSI:mode>2_mem): On ISA 3.0, prevent
+	the register allocator from doing a direct move to the GPRs to do
+	a store, and instead use the ISA 3.0 store byte/half-word from
+	vector register instruction.  For IEEE 128-bit floating point,
+	also optimize stores of 32-bit ints.
+	(fix<uns>_trunc<IEEE128:mode><QHSI:mode>2_mem): Likewise.
+
+2018-02-15  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>
+
+	Back port from mainline
+	2018-01-30  Aaron Sawdey  <acsawdey@linux.vnet.ibm.com>
+
+	PR target/83758
+	* config/rs6000/rs6000.c (rs6000_internal_arg_pointer): Only return
+	a reg rtx.
+
+2018-02-14  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Back port from mainline
+	2018-02-13  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/84279
+	* config/rs6000/rs6000.c (mem_operand_gpr): Disallow altivec addresses.
+
+2018-02-14  Martin Jambor  <mjambor@suse.cz>
+
+	PR c++/83990
+	* ipa-prop.c (ipa_modify_call_arguments): Use location of call
+	statements, also set location of a load to a temporary.
+
+2018-02-10  John David Anglin  <danglin@gcc.gnu.org>
+
+	* config/pa/pa.c (hppa_profile_hook): Mark SYMBOL_REF for _mcount as
+	function label.
+
+	Backport from mainline
+	2018-02-01  Aldy Hernandez  <aldyh@redhat.com>
+
+	PR target/84089
+	* config/pa/predicates.md (base14_operand): Handle VOIDmode.
+
+2018-02-09  Martin Jambor  <mjambor@suse.cz>
+
+	Backport from mainline
+	2018-02-08  Martin Jambor  <mjambor@suse.cz>
+
+	* hsa-gen.c (get_symbol_for_decl): Set program allocation for
+	static local variables.
+
+2018-02-09  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-02-09  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	PR target/PR84295
+	* config/s390/s390.c (s390_set_current_function): Invoke
+	s390_indirect_branch_settings also if fndecl didn't change.
+
+2018-02-08  Iain Sandoe  <iain@codesourcery.com>
+
+	PR target/84113
+	* config/rs6000/altivec.md (*restore_world): Remove LR use.
+	* config/rs6000/predicates.md (restore_world_operation): Adjust op
+	count, remove one USE.
+
+2018-02-08  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-02-08  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* config/s390/s390-opts.h (enum indirect_branch): Define.
+	* config/s390/s390-protos.h (s390_return_addr_from_memory)
+	(s390_indirect_branch_via_thunk)
+	(s390_indirect_branch_via_inline_thunk): Add function prototypes.
+	(enum s390_indirect_branch_type): Define.
+	* config/s390/s390.c (struct s390_frame_layout, struct
+	machine_function): Remove.
+	(indirect_branch_prez10thunk_mask, indirect_branch_z10thunk_mask)
+	(indirect_branch_table_label_no, indirect_branch_table_name):
+	Define variables.
+	(INDIRECT_BRANCH_NUM_OPTIONS): Define macro.
+	(enum s390_indirect_branch_option): Define.
+	(s390_return_addr_from_memory): New function.
+	(s390_handle_string_attribute): New function.
+	(s390_attribute_table): Add new attribute handler.
+	(s390_execute_label): Handle UNSPEC_EXECUTE_JUMP patterns.
+	(s390_indirect_branch_via_thunk): New function.
+	(s390_indirect_branch_via_inline_thunk): New function.
+	(s390_function_ok_for_sibcall): When jumping via thunk disallow
+	sibling call optimization for non z10 compiles.
+	(s390_emit_call): Force indirect branch target to be a single
+	register.  Add r1 clobber for non-z10 compiles.
+	(s390_emit_epilogue): Emit return jump via return_use expander.
+	(s390_reorg): Handle JUMP_INSNs as execute targets.
+	(s390_option_override_internal): Perform validity checks for the
+	new command line options.
+	(s390_indirect_branch_attrvalue): New function.
+	(s390_indirect_branch_settings): New function.
+	(s390_set_current_function): Invoke s390_indirect_branch_settings.
+	(s390_output_indirect_thunk_function):  New function.
+	(s390_code_end): Implement target hook.
+	(s390_case_values_threshold): Implement target hook.
+	(TARGET_ASM_CODE_END, TARGET_CASE_VALUES_THRESHOLD): Define target
+	macros.
+	* config/s390/s390.h (struct s390_frame_layout)
+	(struct	machine_function): Move here from s390.c.
+	(TARGET_INDIRECT_BRANCH_NOBP_RET)
+	(TARGET_INDIRECT_BRANCH_NOBP_JUMP)
+	(TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK)
+	(TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK)
+	(TARGET_INDIRECT_BRANCH_NOBP_CALL)
+	(TARGET_DEFAULT_INDIRECT_BRANCH_TABLE)
+	(TARGET_INDIRECT_BRANCH_THUNK_NAME_EXRL)
+	(TARGET_INDIRECT_BRANCH_THUNK_NAME_EX)
+	(TARGET_INDIRECT_BRANCH_TABLE): Define macros.
+	* config/s390/s390.md (UNSPEC_EXECUTE_JUMP)
+	(INDIRECT_BRANCH_THUNK_REGNUM): Define constants.
+	(mnemonic attribute): Add values which aren't recognized
+	automatically.
+	("*cjump_long", "*icjump_long", "*basr", "*basr_r"): Disable
+	pattern for branch conversion.  Fix mnemonic attribute.
+	("*c<code>", "*sibcall_br", "*sibcall_value_br", "*return"): Emit
+	indirect branch via thunk if requested.
+	("indirect_jump", "<code>"): Expand patterns for branch conversion.
+	("*indirect_jump"): Disable for branch conversion using out of
+	line thunks.
+	("indirect_jump_via_thunk<mode>_z10")
+	("indirect_jump_via_thunk<mode>")
+	("indirect_jump_via_inlinethunk<mode>_z10")
+	("indirect_jump_via_inlinethunk<mode>", "*casesi_jump")
+	("casesi_jump_via_thunk<mode>_z10", "casesi_jump_via_thunk<mode>")
+	("casesi_jump_via_inlinethunk<mode>_z10")
+	("casesi_jump_via_inlinethunk<mode>", "*basr_via_thunk<mode>_z10")
+	("*basr_via_thunk<mode>", "*basr_r_via_thunk_z10")
+	("*basr_r_via_thunk", "return<mode>_prez10"): New pattern.
+	("*indirect2_jump"): Disable for branch conversion.
+	("casesi_jump"): Turn into expander and expand patterns for branch
+	conversion.
+	("return_use"): New expander.
+	("*return"): Emit return via thunk and rename it to ...
+	("*return<mode>"): ... this one.
+	* config/s390/s390.opt: Add new options and and enum for the
+	option values.
+
+2018-02-08  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/84233
+	* tree-ssa-phiprop.c (propagate_with_phi): Use separate
+	changed flag instead of boguously re-using phi_inserted.
+
+2018-02-07  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-02-06  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* config/rs6000/rs6000.c (rs6000_option_override_internal):
+	Display warning message for -mno-speculate-indirect-jumps.
+
+2018-02-05  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline
+	2018-01-30  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR bootstrap/84017
+	* configure.ac (gcc_cv_as_shf_merge): Disable on Solaris 10/x86.
+	* configure: Regenerate.
+
+2018-02-05  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Back port from mainline
+	2018-02-01  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/56010
+	PR target/83743
+	* config/rs6000/driver-rs6000.c: #include "diagnostic.h".
+	#include "opts.h".
+	(rs6000_supported_cpu_names): New static variable.
+	(linux_cpu_translation_table): Likewise.
+	(elf_platform) <cpu>: Define new static variable and use it.
+	Translate kernel AT_PLATFORM name to canonical name if needed.
+	Error if platform name is unknown.
+
+2018-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-02-02  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* config/i386/i386.c (ix86_output_function_return): Pass
+	INVALID_REGNUM, instead of -1, as invalid register number to
+	indirect_thunk_name and output_indirect_thunk.
+
+2018-02-01  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2018-01-31  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR rtl-optimization/84123
+	* combine.c (change_zero_ext): Check if hard register satisfies
+	can_change_dest_mode before calling gen_lowpart_SUBREG.
+
+2018-02-01  Renlin Li  <renlin.li@arm.com>
+
+	Backport from mainline
+	2018-02-01  Renlin Li  <renlin.li@arm.com>
+
+	PR target/83370
+	* config/aarch64/aarch64.c (aarch64_class_max_nregs): Handle
+	TAILCALL_ADDR_REGS.
+	(aarch64_register_move_cost): Likewise.
+	* config/aarch64/aarch64.h (reg_class): Rename CALLER_SAVE_REGS to
+	TAILCALL_ADDR_REGS.
+	(REG_CLASS_NAMES): Likewise.
+	(REG_CLASS_CONTENTS): Rename CALLER_SAVE_REGS to
+	TAILCALL_ADDR_REGS. Remove IP registers.
+	* config/aarch64/aarch64.md (Ucs): Update register constraint.
+
+2018-02-01  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2017-11-02  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/82795
+	* tree-if-conv.c (predicate_mem_writes): Remove bogus assert.
+
+2018-01-31  Richard Biener <rguenther@suse.de>
+	    Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backport from mainline
+	2018-01-29  Richard Biener <rguenther@suse.de>
+		    Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	PR bootstrap/80867
+	* tree-vect-stmts.c (vectorizable_call): Don't call
+	targetm.vectorize_builtin_md_vectorized_function if callee is
+	NULL.
+
+2018-01-31  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/84071
+	* doc/tm.texi.in (WORD_REGISTER_OPERATIONS): Add explicit case.
+	* doc/tm.texi: Regenerate.
+
+2018-01-31  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/84071
+	* combine.c (record_dead_and_set_regs_1): Record the source unmodified
+	for a paradoxical SUBREG on a WORD_REGISTER_OPERATIONS target.
+
+2018-01-29  Joseph Myers  <joseph@codesourcery.com>
+
+	Backport from mainline
+	2018-01-24  Joseph Myers  <joseph@codesourcery.com>
+
+	PR target/68467
+	* config/m68k/m68k.c (m68k_promote_function_mode): New function.
+	(TARGET_PROMOTE_FUNCTION_MODE): New macro.
+
+2018-01-29  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2018-01-26  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/81763
+	* config/i386/i386.md (*andndi3_doubleword): Add earlyclobber
+	to (=&r,r,rm) alternative. Add (=r,0,rm) and (=r,r,0) alternatives.
+
+2018-01-29  Alan Modra  <amodra@gmail.com>
+
+	Backport from mainline
+	2018-01-26  Alan Modra  <amodra@gmail.com>
+	PR target/84033
+	* config/rs6000/rs6000.c (rtx_is_swappable_p): Exclude
+	UNSPEC_VBPERMQ.
+
+2018-01-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-01-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	* doc/invoke.texi: Replace -mfunction-return==@var{choice} with
+	-mfunction-return=@var{choice}.
+
+2018-01-27  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-01-23  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/83905
+	* config/i386/i386.c (ix86_expand_prologue): Use cost reference
+	of struct ix86_frame.
+	(ix86_expand_epilogue): Likewise.  Add a local variable for
+	the reg_save_offset field in struct ix86_frame.
+
+2018-01-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/83985
+	* dce.c (deletable_insn_p): Return false for separate shrink wrapping
+	REG_CFA_RESTORE insns.
+	(delete_unmarked_insns): Don't ignore separate shrink wrapping
+	REG_CFA_RESTORE insns here.
+
+2018-01-25  Uros Bizjak  <ubizjak@gmail.com>
+
+	Backport from mainline
+	2018-01-17  Uros Bizjak  <ubizjak@gmail.com>
+
+	* config/i386/i386.c (indirect_thunk_name): Declare regno
+	as unsigned int.  Compare regno with INVALID_REGNUM.
+	(output_indirect_thunk): Ditto.
+	(output_indirect_thunk_function): Ditto.
+	(ix86_code_end): Declare regno as unsigned int.  Use INVALID_REGNUM
+	in the call to output_indirect_thunk_function.
+
+2018-01-25  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk
+	2018-01-22  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/83862
+	* config/rs6000/rs6000-protos.h (rs6000_split_signbit): Delete,
+	no longer used.
+	* config/rs6000/rs6000.c (rs6000_split_signbit): Likewise.
+	* config/rs6000/rs6000.md (signbit<mode>2): Change code for IEEE
+	128-bit to produce an UNSPEC move to get the double word with the
+	signbit and then a shift directly to do signbit.
+	(signbit<mode>2_dm): Replace old IEEE 128-bit signbit
+	implementation with a new version that just does either a direct
+	move or a regular move.  Move memory interface to separate insns.
+	Move insns so they are next to the expander.
+	(signbit<mode>2_dm_mem_be): New combiner insns to combine load
+	with signbit move.  Split big and little endian case.
+	(signbit<mode>2_dm_mem_le): Likewise.
+	(signbit<mode>2_dm_<su>ext): Delete, no longer used.
+	(signbit<mode>2_dm2): Likewise.
+
+2018-01-25  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Back port from mainline
+	2018-01-10  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/83399
+	* config/rs6000/rs6000.c (print_operand) <'y'>: Use
+	VECTOR_MEM_ALTIVEC_OR_VSX_P.
+	* config/rs6000/vsx.md (*vsx_le_perm_load_<mode> for VSX_D): Use
+	indexed_or_indirect_operand predicate.
+	(*vsx_le_perm_load_<mode> for VSX_W): Likewise.
+	(*vsx_le_perm_load_v8hi): Likewise.
+	(*vsx_le_perm_load_v16qi): Likewise.
+	(*vsx_le_perm_store_<mode> for VSX_D): Likewise.
+	(*vsx_le_perm_store_<mode> for VSX_W): Likewise.
+	(*vsx_le_perm_store_v8hi): Likewise.
+	(*vsx_le_perm_store_v16qi): Likewise.
+	(eight unnamed splitters): Likewise.
+
+2018-01-25  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-01-02  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* config/rs6000/rs6000-p8swap.c (swap_feeds_both_load_and_store):
+	New function.
+	(rs6000_analyze_swaps): Mark a web unoptimizable if it contains a
+	swap associated with both a load and a store.
+
+2018-01-25  Richard Biener  <rguenther@suse.de>
+
+	* BASE-VER: Increment to 7.3.1.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
Index: gcc/testsuite/gcc.target/powerpc/p9-vinsert4b-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/p9-vinsert4b-1.c b/gcc/testsuite/gcc.target/powerpc/p9-vinsert4b-1.c
deleted file mode 10644
--- a/gcc/testsuite/gcc.target/powerpc/p9-vinsert4b-1.c	(revision 262353)
+++ /dev/null	(nonexistent)
@@ -1,39 +0,0 @@
-/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
-/* { dg-require-effective-target powerpc_p9vector_ok } */
-/* { dg-options "-mcpu=power9 -O2" } */
-
-#include <altivec.h>
-
-vector signed char
-vins_v4si (vector int *vi, vector signed char *vc)
-{
-  return vec_vinsert4b (*vi, *vc, 1);
-}
-
-vector unsigned char
-vins_di (long di, vector unsigned char *vc)
-{
-  return vec_vinsert4b (di, *vc, 2);
-}
-
-vector char
-vins_di2 (long *p_di, vector char *vc)
-{
-  return vec_vinsert4b (*p_di, *vc, 3);
-}
-
-vector unsigned char
-vins_di0 (vector unsigned char *vc)
-{
-  return vec_vinsert4b (0, *vc, 4);
-}
-
-long
-vext (vector signed char *vc)
-{
-  return vec_vextract4b (*vc, 5);
-}
-
-/* { dg-final { scan-assembler "xxextractuw\|vextuw\[lr\]x" } } */
-/* { dg-final { scan-assembler "xxinsertw" } } */
Index: gcc/testsuite/gcc.target/powerpc/p9-vinsert4b-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/p9-vinsert4b-2.c b/gcc/testsuite/gcc.target/powerpc/p9-vinsert4b-2.c
deleted file mode 10644
--- a/gcc/testsuite/gcc.target/powerpc/p9-vinsert4b-2.c	(revision 262353)
+++ /dev/null	(nonexistent)
@@ -1,30 +0,0 @@
-/* { dg-do compile { target { powerpc64*-*-* && lp64 } } } */
-/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
-/* { dg-require-effective-target powerpc_p9vector_ok } */
-/* { dg-options "-mcpu=power9 -O2" } */
-
-#include <altivec.h>
-
-vector signed char
-ins_v4si (vector int vi, vector signed char vc)
-{
-  return vec_vinsert4b (vi, vc, 13);	/* { dg-error "vec_vinsert4b" } */
-}
-
-vector unsigned char
-ins_di (long di, vector unsigned char vc, long n)
-{
-  return vec_vinsert4b (di, vc, n);	/* { dg-error "vec_vinsert4b" } */
-}
-
-long
-vext1 (vector signed char vc)
-{
-  return vec_vextract4b (vc, 13);	/* { dg-error "vec_vextract4b" } */
-}
-
-long
-vextn (vector unsigned char vc, long n)
-{
-  return vec_vextract4b (vc, n);	/* { dg-error "vec_vextract4b" } */
-}
Index: gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-8.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-8.c b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-8.c
deleted file mode 10644
--- a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-8.c	(revision 262353)
+++ /dev/null	(nonexistent)
@@ -1,15 +0,0 @@
-/* { dg-do compile { target { ilp32 } } } */
-/* { dg-additional-options "-O2 -mno-speculate-indirect-jumps" } */
-
-/* Test for deliberate misprediction of -m32 sibcalls.  */
-
-extern int (*f)();
-
-int bar ()
-{
-  return (*f) ();
-}
-
-/* { dg-final { scan-assembler "crset 2" } } */
-/* { dg-final { scan-assembler "beqctr-" } } */
-/* { dg-final { scan-assembler {b \$} } } */
Index: gcc/testsuite/gcc.target/powerpc/ppc-sdata-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/ppc-sdata-2.c b/gcc/testsuite/gcc.target/powerpc/ppc-sdata-2.c
--- a/gcc/testsuite/gcc.target/powerpc/ppc-sdata-2.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/powerpc/ppc-sdata-2.c	(revision 262353)
@@ -5,6 +5,7 @@
 /* { dg-final { scan-assembler-not "\\.section\[ \t\]\\.sdata2," } } */
 /* { dg-final { scan-assembler "sdat@sdarel\\(13\\)" } } */
 /* { dg-final { scan-assembler "sdat2@sdarel\\(13\\)" } } */
+/* { dg-skip-if "" { *-*-* } { "-mno-readonly-in-sdata" } { "" } } */
 
 
 int sdat = 2;
Index: gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-2.c b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-2.c
--- a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-2.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-2.c	(revision 262353)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-mno-speculate-indirect-jumps" } */
+/* { dg-warning "'-mno-speculate-indirect-jumps' is deprecated" "" { target *-*-* } 0 } */
 
 /* Test for deliberate misprediction of computed goto.  */
 
Index: gcc/testsuite/gcc.target/powerpc/pr81572.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pr81572.c b/gcc/testsuite/gcc.target/powerpc/pr81572.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/pr81572.c	(revision 262353)
@@ -0,0 +1,13 @@
+/* { dg-do compile { target powerpc64*-*-* } } */
+/* { dg-options "-O2 -mcpu=power7" } */
+/* { dg-final { scan-assembler-not "xxlor" } } */
+
+#include <altivec.h>
+
+typedef __vector unsigned char nvec_t;
+
+long testz_and(nvec_t a, nvec_t b)
+{
+  nvec_t c = vec_andc(a, b);
+  return vec_all_eq(a, c);
+}
Index: gcc/testsuite/gcc.target/powerpc/builtins-3-p8.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/builtins-3-p8.c b/gcc/testsuite/gcc.target/powerpc/builtins-3-p8.c
--- a/gcc/testsuite/gcc.target/powerpc/builtins-3-p8.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/powerpc/builtins-3-p8.c	(revision 262353)
@@ -1,6 +1,7 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
 /* { dg-options "-mcpu=power8" } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
 
 #include <altivec.h>
 
Index: gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-3.c b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-3.c
--- a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-3.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-3.c	(revision 262353)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-mno-speculate-indirect-jumps" } */
+/* { dg-warning "'-mno-speculate-indirect-jumps' is deprecated" "" { target *-*-* } 0 } */
 
 /* Test for deliberate misprediction of jump tables.  */
 
Index: gcc/testsuite/gcc.target/powerpc/pr79799-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pr79799-2.c b/gcc/testsuite/gcc.target/powerpc/pr79799-2.c
--- a/gcc/testsuite/gcc.target/powerpc/pr79799-2.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/powerpc/pr79799-2.c	(revision 262353)
@@ -8,7 +8,7 @@
 /* Optimize x = vec_insert (vec_extract (v2, N), v1, M) for SFmode if N is the default
    scalar position.  */
 
-#if __ORDER_LITTLE_ENDIAN__
+#if __LITTLE_ENDIAN__
 #define ELE 2
 #else
 #define ELE 1
Index: gcc/testsuite/gcc.target/powerpc/fold-vec-mult-int128-p8.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/fold-vec-mult-int128-p8.c b/gcc/testsuite/gcc.target/powerpc/fold-vec-mult-int128-p8.c
--- a/gcc/testsuite/gcc.target/powerpc/fold-vec-mult-int128-p8.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/powerpc/fold-vec-mult-int128-p8.c	(revision 262353)
@@ -4,7 +4,9 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target powerpc_p8vector_ok } */
 /* { dg-require-effective-target int128 } */
-/* { dg-options "-maltivec -mvsx -mpower8-vector" } */
+/* { dg-require-effective-target lp64 } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mpower8-vector -mcpu=power8 -O2" } */
 /* { dg-additional-options "-maix64" { target powerpc-ibm-aix* } } */
 
 #include "altivec.h"
@@ -21,5 +23,5 @@
   return vec_mul (x, y);
 }
 
-/* { dg-final { scan-assembler-times "\[ \t\]mulld " 6 } } */
-/* { dg-final { scan-assembler-times "\[ \t\]mulhdu" 2 } } */
+/* { dg-final { scan-assembler-times {\mmulld\M} 6 } } */
+/* { dg-final { scan-assembler-times {\mmulhdu\M} 2 } } */
Index: gcc/testsuite/gcc.target/powerpc/builtins-3-p9.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/builtins-3-p9.c b/gcc/testsuite/gcc.target/powerpc/builtins-3-p9.c
--- a/gcc/testsuite/gcc.target/powerpc/builtins-3-p9.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/powerpc/builtins-3-p9.c	(revision 262353)
@@ -1,6 +1,7 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target powerpc_p9vector_ok } */
 /* { dg-options "-mcpu=power9" } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
 
 #include <altivec.h>
 
Index: gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-4.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-4.c b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-4.c
--- a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-4.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-4.c	(revision 262353)
@@ -1,5 +1,6 @@
 /* { dg-do run } */
 /* { dg-additional-options "-mno-speculate-indirect-jumps" } */
+/* { dg-warning "'-mno-speculate-indirect-jumps' is deprecated" "" { target *-*-* } 0 } */
 
 /* Test for deliberate misprediction of indirect calls for ELFv2.  */
 
Index: gcc/testsuite/gcc.target/powerpc/fold-vec-mult-int128-p9.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/fold-vec-mult-int128-p9.c b/gcc/testsuite/gcc.target/powerpc/fold-vec-mult-int128-p9.c
--- a/gcc/testsuite/gcc.target/powerpc/fold-vec-mult-int128-p9.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/powerpc/fold-vec-mult-int128-p9.c	(revision 262353)
@@ -2,10 +2,10 @@
    inputs produce the right results.  */
 
 /* { dg-do compile } */
-/* { dg-require-effective-target powerpc_float128_hw_ok } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
 /* { dg-require-effective-target int128 } */
 /* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
-/* { dg-options "-maltivec -mvsx -mcpu=power9 -O2" } */
+/* { dg-options "-mpower9-vector -mcpu=power9 -O2" } */
 /* { dg-additional-options "-maix64" { target powerpc-ibm-aix* } } */
 
 #include "altivec.h"
@@ -22,4 +22,5 @@
   return vec_mul (x, y);
 }
 
-/* { dg-final { scan-assembler-times "\[ \t\]xsmulqp" 2 } } */
+/* { dg-final { scan-assembler-times {\mmulld\M} 4 } } */
+/* { dg-final { scan-assembler-times {\mmulhdu\M} 2 } } */
Index: gcc/testsuite/gcc.target/powerpc/builtins-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/builtins-1.c b/gcc/testsuite/gcc.target/powerpc/builtins-1.c
--- a/gcc/testsuite/gcc.target/powerpc/builtins-1.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/powerpc/builtins-1.c	(revision 262353)
@@ -165,3 +165,6 @@
 
   return 0;
 }
+
+/* Translation of vec_packsu (unsigned long long, unsigned long long) */
+/* { dg-final { scan-assembler-times {\mvpkudus\M} 1 } } */
Index: gcc/testsuite/gcc.target/powerpc/pr83969.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pr83969.c b/gcc/testsuite/gcc.target/powerpc/pr83969.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/pr83969.c	(revision 262353)
@@ -0,0 +1,14 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=G5" } } */
+/* { dg-options "-O1 -mcpu=G5 -fno-split-wide-types -ftree-loop-vectorize" } */
+
+long long int
+n7 (int po, long long int r4)
+{
+  while (po < 1)
+    {
+      r4 |= 1;
+      ++po;
+    }
+  return r4;
+}
Index: gcc/testsuite/gcc.target/powerpc/pr83660.C
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pr83660.C b/gcc/testsuite/gcc.target/powerpc/pr83660.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/pr83660.C	(revision 262353)
@@ -0,0 +1,14 @@
+/* PR target/83660 */
+/* { dg-do compile } */
+/* { dg-options "-mcpu=power7" } */
+
+#include <altivec.h>
+
+typedef __vector unsigned int  uvec32_t  __attribute__((__aligned__(16)));
+
+unsigned get_word(uvec32_t v)
+{
+    return ({const unsigned _B1 = 32;
+            vec_extract((uvec32_t)v, 2);});
+}
+
Index: gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-5.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-5.c b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-5.c
--- a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-5.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-5.c	(revision 262353)
@@ -1,5 +1,6 @@
 /* { dg-do run } */
 /* { dg-additional-options "-mno-speculate-indirect-jumps -Wno-pedantic" } */
+/* { dg-warning "'-mno-speculate-indirect-jumps' is deprecated" "" { target *-*-* } 0 } */
 
 /* Test for deliberate misprediction of computed goto.  */
 
Index: gcc/testsuite/gcc.target/powerpc/pr84878.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pr84878.c b/gcc/testsuite/gcc.target/powerpc/pr84878.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/pr84878.c	(revision 262353)
@@ -0,0 +1,18 @@
+/* PR rtl-optimization/84878 */
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-require-effective-target powerpc_altivec_ok } */
+/* { dg-options "-O2 -maltivec -mno-vsx -fmodulo-sched -ftree-vectorize -funroll-loops -fassociative-math -fno-signed-zeros -fno-trapping-math" } */
+
+int ek;
+float zu;
+
+int
+k5 (int ks)
+{
+  while (ek < 1)
+    {
+      ks += (int)(0x1000000 + zu + !ek);
+      ++ek;
+    }
+  return ks;
+}
Index: gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-6.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-6.c b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-6.c
--- a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-6.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-6.c	(revision 262353)
@@ -1,5 +1,6 @@
 /* { dg-do run } */
 /* { dg-additional-options "-mno-speculate-indirect-jumps" } */
+/* { dg-warning "'-mno-speculate-indirect-jumps' is deprecated" "" { target *-*-* } 0 } */
 
 /* Test for deliberate misprediction of jump tables.  */
 
Index: gcc/testsuite/gcc.target/powerpc/builtins-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/builtins-3.c b/gcc/testsuite/gcc.target/powerpc/builtins-3.c
--- a/gcc/testsuite/gcc.target/powerpc/builtins-3.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/powerpc/builtins-3.c	(revision 262353)
@@ -1,6 +1,7 @@
 /* { dg-do compile } */
 /* { dg-require-effective-target powerpc_vsx_ok } */
-/* { dg-options "-maltivec -mvsx" } */
+/* { dg-options "-O2 -mvsx -mcpu=power6" } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power6" } } */
 
 #include <altivec.h>
 
Index: gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-7.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-7.c b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-7.c
--- a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-7.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-7.c	(revision 262353)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-additional-options "-mno-speculate-indirect-jumps" } */
+/* { dg-warning "'-mno-speculate-indirect-jumps' is deprecated" "" { target *-*-* } 0 } */
 
 /* Test for deliberate misprediction of indirect calls.  */
 
Index: gcc/testsuite/gcc.target/powerpc/pr85698.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pr85698.c b/gcc/testsuite/gcc.target/powerpc/pr85698.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/pr85698.c	(revision 262353)
@@ -0,0 +1,79 @@
+/* { dg-do run } */
+/* { dg-require-effective-target vsx_hw } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
+/* { dg-options "-O3 -mcpu=power7" } */
+
+/* PR85698: Incorrect code generated on LE due to use of stxvw4x. */
+
+typedef unsigned char uint8_t;
+typedef short int16_t;
+extern void abort (void);
+extern int memcmp(const void *, const void *, __SIZE_TYPE__);
+
+uint8_t expected[128] =
+{14, 0, 4, 2, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
+ 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 28, 35, 33, 35, 36, 37, 38, 39, 40,
+ 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,
+ 60, 61, 62, 63, 66, 63, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78,
+ 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97, 96,
+ 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113,
+ 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127};
+
+static uint8_t x264_clip_uint8( int x )
+{
+  return x&(~255) ? (-x)>>31 : x;
+}
+void add4x4_idct( uint8_t *p_dst, int16_t dct[16])
+{
+  int16_t d[16];
+  int16_t tmp[16];
+  int i, y, x;
+  for( i = 0; i < 4; i++ )
+    {
+      int s02 =  dct[0*4+i]     +  dct[2*4+i];
+      int d02 =  dct[0*4+i]     -  dct[2*4+i];
+      int s13 =  dct[1*4+i]     + (dct[3*4+i]>>1);
+      int d13 = (dct[1*4+i]>>1) -  dct[3*4+i];
+      tmp[i*4+0] = s02 + s13;
+      tmp[i*4+1] = d02 + d13;
+      tmp[i*4+2] = d02 - d13;
+      tmp[i*4+3] = s02 - s13;
+    }
+  for( i = 0; i < 4; i++ )
+    {
+      int s02 =  tmp[0*4+i]     +  tmp[2*4+i];
+      int d02 =  tmp[0*4+i]     -  tmp[2*4+i];
+      int s13 =  tmp[1*4+i]     + (tmp[3*4+i]>>1);
+      int d13 = (tmp[1*4+i]>>1) -  tmp[3*4+i];
+      d[0*4+i] = ( s02 + s13 + 32 ) >> 6;
+      d[1*4+i] = ( d02 + d13 + 32 ) >> 6;
+      d[2*4+i] = ( d02 - d13 + 32 ) >> 6;
+      d[3*4+i] = ( s02 - s13 + 32 ) >> 6;
+    }
+  for( y = 0; y < 4; y++ )
+    {
+      for( x = 0; x < 4; x++ )
+        p_dst[x] = x264_clip_uint8( p_dst[x] + d[y*4+x] );
+      p_dst += 32;
+    }
+}
+
+int main()
+{
+  uint8_t dst[128];
+  int16_t dct[16];
+  int i;
+
+  for (i = 0; i < 16; i++)
+    dct[i] = i*10 + i;
+  for (i = 0; i < 128; i++)
+    dst[i] = i;
+
+  add4x4_idct(dst, dct);
+
+  if (memcmp (dst, expected, 128))
+    abort();
+
+ return 0;
+}
+
Index: gcc/testsuite/gcc.target/powerpc/swaps-p8-46.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/swaps-p8-46.c b/gcc/testsuite/gcc.target/powerpc/swaps-p8-46.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/swaps-p8-46.c	(revision 262353)
@@ -0,0 +1,34 @@
+/* { dg-do run { target { powerpc64le-*-* } } } */
+/* { dg-require-effective-target powerpc_p8vector_ok } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8 -O2 " } */
+
+typedef __attribute__ ((__aligned__ (8))) unsigned long long __m64;
+typedef float __m128 __attribute__ ((__vector_size__ (16), __may_alias__));
+
+/* PR84033.  Extracted from xmmintrin.h but with a pointer param to
+   allow swaps to happen when not inline.  */
+int __attribute__ ((__noinline__))
+_mm_movemask_ps (__m128 *__A)
+{
+  __vector __m64 result;
+  static const __vector unsigned int perm_mask =
+    {
+      0x00204060, 0x80808080, 0x80808080, 0x80808080
+    };
+
+  result = (__vector __m64)
+    __builtin_vec_vbpermq ((__vector unsigned char) (*__A),
+			   (__vector unsigned char) perm_mask);
+  return result[1];
+}
+
+int
+main (void)
+{
+  union { unsigned int i[4]; __m128 m; } x
+    = { 0x80000000, 0x80000000, 0x7fffffff, 0x7fffffff };
+  if (_mm_movemask_ps (&x.m) != 3)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/powerpc/extend-divide-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/extend-divide-1.c b/gcc/testsuite/gcc.target/powerpc/extend-divide-1.c
--- a/gcc/testsuite/gcc.target/powerpc/extend-divide-1.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/powerpc/extend-divide-1.c	(revision 262353)
@@ -5,9 +5,7 @@
 /* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
 /* { dg-options "-mcpu=power7 -O2" } */
 /* { dg-final { scan-assembler-times "divwe "   1 } } */
-/* { dg-final { scan-assembler-times "divweo "  1 } } */
 /* { dg-final { scan-assembler-times "divweu "  1 } } */
-/* { dg-final { scan-assembler-times "divweuo " 1 } } */
 /* { dg-final { scan-assembler-not    "bl __builtin" } } */
 
 int
@@ -16,20 +14,8 @@
   return __builtin_divwe (a, b);
 }
 
-int
-div_weo (int a, int b)
-{
-  return __builtin_divweo (a, b);
-}
-
 unsigned int
 div_weu (unsigned int a, unsigned int b)
 {
   return __builtin_divweu (a, b);
 }
-
-unsigned int
-div_weuo (unsigned int a, unsigned int b)
-{
-  return __builtin_divweuo (a, b);
-}
Index: gcc/testsuite/gcc.target/powerpc/extend-divide-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/extend-divide-2.c b/gcc/testsuite/gcc.target/powerpc/extend-divide-2.c
--- a/gcc/testsuite/gcc.target/powerpc/extend-divide-2.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/powerpc/extend-divide-2.c	(revision 262353)
@@ -5,9 +5,7 @@
 /* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power7" } } */
 /* { dg-options "-mcpu=power7 -O2" } */
 /* { dg-final { scan-assembler-times "divde "   1 } } */
-/* { dg-final { scan-assembler-times "divdeo "  1 } } */
 /* { dg-final { scan-assembler-times "divdeu "  1 } } */
-/* { dg-final { scan-assembler-times "divdeuo " 1 } } */
 /* { dg-final { scan-assembler-not    "bl __builtin" } } */
 
 long
@@ -16,20 +14,8 @@
   return __builtin_divde (a, b);
 }
 
-long
-div_deo (long a, long b)
-{
-  return __builtin_divdeo (a, b);
-}
-
 unsigned long
 div_deu (unsigned long a, unsigned long b)
 {
   return __builtin_divdeu (a, b);
 }
-
-unsigned long
-div_deuo (unsigned long a, unsigned long b)
-{
-  return __builtin_divdeuo (a, b);
-}
Index: gcc/testsuite/gcc.target/powerpc/pr83862.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pr83862.c b/gcc/testsuite/gcc.target/powerpc/pr83862.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/pr83862.c	(revision 262353)
@@ -0,0 +1,34 @@
+/* PR target/83862.c */
+/* { dg-do compile { target { powerpc*-*-* && lp64 } } } */
+/* { dg-require-effective-target ppc_float128_sw } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-options "-mpower9-vector -O2 -mfloat128" } */
+
+/* On little endian systems, optimizing signbit of IEEE 128-bit values from
+   memory could abort if the memory address was indexed (reg+reg).  The
+   optimization is only on 64-bit machines with direct move.
+
+   Compile with -g -O2 -mabi=ieeelongdouble -Wno-psabi.  */
+
+#ifndef TYPE
+#define TYPE __float128
+#endif
+
+int sbr (TYPE a) { return __builtin_signbit (a); }
+int sbm (TYPE *a) { return __builtin_signbit (*a); }
+int sbo (TYPE *a) { return __builtin_signbit (a[4]); }
+int sbi (TYPE *a, unsigned long n) { return __builtin_signbit (a[n]); }
+void sbs (int *p, TYPE a) { *p = __builtin_signbit (a); }
+
+/* On big endian systems, this will generate 2 LDs and 1 LDX, while on
+   little endian systems, this will generate 3 LDs and an ADD.  */
+
+/* { dg-final { scan-assembler-times {\mldx?\M}    3 } } */
+/* { dg-final { scan-assembler-times {\mmfvsrd\M}  2 } } */
+/* { dg-final { scan-assembler-times {\msrdi\M}    5 } } */
+/* { dg-final { scan-assembler-not   {\mmfvsrld\M}   } } */
+/* { dg-final { scan-assembler-not   {\mstxvx?\M}    } } */
+/* { dg-final { scan-assembler-not   {\mstxvw4x\M}   } } */
+/* { dg-final { scan-assembler-not   {\mstxvd2x\M}   } } */
+/* { dg-final { scan-assembler-not   {\mstvx\M}      } } */
+
Index: gcc/testsuite/gcc.target/powerpc/builtins-7-p9-runnable.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/builtins-7-p9-runnable.c b/gcc/testsuite/gcc.target/powerpc/builtins-7-p9-runnable.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/builtins-7-p9-runnable.c	(revision 262353)
@@ -0,0 +1,169 @@
+/* { dg-do run { target { powerpc*-*-* && p9vector_hw } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-options "-mcpu=power9 -O2" } */
+
+#include <altivec.h>
+#define TRUE 1
+#define FALSE 0
+
+#ifdef DEBUG
+#include <stdio.h>
+#endif
+
+#define EXTRACT 0
+
+void abort (void);
+
+int result_wrong_ull (vector unsigned long long vec_expected,
+		      vector unsigned long long vec_actual)
+{
+  int i;
+
+  for (i = 0; i < 2; i++)
+    if (vec_expected[i] != vec_actual[i])
+      return TRUE;
+
+  return FALSE;
+}
+
+int result_wrong_uc (vector unsigned char vec_expected,
+		     vector unsigned char vec_actual)
+{
+  int i;
+
+  for (i = 0; i < 16; i++)
+    if (vec_expected[i] != vec_actual[i])
+      return TRUE;
+
+  return FALSE;
+}
+
+#ifdef DEBUG
+void print_ull (vector unsigned long long vec_expected,
+		vector unsigned long long vec_actual)
+{
+  int i;
+
+  printf("expected unsigned long long data\n");
+  for (i = 0; i < 2; i++)
+    printf(" %lld,", vec_expected[i]);
+
+  printf("\nactual signed char data\n");
+  for (i = 0; i < 2; i++)
+    printf(" %lld,", vec_actual[i]);
+  printf("\n");
+}
+
+void print_uc (vector unsigned char vec_expected,
+	       vector unsigned char vec_actual)
+{
+  int i;
+
+  printf("expected unsigned char data\n");
+  for (i = 0; i < 16; i++)
+    printf(" %d,", vec_expected[i]);
+
+  printf("\nactual unsigned char data\n");
+  for (i = 0; i < 16; i++)
+    printf(" %d,", vec_actual[i]);
+  printf("\n");
+}
+#endif
+
+#if EXTRACT
+vector unsigned long long
+vext (vector unsigned char *vc)
+{
+  return vextract_si_vchar (*vc, 5);
+}
+#endif
+
+int main()
+{
+   vector signed int vsi_arg;
+   vector unsigned char vec_uc_arg, vec_uc_result, vec_uc_expected;
+   vector unsigned long long vec_ull_result, vec_ull_expected;
+   unsigned long long ull_result, ull_expected;
+
+   vec_uc_arg = (vector unsigned char){1, 2, 3, 4,
+				       5, 6, 7, 8,
+				       9, 10, 11, 12,
+				       13, 14, 15, 16};
+
+   vsi_arg = (vector signed int){0xA, 0xB, 0xC, 0xD};
+
+   vec_uc_expected = (vector unsigned char){0xC, 0, 0, 0,
+					    5, 6, 7, 8,
+					    9, 10, 11, 12,
+					    13, 14, 15, 16};
+   /* Test vec_insert4b() */
+   /* Insert into char 0 location */
+   vec_uc_result = vec_insert4b (vsi_arg, vec_uc_arg, 0);
+
+   if (result_wrong_uc(vec_uc_expected, vec_uc_result))
+     {
+#ifdef DEBUG
+        printf("Error: vec_insert4b pos 0, result does not match expected result\n");
+	print_uc (vec_uc_expected, vec_uc_result);
+#else
+        abort();
+#endif
+      }
+
+   /* insert into char 4 location */
+   vec_uc_expected = (vector unsigned char){1, 2, 3, 4,
+					    0xC, 0, 0, 0,
+					    9, 10, 11, 12,
+					    13, 14, 15, 16};
+   vec_uc_result = vec_insert4b (vsi_arg, vec_uc_arg, 4);
+
+   if (result_wrong_uc(vec_uc_expected, vec_uc_result))
+     {
+#ifdef DEBUG
+        printf("Error: vec_insert4b pos 4, result does not match expected result\n");
+	print_uc (vec_uc_expected, vec_uc_result);
+#else
+        abort();
+#endif
+      }
+
+   /* Test vec_extract4b() */
+   /* Extract 4b, from char 0 location */
+   vec_uc_arg = (vector unsigned char){10, 0, 0, 0,
+				       20, 0, 0, 0,
+				       30, 0, 0, 0,
+				       40, 0, 0, 0};
+
+   vec_ull_expected = (vector unsigned long long){0, 10};
+   vec_ull_result = vec_extract4b(vec_uc_arg, 0);
+
+   if (result_wrong_ull(vec_ull_expected, vec_ull_result))
+     {
+#ifdef DEBUG
+        printf("Error: vec_extract4b pos 0, result does not match expected result\n");
+	print_ull (vec_ull_expected, vec_ull_result);
+#else
+        abort();
+#endif
+      }
+
+   /* Extract 4b, from char 12 location */
+   vec_uc_arg = (vector unsigned char){10, 0, 0, 0,
+				       20, 0, 0, 0,
+				       30, 0, 0, 0,
+				       40, 0, 0, 0};
+
+   vec_ull_expected = (vector unsigned long long){0, 40};
+   vec_ull_result = vec_extract4b(vec_uc_arg, 12);
+
+   if (result_wrong_ull(vec_ull_expected, vec_ull_result))
+     {
+#ifdef DEBUG
+        printf("Error: vec_extract4b pos 12, result does not match expected result\n");
+	print_ull (vec_ull_expected, vec_ull_result);
+#else
+        abort();
+#endif
+      }
+}
Index: gcc/testsuite/gcc.target/powerpc/pr83399.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pr83399.c b/gcc/testsuite/gcc.target/powerpc/pr83399.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/pr83399.c	(revision 262353)
@@ -0,0 +1,15 @@
+/* PR target/83399 */
+/* { dg-do compile } */
+/* { dg-require-effective-target powerpc_vsx_ok } */
+/* { dg-options "-O1 -mabi=elfv2 -mlittle -mvsx" } */
+
+typedef __attribute__((altivec(vector__))) int v4si_t;
+int
+foo (void)
+{
+  v4si_t a, u, v, y;
+  u = __builtin_altivec_lvx (32, ((void *) &a) - 32);
+  v = __builtin_altivec_lvx (64, ((void *) &a) - 32);
+  y = u + v;
+  return y[0];
+}
Index: gcc/testsuite/gcc.target/powerpc/lvsl-lvsr.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/lvsl-lvsr.c b/gcc/testsuite/gcc.target/powerpc/lvsl-lvsr.c
--- a/gcc/testsuite/gcc.target/powerpc/lvsl-lvsr.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/powerpc/lvsl-lvsr.c	(revision 262353)
@@ -6,7 +6,7 @@
 /* { dg-options "-O0 -Wno-deprecated" } */
 /* { dg-final { scan-assembler-times "lvsl" 2 } } */
 /* { dg-final { scan-assembler-times "lvsr" 2 } } */
-/* { dg-final { scan-assembler-times "lxvd2x" 2 } } */
+/* { dg-final { scan-assembler-times {\mlxvd2x\M|\mlxv\M} 2 } } */
 /* { dg-final { scan-assembler-times "vperm" 2 } } */
 
 
Index: gcc/testsuite/gcc.target/powerpc/pr84154-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pr84154-1.c b/gcc/testsuite/gcc.target/powerpc/pr84154-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/pr84154-1.c	(revision 262353)
@@ -0,0 +1,55 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-require-effective-target powerpc_p8vector_ok } */
+/* { dg-options "-mpower8-vector -O2" } */
+
+/* PR target/84154.  Make sure conversion to char/short does not generate a
+   store and a load on ISA 2.07 and newer systems.  */
+
+unsigned char
+double_to_uc (double x)
+{
+  return x;
+}
+
+signed char
+double_to_sc (double x)
+{
+  return x;
+}
+
+unsigned short
+double_to_us (double x)
+{
+  return x;
+}
+
+short
+double_to_ss (double x)
+{
+  return x;
+}
+
+unsigned int
+double_to_ui (double x)
+{
+  return x;
+}
+
+int
+double_to_si (double x)
+{
+  return x;
+}
+
+/* { dg-final { scan-assembler-times {\mextsb\M}                  1 } } */
+/* { dg-final { scan-assembler-times {\mextsh\M}                  1 } } */
+/* { dg-final { scan-assembler-times {\mfctiwuz\M|\mxscvdpuxws\M} 3 } } */
+/* { dg-final { scan-assembler-times {\mfctiwz\M|\mxscvdpsxws\M}  3 } } */
+/* { dg-final { scan-assembler-times {\mmfvsrwz\M}                6 } } */
+/* { dg-final { scan-assembler-times {\mrlwinm\M}                 2 } } */
+/* { dg-final { scan-assembler-not   {\mlbz\M}                      } } */
+/* { dg-final { scan-assembler-not   {\mlhz\M}                      } } */
+/* { dg-final { scan-assembler-not   {\mlha\M}                      } } */
+/* { dg-final { scan-assembler-not   {\mmfvsrd\M}                   } } */
+/* { dg-final { scan-assembler-not   {\mstw\M}                      } } */
Index: gcc/testsuite/gcc.target/powerpc/crypto-builtin-1-runnable.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/crypto-builtin-1-runnable.c b/gcc/testsuite/gcc.target/powerpc/crypto-builtin-1-runnable.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/crypto-builtin-1-runnable.c	(revision 262353)
@@ -0,0 +1,109 @@
+/* { dg-do run { target { powerpc*-*-* && p8vector_hw } } } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8 -O2 " } */
+
+/* Make sure the test case compiled with -O2 generates the same expected
+   results.  The expected results were generated with -O0.  */
+
+#include <altivec.h>
+#define TRUE 1
+#define FALSE 0
+
+#define DEBUG 1
+
+#ifdef DEBUG
+#include <stdio.h>
+#endif
+
+void abort (void);
+
+typedef vector unsigned long long	crypto_t;
+typedef vector unsigned long long	v2di_t;
+typedef vector unsigned int		v4si_t;
+typedef vector unsigned short		v8hi_t;
+typedef vector unsigned char		v16qi_t;
+
+v16qi_t crypto6a (v16qi_t a, v16qi_t b, v16qi_t c)
+{
+  return __builtin_crypto_vpermxor (a, b, c);
+}
+
+v8hi_t crypto6b (v8hi_t a, v8hi_t b, v8hi_t c)
+{
+  return __builtin_crypto_vpermxor (a, b, c);
+}
+
+v4si_t crypto6c (v4si_t a, v4si_t b, v4si_t c)
+{
+  return __builtin_crypto_vpermxor (a, b, c);
+}
+
+v2di_t crypto6d (v2di_t a, v2di_t b, v2di_t c)
+{
+  return __builtin_crypto_vpermxor (a, b, c);
+}
+
+int main()
+{
+  int i;
+  v16qi_t expected_v16qi, result_v16qi;
+  v8hi_t expected_v8hi, result_v8hi;
+  v4si_t expected_v4si, result_v4si;
+  v2di_t expected_v2di, result_v2di;
+  v16qi_t v16qi_arg_a, v16qi_arg_b, v16qi_arg_c;
+  v8hi_t v8hi_arg_a, v8hi_arg_b, v8hi_arg_c;
+  v4si_t v4si_arg_a, v4si_arg_b, v4si_arg_c;
+  v2di_t v2di_arg_a, v2di_arg_b, v2di_arg_c;
+
+  v16qi_arg_a = (vector unsigned char){ 7, 6, 5, 4, 3, 2, 1, 0,
+					1, 2, 3, 4, 5, 6, 7, 8 };
+  v16qi_arg_b = (vector unsigned char){ 1, 2, 3, 4, 5, 6, 7, 8,
+					7, 6, 5, 4, 3, 2, 1, 0 };
+  v16qi_arg_c = (vector unsigned char){ 7, 2, 5, 4, 3, 6, 1, 8,
+					1, 6, 3, 4, 5, 2, 7, 0 };
+  expected_v16qi = (vector unsigned char){ 15, 10, 13, 12, 11, 14, 9, 0,
+					   9, 14, 11, 12, 13, 10, 15, 8 };
+		
+  result_v16qi = crypto6a (v16qi_arg_a, v16qi_arg_b, v16qi_arg_c);
+				      
+  for (i = 0; i < 16; i++)
+    if (expected_v16qi[i] != result_v16qi[i])
+      printf("crypto6a: result_v16qi[%d] =  %d, expected = %d\n",
+	     i, result_v16qi[i], expected_v16qi[i]);
+
+  v8hi_arg_a = (vector unsigned short int){ 7, 6, 5, 4, 3, 2, 1, 0};
+  v8hi_arg_b = (vector unsigned short int){ 1, 2, 3, 4, 5, 6, 7, 8};
+  v8hi_arg_c = (vector unsigned short int){ 7, 2, 5, 4, 3, 6, 1, 8};
+  expected_v8hi = (vector unsigned short int){ 5, 0, 6, 0, 7, 0, 8};
+		
+  result_v8hi = crypto6b (v8hi_arg_a, v8hi_arg_b, v8hi_arg_c);
+				      
+  for (i = 0; i < 8; i++)
+    if (expected_v8hi[i] != result_v8hi[i])
+      printf("crypto6a: result_v8hi[%d] =  %d, expected = %d\n",
+	     i, result_v8hi[i], expected_v8hi[i]);
+
+  v4si_arg_a = (vector unsigned int){ 7, 6, 5, 4};
+  v4si_arg_b = (vector unsigned int){ 15, 6, 7, 8};
+  v4si_arg_c = (vector unsigned int){ 7, 14, 3, 6};
+  expected_v4si = (vector unsigned int){ 7, 0, 8, 0};
+		
+  result_v4si = crypto6c (v4si_arg_a, v4si_arg_b, v4si_arg_c);
+				      
+  for (i = 0; i < 4; i++)
+    if (expected_v4si[i] != result_v4si[i])
+      printf("crypto6a: result_v4si[%d] =  %d, expected = %d\n",
+	     i, result_v4si[i], expected_v4si[i]);
+
+  v2di_arg_a = (vector unsigned long long int){ 7, 6, };
+  v2di_arg_b = (vector unsigned long long int){ 15, 6, };
+  v2di_arg_c = (vector unsigned long long int){ 7, 14};
+  expected_v2di = (vector unsigned long long int){ 6, 0};
+		
+  result_v2di = crypto6d (v2di_arg_a, v2di_arg_b, v2di_arg_c);
+				      
+  for (i = 0; i < 2; i++)
+    if (expected_v2di[i] != result_v2di[i])
+      printf("crypto6a: result_v2di[%d] =  %d, expected = %d\n",
+	     i, result_v2di[i], expected_v2di[i]);
+}
Index: gcc/testsuite/gcc.target/powerpc/pr84154-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pr84154-2.c b/gcc/testsuite/gcc.target/powerpc/pr84154-2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/pr84154-2.c	(revision 262353)
@@ -0,0 +1,58 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-require-effective-target powerpc_p8vector_ok } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-mcpu=power8 -O2" } */
+
+/* PR target/84154.  Make sure on ISA 2.07 (power8) that we store the result of
+   a conversion to char/short using an offsettable address does not generate
+   direct moves for storing 32-bit integers, but does do a direct move for
+   8/16-bit integers.  */
+
+void
+double_to_uc (double x, unsigned char *p)
+{
+  p[3] = x;
+}
+
+void
+double_to_sc (double x, signed char *p)
+{
+  p[3] = x;
+}
+
+void
+double_to_us (double x, unsigned short *p)
+{
+  p[3] = x;
+}
+
+void
+double_to_ss (double x, short *p)
+{
+  p[3] = x;
+}
+
+void
+double_to_ui (double x, unsigned int *p)
+{
+  p[3] = x;
+}
+
+void
+double_to_si (double x, int *p)
+{
+  p[3] = x;
+}
+
+/* { dg-final { scan-assembler-times {\mfctiwuz\M|\mxscvdpuxws\M} 3 } } */
+/* { dg-final { scan-assembler-times {\mfctiwz\M|\mxscvdpsxws\M}  3 } } */
+/* { dg-final { scan-assembler-times {\mmfvsrwz\M}                4 } } */
+/* { dg-final { scan-assembler-times {\mstfiwx\M|\mstxsiwx\M}     2 } } */
+/* { dg-final { scan-assembler-times {\mstb\M}                    2 } } */
+/* { dg-final { scan-assembler-times {\msth\M}                    2 } } */
+/* { dg-final { scan-assembler-not   {\mlbz\M}                      } } */
+/* { dg-final { scan-assembler-not   {\mlhz\M}                      } } */
+/* { dg-final { scan-assembler-not   {\mlha\M}                      } } */
+/* { dg-final { scan-assembler-not   {\mmfvsrd\M}                   } } */
+/* { dg-final { scan-assembler-not   {\mstw\M}                      } } */
Index: gcc/testsuite/gcc.target/powerpc/vsxcopy.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/vsxcopy.c b/gcc/testsuite/gcc.target/powerpc/vsxcopy.c
--- a/gcc/testsuite/gcc.target/powerpc/vsxcopy.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/powerpc/vsxcopy.c	(revision 262353)
@@ -1,8 +1,8 @@
 /* { dg-do compile { target { powerpc64*-*-* } } } */
 /* { dg-require-effective-target powerpc_vsx_ok } */
 /* { dg-options "-O1 -mvsx" } */
-/* { dg-final { scan-assembler "lxvd2x" } } */
-/* { dg-final { scan-assembler "stxvd2x" } } */
+/* { dg-final { scan-assembler {\mlxvd2x\M|\mlxv\M} } } */
+/* { dg-final { scan-assembler {\mstxvd2x\M|\mstxv\M} } } */
 /* { dg-final { scan-assembler-not "xxpermdi" } } */
 
 typedef float vecf __attribute__ ((vector_size (16)));
Index: gcc/testsuite/gcc.target/powerpc/pr85755.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pr85755.c b/gcc/testsuite/gcc.target/powerpc/pr85755.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/pr85755.c	(revision 262353)
@@ -0,0 +1,22 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-options "-O1" } */
+
+void
+preinc (long *q, long n)
+{
+  long i;
+  for (i = 0; i < n; i++)
+    q[i] = i;
+}
+
+void
+predec (long *q, long n)
+{
+  long i;
+  for (i = n; i >= 0; i--)
+    q[i] = i;
+}
+
+/* { dg-final { scan-assembler-times {\mstwu\M} 2 { target ilp32 } } } */
+/* { dg-final { scan-assembler-times {\mstdu\M} 2 { target lp64 } } } */
+/* { dg-final { scan-assembler-not {\mstfdu\M} } } */
Index: gcc/testsuite/gcc.target/powerpc/pr84154-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pr84154-3.c b/gcc/testsuite/gcc.target/powerpc/pr84154-3.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/pr84154-3.c	(revision 262353)
@@ -0,0 +1,60 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-require-effective-target powerpc_p9vector_ok } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power9" } } */
+/* { dg-options "-mcpu=power9 -O2" } */
+
+/* PR target/84154.  Make sure on ISA 3.0 we store the result of a conversion
+   to char/short using an offsettable address does not generate direct moves
+   for storing 8/16/32-bit integers.  */
+
+void
+double_to_uc (double x, unsigned char *p)
+{
+  p[3] = x;
+}
+
+void
+double_to_sc (double x, signed char *p)
+{
+  p[3] = x;
+}
+
+void
+double_to_us (double x, unsigned short *p)
+{
+  p[3] = x;
+}
+
+void
+double_to_ss (double x, short *p)
+{
+  p[3] = x;
+}
+
+void
+double_to_ui (double x, unsigned int *p)
+{
+  p[3] = x;
+}
+
+void
+double_to_si (double x, int *p)
+{
+  p[3] = x;
+}
+
+/* { dg-final { scan-assembler-times {\maddi\M}                   6 } } */
+/* { dg-final { scan-assembler-times {\mfctiwuz\M|\mxscvdpuxws\M} 3 } } */
+/* { dg-final { scan-assembler-times {\mfctiwz\M|\mxscvdpsxws\M}  3 } } */
+/* { dg-final { scan-assembler-times {\mstfiwx\M|\mstxsiwx\M}     2 } } */
+/* { dg-final { scan-assembler-times {\mstxsibx\M}                2 } } */
+/* { dg-final { scan-assembler-times {\mstxsihx\M}                2 } } */
+/* { dg-final { scan-assembler-not   {\mlbz\M}                      } } */
+/* { dg-final { scan-assembler-not   {\mlhz\M}                      } } */
+/* { dg-final { scan-assembler-not   {\mlha\M}                      } } */
+/* { dg-final { scan-assembler-not   {\mmfvsrwz\M}                  } } */
+/* { dg-final { scan-assembler-not   {\mmfvsrd\M}                   } } */
+/* { dg-final { scan-assembler-not   {\mstw\M}                      } } */
+/* { dg-final { scan-assembler-not   {\mstb\M}                      } } */
+/* { dg-final { scan-assembler-not   {\msth\M}                      } } */
Index: gcc/testsuite/gcc.target/powerpc/pr84700.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/pr84700.c b/gcc/testsuite/gcc.target/powerpc/pr84700.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/powerpc/pr84700.c	(revision 262353)
@@ -0,0 +1,12 @@
+/* PR target/84700 */
+/* { dg-do compile } */
+/* { dg-options "-O1 -misel" } */
+
+long long int
+foo (long long int x)
+{
+  long long int a = x < 2;
+  int b = a >= 0;
+
+  return a + ((x == 0) ? a : b);
+}
Index: gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-1.c b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-1.c
--- a/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-1.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/powerpc/safe-indirect-jump-1.c	(revision 262353)
@@ -1,5 +1,6 @@
-/* { dg-do compile { target { lp64 } } } */
+/* { dg-do compile } */
 /* { dg-additional-options "-mno-speculate-indirect-jumps" } */
+/* { dg-warning "'-mno-speculate-indirect-jumps' is deprecated" "" { target *-*-* } 0 } */
 
 /* Test for deliberate misprediction of indirect calls.  */
 
@@ -11,4 +12,10 @@
 }
 
 /* { dg-final { scan-assembler "crset 2" } } */
-/* { dg-final { scan-assembler "beqctrl-" } } */
+
+/* The AIX and ELFv2 ABIs don't allow a sibcall here.  */
+/* { dg-final { scan-assembler "beqctrl-" { target { lp64 || { powerpc*-*-aix* } } } } } */
+
+/* The other ABIs do allow a sibcall.  */
+/* { dg-final { scan-assembler "beqctr-" { target { ilp32 && !powerpc*-*-aix* } } } } */
+/* { dg-final { scan-assembler {b \$} { target { ilp32 && !powerpc*-*-aix* } } } } */
Index: gcc/testsuite/gcc.target/nvptx/pr85056a.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/nvptx/pr85056a.c b/gcc/testsuite/gcc.target/nvptx/pr85056a.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/nvptx/pr85056a.c	(revision 262353)
@@ -0,0 +1,3 @@
+/* { dg-skip-if "" { *-*-* } } */
+
+int a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
Index: gcc/testsuite/gcc.target/nvptx/pr85056.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/nvptx/pr85056.c b/gcc/testsuite/gcc.target/nvptx/pr85056.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/nvptx/pr85056.c	(revision 262353)
@@ -0,0 +1,21 @@
+/* { dg-do run } */
+/* { dg-additional-sources "pr85056a.c" } */
+
+extern void abort ();
+
+extern int a[];
+
+int
+main ()
+{
+  int i, sum;
+
+  sum = 0;
+  for (i = 0; i < 10; i++)
+    sum += a[i];
+
+  if (sum != 55)
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/nvptx/indirect_call.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/nvptx/indirect_call.c b/gcc/testsuite/gcc.target/nvptx/indirect_call.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/nvptx/indirect_call.c	(revision 262353)
@@ -0,0 +1,19 @@
+/* { dg-options "-O2 -msoft-stack" } */
+/* { dg-do run } */
+
+int
+f1 (int a)
+{
+  return a + 1;
+}
+  
+int (*f2)(int) = f1;
+
+int
+main ()
+{
+  if (f2 (100) != 101)
+    __builtin_abort();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/arm/pr82518.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/arm/pr82518.c b/gcc/testsuite/gcc.target/arm/pr82518.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/arm/pr82518.c	(revision 262353)
@@ -0,0 +1,29 @@
+/* { dg-do run } */
+/* { dg-require-effective-target arm_neon_hw } */
+/* { dg-additional-options "-O3 -fno-inline -std=gnu99" } */
+/* { dg-add-options arm_neon } */
+
+typedef struct { int x, y; } X;
+
+void f4(X *p, int n)
+{
+  for (int i = 0; i < n; i++)
+  { p[i].x = i;
+    p[i].y = i + 1;
+  }
+}
+
+__attribute ((aligned (16))) X arr[100];
+
+int main(void)
+{
+  volatile int fail = 0;
+  f4 (arr, 100);
+  for (int i = 0; i < 100; i++)
+    if (arr[i].y != i+1 || arr[i].x != i)
+      fail = 1;
+  if (fail)
+     __builtin_abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.target/arm/cmse/cmse-1c99.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/arm/cmse/cmse-1c99.c b/gcc/testsuite/gcc.target/arm/cmse/cmse-1c99.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/arm/cmse/cmse-1c99.c	(revision 262353)
@@ -0,0 +1,4 @@
+/* { dg-do compile } */
+/* { dg-options "-Os -mcmse -std=c99" }  */
+/* This is a copy of cmse-1.c to test arm_mve.h ISO C compatibility.  */
+#include "cmse-1.c"
Index: gcc/testsuite/gcc.target/arm/cmse/cmse-16.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/arm/cmse/cmse-16.c b/gcc/testsuite/gcc.target/arm/cmse/cmse-16.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/arm/cmse/cmse-16.c	(revision 262353)
@@ -0,0 +1,18 @@
+/* { dg-do run } */
+/* { dg-options "-Os -mcmse" }  */
+
+#include <arm_cmse.h>
+
+int
+foo (void)
+{
+  return cmse_nonsecure_caller ();
+}
+
+int
+main (void)
+{
+  /* Return success (0) if main is secure, ie if cmse_nonsecure_caller/foo
+     returns false (0).  */
+  return foo ();
+}
Index: gcc/testsuite/gcc.target/arm/cmse/cmse-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/arm/cmse/cmse-1.c b/gcc/testsuite/gcc.target/arm/cmse/cmse-1.c
--- a/gcc/testsuite/gcc.target/arm/cmse/cmse-1.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/arm/cmse/cmse-1.c	(revision 262353)
@@ -71,7 +71,21 @@
 {
   return cmse_nonsecure_caller ();
 }
+/* { dg-final { scan-assembler "baz:" } } */
+/* { dg-final { scan-assembler "__acle_se_baz:" } } */
+/* { dg-final { scan-assembler-not "\tcmse_nonsecure_caller" } } */
+/* Look for an andsi of 1 with a register in function baz, ie.
 
+;; Function baz<anything>
+<any line without '('>
+(insn <anything but '('> (set (reg<any register modifier>:SI <anything but ')'>)
+     (and:SI (reg<any register modifier>:SI <anything but ')'>)
+	     (const_int 1 <anything but ')'>)<anything but '('>
+   <optional: (nil)<anything but '('>>
+(insn
+*/
+/* { dg-final { scan-rtl-dump "\n;; Function baz\[^\n\]*\[^(\]+\[^;\]*\n\\(insn \[^(\]+ \\(set \\(reg\[^:\]*:SI \[^)\]+\\)\[^(\]*\\(and:SI \\(reg\[^:\]*:SI \[^)\]+\\)\[^(\]*\\((const_int 1|reg\[^:\]*:SI) \[^)\]+\\)\[^(\]+(\\(nil\\)\[^(\]+)?\\(insn" expand } } */
+
 typedef int __attribute__ ((cmse_nonsecure_call)) (int_nsfunc_t) (void);
 
 int default_callback (void)
@@ -86,6 +100,11 @@
 {
   fp = cmse_nsfptr_create (callback);
 }
+/* { dg-final { scan-assembler "qux:" } } */
+/* { dg-final { scan-assembler "__acle_se_qux:" } } */
+/* { dg-final { scan-assembler "bic" } } */
+/* { dg-final { scan-assembler "push\t\{r4, r5, r6" } } */
+/* { dg-final { scan-assembler "msr\tAPSR_nzcvq" } } */
 
 int call_callback (void)
 {
@@ -94,13 +113,4 @@
   else
     return default_callback ();
 }
-/* { dg-final { scan-assembler "baz:" } } */
-/* { dg-final { scan-assembler "__acle_se_baz:" } } */
-/* { dg-final { scan-assembler "qux:" } } */
-/* { dg-final { scan-assembler "__acle_se_qux:" } } */
-/* { dg-final { scan-assembler-not "\tcmse_nonsecure_caller" } } */
-/* { dg-final { scan-rtl-dump "and.*reg.*const_int 1" expand } } */
-/* { dg-final { scan-assembler "bic" } } */
-/* { dg-final { scan-assembler "push\t\{r4, r5, r6" } } */
-/* { dg-final { scan-assembler "msr\tAPSR_nzcvq" } } */
 /* { dg-final { scan-assembler-times "bl\\s+__gnu_cmse_nonsecure_call" 1 } } */
Index: gcc/testsuite/gcc.target/arm/pr82989.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/arm/pr82989.c b/gcc/testsuite/gcc.target/arm/pr82989.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/arm/pr82989.c	(revision 262353)
@@ -0,0 +1,33 @@
+/* PR target/82989.  */
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_neon_ok } */
+/* { dg-skip-if "avoid conflicts with multilib options" { *-*-* } { "-mcpu=*" } { "-mcpu=cortex-a8" } } */
+/* { dg-skip-if "avoid conflicts with multilib options" { *-*-* } { "-mfpu=*" } { "-mfpu=neon" } } */
+/* { dg-skip-if "avoid conflicts with multilib options" { *-*-* } { "-mfloat-abi=*" } { "-mfloat-abi=hard" } } */
+/* { dg-options "-O2 -mcpu=cortex-a8 -mfpu=neon -mfloat-abi=hard" } */
+/* { dg-add-options arm_neon } */
+
+typedef unsigned long long uint64_t;
+
+void f_shr_imm (uint64_t *a)
+{
+  *a += *a >> 32;
+}
+
+void f_shr_reg (uint64_t *a, uint64_t b)
+{
+  *a += *a >> b;
+}
+
+void f_shl_imm (uint64_t *a)
+{
+  *a += *a << 32;
+}
+
+void f_shl_reg (uint64_t *a, uint64_t b)
+{
+  *a += *a << b;
+}
+/* { dg-final { scan-assembler-not "vshl*" } } */
+/* { dg-final { scan-assembler-not "vshr*" } } */
+/* { dg-final { scan-assembler-not "vmov*" } } */
Index: gcc/testsuite/gcc.target/arm/fpscr.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/arm/fpscr.c b/gcc/testsuite/gcc.target/arm/fpscr.c
--- a/gcc/testsuite/gcc.target/arm/fpscr.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/arm/fpscr.c	(revision 262353)
@@ -6,11 +6,14 @@
 /* { dg-add-options arm_fp } */
 
 void
-test_fpscr ()
+test_fpscr (void)
 {
-  volatile unsigned int status = __builtin_arm_get_fpscr ();
+  unsigned status;
+
+  __builtin_arm_set_fpscr (0);
+  status = __builtin_arm_get_fpscr ();
   __builtin_arm_set_fpscr (status);
 }
 
 /* { dg-final { scan-assembler "mrc\tp10, 7, r\[0-9\]+, cr1, cr0, 0" } } */
-/* { dg-final { scan-assembler "mcr\tp10, 7, r\[0-9\]+, cr1, cr0, 0" } } */
+/* { dg-final { scan-assembler-times "mcr\tp10, 7, r\[0-9\]+, cr1, cr0, 0" 2 } } */
Index: gcc/testsuite/gcc.target/arm/pr84826.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/arm/pr84826.c b/gcc/testsuite/gcc.target/arm/pr84826.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/arm/pr84826.c	(revision 262353)
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target arm_thumb2_ok } */
+/* { dg-options "-Ofast -fstack-check" } */
+
+void d (void *);
+
+void a ()
+{
+  int b;
+  void bar (int c)
+  {
+    if (__builtin_expect (c, 0))
+      ++b;
+  }
+  d (bar);
+}
Index: gcc/testsuite/gcc.target/s390/nobp-table-jump-z10.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/nobp-table-jump-z10.c b/gcc/testsuite/gcc.target/s390/nobp-table-jump-z10.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/nobp-table-jump-z10.c	(revision 262353)
@@ -0,0 +1,77 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z10 -mzarch --save-temps -mindirect-branch-jump=thunk -mindirect-branch-table" } */
+/* case-values-threshold will be set to 20 by the back-end when jump
+   thunk are requested.  */
+
+int __attribute__((noinline,noclone)) foo1 (void) { return 1; }
+int __attribute__((noinline,noclone)) foo2 (void) { return 2; }
+int __attribute__((noinline,noclone)) foo3 (void) { return 3; }
+int __attribute__((noinline,noclone)) foo4 (void) { return 4; }
+int __attribute__((noinline,noclone)) foo5 (void) { return 5; }
+int __attribute__((noinline,noclone)) foo6 (void) { return 6; }
+int __attribute__((noinline,noclone)) foo7 (void) { return 7; }
+int __attribute__((noinline,noclone)) foo8 (void) { return 8; }
+int __attribute__((noinline,noclone)) foo9 (void) { return 9; }
+int __attribute__((noinline,noclone)) foo10 (void) { return 10; }
+int __attribute__((noinline,noclone)) foo11 (void) { return 11; }
+int __attribute__((noinline,noclone)) foo12 (void) { return 12; }
+int __attribute__((noinline,noclone)) foo13 (void) { return 13; }
+int __attribute__((noinline,noclone)) foo14 (void) { return 14; }
+int __attribute__((noinline,noclone)) foo15 (void) { return 15; }
+int __attribute__((noinline,noclone)) foo16 (void) { return 16; }
+int __attribute__((noinline,noclone)) foo17 (void) { return 17; }
+int __attribute__((noinline,noclone)) foo18 (void) { return 18; }
+int __attribute__((noinline,noclone)) foo19 (void) { return 19; }
+int __attribute__((noinline,noclone)) foo20 (void) { return 20; }
+
+
+int __attribute__((noinline,noclone))
+bar (int a)
+{
+  int ret = 0;
+
+  switch (a)
+    {
+    case 1: ret = foo1 (); break;
+    case 2: ret = foo2 (); break;
+    case 3: ret = foo3 (); break;
+    case 4: ret = foo4 (); break;
+    case 5: ret = foo5 (); break;
+    case 6: ret = foo6 (); break;
+    case 7: ret = foo7 (); break;
+    case 8: ret = foo8 (); break;
+    case 9: ret = foo9 (); break;
+    case 10: ret = foo10 (); break;
+    case 11: ret = foo11 (); break;
+    case 12: ret = foo12 (); break;
+    case 13: ret = foo13 (); break;
+    case 14: ret = foo14 (); break;
+    case 15: ret = foo15 (); break;
+    case 16: ret = foo16 (); break;
+    case 17: ret = foo17 (); break;
+    case 18: ret = foo18 (); break;
+    case 19: ret = foo19 (); break;
+    case 20: ret = foo20 (); break;
+    default:
+      __builtin_abort ();
+    }
+
+  return ret;
+}
+
+int
+main ()
+{
+  if (bar (3) != 3)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* 1 x bar
+/* { dg-final { scan-assembler-times "exrl" 1 } } */
+
+/* { dg-final { scan-assembler     "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_fromreg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_frommem" } } */
Index: gcc/testsuite/gcc.target/s390/nobp-indirect-jump-z900.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-z900.c b/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-z900.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-z900.c	(revision 262353)
@@ -0,0 +1,43 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z900 --save-temps -mindirect-branch-jump=thunk -mindirect-branch-table" } */
+/* { dg-require-effective-target label_values } */
+
+/* This is a copy of the gcc.c-torture/execute/20040302-1.c
+   testcase.  */
+
+int code[]={0,0,0,0,1};
+
+void
+foo(int x) {
+  volatile int b;
+  b = 0xffffffff;
+}
+
+void
+bar(int *pc) {
+  static const void *l[] = {&&lab0, &&end};
+
+  foo(0);
+  goto *l[*pc];
+ lab0:
+  foo(0);
+  pc++;
+  goto *l[*pc];
+ end:
+  return;
+}
+
+int
+main() {
+  bar(code);
+  return 0;
+}
+
+/* 2 x bar
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 2 } } */
+/* { dg-final { scan-assembler "ex\t" } } */
+
+/* { dg-final { scan-assembler     "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
Index: gcc/testsuite/gcc.target/s390/htm-builtins-compile-4.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/htm-builtins-compile-4.c b/gcc/testsuite/gcc.target/s390/htm-builtins-compile-4.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/htm-builtins-compile-4.c	(revision 262353)
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -march=zEC12 -mzarch" } */
+
+/* A bug in the builtin definition made__builtin_tbeginc to have an
+   integer return argument.  */
+void
+must_not_compile1 (void)
+{
+  int rc = __builtin_tbeginc (); /* { dg-error "void value not ignored as it ought to be" } */
+}
Index: gcc/testsuite/gcc.target/s390/nobp-no-dwarf2-cfi.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/nobp-no-dwarf2-cfi.c b/gcc/testsuite/gcc.target/s390/nobp-no-dwarf2-cfi.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/nobp-no-dwarf2-cfi.c	(revision 262353)
@@ -0,0 +1,19 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z900 --save-temps -mfunction-return-reg=thunk -mindirect-branch-table -fno-dwarf2-cfi-asm" } */
+
+/* Make sure that we do not emit .cfi directives when -fno-dwarf2-cfi-asm is being used.  */
+
+int
+main ()
+{
+  return 0;
+}
+
+/* 1 x main
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 1 } } */
+/* { dg-final { scan-assembler "ex\t" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler     "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
Index: gcc/testsuite/gcc.target/s390/pr84295.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/pr84295.c b/gcc/testsuite/gcc.target/s390/pr84295.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/pr84295.c	(revision 262353)
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -march=z900 -fgnu89-inline --save-temps -mfunction-return-reg=thunk -mindirect-branch-table" } */
+
+extern void foo (void);
+extern __inline  void foo (void) {}
+void foo (void) {}
+
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 1 } } */
+/* { dg-final { scan-assembler "ex\t" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler     "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
Index: gcc/testsuite/gcc.target/s390/nobp-return-mem-attr.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/nobp-return-mem-attr.c b/gcc/testsuite/gcc.target/s390/nobp-return-mem-attr.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/nobp-return-mem-attr.c	(revision 262353)
@@ -0,0 +1,46 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z10 -mzarch --save-temps -mindirect-branch-table" } */
+
+int gl = 0;
+
+int __attribute__((noinline,noclone))
+bar (int a)
+{
+  return a + 2;
+}
+
+void __attribute__((function_return_mem("thunk"),noinline,noclone))
+foo (int a)
+{
+  int i;
+
+  if (a == 42)
+    return;
+
+  for (i = 0; i < a; i++)
+    gl += bar (i);
+}
+
+int
+main ()
+{
+  foo (3);
+  if (gl != 9)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* With -march=z10 -mzarch the shrink wrapped returns use compare and
+   swap relative to jump to the exit block instead of making use of
+   the conditional return pattern.
+   FIXME: Use compare and branch register for that!!!! */
+
+/* 2 x foo
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 2 } } */
+/* { dg-final { scan-assembler "exrl" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler     "section\t.s390_return_mem" } } */
Index: gcc/testsuite/gcc.target/s390/nobp-function-pointer-attr.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/nobp-function-pointer-attr.c b/gcc/testsuite/gcc.target/s390/nobp-function-pointer-attr.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/nobp-function-pointer-attr.c	(revision 262353)
@@ -0,0 +1,56 @@
+/* { dg-do run } */
+/* { dg-options "-O3  -march=z10 --save-temps -mindirect-branch-table" } */
+
+int gl;
+
+void __attribute__((noinline,noclone))
+foo (int a)
+{
+  gl = a + 40;
+}
+
+int __attribute__((noinline,noclone))
+foo_value (int a)
+{
+  return a + 40;
+}
+
+void* __attribute__((noinline,noclone))
+get_fptr (int a)
+{
+  switch (a)
+    {
+    case 0: return &foo; break;
+    case 1: return &foo_value; break;
+    default: __builtin_abort ();
+    }
+}
+
+void (*f) (int);
+int (*g) (int);
+
+int __attribute__((indirect_branch_call("thunk")))
+main ()
+{
+  int res;
+
+  f = get_fptr(0);
+  f (2);
+  if (gl != 42)
+    __builtin_abort ();
+
+  g = get_fptr(1);
+  if (g (2) != 42)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* 2 x main
+/* { dg-final { scan-assembler-times "brasl\t%r\[0-9\]*,__s390_indirect_jump" 2 } } */
+/* { dg-final { scan-assembler "exrl" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler     "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
Index: gcc/testsuite/gcc.target/s390/nobp-indirect-jump-inline-z900.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-inline-z900.c b/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-inline-z900.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-inline-z900.c	(revision 262353)
@@ -0,0 +1,43 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z900 --save-temps -mindirect-branch-jump=thunk-inline -mindirect-branch-table" } */
+/* { dg-require-effective-target label_values } */
+
+/* This is a copy of the gcc.c-torture/execute/20040302-1.c
+   testcase.  */
+
+int code[]={0,0,0,0,1};
+
+void
+foo(int x) {
+  volatile int b;
+  b = 0xffffffff;
+}
+
+void
+bar(int *pc) {
+  static const void *l[] = {&&lab0, &&end};
+
+  foo(0);
+  goto *l[*pc];
+ lab0:
+  foo(0);
+  pc++;
+  goto *l[*pc];
+ end:
+  return;
+}
+
+int
+main() {
+  bar(code);
+  return 0;
+}
+
+/* The two gotos in bar get merged.  */
+/* { dg-final { scan-assembler-times "\tex\t" 1 } } */
+
+/* { dg-final { scan-assembler-not "jg\t__s390_indirect_jump" } } */
+/* { dg-final { scan-assembler     "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
Index: gcc/testsuite/gcc.target/s390/nobp-table-jump-inline-z900.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/nobp-table-jump-inline-z900.c b/gcc/testsuite/gcc.target/s390/nobp-table-jump-inline-z900.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/nobp-table-jump-inline-z900.c	(revision 262353)
@@ -0,0 +1,78 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z900 -mzarch --save-temps -mindirect-branch-jump=thunk-inline -mindirect-branch-table" } */
+
+/* case-values-threshold will be set to 20 by the back-end when jump
+   thunk are requested.  */
+
+int __attribute__((noinline,noclone)) foo1 (void) { return 1; }
+int __attribute__((noinline,noclone)) foo2 (void) { return 2; }
+int __attribute__((noinline,noclone)) foo3 (void) { return 3; }
+int __attribute__((noinline,noclone)) foo4 (void) { return 4; }
+int __attribute__((noinline,noclone)) foo5 (void) { return 5; }
+int __attribute__((noinline,noclone)) foo6 (void) { return 6; }
+int __attribute__((noinline,noclone)) foo7 (void) { return 7; }
+int __attribute__((noinline,noclone)) foo8 (void) { return 8; }
+int __attribute__((noinline,noclone)) foo9 (void) { return 9; }
+int __attribute__((noinline,noclone)) foo10 (void) { return 10; }
+int __attribute__((noinline,noclone)) foo11 (void) { return 11; }
+int __attribute__((noinline,noclone)) foo12 (void) { return 12; }
+int __attribute__((noinline,noclone)) foo13 (void) { return 13; }
+int __attribute__((noinline,noclone)) foo14 (void) { return 14; }
+int __attribute__((noinline,noclone)) foo15 (void) { return 15; }
+int __attribute__((noinline,noclone)) foo16 (void) { return 16; }
+int __attribute__((noinline,noclone)) foo17 (void) { return 17; }
+int __attribute__((noinline,noclone)) foo18 (void) { return 18; }
+int __attribute__((noinline,noclone)) foo19 (void) { return 19; }
+int __attribute__((noinline,noclone)) foo20 (void) { return 20; }
+
+
+int __attribute__((noinline,noclone))
+bar (int a)
+{
+  int ret = 0;
+
+  switch (a)
+    {
+    case 1: ret = foo1 (); break;
+    case 2: ret = foo2 (); break;
+    case 3: ret = foo3 (); break;
+    case 4: ret = foo4 (); break;
+    case 5: ret = foo5 (); break;
+    case 6: ret = foo6 (); break;
+    case 7: ret = foo7 (); break;
+    case 8: ret = foo8 (); break;
+    case 9: ret = foo9 (); break;
+    case 10: ret = foo10 (); break;
+    case 11: ret = foo11 (); break;
+    case 12: ret = foo12 (); break;
+    case 13: ret = foo13 (); break;
+    case 14: ret = foo14 (); break;
+    case 15: ret = foo15 (); break;
+    case 16: ret = foo16 (); break;
+    case 17: ret = foo17 (); break;
+    case 18: ret = foo18 (); break;
+    case 19: ret = foo19 (); break;
+    case 20: ret = foo20 (); break;
+    default:
+      __builtin_abort ();
+    }
+
+  return ret;
+}
+
+int
+main ()
+{
+  if (bar (3) != 3)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* 1 x bar
+/* { dg-final { scan-assembler-times "\tex\t" 1 } } */
+
+/* { dg-final { scan-assembler     "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_fromreg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_frommem" } } */
Index: gcc/testsuite/gcc.target/s390/nobp-return-reg-nothunk.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/nobp-return-reg-nothunk.c b/gcc/testsuite/gcc.target/s390/nobp-return-reg-nothunk.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/nobp-return-reg-nothunk.c	(revision 262353)
@@ -0,0 +1,44 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -march=z10 --save-temps -mfunction-return-reg=thunk-extern -mindirect-branch-table" } */
+
+int gl = 0;
+
+int __attribute__((noinline,noclone))
+bar (int a)
+{
+  return a + 2;
+}
+
+void __attribute__((noinline,noclone))
+foo (int a)
+{
+  int i;
+
+  if (a == 42)
+    return;
+
+  for (i = 0; i < a; i++)
+    gl += bar (i);
+}
+
+int
+main ()
+{
+  foo (3);
+  if (gl != 9)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* 1 x bar
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 1 } } */
+
+/* No thunks due to thunk-extern.  */
+/* { dg-final { scan-assembler-not "exrl" } } */
+/* { dg-final { scan-assembler-not ".globl __s390_indirect_jump" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler     "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
Index: gcc/testsuite/gcc.target/s390/nobp-return-mem-nothunk.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/nobp-return-mem-nothunk.c b/gcc/testsuite/gcc.target/s390/nobp-return-mem-nothunk.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/nobp-return-mem-nothunk.c	(revision 262353)
@@ -0,0 +1,49 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -march=z10 -mzarch --save-temps -mfunction-return-mem=thunk-extern -mindirect-branch-table" } */
+
+int gl = 0;
+
+int __attribute__((noinline,noclone))
+bar (int a)
+{
+  return a + 2;
+}
+
+void __attribute__((noinline,noclone))
+foo (int a)
+{
+  int i;
+
+  if (a == 42)
+    return;
+
+  for (i = 0; i < a; i++)
+    gl += bar (i);
+}
+
+int
+main ()
+{
+  foo (3);
+  if (gl != 9)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* With -march=z10 -mzarch the shrink wrapped returns use compare and
+   swap relative to jump to the exit block instead of making use of
+   the conditional return pattern.
+   FIXME: Use compare and branch register for that!!!! */
+
+/* 2 x foo, 1 x main
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 3 } } */
+
+/* No thunks due to thunk-extern.  */
+/* { dg-final { scan-assembler-not "exrl" } } */
+/* { dg-final { scan-assembler-not ".globl __s390_indirect_jump" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler     "section\t.s390_return_mem" } } */
Index: gcc/testsuite/gcc.target/s390/nobp-function-pointer-nothunk.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/nobp-function-pointer-nothunk.c b/gcc/testsuite/gcc.target/s390/nobp-function-pointer-nothunk.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/nobp-function-pointer-nothunk.c	(revision 262353)
@@ -0,0 +1,59 @@
+/* { dg-do compile } */
+/* { dg-options "-O3  -march=z10 --save-temps -mindirect-branch-call=thunk-extern -mindirect-branch-table" } */
+
+int gl;
+
+void __attribute__((noinline,noclone))
+foo (int a)
+{
+  gl = a + 40;
+}
+
+int __attribute__((noinline,noclone))
+foo_value (int a)
+{
+  return a + 40;
+}
+
+void*  __attribute__((noinline,noclone))
+get_fptr (int a)
+{
+  switch (a)
+    {
+    case 0: return &foo; break;
+    case 1: return &foo_value; break;
+    default: __builtin_abort ();
+    }
+}
+
+void (*f) (int);
+int (*g) (int);
+
+int
+main ()
+{
+  int res;
+
+  f = get_fptr(0);
+  f (2);
+  if (gl != 42)
+    __builtin_abort ();
+
+  g = get_fptr(1);
+  if (g (2) != 42)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* 2 x main
+/* { dg-final { scan-assembler-times "brasl\t%r\[0-9\]*,__s390_indirect_jump" 2 } } */
+
+/* No thunks due to thunk-extern.  */
+/* { dg-final { scan-assembler-not "exrl" } } */
+/* { dg-final { scan-assembler-not ".globl __s390_indirect_jump" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler     "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
Index: gcc/testsuite/gcc.target/s390/nobp-indirect-jump-nothunk.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-nothunk.c b/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-nothunk.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-nothunk.c	(revision 262353)
@@ -0,0 +1,46 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -march=z10 --save-temps -mindirect-branch-jump=thunk-extern -mindirect-branch-table" } */
+/* { dg-require-effective-target label_values } */
+
+/* This is a copy of the gcc.c-torture/execute/20040302-1.c
+   testcase.  */
+
+int code[]={0,0,0,0,1};
+
+void
+foo(int x) {
+  volatile int b;
+  b = 0xffffffff;
+}
+
+void
+bar(int *pc) {
+  static const void *l[] = {&&lab0, &&end};
+
+  foo(0);
+  goto *l[*pc];
+ lab0:
+  foo(0);
+  pc++;
+  goto *l[*pc];
+ end:
+  return;
+}
+
+int
+main() {
+  bar(code);
+  return 0;
+}
+
+/* 2 x bar
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 2 } } */
+
+/* No thunks due to thunk-extern.  */
+/* { dg-final { scan-assembler-not "exrl" } } */
+/* { dg-final { scan-assembler-not ".globl __s390_indirect_jump" } } */
+
+/* { dg-final { scan-assembler     "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
Index: gcc/testsuite/gcc.target/s390/nobp-return-mem-z10.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/nobp-return-mem-z10.c b/gcc/testsuite/gcc.target/s390/nobp-return-mem-z10.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/nobp-return-mem-z10.c	(revision 262353)
@@ -0,0 +1,46 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z10 -mzarch --save-temps -mfunction-return-mem=thunk -mindirect-branch-table" } */
+
+int gl = 0;
+
+int __attribute__((noinline,noclone))
+bar (int a)
+{
+  return a + 2;
+}
+
+void __attribute__((noinline,noclone))
+foo (int a)
+{
+  int i;
+
+  if (a == 42)
+    return;
+
+  for (i = 0; i < a; i++)
+    gl += bar (i);
+}
+
+int
+main ()
+{
+  foo (3);
+  if (gl != 9)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* With -march=z10 -mzarch the shrink wrapped returns use compare and
+   swap relative to jump to the exit block instead of making use of
+   the conditional return pattern.
+   FIXME: Use compare and branch register for that!!!! */
+
+/* 2 x foo, 1 x main
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 3 } } */
+/* { dg-final { scan-assembler "exrl" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler     "section\t.s390_return_mem" } } */
Index: gcc/testsuite/gcc.target/s390/nobp-function-pointer-z10.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/nobp-function-pointer-z10.c b/gcc/testsuite/gcc.target/s390/nobp-function-pointer-z10.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/nobp-function-pointer-z10.c	(revision 262353)
@@ -0,0 +1,56 @@
+/* { dg-do run } */
+/* { dg-options "-O3  -march=z10 --save-temps -mindirect-branch-call=thunk -mindirect-branch-table" } */
+
+int gl;
+
+void __attribute__((noinline,noclone))
+foo (int a)
+{
+  gl = a + 40;
+}
+
+int __attribute__((noinline,noclone))
+foo_value (int a)
+{
+  return a + 40;
+}
+
+void*  __attribute__((noinline,noclone))
+get_fptr (int a)
+{
+  switch (a)
+    {
+    case 0: return &foo; break;
+    case 1: return &foo_value; break;
+    default: __builtin_abort ();
+    }
+}
+
+void (*f) (int);
+int (*g) (int);
+
+int
+main ()
+{
+  int res;
+
+  f = get_fptr(0);
+  f (2);
+  if (gl != 42)
+    __builtin_abort ();
+
+  g = get_fptr(1);
+  if (g (2) != 42)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* 2 x main
+/* { dg-final { scan-assembler-times "brasl\t%r\[0-9\]*,__s390_indirect_jump" 2 } } */
+/* { dg-final { scan-assembler "exrl" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler     "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
Index: gcc/testsuite/gcc.target/s390/nobp-return-reg-attr.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/nobp-return-reg-attr.c b/gcc/testsuite/gcc.target/s390/nobp-return-reg-attr.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/nobp-return-reg-attr.c	(revision 262353)
@@ -0,0 +1,41 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z10 --save-temps -mindirect-branch-table" } */
+
+int gl = 0;
+
+int __attribute__((function_return_reg("thunk"),noinline,noclone))
+bar (int a)
+{
+  return a + 2;
+}
+
+void __attribute__((noinline,noclone))
+foo (int a)
+{
+  int i;
+
+  if (a == 42)
+    return;
+
+  for (i = 0; i < a; i++)
+    gl += bar (i);
+}
+
+int
+main ()
+{
+  foo (3);
+  if (gl != 9)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* 1 x bar
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 1 } } */
+/* { dg-final { scan-assembler "exrl" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler     "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
Index: gcc/testsuite/gcc.target/s390/nobp-indirect-jump-attr.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-attr.c b/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-attr.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-attr.c	(revision 262353)
@@ -0,0 +1,42 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z10 --save-temps -mindirect-branch-table" } */
+/* { dg-require-effective-target label_values } */
+
+/* This is a copy of the gcc.c-torture/execute/20040302-1.c
+   testcase.  */
+
+int code[]={0,0,0,0,1};
+
+void
+foo(int x) {
+  volatile int b;
+  b = 0xffffffff;
+}
+
+void __attribute__((indirect_branch_jump("thunk")))
+bar(int *pc) {
+  static const void *l[] = {&&lab0, &&end};
+
+  foo(0);
+  goto *l[*pc];
+ lab0:
+  foo(0);
+  pc++;
+  goto *l[*pc];
+ end:
+  return;
+}
+
+int main() {
+  bar(code);
+  return 0;
+}
+
+/* 2x bar */
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 2 } } */
+/* { dg-final { scan-assembler "exrl" } } */
+
+/* { dg-final { scan-assembler     "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
Index: gcc/testsuite/gcc.target/s390/nobp-return-mem-z900.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/nobp-return-mem-z900.c b/gcc/testsuite/gcc.target/s390/nobp-return-mem-z900.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/nobp-return-mem-z900.c	(revision 262353)
@@ -0,0 +1,48 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z900 --save-temps -mfunction-return-mem=thunk -mindirect-branch-table" } */
+
+int gl = 0;
+
+int __attribute__((noinline,noclone))
+bar (int a)
+{
+  return a + 2;
+}
+
+void __attribute__((noinline,noclone))
+foo (int a)
+{
+  int i;
+
+  if (a == 42)
+    return;
+
+  for (i = 0; i < a; i++)
+    gl += bar (i);
+}
+
+int
+main ()
+{
+  foo (3);
+  if (gl != 9)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* 1 x foo, 1 x main
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 2 } } */
+
+/* 1 x foo, conditional return, shrink wrapped
+/* { dg-final { scan-assembler "jge\t__s390_indirect_jump" } } */
+
+/* 1 x foo, conditional return, shrink wrapped
+/* { dg-final { scan-assembler "jgle\t__s390_indirect_jump" } } */
+
+/* { dg-final { scan-assembler "ex\t" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler     "section\t.s390_return_mem" } } */
Index: gcc/testsuite/gcc.target/s390/nobp-indirect-jump-inline-z10.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-inline-z10.c b/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-inline-z10.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-inline-z10.c	(revision 262353)
@@ -0,0 +1,43 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z10 --save-temps -mindirect-branch-jump=thunk-inline -mindirect-branch-table" } */
+/* { dg-require-effective-target label_values } */
+
+/* This is a copy of the gcc.c-torture/execute/20040302-1.c
+   testcase.  */
+
+int code[]={0,0,0,0,1};
+
+void
+foo(int x) {
+  volatile int b;
+  b = 0xffffffff;
+}
+
+void
+bar(int *pc) {
+  static const void *l[] = {&&lab0, &&end};
+
+  foo(0);
+  goto *l[*pc];
+ lab0:
+  foo(0);
+  pc++;
+  goto *l[*pc];
+ end:
+  return;
+}
+
+int
+main() {
+  bar(code);
+  return 0;
+}
+
+/* The two gotos in bar get merged.  */
+/* { dg-final { scan-assembler-times "exrl" 1 } } */
+
+/* { dg-final { scan-assembler-not "jg\t__s390_indirect_jump" } } */
+/* { dg-final { scan-assembler     "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
Index: gcc/testsuite/gcc.target/s390/nobp-return-attr-neg.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/nobp-return-attr-neg.c b/gcc/testsuite/gcc.target/s390/nobp-return-attr-neg.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/nobp-return-attr-neg.c	(revision 262353)
@@ -0,0 +1,40 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z10 -mzarch --save-temps -mfunction-return-mem=thunk -mindirect-branch-table" } */
+
+int gl = 0;
+
+int __attribute__((noinline,noclone))
+bar (int a)
+{
+  return a + 2;
+}
+
+void __attribute__((function_return("keep"),noinline,noclone))
+foo (int a)
+{
+  int i;
+
+  if (a == 42)
+    return;
+
+  for (i = 0; i < a; i++)
+    gl += bar (i);
+}
+
+int __attribute__((function_return("keep")))
+main ()
+{
+  foo (3);
+  if (gl != 9)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* { dg-final { scan-assembler-not "jg\t__s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "exrl" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
Index: gcc/testsuite/gcc.target/s390/nobp-function-pointer-z900.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/nobp-function-pointer-z900.c b/gcc/testsuite/gcc.target/s390/nobp-function-pointer-z900.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/nobp-function-pointer-z900.c	(revision 262353)
@@ -0,0 +1,56 @@
+/* { dg-do run } */
+/* { dg-options "-O3  -march=z900 --save-temps -mindirect-branch-call=thunk -mindirect-branch-table" } */
+
+int gl;
+
+void __attribute__((noinline,noclone))
+foo (int a)
+{
+  gl = a + 40;
+}
+
+int __attribute__((noinline,noclone))
+foo_value (int a)
+{
+  return a + 40;
+}
+
+void*  __attribute__((noinline,noclone))
+get_fptr (int a)
+{
+  switch (a)
+    {
+    case 0: return &foo; break;
+    case 1: return &foo_value; break;
+    default: __builtin_abort ();
+    }
+}
+
+void (*f) (int);
+int (*g) (int);
+
+int
+main ()
+{
+  int res;
+
+  f = get_fptr(0);
+  f (2);
+  if (gl != 42)
+    __builtin_abort ();
+
+  g = get_fptr(1);
+  if (g (2) != 42)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* 2 x main
+/* { dg-final { scan-assembler-times "brasl\t%r\[0-9\]*,__s390_indirect_jump" 2 } } */
+/* { dg-final { scan-assembler "ex\t" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler     "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
Index: gcc/testsuite/gcc.target/s390/nobp-indirect-jump-inline-attr.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-inline-attr.c b/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-inline-attr.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-inline-attr.c	(revision 262353)
@@ -0,0 +1,42 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z10 --save-temps -mindirect-branch-table" } */
+/* { dg-require-effective-target label_values } */
+
+/* This is a copy of the gcc.c-torture/execute/20040302-1.c
+   testcase.  */
+
+int code[]={0,0,0,0,1};
+
+void foo(int x) {
+  volatile int b;
+  b = 0xffffffff;
+}
+
+void __attribute__((indirect_branch_jump("thunk-inline")))
+bar(int *pc) {
+  static const void *l[] = {&&lab0, &&end};
+
+  foo(0);
+  goto *l[*pc];
+ lab0:
+  foo(0);
+  pc++;
+  goto *l[*pc];
+ end:
+  return;
+}
+
+int
+main() {
+  bar(code);
+  return 0;
+}
+
+/* The two gotos in bar get merged.  */
+/* { dg-final { scan-assembler-times "exrl" 1 } } */
+
+/* { dg-final { scan-assembler-not "jg\t__s390_indirect_jump" } } */
+/* { dg-final { scan-assembler     "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
Index: gcc/testsuite/gcc.target/s390/nobp-table-jump-z900.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/nobp-table-jump-z900.c b/gcc/testsuite/gcc.target/s390/nobp-table-jump-z900.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/nobp-table-jump-z900.c	(revision 262353)
@@ -0,0 +1,78 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z900 -mzarch --save-temps -mindirect-branch-jump=thunk -mindirect-branch-table" } */
+
+/* case-values-threshold will be set to 20 by the back-end when jump
+   thunk are requested.  */
+
+int __attribute__((noinline,noclone)) foo1 (void) { return 1; }
+int __attribute__((noinline,noclone)) foo2 (void) { return 2; }
+int __attribute__((noinline,noclone)) foo3 (void) { return 3; }
+int __attribute__((noinline,noclone)) foo4 (void) { return 4; }
+int __attribute__((noinline,noclone)) foo5 (void) { return 5; }
+int __attribute__((noinline,noclone)) foo6 (void) { return 6; }
+int __attribute__((noinline,noclone)) foo7 (void) { return 7; }
+int __attribute__((noinline,noclone)) foo8 (void) { return 8; }
+int __attribute__((noinline,noclone)) foo9 (void) { return 9; }
+int __attribute__((noinline,noclone)) foo10 (void) { return 10; }
+int __attribute__((noinline,noclone)) foo11 (void) { return 11; }
+int __attribute__((noinline,noclone)) foo12 (void) { return 12; }
+int __attribute__((noinline,noclone)) foo13 (void) { return 13; }
+int __attribute__((noinline,noclone)) foo14 (void) { return 14; }
+int __attribute__((noinline,noclone)) foo15 (void) { return 15; }
+int __attribute__((noinline,noclone)) foo16 (void) { return 16; }
+int __attribute__((noinline,noclone)) foo17 (void) { return 17; }
+int __attribute__((noinline,noclone)) foo18 (void) { return 18; }
+int __attribute__((noinline,noclone)) foo19 (void) { return 19; }
+int __attribute__((noinline,noclone)) foo20 (void) { return 20; }
+
+
+int __attribute__((noinline,noclone))
+bar (int a)
+{
+  int ret = 0;
+
+  switch (a)
+    {
+    case 1: ret = foo1 (); break;
+    case 2: ret = foo2 (); break;
+    case 3: ret = foo3 (); break;
+    case 4: ret = foo4 (); break;
+    case 5: ret = foo5 (); break;
+    case 6: ret = foo6 (); break;
+    case 7: ret = foo7 (); break;
+    case 8: ret = foo8 (); break;
+    case 9: ret = foo9 (); break;
+    case 10: ret = foo10 (); break;
+    case 11: ret = foo11 (); break;
+    case 12: ret = foo12 (); break;
+    case 13: ret = foo13 (); break;
+    case 14: ret = foo14 (); break;
+    case 15: ret = foo15 (); break;
+    case 16: ret = foo16 (); break;
+    case 17: ret = foo17 (); break;
+    case 18: ret = foo18 (); break;
+    case 19: ret = foo19 (); break;
+    case 20: ret = foo20 (); break;
+    default:
+      __builtin_abort ();
+    }
+
+  return ret;
+}
+
+int
+main ()
+{
+  if (bar (3) != 3)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* 1 x bar
+/* { dg-final { scan-assembler-times "ex\t" 1 } } */
+
+/* { dg-final { scan-assembler     "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_fromreg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_frommem" } } */
Index: gcc/testsuite/gcc.target/s390/nobp-return-reg-z10.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/nobp-return-reg-z10.c b/gcc/testsuite/gcc.target/s390/nobp-return-reg-z10.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/nobp-return-reg-z10.c	(revision 262353)
@@ -0,0 +1,41 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z10 --save-temps -mfunction-return-reg=thunk -mindirect-branch-table" } */
+
+int gl = 0;
+
+int __attribute__((noinline,noclone))
+bar (int a)
+{
+  return a + 2;
+}
+
+void __attribute__((noinline,noclone))
+foo (int a)
+{
+  int i;
+
+  if (a == 42)
+    return;
+
+  for (i = 0; i < a; i++)
+    gl += bar (i);
+}
+
+int
+main ()
+{
+  foo (3);
+  if (gl != 9)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* 1 x bar
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 1 } } */
+/* { dg-final { scan-assembler "exrl" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler     "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
Index: gcc/testsuite/gcc.target/s390/nobp-indirect-jump-z10.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-z10.c b/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-z10.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/nobp-indirect-jump-z10.c	(revision 262353)
@@ -0,0 +1,43 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z10 --save-temps -mindirect-branch-jump=thunk -mindirect-branch-table" } */
+/* { dg-require-effective-target label_values } */
+
+/* This is a copy of the gcc.c-torture/execute/20040302-1.c
+   testcase.  */
+
+int code[]={0,0,0,0,1};
+
+void
+foo(int x) {
+  volatile int b;
+  b = 0xffffffff;
+}
+
+void
+bar(int *pc) {
+  static const void *l[] = {&&lab0, &&end};
+
+  foo(0);
+  goto *l[*pc];
+ lab0:
+  foo(0);
+  pc++;
+  goto *l[*pc];
+ end:
+  return;
+}
+
+int
+main() {
+  bar(code);
+  return 0;
+}
+
+/* 2x bar */
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 2 } } */
+/* { dg-final { scan-assembler "exrl" } } */
+
+/* { dg-final { scan-assembler     "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
Index: gcc/testsuite/gcc.target/s390/nobp-table-jump-inline-z10.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/nobp-table-jump-inline-z10.c b/gcc/testsuite/gcc.target/s390/nobp-table-jump-inline-z10.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/nobp-table-jump-inline-z10.c	(revision 262353)
@@ -0,0 +1,78 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z10 -mzarch --save-temps -mindirect-branch-jump=thunk-inline -mindirect-branch-table" } */
+
+/* case-values-threshold will be set to 20 by the back-end when jump
+   thunk are requested.  */
+
+int __attribute__((noinline,noclone)) foo1 (void) { return 1; }
+int __attribute__((noinline,noclone)) foo2 (void) { return 2; }
+int __attribute__((noinline,noclone)) foo3 (void) { return 3; }
+int __attribute__((noinline,noclone)) foo4 (void) { return 4; }
+int __attribute__((noinline,noclone)) foo5 (void) { return 5; }
+int __attribute__((noinline,noclone)) foo6 (void) { return 6; }
+int __attribute__((noinline,noclone)) foo7 (void) { return 7; }
+int __attribute__((noinline,noclone)) foo8 (void) { return 8; }
+int __attribute__((noinline,noclone)) foo9 (void) { return 9; }
+int __attribute__((noinline,noclone)) foo10 (void) { return 10; }
+int __attribute__((noinline,noclone)) foo11 (void) { return 11; }
+int __attribute__((noinline,noclone)) foo12 (void) { return 12; }
+int __attribute__((noinline,noclone)) foo13 (void) { return 13; }
+int __attribute__((noinline,noclone)) foo14 (void) { return 14; }
+int __attribute__((noinline,noclone)) foo15 (void) { return 15; }
+int __attribute__((noinline,noclone)) foo16 (void) { return 16; }
+int __attribute__((noinline,noclone)) foo17 (void) { return 17; }
+int __attribute__((noinline,noclone)) foo18 (void) { return 18; }
+int __attribute__((noinline,noclone)) foo19 (void) { return 19; }
+int __attribute__((noinline,noclone)) foo20 (void) { return 20; }
+
+
+int __attribute__((noinline,noclone))
+bar (int a)
+{
+  int ret = 0;
+
+  switch (a)
+    {
+    case 1: ret = foo1 (); break;
+    case 2: ret = foo2 (); break;
+    case 3: ret = foo3 (); break;
+    case 4: ret = foo4 (); break;
+    case 5: ret = foo5 (); break;
+    case 6: ret = foo6 (); break;
+    case 7: ret = foo7 (); break;
+    case 8: ret = foo8 (); break;
+    case 9: ret = foo9 (); break;
+    case 10: ret = foo10 (); break;
+    case 11: ret = foo11 (); break;
+    case 12: ret = foo12 (); break;
+    case 13: ret = foo13 (); break;
+    case 14: ret = foo14 (); break;
+    case 15: ret = foo15 (); break;
+    case 16: ret = foo16 (); break;
+    case 17: ret = foo17 (); break;
+    case 18: ret = foo18 (); break;
+    case 19: ret = foo19 (); break;
+    case 20: ret = foo20 (); break;
+    default:
+      __builtin_abort ();
+    }
+
+  return ret;
+}
+
+int
+main ()
+{
+  if (bar (3) != 3)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* 1 x bar
+/* { dg-final { scan-assembler-times "exrl" 1 } } */
+
+/* { dg-final { scan-assembler     "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_fromreg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_frommem" } } */
Index: gcc/testsuite/gcc.target/s390/nobp-return-reg-z900.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/nobp-return-reg-z900.c b/gcc/testsuite/gcc.target/s390/nobp-return-reg-z900.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/nobp-return-reg-z900.c	(revision 262353)
@@ -0,0 +1,41 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z900 --save-temps -mfunction-return-reg=thunk -mindirect-branch-table" } */
+
+int gl = 0;
+
+int __attribute__((noinline,noclone))
+bar (int a)
+{
+  return a + 2;
+}
+
+void __attribute__((noinline,noclone))
+foo (int a)
+{
+  int i;
+
+  if (a == 42)
+    return;
+
+  for (i = 0; i < a; i++)
+    gl += bar (i);
+}
+
+int
+main ()
+{
+  foo (3);
+  if (gl != 9)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* 1 x bar
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 1 } } */
+/* { dg-final { scan-assembler "ex\t" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler     "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
Index: gcc/testsuite/gcc.target/s390/nobp-return-attr-all.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/nobp-return-attr-all.c b/gcc/testsuite/gcc.target/s390/nobp-return-attr-all.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/nobp-return-attr-all.c	(revision 262353)
@@ -0,0 +1,46 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z10 -mzarch --save-temps -mindirect-branch-table" } */
+
+int gl = 0;
+
+int __attribute__((noinline,noclone))
+bar (int a)
+{
+  return a + 2;
+}
+
+void __attribute__((function_return("thunk"),noinline,noclone))
+foo (int a)
+{
+  int i;
+
+  if (a == 42)
+    return;
+
+  for (i = 0; i < a; i++)
+    gl += bar (i);
+}
+
+int
+main ()
+{
+  foo (3);
+  if (gl != 9)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* With -march=z10 -mzarch the shrink wrapped returns use compare and
+   swap relative to jump to the exit block instead of making use of
+   the conditional return pattern.
+   FIXME: Use compare and branch register for that!!!! */
+
+/* 2 x foo
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 2 } } */
+/* { dg-final { scan-assembler "exrl" } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler     "section\t.s390_return_mem" } } */
Index: gcc/testsuite/gcc.target/s390/nobp-return-reg-mixed.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/s390/nobp-return-reg-mixed.c b/gcc/testsuite/gcc.target/s390/nobp-return-reg-mixed.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/s390/nobp-return-reg-mixed.c	(revision 262353)
@@ -0,0 +1,44 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -march=z900 --save-temps -mfunction-return-reg=thunk -mindirect-branch-table" } */
+
+/* We have to generate different thunks for indirect branches
+   depending on whether the code is compiled for pre z10 machines or
+   later.  This testcase makes sure this works within the same compile
+   unit.  */
+
+int __attribute__((noinline,noclone,target("arch=z10")))
+bar (int a)
+{
+  return a + 2;
+}
+
+int __attribute__((noinline,noclone,target("arch=z9-ec")))
+foo (int a)
+{
+  return a + 3;
+}
+
+int
+main ()
+{
+  if (bar (42) != 44)
+    __builtin_abort ();
+
+  if (foo (42) != 45)
+    __builtin_abort ();
+
+  return 0;
+}
+
+/* 1 x bar, 1 x foo */
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump" 2 } } */
+/* 1 x foo */
+/* { dg-final { scan-assembler-times "jg\t__s390_indirect_jump_r1use" 1 } } */
+
+/* { dg-final { scan-assembler-times "ex\t" 1 } } */
+/* { dg-final { scan-assembler-times "exrl\t" 1 } } */
+
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_jump" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_indirect_call" } } */
+/* { dg-final { scan-assembler     "section\t.s390_return_reg" } } */
+/* { dg-final { scan-assembler-not "section\t.s390_return_mem" } } */
Index: gcc/testsuite/gcc.target/msp430/pr79242.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/msp430/pr79242.c b/gcc/testsuite/gcc.target/msp430/pr79242.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/msp430/pr79242.c	(revision 262353)
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { "*-*-*" } { "-mcpu=msp430" "-msmall" } { "" } } */
+/* { dg-options "-mcpu=msp430x" } */
+
+typedef _Complex __int20 C;
+
+C
+foo (C x, C y)
+{
+  return x + y;
+}
Index: gcc/testsuite/gcc.target/aarch64/pr81647.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/aarch64/pr81647.c b/gcc/testsuite/gcc.target/aarch64/pr81647.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/aarch64/pr81647.c	(revision 262353)
@@ -0,0 +1,45 @@
+/* { dg-do run } */
+/* { dg-options "-O3 -fdump-tree-ssa" } */
+/* { dg-require-effective-target fenv_exceptions } */
+
+#include <fenv.h>
+
+double x[28], y[28];
+int res[28];
+
+int
+main (void)
+{
+  int i;
+  for (i = 0; i < 28; ++i)
+    {
+      x[i] = __builtin_nan ("");
+      y[i] = i;
+    }
+  __asm__ volatile ("" ::: "memory");
+  feclearexcept (FE_ALL_EXCEPT);
+  for (i = 0; i < 4; ++i)
+    res[i] = __builtin_isgreater (x[i], y[i]);
+  for (i = 4; i < 8; ++i)
+    res[i] = __builtin_isgreaterequal (x[i], y[i]);
+  for (i = 8; i < 12; ++i)
+    res[i] = __builtin_isless (x[i], y[i]);
+  for (i = 12; i < 16; ++i)
+    res[i] = __builtin_islessequal (x[i], y[i]);
+  for (i = 16; i < 20; ++i)
+    res[i] = __builtin_islessgreater (x[i], y[i]);
+  for (i = 20; i < 24; ++i)
+    res[i] = __builtin_isunordered (x[i], y[i]);
+  for (i = 24; i < 28; ++i)
+    res[i] = !(__builtin_isunordered (x[i], y[i]));
+  __asm__ volatile ("" ::: "memory");
+  return fetestexcept (FE_ALL_EXCEPT) != 0;
+}
+
+/* { dg-final { scan-tree-dump " u> " "ssa" } } */
+/* { dg-final { scan-tree-dump " u>= " "ssa" } } */
+/* { dg-final { scan-tree-dump " u< " "ssa" } } */
+/* { dg-final { scan-tree-dump " u<= " "ssa" } } */
+/* { dg-final { scan-tree-dump " u== " "ssa" } } */
+/* { dg-final { scan-tree-dump " unord " "ssa" } } */
+/* { dg-final { scan-tree-dump " ord " "ssa" } } */
Index: gcc/testsuite/gcc.target/aarch64/pr63304_1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/aarch64/pr63304_1.c b/gcc/testsuite/gcc.target/aarch64/pr63304_1.c
--- a/gcc/testsuite/gcc.target/aarch64/pr63304_1.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/aarch64/pr63304_1.c	(revision 262353)
@@ -1,5 +1,5 @@
 /* { dg-do assemble } */
-/* { dg-options "-O1 --save-temps -mno-fix-cortex-a53-843419" } */
+/* { dg-options "-O1 --save-temps" } */
 #pragma GCC push_options
 #pragma GCC target ("+nothing+simd, cmodel=small")
 
Index: gcc/testsuite/gcc.target/aarch64/pr83370.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/aarch64/pr83370.c b/gcc/testsuite/gcc.target/aarch64/pr83370.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/aarch64/pr83370.c	(revision 262353)
@@ -0,0 +1,22 @@
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+typedef void (*fun) (void);
+
+void
+f (fun x1)
+{
+  register fun x2 asm ("x16");
+  int arr[5000];
+  int *volatile ptr = arr;
+  asm ("mov %0, %1" : "=r" (x2) : "r" (x1));
+  x2 ();
+}
+
+void g (void) {}
+
+int
+main (void)
+{
+  f (g);
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-inline-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-3.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-3.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-3.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-3.c	(revision 262353)
@@ -12,7 +12,7 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-1.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-1.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-1.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-1.c	(revision 262353)
@@ -11,9 +11,8 @@
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
Index: gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2sd64-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2sd64-1.c b/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2sd64-1.c
--- a/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2sd64-1.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2sd64-1.c	(revision 262353)
@@ -1,7 +1,7 @@
 /* { dg-do compile { target { ! ia32 } } } */
 /* { dg-options "-mavx512f -O2" } */
-/* { dg-final { scan-assembler-times "vcvtusi2sd\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
-/* { dg-final { scan-assembler-times "vcvtusi2sd\[ \\t\]+\[^%\n\]*%r\[^\{\n\]*\{ru-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vcvtusi2sdq\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vcvtusi2sdq\[ \\t\]+\[^%\n\]*%r\[^\{\n\]*\{ru-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
 
 #include <immintrin.h>
 
Index: gcc/testsuite/gcc.target/i386/pr85193.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr85193.c b/gcc/testsuite/gcc.target/i386/pr85193.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr85193.c	(revision 262353)
@@ -0,0 +1,17 @@
+/* { dg-do compile } */
+/* { dg-options "-Wno-psabi -O2 -fno-tree-ccp -fno-tree-fre -mno-sse" } */
+
+typedef unsigned char U __attribute__((vector_size(16)));
+typedef unsigned int V __attribute__((vector_size(16)));
+typedef unsigned long long W __attribute__((vector_size(16)));
+
+extern void bar(U, U);
+
+V v;
+
+void
+foo(U f)
+{
+  f[0] = f[0] << (unsigned char)~v[0] | f[~((W)(U){0, 0, 0, 0, 0, 0, 0, 0, 5})[1] & 5] >> (-(unsigned char)~v[0] & 7);
+  bar(f, (U){});
+}
Index: gcc/testsuite/gcc.target/i386/ret-thunk-10.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-10.c b/gcc/testsuite/gcc.target/i386/ret-thunk-10.c
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-10.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-10.c	(revision 262353)
@@ -15,9 +15,6 @@
 /* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-times {\tpause} 2 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 2 } } */
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?bar" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } }  } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk:" { target { ! x32 } }  } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { x32 } }  } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk_(r|e)ax:" { target { x32 } }  } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "__x86_indirect_thunk_(r|e)ax:" } } */
+/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-extern-5.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-5.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-5.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-5.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-5.c	(revision 262353)
@@ -9,8 +9,10 @@
   bar ();
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" { target x32 } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar@GOT" { target { ! x32 } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { ! x32 } } } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
 /* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
Index: gcc/testsuite/gcc.target/i386/pr85095-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr85095-2.c b/gcc/testsuite/gcc.target/i386/pr85095-2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr85095-2.c	(revision 262353)
@@ -0,0 +1,54 @@
+/* PR target/85095 *
+/* { dg-do compile } */
+/* { dg-options "-O2 -masm=att" } */
+
+unsigned int
+f1 (unsigned int a, unsigned int b)
+{
+  unsigned int i = __builtin_add_overflow (a, b, &a);
+  return a + i;
+}
+
+unsigned int
+f2 (unsigned int a, unsigned int b)
+{
+  unsigned int i = __builtin_add_overflow (a, b, &a);
+  return a - i;
+}
+
+#ifdef __x86_64__
+unsigned long long
+f3 (unsigned long long a, unsigned long long b)
+{
+  unsigned long long i = __builtin_add_overflow (a, b, &a);
+  return a + i;
+}
+
+unsigned long long
+f4 (unsigned long long a, unsigned long long b)
+{
+  unsigned long long i = __builtin_add_overflow (a, b, &a);
+  return a - i;
+}
+
+unsigned long long
+f5 (unsigned int a, unsigned int b)
+{
+  unsigned int i = __builtin_add_overflow (a, b, &a);
+  return a + i;
+}
+
+unsigned long long
+f6 (unsigned int a, unsigned int b)
+{
+  unsigned int i = __builtin_add_overflow (a, b, &a);
+  return a - i;
+}
+#endif
+
+/* { dg-final { scan-assembler-times "adcl\t\\\$0," 1 { target ia32 } } } */
+/* { dg-final { scan-assembler-times "sbbl\t\\\$0," 1 { target ia32 } } } */
+/* { dg-final { scan-assembler-times "adcl\t\\\$0," 2 { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler-times "sbbl\t\\\$0," 2 { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler-times "adcq\t\\\$0," 1 { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler-times "sbbq\t\\\$0," 1 { target { ! ia32 } } } } */
Index: gcc/testsuite/gcc.target/i386/pr85034.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr85034.c b/gcc/testsuite/gcc.target/i386/pr85034.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr85034.c	(revision 262353)
@@ -0,0 +1,11 @@
+/* PR inline-asm/85034 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void
+foo (void)
+{
+  volatile float a;
+  struct S { char a; } b = { 0 };
+  asm volatile ("" : "=r" (a) : "0ir" (b));
+}
Index: gcc/testsuite/gcc.target/i386/pr82795.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr82795.c b/gcc/testsuite/gcc.target/i386/pr82795.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr82795.c	(revision 262353)
@@ -0,0 +1,23 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -mavx2" } */
+
+void
+sj (int qh, int rn, int *by)
+{
+  for (;;)
+    if (qh != 0)
+      {
+	int dc;
+
+	for (dc = 0; dc < 17; ++dc)
+	  {
+	    int nn;
+
+	    nn = (rn != 0) ? qh : dc;
+	    if (nn != 0)
+	      qh = nn;
+	    else
+	      qh = (qh != 0) ? *by : dc;
+	  }
+      }
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-2.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-2.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-2.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-2.c	(revision 262353)
@@ -12,9 +12,8 @@
   dispatch[offset](offset);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-25.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-25.c b/gcc/testsuite/gcc.target/i386/ret-thunk-25.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-25.c	(revision 262353)
@@ -0,0 +1,15 @@
+/* PR target/r84530 */
+/* { dg-do compile { target ia32 } } */
+/* { dg-options "-O2 -mfunction-return=thunk -fcheck-pointer-bounds -mmpx -fno-pic" } */
+
+struct s { _Complex unsigned short x; };
+struct s gs = { 100 + 200i };
+struct s __attribute__((noinline)) foo (void) { return gs; }
+
+/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 } } */
+/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk_bnd_ecx" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler {\tpause} } } */
+/* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-9.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-9.c b/gcc/testsuite/gcc.target/i386/ret-thunk-9.c
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-9.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-9.c	(revision 262353)
@@ -13,12 +13,9 @@
 /* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk:" } } */
-/* { dg-final { scan-assembler-times {\tpause} 1 { target { ! x32 } } } } */
-/* { dg-final { scan-assembler-times {\tlfence} 1 { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?bar" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler-times {\tpause} 2 { target { x32 } } } } */
-/* { dg-final { scan-assembler-times {\tlfence} 2 { target { x32 } } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { x32 } } } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
+/* { dg-final { scan-assembler "__x86_return_thunk:" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?bar" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler-times {\tpause} 2 } } */
+/* { dg-final { scan-assembler-times {\tlfence} 2 } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
Index: gcc/testsuite/gcc.target/i386/avx512f-pr84786-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-pr84786-3.c b/gcc/testsuite/gcc.target/i386/avx512f-pr84786-3.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/avx512f-pr84786-3.c	(revision 262353)
@@ -0,0 +1,50 @@
+/* PR target/84786 */
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-options "-mavx512f -mno-avx512vl -O2" } */
+
+#include <x86intrin.h>
+
+__m512i v;
+__m128i w;
+
+__m128i
+foo (__m128i x, int y)
+{
+  __m128i z;
+#define A(n) register __m512i zmm##n __asm ("zmm" #n);
+#define B A(1) A(2) A(3) A(4) A(5) A(6) A(7) \
+	  A(8) A(9) A(10) A(11) A(12) A(13) A(14)
+  B
+#undef A
+#define A(n) asm volatile ("" : "=v" (zmm##n) : "0" (v));
+  B
+  asm volatile ("" : "=x" (z) : "0" (w));
+  x = _mm_srli_epi16 (x, y);
+  asm volatile ("" : : "x" (z));
+#undef A
+#define A(n) asm volatile ("" : : "v" (zmm##n));
+  B
+  return x;
+}
+
+__m256i
+bar (__m256i x, int y)
+{
+  __m128i z;
+#undef A
+#define A(n) register __m512i zmm##n __asm ("zmm" #n);
+  B
+#undef A
+#define A(n) asm volatile ("" : "=v" (zmm##n) : "0" (v));
+  B
+  asm volatile ("" : "=x" (z) : "0" (w));
+  x = _mm256_slli_epi16 (x, y);
+  asm volatile ("" : : "x" (z));
+#undef A
+#define A(n) asm volatile ("" : : "v" (zmm##n));
+  B
+  return x;
+}
+
+/* { dg-final { scan-assembler-not "vpsrlw\[\^\n\r]*xmm(1\[6-9]|\[23]\[0-9])" } } */
+/* { dg-final { scan-assembler-not "vpsllw\[\^\n\r]*xmm(1\[6-9]|\[23]\[0-9])" } } */
Index: gcc/testsuite/gcc.target/i386/avx512f-vpermq-imm-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-vpermq-imm-2.c b/gcc/testsuite/gcc.target/i386/avx512f-vpermq-imm-2.c
--- a/gcc/testsuite/gcc.target/i386/avx512f-vpermq-imm-2.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/avx512f-vpermq-imm-2.c	(revision 262353)
@@ -40,18 +40,14 @@
       res3.a[i] = DEFAULT_VALUE;
     }
 
-#if AVX512F_LEN == 512
   res1.x = INTRINSIC (_permutex_epi64) (src1.x, IMM_MASK);
-#endif
   res2.x = INTRINSIC (_maskz_permutex_epi64) (mask, src1.x, IMM_MASK);
   res3.x = INTRINSIC (_mask_permutex_epi64) (res3.x, mask, src1.x, IMM_MASK);
 
   CALC (src1.a, IMM_MASK, res_ref);
 
-#if AVX512F_LEN == 512
   if (UNION_CHECK (AVX512F_LEN, i_q) (res1, res_ref))
     abort ();
-#endif
 
   MASK_ZERO (i_q) (res_ref, mask, SIZE);
   if (UNION_CHECK (AVX512F_LEN, i_q) (res2, res_ref))
Index: gcc/testsuite/gcc.target/i386/avx512bw-pr84524.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/avx512bw-pr84524.c b/gcc/testsuite/gcc.target/i386/avx512bw-pr84524.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/avx512bw-pr84524.c	(revision 262353)
@@ -0,0 +1,14 @@
+/* PR target/84524 */
+/* { dg-do run { target avx512bw } } */
+/* { dg-options "-O3 -mavx512bw" } */
+
+#include "avx512bw-check.h"
+
+#define main() do_main()
+#include "../../gcc.c-torture/execute/pr84524.c"
+
+static void
+avx512bw_test (void)
+{
+  do_main ();
+}
Index: gcc/testsuite/gcc.target/i386/pr84310-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr84310-2.c b/gcc/testsuite/gcc.target/i386/pr84310-2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr84310-2.c	(revision 262353)
@@ -0,0 +1,10 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -malign-loops=16" } */
+/* { dg-warning "is obsolete" "" { target *-*-* } 0 } */
+
+void
+c (void)
+{
+  for (;;)
+    ;
+}
Index: gcc/testsuite/gcc.target/i386/pr84625.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr84625.c b/gcc/testsuite/gcc.target/i386/pr84625.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr84625.c	(revision 262353)
@@ -0,0 +1,12 @@
+/* PR inline-asm/84625 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -msse2" } */
+
+typedef int V __attribute__((vector_size (16)));
+
+void
+foo (void)
+{
+  asm volatile ("# %0" : : "X" ((V) { 1, 2, 3, 4 }));	// { dg-error "invalid vector immediate" }
+  asm volatile ("# %0" : : "" ((V) { 2, 3, 4, 5 }));	// { dg-error "invalid vector immediate" }
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-inline-4.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-4.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-4.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-4.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-4.c	(revision 262353)
@@ -12,7 +12,7 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-2.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-2.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-2.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-2.c	(revision 262353)
@@ -11,9 +11,8 @@
   dispatch[offset](offset);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-11.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-11.c b/gcc/testsuite/gcc.target/i386/ret-thunk-11.c
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-11.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-11.c	(revision 262353)
@@ -15,9 +15,6 @@
 /* { dg-final { scan-assembler-times {\tlfence} 1 } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?bar" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk:" { target { ! x32 } }  } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { x32 } }  } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk_(r|e)ax:" { target { x32 } }  } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "__x86_indirect_thunk_(r|e)ax:" } } */
+/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-extern-6.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-6.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-6.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-6.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-6.c	(revision 262353)
@@ -10,8 +10,8 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 1 } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 1 } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" { target x32 } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar@GOT" { target { ! x32 } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { ! x32 } } } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-3.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-3.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-3.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-3.c	(revision 262353)
@@ -14,10 +14,9 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
 /* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-26.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-26.c b/gcc/testsuite/gcc.target/i386/ret-thunk-26.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-26.c	(revision 262353)
@@ -0,0 +1,40 @@
+/* PR target/r84530 */
+/* { dg-do run } */
+/* { dg-options "-Os -mfunction-return=thunk" } */
+
+struct S { int i; };
+__attribute__((const, noinline, noclone))
+struct S foo (int x)
+{
+  struct S s;
+  s.i = x;
+  return s;
+}
+
+int a[2048], b[2048], c[2048], d[2048];
+struct S e[2048];
+
+__attribute__((noinline, noclone)) void
+bar (void)
+{
+  int i;
+  for (i = 0; i < 1024; i++)
+    {
+      e[i] = foo (i);
+      a[i+2] = a[i] + a[i+1];
+      b[10] = b[10] + i;
+      c[i] = c[2047 - i];
+      d[i] = d[i + 1];
+    }
+}
+
+int
+main ()
+{
+  int i;
+  bar ();
+  for (i = 0; i < 1024; i++)
+    if (e[i].i != i)
+      __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-inline-5.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-5.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-5.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-5.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-5.c	(revision 262353)
@@ -9,7 +9,8 @@
   bar ();
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" } } */
+/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar@GOT" { target { ! x32 } } } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-3.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-3.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-3.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-3.c	(revision 262353)
@@ -12,9 +12,8 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-12.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-12.c b/gcc/testsuite/gcc.target/i386/ret-thunk-12.c
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-12.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-12.c	(revision 262353)
@@ -15,8 +15,6 @@
 /* { dg-final { scan-assembler-times {\tlfence} 1 } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk:" { target { ! x32 } }  } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { x32 } }  } } */
-/* { dg-final { scan-assembler "__x86_indirect_thunk_(r|e)ax:" { target { x32 } }  } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler "__x86_indirect_thunk_(r|e)ax:" } } */
+/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-7.c	(revision 262353)
@@ -35,9 +35,8 @@
     }
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
 /* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
Index: gcc/testsuite/gcc.target/i386/avx512vl-vpermd-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/avx512vl-vpermd-1.c b/gcc/testsuite/gcc.target/i386/avx512vl-vpermd-1.c
--- a/gcc/testsuite/gcc.target/i386/avx512vl-vpermd-1.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/avx512vl-vpermd-1.c	(revision 262353)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-mavx512vl -O2" } */
+/* { dg-final { scan-assembler-times "vpermd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\](?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vpermd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vpermd\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
 
@@ -11,6 +12,7 @@
 void extern
 avx512vl_test (void)
 {
+  x = _mm256_permutexvar_epi32 (x, x);
   x = _mm256_maskz_permutexvar_epi32 (m, x, x);
   x = _mm256_mask_permutexvar_epi32 (x, m, x, x);
 }
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-4.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-4.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-4.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-4.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-4.c	(revision 262353)
@@ -13,10 +13,9 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
 /* { dg-final { scan-assembler-not "__x86_indirect_thunk" } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
Index: gcc/testsuite/gcc.target/i386/avx512vl-vpermq-imm-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/avx512vl-vpermq-imm-1.c b/gcc/testsuite/gcc.target/i386/avx512vl-vpermq-imm-1.c
--- a/gcc/testsuite/gcc.target/i386/avx512vl-vpermq-imm-1.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/avx512vl-vpermq-imm-1.c	(revision 262353)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-mavx512vl -O2" } */
+/* { dg-final { scan-assembler-times "vpermq\[ \\t\]+\[^\{\n\]*%ymm\[0-9\](?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vpermq\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vpermq\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)" 1 } } */
 
@@ -11,6 +12,7 @@
 void extern
 avx512vl_test (void)
 {
+  x = _mm256_permutex_epi64 (x, 13);
   x = _mm256_mask_permutex_epi64 (x, m, x, 13);
   x = _mm256_maskz_permutex_epi64 (m, x, 13);
 }
Index: gcc/testsuite/gcc.target/i386/avx512f-vpermq-var-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-vpermq-var-2.c b/gcc/testsuite/gcc.target/i386/avx512f-vpermq-var-2.c
--- a/gcc/testsuite/gcc.target/i386/avx512f-vpermq-var-2.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/avx512f-vpermq-var-2.c	(revision 262353)
@@ -41,18 +41,14 @@
       res3.a[i] = DEFAULT_VALUE;
     }
 
-#if AVX512F_LEN == 512
   res1.x = INTRINSIC (_permutexvar_epi64) (src1.x, src2.x);
-#endif
   res2.x = INTRINSIC (_maskz_permutexvar_epi64) (mask, src1.x, src2.x);
   res3.x = INTRINSIC (_mask_permutexvar_epi64) (res3.x, mask, src1.x, src2.x);
 
   CALC (src1.a, src2.a, res_ref);
 
-#if AVX512F_LEN == 512
   if (UNION_CHECK (AVX512F_LEN, i_q) (res1, res_ref))
     abort ();
-#endif
 
   MASK_ZERO (i_q) (res_ref, mask, SIZE);
   if (UNION_CHECK (AVX512F_LEN, i_q) (res2, res_ref))
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-inline-6.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-6.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-6.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-6.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-6.c	(revision 262353)
@@ -10,7 +10,8 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" } } */
+/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar@GOT" { target { ! x32 } } } } */
 /* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-4.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-4.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-4.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-4.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-4.c	(revision 262353)
@@ -12,9 +12,8 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-13.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-13.c b/gcc/testsuite/gcc.target/i386/ret-thunk-13.c
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-13.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-13.c	(revision 262353)
@@ -14,9 +14,8 @@
 /* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk" } } */
 /* { dg-final { scan-assembler-times {\tpause} 2 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 2 } } */
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?bar" { target { { ! x32 } && *-*-linux* } } } } */
 /* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 3 } } */
 /* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 3 } } */
 /* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_indirect_thunk" } } */
-/* { dg-final { scan-assembler-not "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { x32 } }  } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
+/* { dg-final { scan-assembler-not "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
Index: gcc/testsuite/gcc.target/i386/i386.exp
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/i386.exp b/gcc/testsuite/gcc.target/i386/i386.exp
--- a/gcc/testsuite/gcc.target/i386/i386.exp	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/i386.exp	(revision 262353)
@@ -241,18 +241,6 @@
     } "-mrtm" ]
 }
 
-# Return 1 if avx512f instructions can be compiled.
-proc check_effective_target_avx512f { } {
-    return [check_no_compiler_messages avx512f object {
-	typedef long long __v8di __attribute__ ((__vector_size__ (64)));
-	__v8di
-	mm512_and_epi64  (__v8di __X, __v8di __Y)
-	{
-            return __builtin_ia32_pandq512_mask (__X, __Y, __X, -1);
-	}
-    } "-mavx512f" ]
-}
-
 # Return 1 if avx512vl instructions can be compiled.
 proc check_effective_target_avx512vl { } {
     return [check_no_compiler_messages avx512vl object {
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-5.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-5.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-5.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-5.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-5.c	(revision 262353)
@@ -14,9 +14,8 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
Index: gcc/testsuite/gcc.target/i386/avx512f-vpermd-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-vpermd-2.c b/gcc/testsuite/gcc.target/i386/avx512f-vpermd-2.c
--- a/gcc/testsuite/gcc.target/i386/avx512f-vpermd-2.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/avx512f-vpermd-2.c	(revision 262353)
@@ -41,18 +41,14 @@
       res3.a[i] = DEFAULT_VALUE;
     }
 
-#if AVX512F_LEN == 512
   res1.x = INTRINSIC (_permutexvar_epi32) (src1.x, src2.x);
-#endif
   res2.x = INTRINSIC (_maskz_permutexvar_epi32) (mask, src1.x, src2.x);
   res3.x = INTRINSIC (_mask_permutexvar_epi32) (res3.x, mask, src1.x, src2.x);
 
   CALC (src1.a, src2.a, res_ref);
 
-#if AVX512F_LEN == 512
   if (UNION_CHECK (AVX512F_LEN, i_d) (res1, res_ref))
     abort ();
-#endif
 
   MASK_ZERO (i_d) (res_ref, mask, SIZE);
   if (UNION_CHECK (AVX512F_LEN, i_d) (res2, res_ref))
Index: gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2ss64-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2ss64-1.c b/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2ss64-1.c
--- a/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2ss64-1.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/avx512f-vcvtusi2ss64-1.c	(revision 262353)
@@ -1,7 +1,7 @@
 /* { dg-do compile { target { ! ia32 } } } */
 /* { dg-options "-mavx512f -O2" } */
-/* { dg-final { scan-assembler-times "vcvtusi2ss\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
-/* { dg-final { scan-assembler-times "vcvtusi2ss\[ \\t\]+\[^%\n\]*%r\[^\{\n\]*\{rz-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vcvtusi2ssq\[ \\t\]+\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
+/* { dg-final { scan-assembler-times "vcvtusi2ssq\[ \\t\]+\[^%\n\]*%r\[^\{\n\]*\{rz-sae\}\[^\{\n\]*%xmm\[0-9\]+(?:\n|\[ \\t\]+#)" 1 } } */
 
 #include <immintrin.h>
 
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-extern-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-1.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-1.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-1.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-1.c	(revision 262353)
@@ -11,9 +11,8 @@
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
 /* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-7.c	(revision 262353)
@@ -35,8 +35,8 @@
     }
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler-not "pushq\[ \t\]%(r|e)ax" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-5.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-5.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-5.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-5.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-5.c	(revision 262353)
@@ -9,8 +9,10 @@
   bar ();
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" { target x32 } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar@GOT" { target { ! x32 } } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { ! x32 } } } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-1.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-1.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-1.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-1.c	(revision 262353)
@@ -10,9 +10,9 @@
   dispatch (buf);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "pushq\[ \t\]%rax" { target x32 } } } */
-/* { dg-final { scan-assembler "bnd jmp\[ \t\]*__x86_indirect_thunk_bnd" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "bnd jmp\[ \t\]*__x86_indirect_thunk_bnd_rax" { target lp64 } } } */
+/* { dg-final { scan-assembler "bnd call\[ \t\]*__x86_indirect_thunk_bnd_eax" { target ia32 } } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "bnd call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "bnd ret" } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-14.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-14.c b/gcc/testsuite/gcc.target/i386/ret-thunk-14.c
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-14.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-14.c	(revision 262353)
@@ -16,7 +16,6 @@
 /* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?bar" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { x32 } }  } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?bar" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-6.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-6.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-6.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-6.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-6.c	(revision 262353)
@@ -13,9 +13,8 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
Index: gcc/testsuite/gcc.target/i386/avx512vl-vpermq-var-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/avx512vl-vpermq-var-1.c b/gcc/testsuite/gcc.target/i386/avx512vl-vpermq-var-1.c
--- a/gcc/testsuite/gcc.target/i386/avx512vl-vpermq-var-1.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/avx512vl-vpermq-var-1.c	(revision 262353)
@@ -1,5 +1,6 @@
 /* { dg-do compile } */
 /* { dg-options "-mavx512vl -O2" } */
+/* { dg-final { scan-assembler-times "vpermq\[ \\t\]+\[^\{\n\]*%ymm\[0-9\](?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vpermq\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}\{z\}(?:\n|\[ \\t\]+#)" 1 } } */
 /* { dg-final { scan-assembler-times "vpermq\[ \\t\]+\[^\{\n\]*%ymm\[0-9\]+\{%k\[1-7\]\}(?:\n|\[ \\t\]+#)" 1 } } */
 
@@ -11,6 +12,7 @@
 void extern
 avx512vl_test (void)
 {
+  x = _mm256_permutexvar_epi64 (x, x);
   x = _mm256_maskz_permutexvar_epi64 (m, x, x);
   x = _mm256_mask_permutexvar_epi64 (x, m, x, x);
 }
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-extern-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-2.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-2.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-2.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-2.c	(revision 262353)
@@ -11,9 +11,8 @@
   dispatch[offset](offset);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
 /* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-6.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-6.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-6.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-6.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-6.c	(revision 262353)
@@ -10,9 +10,13 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 } } */
+/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" { target x32 } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target x32 } } } */
+/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 2 { target x32 } } } */
+/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 2 { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar@GOT" { target { ! x32 } } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target { ! x32 } } } } */
+/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
+/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-22.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-22.c b/gcc/testsuite/gcc.target/i386/ret-thunk-22.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-22.c	(revision 262353)
@@ -0,0 +1,15 @@
+/* PR target/r84530 */
+/* { dg-do compile { target ia32 } } */
+/* { dg-options "-O2 -mfunction-return=thunk" } */
+
+struct s { _Complex unsigned short x; };
+struct s gs = { 100 + 200i };
+struct s __attribute__((noinline)) foo (void) { return gs; }
+
+/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 } } */
+/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk_ecx" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler {\tpause} } } */
+/* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-2.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-2.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-2.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-2.c	(revision 262353)
@@ -11,10 +11,8 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "pushq\[ \t\]%rax" { target x32 } } } */
-/* { dg-final { scan-assembler "bnd jmp\[ \t\]*__x86_indirect_thunk_bnd" } } */
-/* { dg-final { scan-assembler "bnd jmp\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "bnd call\[ \t\]*__x86_indirect_thunk_bnd_(r|e)ax" } } */
 /* { dg-final { scan-assembler "bnd call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "bnd ret" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-15.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-15.c b/gcc/testsuite/gcc.target/i386/ret-thunk-15.c
--- a/gcc/testsuite/gcc.target/i386/ret-thunk-15.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-15.c	(revision 262353)
@@ -16,7 +16,6 @@
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler-times {\tpause} 1 } } */
 /* { dg-final { scan-assembler-times {\tlfence} 1 } } */
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?bar" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
-/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?bar" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
+/* { dg-final { scan-assembler-not "pushq\[ \t\]%rax" } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-inline-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-1.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-1.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-1.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-1.c	(revision 262353)
@@ -11,7 +11,7 @@
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-7.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-7.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-7.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-7.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-7.c	(revision 262353)
@@ -36,9 +36,8 @@
     }
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
 /* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-extern-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-3.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-3.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-3.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-3.c	(revision 262353)
@@ -12,9 +12,8 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
Index: gcc/testsuite/gcc.target/i386/pr84310.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr84310.c b/gcc/testsuite/gcc.target/i386/pr84310.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr84310.c	(revision 262353)
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -falign-functions=100000" } */
+/* { dg-error "is not between 0 and 65536" "" { target *-*-* } 0 } */
+
+void
+test_func (void)
+{
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-7.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-7.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-7.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-7.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-7.c	(revision 262353)
@@ -35,9 +35,8 @@
     }
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*\.L\[0-9\]+\\(,%" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-23.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-23.c b/gcc/testsuite/gcc.target/i386/ret-thunk-23.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-23.c	(revision 262353)
@@ -0,0 +1,15 @@
+/* PR target/r84530 */
+/* { dg-do compile { target ia32 } } */
+/* { dg-options "-O2 -mfunction-return=thunk-extern" } */
+
+struct s { _Complex unsigned short x; };
+struct s gs = { 100 + 200i };
+struct s __attribute__((noinline)) foo (void) { return gs; }
+
+/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 } } */
+/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_return_thunk_ecx" } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler-not {\tpause} } } */
+/* { dg-final { scan-assembler-not {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-3.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-3.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-3.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-3.c	(revision 262353)
@@ -10,8 +10,9 @@
   bar (buf);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" } } */
-/* { dg-final { scan-assembler "bnd jmp\[ \t\]*__x86_indirect_thunk_bnd" } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar@GOT" } } */
+/* { dg-final { scan-assembler "bnd jmp\[ \t\]*__x86_indirect_thunk_bnd_rax" { target lp64 } } } */
+/* { dg-final { scan-assembler "bnd call\[ \t\]*__x86_indirect_thunk_bnd_eax" { target ia32 } } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "bnd call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "bnd ret" } } */
Index: gcc/testsuite/gcc.target/i386/avx512f-pr84786-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-pr84786-1.c b/gcc/testsuite/gcc.target/i386/avx512f-pr84786-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/avx512f-pr84786-1.c	(revision 262353)
@@ -0,0 +1,25 @@
+/* PR target/84786 */
+/* { dg-do run { target { ! ia32 } } } */
+/* { dg-options "-mavx512f -mno-avx512vl -O2" } */
+/* { dg-require-effective-target avx512f } */
+
+#include "avx512f-check.h"
+
+typedef double V __attribute__((vector_size (16)));
+
+__attribute__((noinline, noclone)) V
+foo (V x, double y)
+{
+  register double z __asm ("xmm18");
+  asm volatile ("" : "=v" (z) : "0" (y));
+  x[1] = z;
+  return x;
+}
+
+static void
+avx512f_test (void)
+{
+  V a = foo ((V) { 1.0, 2.0 }, 3.0);
+  if (a[0] != 1.0 || a[1] != 3.0)
+    abort ();
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-inline-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-2.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-2.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-2.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-inline-2.c	(revision 262353)
@@ -11,7 +11,7 @@
   dispatch[offset](offset);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-extern-4.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-4.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-4.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-4.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-extern-4.c	(revision 262353)
@@ -12,9 +12,7 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler-times "jmp\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
-/* { dg-final { scan-assembler-times "call\[ \t\]*\.LIND" 1 { target { ! x32 } } } } */
 /* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "call\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler-not {\t(lfence|pause)} } } */
Index: gcc/testsuite/gcc.target/i386/pr85095-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr85095-1.c b/gcc/testsuite/gcc.target/i386/pr85095-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr85095-1.c	(revision 262353)
@@ -0,0 +1,33 @@
+/* PR target/85095 *
+/* { dg-do compile } */
+/* { dg-options "-O2 -masm=att" } */
+
+unsigned int
+foo (unsigned int a, unsigned int b)
+{
+  a += b;
+  if (a < b) a++;
+  return a;
+}
+
+#ifdef __x86_64__
+unsigned long long
+bar (unsigned long long a, unsigned long long b)
+{
+  a += b;
+  if (a < b) a++;
+  return a;
+}
+
+unsigned long long
+baz (unsigned int a, unsigned int b)
+{
+  a += b;
+  if (a < b) a++;
+  return a;
+}
+#endif
+
+/* { dg-final { scan-assembler-times "adcl\t\\\$0," 1 { target ia32 } } } */
+/* { dg-final { scan-assembler-times "adcl\t\\\$0," 2 { target { ! ia32 } } } } */
+/* { dg-final { scan-assembler-times "adcq\t\\\$0," 1 { target { ! ia32 } } } } */
Index: gcc/testsuite/gcc.target/i386/pr84827.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/pr84827.c b/gcc/testsuite/gcc.target/i386/pr84827.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/pr84827.c	(revision 262353)
@@ -0,0 +1,21 @@
+/* PR target/84827 */
+/* { dg-do compile } */
+/* { dg-options "-Ofast -fno-fp-int-builtin-inexact -ftrapping-math -fno-associative-math -mfpmath=387" } */
+
+double
+f1 (double a)
+{
+  return __builtin_round (a);
+}
+
+float
+f2 (float a)
+{
+  return __builtin_roundf (a);
+}
+
+long double
+f3 (long double a)
+{
+  return __builtin_roundl (a);
+}
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-attr-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-1.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-1.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-1.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-attr-1.c	(revision 262353)
@@ -14,9 +14,8 @@
   dispatch(offset);
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*_?dispatch" { target { { ! x32 } && *-*-linux* } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk" { target { ! x32 } } } } */
-/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" { target x32 } } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*_?dispatch" { target *-*-linux* } } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*__x86_indirect_thunk_(r|e)ax" } } */
 /* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
Index: gcc/testsuite/gcc.target/i386/ret-thunk-24.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/ret-thunk-24.c b/gcc/testsuite/gcc.target/i386/ret-thunk-24.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/ret-thunk-24.c	(revision 262353)
@@ -0,0 +1,15 @@
+/* PR target/r84530 */
+/* { dg-do compile { target ia32 } } */
+/* { dg-options "-O2 -mfunction-return=thunk-inline" } */
+
+struct s { _Complex unsigned short x; };
+struct s gs = { 100 + 200i };
+struct s __attribute__((noinline)) foo (void) { return gs; }
+
+/* { dg-final { scan-assembler-times "popl\[\\t \]*%ecx" 1 } } */
+/* { dg-final { scan-assembler "lea\[l\]?\[\\t \]*4\\(%esp\\), %esp" } } */
+/* { dg-final { scan-assembler-not "jmp\[ \t\]*__x86_return_thunk_ecx" } } */
+/* { dg-final { scan-assembler "jmp\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler "call\[ \t\]*\.LIND" } } */
+/* { dg-final { scan-assembler {\tpause} } } */
+/* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-4.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-4.c b/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-4.c
--- a/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-4.c	(revision 262353)
+++ b/gcc/testsuite/gcc.target/i386/indirect-thunk-bnd-4.c	(revision 262353)
@@ -11,10 +11,9 @@
   return 0;
 }
 
-/* { dg-final { scan-assembler "push(?:l|q)\[ \t\]*bar@GOT" } } */
-/* { dg-final { scan-assembler "bnd jmp\[ \t\]*__x86_indirect_thunk" } } */
-/* { dg-final { scan-assembler "bnd jmp\[ \t\]*\.LIND" } } */
-/* { dg-final { scan-assembler-times "bnd call\[ \t\]*\.LIND" 2 } } */
+/* { dg-final { scan-assembler "mov(?:l|q)\[ \t\]*bar@GOT" } } */
+/* { dg-final { scan-assembler "bnd call\[ \t\]*__x86_indirect_thunk_bnd_(r|e)ax" } } */
+/* { dg-final { scan-assembler-times "bnd call\[ \t\]*\.LIND" 1 } } */
 /* { dg-final { scan-assembler "bnd ret" } } */
 /* { dg-final { scan-assembler {\tpause} } } */
 /* { dg-final { scan-assembler {\tlfence} } } */
Index: gcc/testsuite/gcc.target/i386/avx512f-pr84786-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.target/i386/avx512f-pr84786-2.c b/gcc/testsuite/gcc.target/i386/avx512f-pr84786-2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.target/i386/avx512f-pr84786-2.c	(revision 262353)
@@ -0,0 +1,16 @@
+/* PR target/84786 */
+/* { dg-do compile { target { ! ia32 } } } */
+/* { dg-options "-mavx512f -mno-avx512vl -O2" } */
+
+typedef double V __attribute__((vector_size (16)));
+
+__attribute__((noinline, noclone)) V
+foo (V x, double y)
+{
+  register double z __asm ("xmm18");
+  asm volatile ("" : "=v" (z) : "0" (y));
+  x[1] = z;
+  return x;
+}
+
+/* { dg-final { scan-assembler-not "vunpcklpd\[\^\n\r]*xmm(1\[6-9]|\[23]\[0-9])" } } */
Index: gcc/testsuite/lib/prune.exp
===================================================================
diff --git a/gcc/testsuite/lib/prune.exp b/gcc/testsuite/lib/prune.exp
--- a/gcc/testsuite/lib/prune.exp	(revision 262353)
+++ b/gcc/testsuite/lib/prune.exp	(revision 262353)
@@ -28,7 +28,7 @@
 
     #send_user "Before:$text\n"
 
-    regsub -all "(^|\n)(\[^\n\]*: )?In ((static member |lambda )?function|member|method|(copy )?constructor|destructor|instantiation|substitution|program|subroutine|block-data)\[^\n\]*" $text "" text
+    regsub -all "(^|\n)(\[^\n\]*: \[iI\]|I)n ((static member |lambda )?function|member|method|(copy )?constructor|destructor|instantiation|substitution|program|subroutine|block-data)\[^\n\]*" $text "" text
     regsub -all "(^|\n)\[^\n\]*(: )?At (top level|global scope):\[^\n\]*" $text "" text
     regsub -all "(^|\n)\[^\n\]*:   (recursively )?required \[^\n\]*" $text "" text
     regsub -all "(^|\n)\[^\n\]*:   . skipping \[0-9\]* instantiation contexts \[^\n\]*" $text "" text
Index: gcc/testsuite/lib/target-supports.exp
===================================================================
diff --git a/gcc/testsuite/lib/target-supports.exp b/gcc/testsuite/lib/target-supports.exp
--- a/gcc/testsuite/lib/target-supports.exp	(revision 262353)
+++ b/gcc/testsuite/lib/target-supports.exp	(revision 262353)
@@ -5940,7 +5940,8 @@
 	verbose "check_effective_target_vect_load_lanes: using cached result" 2
     } else {
 	set et_vect_load_lanes 0
-	if { ([istarget arm*-*-*] && [check_effective_target_arm_neon_ok])
+	# We don't support load_lanes correctly on big-endian arm.
+	if { ([check_effective_target_arm_little_endian] && [check_effective_target_arm_neon_ok])
 	     || [istarget aarch64*-*-*] } {
 	    set et_vect_load_lanes 1
 	}
@@ -7348,11 +7349,22 @@
 proc check_effective_target_avx512f { } {
     return [check_no_compiler_messages avx512f object {
 	typedef double __m512d __attribute__ ((__vector_size__ (64)));
+	typedef double __m128d __attribute__ ((__vector_size__ (16)));
 
 	__m512d _mm512_add (__m512d a)
 	{
 	  return __builtin_ia32_addpd512_mask (a, a, a, 1, 4);
 	}
+
+	__m128d _mm128_add (__m128d a)
+	{
+	  return __builtin_ia32_addsd_round (a, a, 8);
+	}
+
+	__m128d _mm128_getmant (__m128d a)
+	{
+	  return __builtin_ia32_getmantsd_round (a, a, 0, 8);
+	}
     } "-O2 -mavx512f" ]
 }
 
Index: gcc/testsuite/gfortran.dg/pr71085.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr71085.f90 b/gcc/testsuite/gfortran.dg/pr71085.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr71085.f90	(revision 262353)
@@ -0,0 +1,12 @@
+! { dg-do compile }
+! PR 71085
+!
+! Testcase from PR by Vladimir Fuka <vladimir.fuka@gmail.com>
+!
+program pr71085
+  print *, f()
+contains
+  function f()
+    integer :: f(iargc()*10)
+  end
+end
Index: gcc/testsuite/gfortran.dg/matmul_rank_1.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/matmul_rank_1.f90 b/gcc/testsuite/gfortran.dg/matmul_rank_1.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/matmul_rank_1.f90	(revision 262353)
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! { dg-additional-options "-ffrontend-optimize" }
+! PR 85044 - used to die on allocating a negative amount of memory.
+! Test case by Gerhard Steinmetz.
+program p
+   real :: a(3,3) = 1.0
+   real :: b(33)
+   b = matmul(a, a) ! { dg-error "Incompatible ranks" }
+end
Index: gcc/testsuite/gfortran.dg/allocate_stat_2.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/allocate_stat_2.f90 b/gcc/testsuite/gfortran.dg/allocate_stat_2.f90
--- a/gcc/testsuite/gfortran.dg/allocate_stat_2.f90	(revision 262353)
+++ b/gcc/testsuite/gfortran.dg/allocate_stat_2.f90	(revision 262353)
@@ -5,6 +5,6 @@
   character(len=30), dimension(2) :: er
   integer, dimension (:), allocatable :: a
   allocate (a (16), stat = ier) ! { dg-error "must be a scalar INTEGER" }
-  allocate (a (14), stat=ier(1),errmsg=er) ! { dg-error "must be a scalar CHARACTER" }
+  allocate (a (14), stat=ier(1),errmsg=er) ! { dg-error "shall be a scalar default CHARACTER" }
 end
 
Index: gcc/testsuite/gfortran.dg/constant_shape.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/constant_shape.f90 b/gcc/testsuite/gfortran.dg/constant_shape.f90
--- a/gcc/testsuite/gfortran.dg/constant_shape.f90	(revision 262353)
+++ b/gcc/testsuite/gfortran.dg/constant_shape.f90	(revision 262353)
@@ -3,7 +3,8 @@
 ! PR 78392: ICE in gfc_trans_auto_array_allocation, at fortran/trans-array.c:5979
 !
 ! Contributed by Janus Weil <janus@gcc.gnu.org>
-
+! Error message update with patch for PR fortran/83633
+!
 module mytypes
    implicit none
  contains
@@ -15,6 +16,6 @@
 program test
   use mytypes
   implicit none
-  integer, dimension(get_i()) :: x  ! { dg-error "must have constant shape" }
-  print *, size (x)
+  integer, dimension(get_i()) :: x  ! { dg-error "array with nonconstant bounds" }
+  print *, size (x)                 ! { dg-error "has no IMPLICIT type" }
 end
Index: gcc/testsuite/gfortran.dg/pr85521_1.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr85521_1.f90 b/gcc/testsuite/gfortran.dg/pr85521_1.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr85521_1.f90	(revision 262353)
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/85521
+program p
+   character(3) :: c = 'abc'
+   character(3) :: z(1)
+   z = [ c(:-1) ]
+   print *, z
+end
Index: gcc/testsuite/gfortran.dg/pr85543.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr85543.f90 b/gcc/testsuite/gfortran.dg/pr85543.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr85543.f90	(revision 262353)
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/85543
+program p
+   procedure(), pointer :: z
+contains
+   real(z()) function f()  ! { dg-error "in initialization expression at" }
+   end
+end
Index: gcc/testsuite/gfortran.dg/pr84117.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr84117.f90 b/gcc/testsuite/gfortran.dg/pr84117.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr84117.f90	(revision 262353)
@@ -0,0 +1,7 @@
+! PR tree-optimization/84117
+! { dg-do compile }
+! { dg-options "-O3 -ftrapv" }
+  FUNCTION pw_integral_aa ( cc ) RESULT ( integral_value )
+    COMPLEX(KIND=8), DIMENSION(:), POINTER :: cc
+    integral_value = accurate_sum ( CONJG ( cc (:) ) * cc (:) )
+  END FUNCTION pw_integral_aa
Index: gcc/testsuite/gfortran.dg/gomp/pr83977.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/gomp/pr83977.f90 b/gcc/testsuite/gfortran.dg/gomp/pr83977.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/gomp/pr83977.f90	(revision 262353)
@@ -0,0 +1,15 @@
+! PR middle-end/83977
+! { dg-do compile }
+
+integer function foo (a, b)
+   integer :: a, b
+!$omp declare simd uniform(b) linear(ref(a):b)
+   a = a + 1
+! This function can't be called from simd loops,
+! because it violates declare simd restrictions.
+! We shouldn't ICE on it though, nor attempt to generate
+! simd clones for the *omp_fn* functions.
+!$omp parallel
+   call sub
+!$omp end parallel
+end
Index: gcc/testsuite/gfortran.dg/gomp/pr85313.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/gomp/pr85313.f90 b/gcc/testsuite/gfortran.dg/gomp/pr85313.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/gomp/pr85313.f90	(revision 262353)
@@ -0,0 +1,25 @@
+! PR fortran/85313
+! { dg-do compile }
+
+!$omp do collapse(3)
+  do i = 1, 10
+    do j = i, 20	! { dg-error "form rectangular iteration space" }
+      do k = 1, 2
+      end do
+    end do
+  end do
+!$omp do collapse(3)
+  do i = 1, 10
+    do j = 1, 5
+      do k = i, 20	! { dg-error "form rectangular iteration space" }
+      end do
+    end do
+  end do
+!$omp do collapse(3)
+  do i = 1, 10
+    do j = 1, 5
+      do k = j, 20	! { dg-error "form rectangular iteration space" }
+      end do
+    end do
+  end do
+end
Index: gcc/testsuite/gfortran.dg/gomp/pr84116.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/gomp/pr84116.f90 b/gcc/testsuite/gfortran.dg/gomp/pr84116.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/gomp/pr84116.f90	(revision 262353)
@@ -0,0 +1,12 @@
+! PR fortran/84116
+! { dg-do compile }
+
+program pr84116
+   integer :: i, j
+   !$omp simd linear ((i))	! { dg-error "Syntax error" }
+   do i = 1, 2
+   end do
+   !$omp simd linear ()		! { dg-error "Syntax error" }
+   do j = 1, 2
+   end do
+end
Index: gcc/testsuite/gfortran.dg/pr86059.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr86059.f90 b/gcc/testsuite/gfortran.dg/pr86059.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr86059.f90	(revision 262353)
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/86059
+program foo
+   integer :: i(2) = [ null(), 1 ]           ! { dg-error "cannot appear in an array constructor" }
+   integer :: j(2) = [ (null(), n = 1, 2) ]  ! { dg-error "cannot appear in an array constructor" }
+   integer k(2)
+   k = 42 + [1, null()]                      ! { dg-error "cannot appear in an array constructor" }
+end program foo
Index: gcc/testsuite/gfortran.dg/pr85687.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr85687.f90 b/gcc/testsuite/gfortran.dg/pr85687.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr85687.f90	(revision 262353)
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/85687
+! Code original contributed by Gerhard Steinmetz gscfq at t-oline dot de
+program p
+   type t
+   end type
+   print *, rank(t)  ! { dg-error "must be a data object" }
+end
Index: gcc/testsuite/gfortran.dg/pr85779_3.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr85779_3.f90 b/gcc/testsuite/gfortran.dg/pr85779_3.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr85779_3.f90	(revision 262353)
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! PR fortran/85779
+class(t) function f()   ! { dg-error "must be dummy, allocatable or pointer" }
+   type f               ! { dg-error "already has a basic type" }
+   end type             ! { dg-error "END FUNCTION statement" }
+end
+
Index: gcc/testsuite/gfortran.dg/pr83149_a.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr83149_a.f90 b/gcc/testsuite/gfortran.dg/pr83149_a.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr83149_a.f90	(revision 262353)
@@ -0,0 +1,11 @@
+! Compiled with pr83149_b.f90
+!
+module mod
+  character(8) string
+contains
+  function get_string() result(s)
+    character(len_trim(string)) s
+    s = string
+  end function
+end module
+
Index: gcc/testsuite/gfortran.dg/coarray_45.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/coarray_45.f90 b/gcc/testsuite/gfortran.dg/coarray_45.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/coarray_45.f90	(revision 262353)
@@ -0,0 +1,24 @@
+! { dg-do compile }
+! { dg-options "-fcoarray=lib -lcaf_single " }
+!
+! Test the fix for PR83076
+!
+module m
+   type t
+      integer, pointer :: z
+   end type
+   type(t) :: ptr
+contains
+   function g(x)
+      type(t) :: x[*]
+      if (associated (x%z, ptr%z)) deallocate (x%z) ! This used to ICE with -fcoarray=lib
+   end
+end module
+
+  use m
+contains
+   function f(x)
+      type(t) :: x[*]
+      if (associated (x%z, ptr%z)) deallocate (x%z)
+   end
+end
Index: gcc/testsuite/gfortran.dg/goacc/pr84963.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/goacc/pr84963.f90 b/gcc/testsuite/gfortran.dg/goacc/pr84963.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/goacc/pr84963.f90	(revision 262353)
@@ -0,0 +1,7 @@
+! PR ipa/84963
+! { dg-options "-O2" }
+
+program p
+   print *, sin([1.0, 2.0])
+   print *, cos([1.0, 2.0])
+end
Index: gcc/testsuite/gfortran.dg/associate_33.f03
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/associate_33.f03 b/gcc/testsuite/gfortran.dg/associate_33.f03
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/associate_33.f03	(revision 262353)
@@ -0,0 +1,11 @@
+! { dg-do run }
+!
+! Test the fix for PR83898.f90
+!
+! Contributed by G Steinmetz  <gscfq@t-online.de>
+!
+program p
+   associate (x => ['1','2'])
+      if (any (x .ne. ['1','2'])) call abort
+   end associate
+end
Index: gcc/testsuite/gfortran.dg/select_type_40.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/select_type_40.f90 b/gcc/testsuite/gfortran.dg/select_type_40.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/select_type_40.f90	(revision 262353)
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! { dg-additional-options "-fdefault-integer-8" }
+! PR 78238 - this used to cause an ICE.
+! Original test cae by Gerhard Steinmetz
+class(*), allocatable :: q
+select type (x => q)
+type is (real)
+end select
+end
Index: gcc/testsuite/gfortran.dg/array_constructor_52.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/array_constructor_52.f90 b/gcc/testsuite/gfortran.dg/array_constructor_52.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/array_constructor_52.f90	(revision 262353)
@@ -0,0 +1,11 @@
+! { dg-do  run }
+! PR 84931 - long array constructors with type conversion were not
+! handled correctly.
+program test
+   implicit none
+   integer, parameter :: n = 2**16
+   real, dimension(n) :: y
+   integer :: i
+   y = (/ (1, i=1, n) /)
+   if (y(2) /= 1) stop 1
+end program test
Index: gcc/testsuite/gfortran.dg/unlimited_polymorphic_30.f03
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/unlimited_polymorphic_30.f03 b/gcc/testsuite/gfortran.dg/unlimited_polymorphic_30.f03
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/unlimited_polymorphic_30.f03	(revision 262353)
@@ -0,0 +1,38 @@
+! { dg-do run }
+!
+! Test the fix for PR83318.
+!
+! Contributed by Neil Carlson  <neil.n.carlson@gmail.com>
+!
+type :: any_vector
+  class(*), allocatable :: v(:)
+end type
+type(any_vector) :: x, y
+
+! This did not work correctly
+  x%v = ['foo','bar']
+  call foo (x, 1)
+
+! This was reported as not working correctly but was OK before the above was fixed
+  y = x
+  call foo (y, 2)
+
+  x%v = [1_4,2_4]
+  call foo (x, 3)
+
+  y = x
+  call foo (y, 4)
+
+contains
+
+  subroutine foo (arg, n)
+    type (any_vector) :: arg
+    integer :: n
+    select type (v => arg%v)
+        type is (character(*))
+           if (any (v .ne. ["foo","bar"])) stop n
+        type is (integer(4))
+           if (any (v .ne. [1_4,2_4])) stop n
+    end select
+  end subroutine
+end
Index: gcc/testsuite/gfortran.dg/pr44491.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr44491.f90 b/gcc/testsuite/gfortran.dg/pr44491.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr44491.f90	(revision 262353)
@@ -0,0 +1,5 @@
+! { dg-do compile }
+! { dg-options "-std=gnu" }
+! PR fortran/44491
+      character*2 escape /z'1B'/  ! { dg-error "Incompatible types in DATA" }
+      end
Index: gcc/testsuite/gfortran.dg/pr85520.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr85520.f90 b/gcc/testsuite/gfortran.dg/pr85520.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr85520.f90	(revision 262353)
@@ -0,0 +1,7 @@
+! { dg-do run }
+! PR fortran/85520
+! Original code from Gerhard Steinmetz <gscfq at t-online dot de>
+program p
+   character(-huge(1)) :: c = ' '
+    if (len(c) /= 0) stop 1
+end
Index: gcc/testsuite/gfortran.dg/internal_references_1.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/internal_references_1.f90 b/gcc/testsuite/gfortran.dg/internal_references_1.f90
--- a/gcc/testsuite/gfortran.dg/internal_references_1.f90	(revision 262353)
+++ b/gcc/testsuite/gfortran.dg/internal_references_1.f90	(revision 262353)
@@ -11,7 +11,7 @@
   implicit none
 contains
 
-  subroutine p (i)   ! { dg-error "is already defined" }
+  subroutine p (i)   ! { dg-error "(1)" }
     integer :: i
   end subroutine
 
@@ -22,11 +22,11 @@
 !
 ! PR25124 - would happily ignore the declaration of foo in the main program.
 program test
-real :: foo, x      ! { dg-error "explicit interface and must not have attributes declared" }
+real :: foo, x
 x = bar ()          ! This is OK because it is a regular reference.
 x = foo ()
 contains
-    function foo () ! { dg-error "explicit interface and must not have attributes declared" }
+    function foo () ! { dg-error "explicit interface from a previous" }
       foo = 1.0
     end function foo
     function bar ()
@@ -33,3 +33,4 @@
       bar = 1.0
     end function bar
 end program test
+
Index: gcc/testsuite/gfortran.dg/bad_automatic_objects_1.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/bad_automatic_objects_1.f90 b/gcc/testsuite/gfortran.dg/bad_automatic_objects_1.f90
--- a/gcc/testsuite/gfortran.dg/bad_automatic_objects_1.f90	(revision 262353)
+++ b/gcc/testsuite/gfortran.dg/bad_automatic_objects_1.f90	(revision 262353)
@@ -5,16 +5,18 @@
 !
 ! Contributed by Joost VandeVondele  <jv244@cam.ac.uk>
 !
+! Error message update with patch for PR fortran/83633
+!
 module foo
   integer    ::  i
 end module foo
 module bar
   use foo
-  integer, dimension (i) :: j ! { dg-error "must have constant shape" }
+  integer, dimension (i) :: j ! { dg-error "array with nonconstant bounds" }
   character (len = i) :: c1   ! { dg-error "must have constant character length" }
 end module bar
 program foobar
   use foo
-  integer, dimension (i) :: k ! { dg-error "must have constant shape" }
+  integer, dimension (i) :: k ! { dg-error "array with nonconstant bounds" }
   character (len = i) :: c2   ! { dg-error "must have constant character length" }
 end program foobar
Index: gcc/testsuite/gfortran.dg/deallocate_error_4.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/deallocate_error_4.f90 b/gcc/testsuite/gfortran.dg/deallocate_error_4.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/deallocate_error_4.f90	(revision 262353)
@@ -0,0 +1,10 @@
+! { dg-do compile }
+! PR fortran/82994
+! Code contributed by Gerhard Steinmetz
+program p
+   type t
+   end type
+   class(t) :: x  ! { dg-error "must be dummy, allocatable or pointer" }
+   allocate (x)   ! { dg-error "neither a data pointer nor an allocatable" }
+   deallocate (x) ! { dg-error "not a nonprocedure pointer nor an allocatable" }
+end
Index: gcc/testsuite/gfortran.dg/statement_function_2.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/statement_function_2.f90 b/gcc/testsuite/gfortran.dg/statement_function_2.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/statement_function_2.f90	(revision 262353)
@@ -0,0 +1,26 @@
+! { dg-do compile }
+! PR fortran/54223
+subroutine r(d)
+    implicit none
+    integer, optional :: d
+    integer :: h, q
+    q(d) = d + 1     ! statement function statement
+    h = q(d)
+end subroutine r
+
+subroutine s(x)
+    implicit none
+    integer, optional :: x
+    integer :: g, z
+    g(x) = x + 1     ! statement function statement
+    z = g()          ! { dg-error "Missing actual argument" }
+end subroutine s
+
+subroutine t(a)
+    implicit none
+    integer :: a
+    integer :: f, y
+    f(a) = a + 1     ! statement function statement
+    y = f()          ! { dg-error "Missing actual argument" }
+end subroutine t
+! { dg-prune-output " Obsolescent feature" }
Index: gcc/testsuite/gfortran.dg/pr85542.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr85542.f90 b/gcc/testsuite/gfortran.dg/pr85542.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr85542.f90	(revision 262353)
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! PR fortran/85542
+function f(x)
+   character(*), intent(in) :: x
+   character((len((x)))) :: f
+   f = x
+end
Index: gcc/testsuite/gfortran.dg/pr85996.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr85996.f90 b/gcc/testsuite/gfortran.dg/pr85996.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr85996.f90	(revision 262353)
@@ -0,0 +1,69 @@
+! { dg-do compile }
+module strings
+
+   type string
+      integer :: len = 0, size = 0
+      character, pointer :: chars(:) => null()
+   end type string
+
+   interface length
+      module procedure len_s
+   end interface
+
+   interface char
+      module procedure s_to_c, s_to_slc  
+   end interface
+
+   interface uppercase
+      module procedure uppercase_c
+   end interface
+
+   interface replace
+      module procedure replace_ccs
+   end interface
+
+   contains
+
+      elemental function len_s(s)
+         type(string), intent(in) :: s
+         integer :: len_s
+      end function len_s
+
+      pure function s_to_c(s)
+         type(string),intent(in) :: s
+         character(length(s)) :: s_to_c
+      end function s_to_c
+
+      pure function s_to_slc(s,long)
+         type(string),intent(in) :: s
+         integer, intent(in) :: long
+         character(long) :: s_to_slc
+      end function s_to_slc
+
+      pure function lr_sc_s(s,start,ss) result(l)
+         type(string), intent(in) :: s
+         character(*), intent(in) :: ss
+         integer, intent(in)  :: start
+         integer :: l
+      end function lr_sc_s
+
+      pure function lr_ccc(s,tgt,ss,action) result(l)
+         character(*), intent(in) :: s,tgt,ss,action
+         integer :: l
+         select case(uppercase(action))
+         case default
+         end select
+      end function lr_ccc
+
+      function replace_ccs(s,tgt,ss) result(r)
+         character(*), intent(in)             :: s,tgt
+         type(string), intent(in)             :: ss
+         character(lr_ccc(s,tgt,char(ss),'first'))  :: r
+      end function replace_ccs
+
+      pure function uppercase_c(c)
+         character(*), intent(in) :: c
+         character(len(c)) :: uppercase_c
+      end function uppercase_c
+
+end module strings
Index: gcc/testsuite/gfortran.dg/pr38351.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr38351.f90 b/gcc/testsuite/gfortran.dg/pr38351.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr38351.f90	(revision 262353)
@@ -0,0 +1,21 @@
+! { dg-do compile }
+module m1
+   type t1
+      integer :: i
+   end type t1
+   interface operator(+)
+      module procedure add
+   end interface
+   contains
+      type(t1) function add(a,b)
+         type(t1), intent(in) :: a,b
+      end function
+end module m1
+
+program foo
+   use m1
+   type(t1), dimension(2,2) :: a = t1(1), b = t1(2)
+   type(t1) :: c=t1(1), d=t1(2)
+   c = c + d
+   a = a + b   ! { dg-error "Unexpected derived-type entities" }
+end program foo
Index: gcc/testsuite/gfortran.dg/shape_9.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/shape_9.f90 b/gcc/testsuite/gfortran.dg/shape_9.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/shape_9.f90	(revision 262353)
@@ -0,0 +1,16 @@
+! { dg-do  run }
+! { dg-require-effective-target lto }
+! { dg-options "-flto" }
+! Check that there are no warnings with LTO for a KIND argument.
+!
+program test
+   implicit none
+   real, allocatable :: x(:,:)
+
+   allocate(x(2,5))
+   if (any(shape(x) /= [ 2, 5 ])) call abort
+   if (any(shape(x,kind=1) /= [ 2, 5 ])) call abort
+   if (any(shape(x,kind=2) /= [ 2, 5 ])) call abort
+   if (any(shape(x,kind=4) /= [ 2, 5 ])) call abort
+   if (any(shape(x,kind=8) /= [ 2, 5 ])) call abort
+ end program test
Index: gcc/testsuite/gfortran.dg/pr85779_2.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr85779_2.f90 b/gcc/testsuite/gfortran.dg/pr85779_2.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr85779_2.f90	(revision 262353)
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! PR fortran/85779
+type(t) function f() result(z)   ! { dg-error "is not accessible" }
+   type z                        ! { dg-error "already has a basic type" }
+   end type                      ! { dg-error "END FUNCTION statement" }
+end
+
Index: gcc/testsuite/gfortran.dg/class_67.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/class_67.f90 b/gcc/testsuite/gfortran.dg/class_67.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/class_67.f90	(revision 262353)
@@ -0,0 +1,55 @@
+! { dg-do run }
+!
+! Test the fix for PR78990 in which the scalarization of the assignment
+! in the main program failed for two reasons: (i) The conversion of 'v1'
+! into a class actual was being done after the call to 'return_t1', giving
+! rise to the ICE reported in comment #1; and (ii) The 'info' descriptor,
+! required for scalarization was not set, which gave rise to the ICE noted
+! by the contributor.
+!
+! Contributed by Chris Macmackin  <cmacmackin@gmail.com>
+!
+module test_type
+  implicit none
+
+  type t1
+     integer :: i
+   contains
+     procedure :: assign
+     generic :: assignment(=) => assign
+  end type t1
+
+contains
+
+  elemental subroutine assign(this,rhs)
+    class(t1), intent(inout) :: this
+    class(t1), intent(in) :: rhs
+    this%i = rhs%i
+  end subroutine assign
+
+  function return_t1(arg)
+    class(t1), dimension(:), intent(in) :: arg
+    class(t1), dimension(:), allocatable :: return_t1
+    allocate(return_t1(size(arg)), source=arg)
+  end function return_t1
+
+  function return_t1_p(arg)
+    class(t1), dimension(:), intent(in), target :: arg
+    class(t1), dimension(:), pointer :: return_t1_p
+    return_t1_p => arg
+  end function return_t1_p
+end module test_type
+
+program test
+  use test_type
+  implicit none
+
+  type(t1), dimension(3) :: v1, v2
+  v1%i = [1,2,3]
+  v2 = return_t1(v1)
+  if (any (v2%i .ne. v1%i)) call abort
+
+  v1%i = [4,5,6]
+  v2 = return_t1_p(v1)
+  if (any (v2%i .ne. v1%i)) call abort
+end program test
Index: gcc/testsuite/gfortran.dg/realloc_on_assign_29.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/realloc_on_assign_29.f90 b/gcc/testsuite/gfortran.dg/realloc_on_assign_29.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/realloc_on_assign_29.f90	(revision 262353)
@@ -0,0 +1,13 @@
+! { dg-do run }
+! PR fortran/81116
+! The assignment was broken due to a missing temporary.
+! Original test case by Clive Page.
+
+program test10
+  implicit none
+  character(:), allocatable :: string
+  !
+  string = '1234567890'
+  string = string(1:5) // string(7:)
+  if (string /= '123457890') STOP 1
+end program test10
Index: gcc/testsuite/gfortran.dg/inline_matmul_22.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/inline_matmul_22.f90 b/gcc/testsuite/gfortran.dg/inline_matmul_22.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/inline_matmul_22.f90	(revision 262353)
@@ -0,0 +1,44 @@
+! { dg-do compile }
+! { dg-additional-options "-ffrontend-optimize" }
+! PR 84270 - this used to be rejected.
+! Test case by Michael Weinert
+
+module fp_precision
+
+   integer, parameter   :: fp = selected_real_kind(13)
+
+end module fp_precision
+
+      subroutine lhcal(nrot,orth,ngpts,vgauss,vr_0)
+
+      use fp_precision  ! floating point precision
+
+      implicit none
+
+!--->    rotation matrices and rotations (input)
+      integer,          intent(in)  :: nrot
+!     real(kind=fp),    intent(in)  :: orth(3,3,nrot)  ! fine at all -O
+      real(kind=fp),    intent(in)  :: orth(3,3,*)
+
+!--->    gaussian integration points
+      integer,          intent(in)  :: ngpts
+      real(kind=fp),    intent(in)  :: vgauss(3,*)
+
+!--->    output results
+      real(kind=fp),    intent(out) :: vr_0(3)
+
+      real(kind=fp)     :: v(3),vr(3)
+      integer           :: n,nn
+
+      vr_0 = 0
+      do nn=1,ngpts
+         v(:) = vgauss(:,nn)
+!--->    apply rotations
+         do n=2,nrot
+            vr = matmul( orth(:,:,n), v )
+            vr_0 = vr_0 + vr
+         enddo
+      enddo
+
+      return
+      end subroutine lhcal
Index: gcc/testsuite/gfortran.dg/automatic_module_variable.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/automatic_module_variable.f90 b/gcc/testsuite/gfortran.dg/automatic_module_variable.f90
--- a/gcc/testsuite/gfortran.dg/automatic_module_variable.f90	(revision 262353)
+++ b/gcc/testsuite/gfortran.dg/automatic_module_variable.f90	(revision 262353)
@@ -1,10 +1,12 @@
 ! { dg-do compile }
 ! Tests fix for PR15976
 !
+! Error message update with patch for PR fortran/83633
+!
 module sd
   integer, parameter :: n = 20
   integer :: i(n)
-  integer :: j(m) ! { dg-error "must have constant shape" }
+  integer :: j(m) ! { dg-error "array with nonconstant bounds" }
   integer, pointer :: p(:)
   integer, allocatable :: q(:)
 contains
Index: gcc/testsuite/gfortran.dg/pr83149_1.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr83149_1.f90 b/gcc/testsuite/gfortran.dg/pr83149_1.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr83149_1.f90	(revision 262353)
@@ -0,0 +1,24 @@
+! Compiled with pr83149.f90
+! { dg-do run }
+! { dg-options "-fno-whole-file" }
+! { dg-compile-aux-modules "pr83149.f90" }
+! { dg-additional-sources pr83149.f90 }
+!
+! Contributed by Neil Carlson  <neil.n.carlson@gmail.com>
+!
+subroutine sub(s)
+  use mod2
+  real :: s
+  s = sum(get())
+end
+
+  use mod1
+  real :: s
+  ncells = 2
+  call sub (s)
+  if (int (s) .ne. ncells) stop 1
+  ncells = 10
+  call sub (s)
+  if (int (s) .ne. ncells) stop 2
+end
+
Index: gcc/testsuite/gfortran.dg/pr65453.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr65453.f90 b/gcc/testsuite/gfortran.dg/pr65453.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr65453.f90	(revision 262353)
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/65453
+! Contributed by Tobias Burnus  <burnus at gcc.gnu.org>
+procedure() :: foo   ! { dg-error "(1)" }
+  contains
+    subroutine foo() ! { dg-error "clashes with procedure" }
+    end
+end
Index: gcc/testsuite/gfortran.dg/proc_ptr_50.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/proc_ptr_50.f90 b/gcc/testsuite/gfortran.dg/proc_ptr_50.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/proc_ptr_50.f90	(revision 262353)
@@ -0,0 +1,68 @@
+! { dg-do compile }
+!
+! Test the fix for PR86242, in which the procedure pointer in 'tester'
+! was being copied as if it were an allocatable class component.
+!
+! Contributed by <cfd@mnet-mail.de>
+!
+module test
+
+   implicit none
+
+   private
+   public :: tester
+
+   type :: wrapper
+      integer(4) :: n
+   end type wrapper
+
+   type :: output
+      real(8) :: dummy
+   end type output
+
+   type :: tester
+      class(wrapper),  allocatable :: wrap
+      procedure(proc1), pointer :: ptr => null()
+   end type tester
+
+   abstract interface
+      function proc1(self) result(uc)
+         import :: tester, output
+         class(tester), intent(in) :: self
+         class(output), allocatable :: uc
+      end function proc1
+   end interface
+
+end module test
+
+! Comment #2 from Janus Weil  <janus@gcc.gnu.org>
+module test1
+
+   implicit none
+
+   type :: output
+   end type
+
+   type :: tester
+      integer,  allocatable :: wrap
+      procedure(proc1), pointer, nopass :: ptr
+   end type
+
+   interface                              ! Originally abstract
+      function proc1() result(uc)
+         import :: output
+         class(output), allocatable :: uc ! Works if a pointer
+      end function
+   end interface
+
+! PR82969 from Gerhard Steinmetz  <gscfq@t-online.de>
+   type t
+      real, allocatable :: x(:)
+      procedure(f), nopass, pointer :: g
+   end type
+contains
+   function f() result(z)
+      class(t), allocatable :: z
+   end
+
+end module test1
Index: gcc/testsuite/gfortran.dg/pr78278.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr78278.f90 b/gcc/testsuite/gfortran.dg/pr78278.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr78278.f90	(revision 262353)
@@ -0,0 +1,14 @@
+! { dg-do compile }
+! { dg-options "-std=f95" }
+! PR fortran/78278
+program p
+   character, pointer :: x => null()
+   data x /null()/         ! { dg-error "GNU Extension: re-initialization" }
+   print *, associated(x)
+end
+
+subroutine foo
+   real :: x = 42
+   data x /0/              ! { dg-error "GNU Extension: re-initialization" }
+   print *, x
+end subroutine foo
Index: gcc/testsuite/gfortran.dg/pr67805.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr67805.f90 b/gcc/testsuite/gfortran.dg/pr67805.f90
--- a/gcc/testsuite/gfortran.dg/pr67805.f90	(revision 262353)
+++ b/gcc/testsuite/gfortran.dg/pr67805.f90	(revision 262353)
@@ -22,7 +22,6 @@
    s = [character([1.]) :: 'x', 'y']      ! { dg-error "INTEGER expression expected" }
    s = [character([1d1]) :: 'x', 'y']     ! { dg-error "INTEGER expression expected" }
    s = [character([(0.,1.)]) :: 'x', 'y'] ! { dg-error "INTEGER expression expected" }
-   s = [character([null()]) :: 'x', 'y']  ! { dg-error "INTEGER expression expected" }
    s =  [character(null()) :: 'x', 'y']   ! { dg-error "INTEGER expression expected" }
    call foo(s)
 end subroutine p
Index: gcc/testsuite/gfortran.dg/pr51434.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr51434.f90 b/gcc/testsuite/gfortran.dg/pr51434.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr51434.f90	(revision 262353)
@@ -0,0 +1,19 @@
+! { dg-do run }
+! PR fortran/51434
+module foo
+   implicit none
+   integer, parameter :: n = 5
+   character(len=1), parameter :: s(n) = 'a'
+   type :: a
+      integer :: m = n
+      character(len=1):: t(n) = transfer('abcde             ', s)
+   end type a
+end module foo
+
+program bar
+   use foo
+   implicit none
+   type(a) c
+   if (c%m /= n) stop 1
+   if (any(c%t /= ['a', 'b', 'c', 'd', 'e'])) stop 2
+end program bar
Index: gcc/testsuite/gfortran.dg/coarray_8.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/coarray_8.f90 b/gcc/testsuite/gfortran.dg/coarray_8.f90
--- a/gcc/testsuite/gfortran.dg/coarray_8.f90	(revision 262353)
+++ b/gcc/testsuite/gfortran.dg/coarray_8.f90	(revision 262353)
@@ -145,7 +145,7 @@
 
 subroutine tfgh()
   integer :: i(2)
-  DATA i/(i, i=1,2)/ ! { dg-error "Expected PARAMETER symbol" }
+  DATA i/(i, i=1,2)/ ! { dg-error "Syntax error in DATA" }
   do i = 1, 5 ! { dg-error "cannot be an array" }
   end do ! { dg-error "Expecting END SUBROUTINE" }
 end subroutine tfgh
@@ -153,7 +153,7 @@
 subroutine tfgh2()
   integer, save :: x[*]
   integer :: i(2)
-  DATA i/(x, x=1,2)/ ! { dg-error "Expected PARAMETER symbol" }
+  DATA i/(x, x=1,2)/ ! { dg-error "Syntax error in DATA" }
   do x = 1, 5 ! { dg-error "cannot be a coarray" }
   end do ! { dg-error "Expecting END SUBROUTINE" }
 end subroutine tfgh2
Index: gcc/testsuite/gfortran.dg/deallocate_alloc_opt_1.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/deallocate_alloc_opt_1.f90 b/gcc/testsuite/gfortran.dg/deallocate_alloc_opt_1.f90
--- a/gcc/testsuite/gfortran.dg/deallocate_alloc_opt_1.f90	(revision 262353)
+++ b/gcc/testsuite/gfortran.dg/deallocate_alloc_opt_1.f90	(revision 262353)
@@ -22,7 +22,7 @@
   deallocate(i)) ! { dg-error "Syntax error in DEALLOCATE" }
   deallocate(i, errmsg=err, errmsg=err) ! { dg-error "Redundant ERRMSG" }
   deallocate(i, errmsg=err) ! { dg-warning "useless without a STAT" }
-  deallocate(i, stat=j, errmsg=x) ! { dg-error "must be a scalar CHARACTER" }
+  deallocate(i, stat=j, errmsg=x) ! { dg-error "shall be a scalar default CHARACTER" }
 
   deallocate(err) ! { dg-error "nonprocedure pointer nor an allocatable" }
 
Index: gcc/testsuite/gfortran.dg/dec_parameter_1.f
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/dec_parameter_1.f b/gcc/testsuite/gfortran.dg/dec_parameter_1.f
--- a/gcc/testsuite/gfortran.dg/dec_parameter_1.f	(revision 262353)
+++ b/gcc/testsuite/gfortran.dg/dec_parameter_1.f	(revision 262353)
@@ -22,7 +22,6 @@
           two = 2.0d0
           x = two * pi_1 * f_1 * t
           y = two * pi_2 * f_2 * t
-          z = two * pi_3 * f_3 * t
           return
         end subroutine
 
Index: gcc/testsuite/gfortran.dg/deallocate_error_3.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/deallocate_error_3.f90 b/gcc/testsuite/gfortran.dg/deallocate_error_3.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/deallocate_error_3.f90	(revision 262353)
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! PR fortran/82994
+! Code contributed by Gerhard Steinmetz
+program p
+   type t
+   end type
+   class(t) :: x  ! { dg-error "must be dummy, allocatable or pointer" }
+   deallocate (x) ! { dg-error "not a nonprocedure pointer nor an allocatable" }
+end
Index: gcc/testsuite/gfortran.dg/statement_function_1.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/statement_function_1.f90 b/gcc/testsuite/gfortran.dg/statement_function_1.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/statement_function_1.f90	(revision 262353)
@@ -0,0 +1,24 @@
+! { dg-do compile }
+! PR fortran/84276
+      subroutine stepns(hh, h, s, w)
+      real, intent(inout) :: h, hh, s
+      real, intent(out) :: w
+      real :: qofs
+      integer i
+      qofs(s) = s
+      w = qofs(hh + h)
+      i = 42
+      w = qofs(i)       ! { dg-error "Type mismatch in argument" }
+      end subroutine stepns
+
+      subroutine step(hh, h, s, w)
+      real, intent(inout) :: h, hh, s
+      real, intent(out) :: w
+      real :: qofs
+      integer i
+      qofs(s, i) = i * s
+      i = 42
+      w = qofs(hh, i)
+      w = qofs(i = i, s = hh) ! { dg-error "invalid in a statement function" }
+      end subroutine step
+! { dg-prune-output " Obsolescent feature" }
Index: gcc/testsuite/gfortran.dg/data_substring.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/data_substring.f90 b/gcc/testsuite/gfortran.dg/data_substring.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/data_substring.f90	(revision 262353)
@@ -0,0 +1,6 @@
+! { dg-do compile }
+! PR fortran/30792
+character string*1025
+integer i
+data (string(i:i),i=1,1025)/1025*'?'/  ! { dg-error "Invalid substring" }
+end
Index: gcc/testsuite/gfortran.dg/pr85779_1.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr85779_1.f90 b/gcc/testsuite/gfortran.dg/pr85779_1.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr85779_1.f90	(revision 262353)
@@ -0,0 +1,6 @@
+! { dg-do compile }
+! PR fortran/85779
+type(t) function f() ! { dg-error "is not accessible" }
+   type f            ! { dg-error "already has a basic type" }
+   end type          ! { dg-error "END FUNCTION statement" }
+end
Index: gcc/testsuite/gfortran.dg/dec_parameter_2.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/dec_parameter_2.f90 b/gcc/testsuite/gfortran.dg/dec_parameter_2.f90
--- a/gcc/testsuite/gfortran.dg/dec_parameter_2.f90	(revision 262353)
+++ b/gcc/testsuite/gfortran.dg/dec_parameter_2.f90	(revision 262353)
@@ -21,7 +21,6 @@
   two = 2.0d0
   x = two * pi_1 * f_1 * t
   y = two * pi_2 * f_2 * t
-  z = two * pi_3 * f_3 * t
   return
 end subroutine
 
Index: gcc/testsuite/gfortran.dg/temporary_3.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/temporary_3.f90 b/gcc/testsuite/gfortran.dg/temporary_3.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/temporary_3.f90	(revision 262353)
@@ -0,0 +1,121 @@
+! { dg-do run }
+!
+! Tests the fix for PR68846 in which compiler generated temporaries were
+! receiving the attributes of dummy arguments. This test is the original.
+! The simplified versions by Gerhard Steinmetz are gratefully acknowledged.
+!
+! Contributed by Mirco Valentini  <mirco.valentini@polimi.it>
+!
+MODULE grid
+  IMPLICIT NONE
+  PRIVATE
+  REAL(KIND=8), DIMENSION(100,100), TARGET :: WORKSPACE
+  TYPE, PUBLIC :: grid_t
+    REAL(KIND=8), DIMENSION(:,:), POINTER :: P => NULL ()
+  END TYPE
+  PUBLIC :: INIT
+CONTAINS
+  SUBROUTINE INIT (DAT)
+    IMPLICIT NONE
+    TYPE(grid_t), INTENT(INOUT) :: DAT
+    INTEGER :: I, J
+    DAT%P => WORKSPACE
+    DO I = 1, 100
+      DO J = 1, 100
+        DAT%P(I,J) = REAL ((I-1)*100+J-1)
+      END DO
+    ENDDO
+  END SUBROUTINE INIT
+END MODULE grid
+
+MODULE subgrid
+  USE :: grid, ONLY: grid_t
+  IMPLICIT NONE
+  PRIVATE
+  TYPE, PUBLIC :: subgrid_t
+    INTEGER, DIMENSION(4) :: range
+    CLASS(grid_t), POINTER    :: grd => NULL ()
+  CONTAINS
+    PROCEDURE, PASS :: INIT => LVALUE_INIT
+    PROCEDURE, PASS :: JMP => LVALUE_JMP
+  END TYPE
+CONTAINS
+  SUBROUTINE LVALUE_INIT (HOBJ, P, D)
+    IMPLICIT NONE
+    CLASS(subgrid_t),      INTENT(INOUT) :: HOBJ
+    TYPE(grid_t), POINTER, INTENT(INOUT) :: P
+    INTEGER, DIMENSION(4), INTENT(IN)    :: D
+    HOBJ%range = D
+    HOBJ%grd => P
+  END SUBROUTINE LVALUE_INIT
+
+  FUNCTION LVALUE_JMP(HOBJ, I, J) RESULT(P)
+    IMPLICIT NONE
+    CLASS(subgrid_t), INTENT(INOUT) :: HOBJ
+    INTEGER, INTENT(IN) :: I, J
+    REAL(KIND=8), POINTER :: P
+    P => HOBJ%grd%P(HOBJ%range(1)+I-1, HOBJ%range(3)+J-1)
+  END FUNCTION LVALUE_JMP
+END MODULE subgrid
+
+MODULE geom
+  IMPLICIT NONE
+CONTAINS
+  SUBROUTINE fillgeom_03( subgrid, value  )
+    USE :: subgrid, ONLY: subgrid_t
+    IMPLICIT NONE
+    TYPE(subgrid_T), intent(inout) :: subgrid
+    REAL(kind=8),    intent(in) :: value
+    INTEGER :: I, J
+    DO i = 1, 3
+      DO J = 1, 4
+        subgrid%jmp(i,j) = value ! Dummy argument '_F.DA0' with INTENT(IN)
+                                 ! in pointer association context or ICE
+                                 ! in trans_decl.c, depending on INTENT of
+                                 ! 'VALUE'
+      ENDDO
+    ENDDO
+  END SUBROUTINE fillgeom_03
+END MODULE geom
+
+PROGRAM test_lvalue
+  USE :: grid
+  USE :: subgrid
+  USE :: geom
+  IMPLICIT NONE
+  TYPE(grid_t), POINTER :: GRD => NULL()
+  TYPE(subgrid_t) :: STENCIL
+  REAL(KIND=8), POINTER :: real_tmp_ptr
+  REAL(KIND=8), DIMENSION(10,10), TARGET :: AA
+  REAL(KIND=8), DIMENSION(3,4) :: VAL
+  INTEGER :: I, J, chksum
+  integer, parameter :: r1 = 50
+  integer, parameter :: r2 = 52
+  integer, parameter :: r3 = 50
+  integer, parameter :: r4 = 53
+  DO I = 1, 3
+    DO J = 1, 4
+      VAL(I,J) = dble(I)*dble(J)
+    ENDDO
+  ENDDO
+
+  ALLOCATE (GRD)
+  CALL INIT (GRD)
+  chksum = sum([([((i-1)*100 + j -1, j=1,100)], i = 1,100)])
+  if (int(sum(grd%p)) .ne. chksum) stop 1
+
+  CALL STENCIL%INIT (GRD, [r1, r2, r3, r4])
+  if (.not.associated (stencil%grd, grd)) stop 2
+  if (int(sum(grd%p)) .ne. chksum) stop 3
+
+  CALL fillgeom_03(stencil, 42.0_8)
+  if (any (int (grd%p(r1:r2,r3:r4)) .ne. 42)) stop 4
+
+  chksum = chksum - sum([([((i - 1) * 100 + j -1, j=r3,r4)], i = r1,r2)]) &
+           + (r4 - r3 + 1) * (r2 - r1 +1) * 42
+  if (int(sum(grd%p)) .ne. chksum) stop 5
+
+  deallocate (grd)
+END PROGRAM test_lvalue
+
+
Index: gcc/testsuite/gfortran.dg/coarray_3.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/coarray_3.f90 b/gcc/testsuite/gfortran.dg/coarray_3.f90
--- a/gcc/testsuite/gfortran.dg/coarray_3.f90	(revision 262353)
+++ b/gcc/testsuite/gfortran.dg/coarray_3.f90	(revision 262353)
@@ -13,7 +13,7 @@
 
 sync all (stat=1) ! { dg-error "Syntax error in SYNC ALL" }
 sync all ( stat = n,stat=k) ! { dg-error "Redundant STAT" }
-sync memory (errmsg=str)
+sync memory (errmsg=str) ! { dg-error "must be a scalar CHARACTER variable" }
 sync memory (errmsg=n) ! { dg-error "must be a scalar CHARACTER variable" }
 sync images (*, stat=1.0) ! { dg-error "Syntax error in SYNC IMAGES" }
 sync images (-1) ! { dg-error "must between 1 and num_images" }
Index: gcc/testsuite/gfortran.dg/pr85895.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr85895.f90 b/gcc/testsuite/gfortran.dg/pr85895.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr85895.f90	(revision 262353)
@@ -0,0 +1,17 @@
+! { dg-do compile }
+! { dg-options "-fcoarray=lib" }
+! PR fortran/85895
+subroutine p
+   character(80) :: c(2)
+   sync memory (errmsg=c)        ! { dg-error "scalar CHARACTER variable" }
+end subroutine p
+
+subroutine q
+   character(80) :: c(2)
+   sync memory (errmsg=c(1:2))   ! { dg-error "scalar CHARACTER variable" }
+end subroutine q
+
+subroutine r
+   character(80) :: c(2)
+   sync memory (errmsg=c(1))
+end subroutine r
Index: gcc/testsuite/gfortran.dg/pr85780.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr85780.f90 b/gcc/testsuite/gfortran.dg/pr85780.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr85780.f90	(revision 262353)
@@ -0,0 +1,5 @@
+! { dg-do compile }
+! { dg-options "-std=legacy" }
+! PR fortran/85780
+subroutine s(*) bind(c)
+end
Index: gcc/testsuite/gfortran.dg/pr85138_2.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr85138_2.f90 b/gcc/testsuite/gfortran.dg/pr85138_2.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr85138_2.f90	(revision 262353)
@@ -0,0 +1,32 @@
+! { dg-do compile }
+module fox_m_fsys_format
+  interface len
+    module procedure str_real_dp_len, str_real_dp_fmt_len
+  end interface
+contains
+  pure function str_real_dp_fmt_len(x, fmt) result(n)
+    real, intent(in) :: x
+    character(len=*), intent(in) :: fmt
+    if (.not.checkFmt(fmt)) then
+    endif
+  end function str_real_dp_fmt_len
+  pure function str_real_dp_len(x) result(n)
+    real, intent(in) :: x
+  end function str_real_dp_len
+  pure function str_real_dp_array_len(xa) result(n)
+    real, dimension(:), intent(in) :: xa
+  end function str_real_dp_array_len
+  pure function str_real_dp_array_fmt_len(xa, fmt) result(n)
+    real, dimension(:), intent(in) :: xa
+    character(len=*), intent(in) :: fmt
+  end function str_real_dp_array_fmt_len
+  pure function str_real_dp_fmt(x, fmt) result(s)
+    real, intent(in) :: x
+    character(len=*), intent(in) :: fmt
+    character(len=len(x, fmt)) :: s
+  end function str_real_dp_fmt
+  pure function checkFmt(fmt) result(good)
+    character(len=*), intent(in) :: fmt
+    logical :: good
+  end function checkFmt
+end module fox_m_fsys_format
Index: gcc/testsuite/gfortran.dg/pr63514.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr63514.f90 b/gcc/testsuite/gfortran.dg/pr63514.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr63514.f90	(revision 262353)
@@ -0,0 +1,41 @@
+! { dg-do compile }
+! PR fortran/63514.f90
+program foo
+
+   implicit none
+
+   integer, volatile :: n
+
+   n = 0
+
+   call bar
+   call bah
+
+   contains
+
+   subroutine bar
+      integer k
+      integer, volatile :: m
+      block
+         integer, save :: i
+         integer, volatile :: j
+         i = 42
+         j = 2 * i
+         k = i + j + n
+      end block
+   end subroutine bar
+
+   pure subroutine bah
+      integer k
+      integer, volatile :: m     ! { dg-error "cannot be specified in a PURE" }
+      block
+         integer, save :: i      ! { dg-error "cannot be specified in a PURE" }
+         integer, volatile :: j  ! { dg-error "cannot be specified in a PURE" }
+         i = 42                  ! { dg-error "has no IMPLICIT type" }
+         j = 2 * i               ! { dg-error "has no IMPLICIT type" }
+         k = i + j + n
+      end block
+      m = k * m                  ! { dg-error "has no IMPLICIT type" }
+   end subroutine bah
+
+end program foo
Index: gcc/testsuite/gfortran.dg/pr83939.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr83939.f90 b/gcc/testsuite/gfortran.dg/pr83939.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr83939.f90	(revision 262353)
@@ -0,0 +1,12 @@
+! { dg-do compile }
+elemental function f() result(s) ! { dg-error "shall not have an ALLOCATABLE or POINTER" }
+  allocatable s
+  allocate(s)
+  s = 3.5
+end function
+
+elemental function g() result(s) ! { dg-error "shall not have an ALLOCATABLE or POINTER" }
+  pointer s
+  allocate(s)
+  s = 3.5
+end function
Index: gcc/testsuite/gfortran.dg/pr70870_1.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr70870_1.f90 b/gcc/testsuite/gfortran.dg/pr70870_1.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr70870_1.f90	(revision 262353)
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! PR fortran/70870
+! Contributed by Vittorio Zecca <zeccav at gmail dot com >
+      type t
+       integer :: g=0   ! default initialization
+      end type
+      type(t) :: v2
+      data v2/t(2)/     ! { dg-error "default initialization shall not" }
+      end
Index: gcc/testsuite/gfortran.dg/select_type_42.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/select_type_42.f90 b/gcc/testsuite/gfortran.dg/select_type_42.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/select_type_42.f90	(revision 262353)
@@ -0,0 +1,26 @@
+! { dg-do run }
+!
+! Tests the fix for PR82275.
+! Associating a name with a reduced-dimension section of a
+! multidimensional array precluded subsequent use of the name
+! with the appropriately reduced dimensionality and instead
+! required use of the (invalid) full set of original dimensions.
+!
+! Contributed by Damian Rouson  <damian@sourceryinstitute.org>
+!
+  type component
+   integer :: i
+  end type
+  type container
+    class(component), allocatable :: component_array(:,:)
+  end type
+  type(container) bag
+  type(component) section_copy
+  allocate(bag%component_array, source = reshape ([component(10), component (100)], [1,2]))
+  select type(associate_name=>bag%component_array(1,:))
+    type is (component)
+      section_copy = associate_name(2)  ! gfortran rejected valid
+!      section_copy = associate_name(1,1)! gfortran accepted invalid
+  end select
+  if (section_copy%i .ne. 100) stop 1
+end
Index: gcc/testsuite/gfortran.dg/pr84734.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr84734.f90 b/gcc/testsuite/gfortran.dg/pr84734.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr84734.f90	(revision 262353)
@@ -0,0 +1,4 @@
+! { dg-do compile }
+! PR fortran/84734
+   integer :: b(huge(1_8)+1_8) = 0 ! { dg-error "Arithmetic overflow" }
+   end
Index: gcc/testsuite/gfortran.dg/allocate_alloc_opt_1.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/allocate_alloc_opt_1.f90 b/gcc/testsuite/gfortran.dg/allocate_alloc_opt_1.f90
--- a/gcc/testsuite/gfortran.dg/allocate_alloc_opt_1.f90	(revision 262353)
+++ b/gcc/testsuite/gfortran.dg/allocate_alloc_opt_1.f90	(revision 262353)
@@ -22,7 +22,7 @@
   allocate(i(2))) ! { dg-error "Syntax error in ALLOCATE" }
   allocate(i(2), errmsg=err, errmsg=err) ! { dg-error "Redundant ERRMSG" }
   allocate(i(2), errmsg=err) ! { dg-warning "useless without a STAT" }
-  allocate(i(2), stat=j, errmsg=x) ! { dg-error "must be a scalar CHARACTER" }
+  allocate(i(2), stat=j, errmsg=x) ! { dg-error "shall be a scalar default CHARACTER" }
 
   allocate(err) ! { dg-error "neither a data pointer nor an allocatable" }
 
Index: gcc/testsuite/gfortran.dg/allocate_assumed_charlen_4.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/allocate_assumed_charlen_4.f90 b/gcc/testsuite/gfortran.dg/allocate_assumed_charlen_4.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/allocate_assumed_charlen_4.f90	(revision 262353)
@@ -0,0 +1,39 @@
+! { dg-do run }
+!
+! Test the fix for PR82923, in which an ICE occurred because the
+! character length from 'getchars' scope was being used in the
+! automatic allocation of 'mine'.
+!
+! Contributed by "Werner Blokbuster"  <werner.blokbuster@gmail.com>
+!
+module m
+    implicit none
+contains
+    function getchars(my_len,my_size)
+        integer, intent(in) :: my_len, my_size
+        character(my_len) :: getchars(my_size)
+            getchars = 'A-'
+    end function getchars
+
+    function getchars2(my_len)
+        integer, intent(in) :: my_len
+        character(my_len) :: getchars2
+            getchars2 = 'B--'
+    end function getchars2
+end module m
+
+program testca
+    use m, only: getchars, getchars2
+    implicit none
+    character(:), allocatable :: mine(:)
+    character(:), allocatable :: mine2
+    integer :: i
+
+    ! ICE occured at this line:
+    mine = getchars(2,4)
+    if (any (mine .ne. [('A-', i = 1, 4)])) stop 1
+
+    ! The scalar version was fine and this will keep it so:
+    mine2 = getchars2(3)
+    if (mine2 .ne. 'B--') stop 2
+end program testca
Index: gcc/testsuite/gfortran.dg/realloc_on_assign_30.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/realloc_on_assign_30.f90 b/gcc/testsuite/gfortran.dg/realloc_on_assign_30.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/realloc_on_assign_30.f90	(revision 262353)
@@ -0,0 +1,13 @@
+! { dg-do compile }
+! PR 85641 - this used to ICE due do infinite recursion.
+! Test case by Antony Lewis.
+program tester
+character(LEN=:), allocatable :: fields
+integer j
+character(LEN=4), parameter :: CMB_CL_Fields = 'TEBP'
+
+fields = ''
+j=1
+fields = fields // CMB_CL_Fields(j:j)
+
+end program tester
Index: gcc/testsuite/gfortran.dg/allocate_alloc_opt_14.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/allocate_alloc_opt_14.f90 b/gcc/testsuite/gfortran.dg/allocate_alloc_opt_14.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/allocate_alloc_opt_14.f90	(revision 262353)
@@ -0,0 +1,8 @@
+! { dg-do compile }
+program p
+   integer, allocatable :: arr(:)
+   integer :: stat
+   character(len=128, kind=4) :: errmsg = ' '
+   allocate (arr(3), stat=stat, errmsg=errmsg)  ! { dg-error "shall be a scalar default CHARACTER" }
+   print *, allocated(arr), stat, trim(errmsg)
+end
Index: gcc/testsuite/gfortran.dg/typebound_operator_4.f03
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/typebound_operator_4.f03 b/gcc/testsuite/gfortran.dg/typebound_operator_4.f03
--- a/gcc/testsuite/gfortran.dg/typebound_operator_4.f03	(revision 262353)
+++ b/gcc/testsuite/gfortran.dg/typebound_operator_4.f03	(revision 262353)
@@ -84,6 +84,6 @@
   TYPE(myint) :: x
 
   x = 0 ! { dg-error "Can't convert" }
-  x = x + 42 ! { dg-error "Operands of" }
+  x = x + 42 ! { dg-error "binary intrinsic numeric operator" }
   x = x .PLUS. 5 ! { dg-error "Unknown operator" }
 END PROGRAM main
Index: gcc/testsuite/gfortran.dg/submodule_31.f08
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/submodule_31.f08 b/gcc/testsuite/gfortran.dg/submodule_31.f08
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/submodule_31.f08	(revision 262353)
@@ -0,0 +1,54 @@
+! { dg-do run }
+!
+! Test the fix for PR82814 in which an ICE occurred for the submodule allocation.
+!
+! Contributed by "Werner Blokbuster"  <werner.blokbuster@gmail.com>
+!
+module u
+
+    implicit none
+
+    interface unique
+        module function uniq_char(input) result(uniq)
+            character(*), intent(in) :: input(:)
+            character(size(input)), allocatable :: uniq(:)
+        end function uniq_char
+    end interface unique
+
+contains
+
+    module function uniq2(input) result(uniq)
+        character(*), intent(in) :: input(:)
+        character(size(input)), allocatable :: uniq(:)
+            allocate(uniq(1))
+            uniq = 'A'
+    end function uniq2
+
+end module u
+
+
+submodule (u) z
+
+    implicit none
+
+contains
+
+    module function uniq_char(input) result(uniq)
+        character(*), intent(in) :: input(:)
+        character(size(input)), allocatable :: uniq(:)
+            allocate(uniq(1)) ! This used to ICE
+            uniq = 'A'
+    end function uniq_char
+
+end submodule z
+
+
+program test_uniq
+    use u
+    implicit none
+    character(1), dimension(4) :: chr = ['1','2','1','2']
+
+    write(*,*) unique(chr)
+    write(*,*) uniq2(chr)
+
+end program test_uniq
Index: gcc/testsuite/gfortran.dg/inquire_19.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/inquire_19.f90 b/gcc/testsuite/gfortran.dg/inquire_19.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/inquire_19.f90	(revision 262353)
@@ -0,0 +1,13 @@
+! { dg-do run }
+! PR84506  INQUIRE(pos=) always sets pos=0 with -fdefault-integer-8
+program TestInquire
+   implicit none
+   integer(8) :: iUnit
+   integer(8) :: iPos
+   open(newunit=iunit, file='output.txt', access='stream', status='replace')
+   write(iUnit) 'TEXT'
+   inquire(iUnit, pos=iPos)
+   close(iUnit, status='delete')
+   !print *, iPos
+   if (iPos.ne.5) stop 1
+end program TestInquire
Index: gcc/testsuite/gfortran.dg/char_result_18.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/char_result_18.f90 b/gcc/testsuite/gfortran.dg/char_result_18.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/char_result_18.f90	(revision 262353)
@@ -0,0 +1,10 @@
+! { dg-do compile }
+!
+! Tests the fix for PR80657.
+!
+! Contributed by Vittorio Zecca  <zeccav@gmail.com>
+!
+function f(x)
+implicit character(len(f)) (x) ! { dg-error "Self reference in character length" }
+character(len(x)) f
+end
Index: gcc/testsuite/gfortran.dg/pr86045.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr86045.f90 b/gcc/testsuite/gfortran.dg/pr86045.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr86045.f90	(revision 262353)
@@ -0,0 +1,7 @@
+! { dg-do compile }
+program p
+   logical :: a(2) = (mod([2,3],0) == 0)     ! { dg-error "shall not be zero" }
+   integer :: b = count(mod([2,3],0) == 0)   ! { dg-error "shall not be zero" }
+   integer :: c = all(mod([2,3],0) == 0)     ! { dg-error "shall not be zero" }
+   integer :: d = any(mod([2,3],0) == 0)     ! { dg-error "shall not be zero" }
+end
Index: gcc/testsuite/gfortran.dg/pr78741.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr78741.f90 b/gcc/testsuite/gfortran.dg/pr78741.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr78741.f90	(revision 262353)
@@ -0,0 +1,16 @@
+! { dg-do compile }
+! PR fortran/78741
+! Contributed by Gerhard Steinmetz <gerhard.steinmetz.fortran at t-online.de>
+subroutine s(n, x)
+   integer :: n
+   character(n) :: x
+   character, pointer :: z(:)
+   x = 'a'
+   return
+entry g(n, x)           ! { dg-error "is already defined" }
+   x = 'b'
+contains
+   subroutine g         ! { dg-error "(1)" }
+      z(1) = x(1:1)
+   end
+end
Index: gcc/testsuite/gfortran.dg/coarray_dependency_1.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/coarray_dependency_1.f90 b/gcc/testsuite/gfortran.dg/coarray_dependency_1.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/coarray_dependency_1.f90	(revision 262353)
@@ -0,0 +1,11 @@
+! { dg-do compile }
+! { dg-options "-fcoarray=lib -lcaf_single" }
+!
+! Check that reffing x on both sides of a coarray send does not ICE. 
+! PR 85507
+
+program check_dependency
+  integer :: x[*]
+  x[42] = x
+end program check_dependency
+
Index: gcc/testsuite/gfortran.dg/pr83149.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr83149.f90 b/gcc/testsuite/gfortran.dg/pr83149.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr83149.f90	(revision 262353)
@@ -0,0 +1,14 @@
+! Compiled with pr83149_1.f90
+!
+module mod1
+  integer :: ncells
+end module
+
+module mod2
+contains
+  function get() result(array)
+    use mod1
+    real array(ncells)
+    array = 1.0
+  end function
+end module
Index: gcc/testsuite/gfortran.dg/statement_function_3.f
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/statement_function_3.f b/gcc/testsuite/gfortran.dg/statement_function_3.f
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/statement_function_3.f	(revision 262353)
@@ -0,0 +1,15 @@
+! { dg-do compile }
+! PR fortran/35299
+      subroutine phtod(e,n,i,h)
+      dimension e(n)
+      hstar(e,b)=b**.4*((1.25*fun(-e/40)+.18)) ! { dg-error "must be scalar" }
+      a = 1.
+      h = hstar(e(i-1), a)
+      end
+
+      function fun(a)
+         real a(*)
+         fun = 42
+      end
+! { dg-prune-output " Obsolescent feature" }
+
Index: gcc/testsuite/gfortran.dg/pr85521_2.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr85521_2.f90 b/gcc/testsuite/gfortran.dg/pr85521_2.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr85521_2.f90	(revision 262353)
@@ -0,0 +1,8 @@
+! { dg-do compile }
+! PR fortran/85521
+program p
+   character(3) :: c = 'abc'
+   character(3) :: z(1)
+   z = [ c(:-2) ]
+   print *, z
+end
Index: gcc/testsuite/gfortran.dg/interface_41.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/interface_41.f90 b/gcc/testsuite/gfortran.dg/interface_41.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/interface_41.f90	(revision 262353)
@@ -0,0 +1,19 @@
+! { dg-do compile }
+! PR fortran/85001 
+! Contributed by Gerhard Steinmetz.
+program p
+   type t
+   end type
+   call s
+contains
+   real function f(x)
+      class(t) :: x
+      dimension :: x(:)
+      f = 1.0
+   end
+   subroutine s
+      type(t) :: x(2)
+      real :: z
+      z = f(x)     ! { dg-error "Rank mismatch in argument" }
+   end
+end
Index: gcc/testsuite/gfortran.dg/explicit_shape_1.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/explicit_shape_1.f90 b/gcc/testsuite/gfortran.dg/explicit_shape_1.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/explicit_shape_1.f90	(revision 262353)
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! PR fortran/83633
+! Original testcase by Nathan T. Weeks  <weeks at iastate dot edu>
+!
+integer :: A(command_argument_count()) = 1 ! { dg-error "nonconstant bounds" }
+write (*,*) A
+end
Index: gcc/testsuite/gfortran.dg/unlimited_polymorphic_29.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/unlimited_polymorphic_29.f90 b/gcc/testsuite/gfortran.dg/unlimited_polymorphic_29.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/unlimited_polymorphic_29.f90	(revision 262353)
@@ -0,0 +1,84 @@
+! { dg-do run }
+!
+! Test the fix for PR84546 in which the failing cases would
+! have x%vec = ['foo','b   '].
+!
+! Contributed by Neil Carlson  <neil.n.carlson@gmail.com>
+!
+module any_vector_type
+
+  type :: any_vector
+    class(*), allocatable :: vec(:)
+  end type
+
+  interface any_vector
+    procedure any_vector1
+  end interface
+
+contains
+
+  function any_vector1(vec) result(this)
+    class(*), intent(in) :: vec(:)
+    type(any_vector) :: this
+    allocate(this%vec, source=vec)
+  end function
+
+end module
+
+program main
+
+  use any_vector_type
+  implicit none
+
+  class(*), allocatable :: x
+  character(*), parameter :: vec(2) = ['foo','bar']
+  integer :: vec1(3) = [7,8,9]
+
+  call foo1
+  call foo2
+  call foo3
+  call foo4
+
+contains
+
+  subroutine foo1 ! This always worked
+    allocate (any_vector :: x)
+    select type (x)
+      type is (any_vector)
+        x = any_vector(vec)
+    end select
+    call bar(1)
+    deallocate (x)
+  end
+
+  subroutine foo2 ! Failure found during diagnosis
+    x = any_vector (vec)
+    call bar(2)
+    deallocate (x)
+  end
+
+  subroutine foo3 ! Original failure
+    allocate (x, source = any_vector (vec))
+    call bar(3)
+    deallocate (x)
+  end
+
+  subroutine foo4 ! This always worked
+    allocate (x, source = any_vector (vec1))
+    call bar(4)
+    deallocate (x)
+  end
+
+  subroutine bar (stop_flag)
+    integer :: stop_flag
+    select type (x)
+      type is (any_vector)
+        select type (xvec => x%vec)
+          type is (character(*))
+            if (any(xvec /= vec)) stop stop_flag
+          type is (integer)
+            if (any(xvec /= (vec1))) stop stop_flag
+        end select
+    end select
+  end
+end program
Index: gcc/testsuite/gfortran.dg/coarray/get_to_indexed_array_1.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/coarray/get_to_indexed_array_1.f90 b/gcc/testsuite/gfortran.dg/coarray/get_to_indexed_array_1.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/coarray/get_to_indexed_array_1.f90	(revision 262353)
@@ -0,0 +1,32 @@
+! { dg-do run }
+
+! Test that index vector on lhs of caf-expression works correctly.
+
+program pr81773
+
+  integer, parameter :: ndim = 5
+  integer :: i
+  integer :: vec(ndim) = -1
+  integer :: res(ndim)[*] = [ (i, i=1, ndim) ]
+  type T
+    integer :: padding
+    integer :: dest(ndim)
+    integer :: src(ndim)
+  end type
+
+  type(T) :: dest
+  type(T), allocatable :: caf[:]
+
+  vec([ndim, 3, 1]) = res(1:3)[1]
+  if (any (vec /= [ 3, -1, 2, -1, 1])) stop 1
+
+  dest = T(42, [ ( -1, i = 1, ndim ) ], [ ( i - 2, i = ndim, 1, -1) ] )
+  dest%dest([ 4,3,2 ]) = res(3:5)[1]
+  if (any (dest%dest /= [-1, 5, 4, 3, -1])) stop 2
+
+  vec(:) = -1
+  allocate(caf[*], source = T(42, [ ( -1, i = 1, ndim ) ], [ ( i - 2, i = ndim, 1, -1) ] ))
+  vec([ 5,3,2 ]) = caf[1]%src(2:4)
+  if (any (vec /= [ -1, 0, 1, -1, 2])) stop 3
+end
+
Index: gcc/testsuite/gfortran.dg/coarray/get_to_indirect_array.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/coarray/get_to_indirect_array.f90 b/gcc/testsuite/gfortran.dg/coarray/get_to_indirect_array.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/coarray/get_to_indirect_array.f90	(revision 262353)
@@ -0,0 +1,28 @@
+! { dg-do run }
+!
+! Test that pr81773/fortran is fixed.
+
+program get_to_indexed_array
+
+  integer, parameter :: ndim = 5
+  integer :: i
+  integer :: vec(1:ndim) = 0
+  integer :: indx(1:2) = [3, 2]
+  integer :: mat(1:ndim, 1:ndim) = 0
+  integer :: res(1:ndim)[*]=[ (i, i=1, ndim) ]
+
+  ! No sync needed, because this test always is running on single image
+  vec([ndim , 1]) = res(1:2)[1]
+  if (vec(1) /= res(2) .or. vec(ndim) /= res(1)) then
+    print *,"vec: ", vec, " on image: ", this_image()
+    stop 1
+  end if
+
+  mat(2:3,[indx(:)]) = reshape(res(1:4)[1], [2, 2])
+  if (any(mat(2:3, 3:2:-1) /= reshape(res(1:4), [2,2]))) then
+    print *, "mat: ", mat, " on image: ", this_image()
+    stop 2
+  end if
+end
+
+! vim:ts=2:sts=2:sw=2:
Index: gcc/testsuite/gfortran.dg/assumed_charlen_parameter.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/assumed_charlen_parameter.f90 b/gcc/testsuite/gfortran.dg/assumed_charlen_parameter.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/assumed_charlen_parameter.f90	(revision 262353)
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! PR fortran/82049
+! Original code contributed by John Harper <john dot harper at vuw dot ac dot nz>
+program ice ! f2003
+  implicit none
+  character(*), parameter:: a = 'ice', b = '*'
+  character(*), parameter:: c(2) = [character(len(a)) :: a, b]
+  print "(2A4)",adjustr(c)
+end program ice
Index: gcc/testsuite/gfortran.dg/temporary_2.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/temporary_2.f90 b/gcc/testsuite/gfortran.dg/temporary_2.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/temporary_2.f90	(revision 262353)
@@ -0,0 +1,39 @@
+! { dg-do compile }
+!
+! Tests the fix for PR70864 in which compiler generated temporaries received
+! the attributes of a dummy argument. This is the original testcase.
+! The simplified version by Gerhard Steinmetz is gratefully acknowledged.
+!
+! Contributed by Weiqun Zhang  <weiqun.zhang@gmail.com>
+!
+module boxarray_module
+  implicit none
+  type :: BoxArray
+     integer     :: i = 0
+   contains
+     procedure ::                  boxarray_assign
+     generic   :: assignment(=) => boxarray_assign
+  end type BoxArray
+contains
+  subroutine boxarray_assign (dst, src)
+    class(BoxArray), intent(inout) :: dst
+    type (BoxArray), intent(in   ) :: src
+    dst%i =src%i
+  end subroutine boxarray_assign
+end module boxarray_module
+
+module multifab_module
+  use boxarray_module
+  implicit none
+  type, public   :: MultiFab
+     type(BoxArray) :: ba
+  end type MultiFab
+contains
+  subroutine multifab_swap(mf1, mf2)
+    type(MultiFab), intent(inout) :: mf1, mf2
+    type(MultiFab) :: tmp
+    tmp = mf1
+    mf1 = mf2 ! Generated an ICE in trans-decl.c.
+    mf2 = tmp
+  end subroutine multifab_swap
+end module multifab_module
Index: gcc/testsuite/gfortran.dg/pr85138_1.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr85138_1.f90 b/gcc/testsuite/gfortran.dg/pr85138_1.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr85138_1.f90	(revision 262353)
@@ -0,0 +1,29 @@
+! { dg-do compile }
+module fox_m_fsys_format
+
+  interface len
+     module procedure str_real_sp_len, str_real_sp_fmt_len
+  end interface
+
+contains
+
+  pure function str_real_sp_fmt_len(x, fmt) result(n)
+    real, intent(in) :: x
+    character(len=*), intent(in) :: fmt
+    if (.not.checkFmt(fmt)) then
+    endif
+  end function str_real_sp_fmt_len
+  pure function str_real_sp_len(x) result(n)
+    real, intent(in) :: x
+    n = len(x, "")
+  end function str_real_sp_len
+  pure function str_real_dp_matrix(xa) result(s)
+    real, intent(in) :: xa
+    character(len=len(xa)) :: s
+  end function str_real_dp_matrix
+
+  pure function checkfmt(s) result(a)
+   logical a
+   character(len=*), intent(in) :: s
+  end function checkfmt
+end module fox_m_fsys_format
Index: gcc/testsuite/gfortran.dg/pr83149_b.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr83149_b.f90 b/gcc/testsuite/gfortran.dg/pr83149_b.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr83149_b.f90	(revision 262353)
@@ -0,0 +1,16 @@
+! Compiled with pr83149_a.f90
+! { dg-do run }
+! { dg-options "-fno-whole-file" }
+! { dg-compile-aux-modules "pr83149_a.f90" }
+! { dg-additional-sources pr83149_a.f90 }
+!
+! Contributed by Neil Carlson  <neil.n.carlson@gmail.com>
+!
+  use mod
+  string = 'fubar'
+  select case (get_string())
+    case ('fubar')
+    case default
+      stop 1
+  end select
+end
Index: gcc/testsuite/gfortran.dg/pr70409.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr70409.f90 b/gcc/testsuite/gfortran.dg/pr70409.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr70409.f90	(revision 262353)
@@ -0,0 +1,23 @@
+! { dg-do run }
+! PR fortran/70409
+! Contriubted by Harald Anlauf  <anlauf at gmx dot de>
+program foo
+  integer, parameter :: huge_1 = huge(0_1)
+  character(    huge_1      ), parameter :: x = 'abc'
+  character(    huge(0_1)   ), parameter :: y = 'abc'
+  character(    huge(0_1)+0 ), parameter :: z = 'abcdef'
+  character(    huge(0_1)   )            :: a = 'abc'
+  integer, parameter :: huge_2 = huge(0_2)
+  character(    huge_2      ), parameter :: u = 'abc'
+  character(    huge(0_2)   ), parameter :: v = 'abc'
+  character(int(huge(0_2),4)), parameter :: w = 'abcdef'
+  character(    huge(0_2)   )            :: b = 'abc'
+  if (len(x) /= huge_1) stop 1
+  if (len(y) /= huge_1) stop 2
+  if (len(z) /= huge_1) stop 3
+  if (len(a) /= huge_1) stop 4
+  if (len(u) /= huge_2) stop 5
+  if (len(v) /= huge_2) stop 6
+  if (len(w) /= huge_2) stop 7
+  if (len(b) /= huge_2) stop 8
+end program foo
Index: gcc/testsuite/gfortran.dg/coarray_46.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/coarray_46.f90 b/gcc/testsuite/gfortran.dg/coarray_46.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/coarray_46.f90	(revision 262353)
@@ -0,0 +1,17 @@
+! { dg-do compile }
+! { dg-options "-fcoarray=lib -lcaf_single" }
+!
+! Test the fix for PR83319
+!
+module foo_module
+  implicit none
+  type foo
+    integer, allocatable :: i(:)
+  end type
+end module
+
+  use foo_module
+  implicit none
+  type(foo), save :: bar[*]
+  allocate(bar%i(1))     ! Used to ICE here.
+end
Index: gcc/testsuite/gfortran.dg/pr77414.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr77414.f90 b/gcc/testsuite/gfortran.dg/pr77414.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr77414.f90	(revision 262353)
@@ -0,0 +1,9 @@
+! { dg-do compile }
+! PR fortran/77414
+subroutine a(x)               ! { dg-error "(1)" }
+   character(*) :: x
+   contains
+      subroutine a(x)         ! { dg-error " is already defined at" }
+         character(*) :: x
+      end subroutine a
+end subroutine a
Index: gcc/testsuite/gfortran.dg/associate_30.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/associate_30.f90 b/gcc/testsuite/gfortran.dg/associate_30.f90
--- a/gcc/testsuite/gfortran.dg/associate_30.f90	(revision 262353)
+++ b/gcc/testsuite/gfortran.dg/associate_30.f90	(revision 262353)
@@ -8,8 +8,3 @@
       associate (x => null())   ! { dg-error "cannot be NULL()" }
       end associate
    end subroutine
-
-   subroutine s2
-      associate (x => [null()]) ! { dg-error "has no type" }
-      end associate
-   end subroutine
Index: gcc/testsuite/gfortran.dg/implied_do_2.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/implied_do_2.f90 b/gcc/testsuite/gfortran.dg/implied_do_2.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/implied_do_2.f90	(revision 262353)
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! PR fortran/56667
+program error_message
+   implicit none
+   integer :: ir
+   write(*,*) ( ir, ir = 1,10    ! { dg-error "Expected a right parenthesis" }
+end program error_message 
Index: gcc/testsuite/gfortran.dg/pr67803.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr67803.f90 b/gcc/testsuite/gfortran.dg/pr67803.f90
--- a/gcc/testsuite/gfortran.dg/pr67803.f90	(revision 262353)
+++ b/gcc/testsuite/gfortran.dg/pr67803.f90	(revision 262353)
@@ -10,5 +10,4 @@
   x = '0' // [character :: 1d1]     ! { dg-error "Incompatible typespec for" }
   x = '0' // [character :: (0.,1.)] ! { dg-error "Incompatible typespec for" }
   x = '0' // [character :: .true.]  ! { dg-error "Incompatible typespec for" }
-  x = '0' // [character :: null()]  ! { dg-error "Incompatible typespec for" }
 end
Index: gcc/testsuite/gfortran.dg/select_type_41.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/select_type_41.f90 b/gcc/testsuite/gfortran.dg/select_type_41.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/select_type_41.f90	(revision 262353)
@@ -0,0 +1,30 @@
+! { dg-do compile }
+! { dg-options "-O2" }
+!
+! Tests the fix for PR80965 in which the use of the name 'loc'
+! for the dummy argument of 'xyz' caused an ICE. If the module
+! was used, the error "DUMMY attribute conflicts with INTRINSIC
+! attribute in ‘loc’ at (1)" was emitted. Note that although 'loc'
+! is a GNU extension and so can be over-ridden, this is not very
+! good practice.
+!
+! Contributed by David Sagan  <david.sagan@gmail.com>
+!
+module mode3_mod
+contains
+  subroutine xyz (loc)
+    implicit none
+    class(*) :: loc
+    real x(6)
+    integer ix_use
+    select type (loc)
+      type is (integer)
+        x = 0
+        print *, "integer"
+      type is (real)
+        ix_use = 0
+        print *, "real"
+    end select
+  end subroutine xyz
+end module mode3_mod
+
Index: gcc/testsuite/gfortran.dg/init_flag_17.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/init_flag_17.f90 b/gcc/testsuite/gfortran.dg/init_flag_17.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/init_flag_17.f90	(revision 262353)
@@ -0,0 +1,28 @@
+! { dg-do compile }
+! { dg-options "-finit-derived -finit-local-zero -fdump-tree-original" }
+!
+! PR fortran/82972
+!
+! Make sure we do not ICE when generating initializers for c_ptr and c_funptr
+! components of derived types (and make sure they are properly initialized to
+! zero).
+!
+
+program init_flag_17
+  use iso_c_binding
+  implicit none
+
+  type :: ty
+    type(c_ptr)    :: ptr  ! = c_null_ptr
+    type(c_funptr) :: fptr ! = c_null_funptr
+  end type
+
+  type(ty) :: t
+
+  print *, t%ptr
+  print *, t%fptr
+
+end program
+
+! { dg-final { scan-tree-dump "\.ptr=0" "original" } }
+! { dg-final { scan-tree-dump "\.fptr=0" "original" } }
Index: gcc/testsuite/gfortran.dg/coarray_lib_comm_1.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/coarray_lib_comm_1.f90 b/gcc/testsuite/gfortran.dg/coarray_lib_comm_1.f90
--- a/gcc/testsuite/gfortran.dg/coarray_lib_comm_1.f90	(revision 262353)
+++ b/gcc/testsuite/gfortran.dg/coarray_lib_comm_1.f90	(revision 262353)
@@ -38,9 +38,8 @@
 if (any (A-B /= 0)) call abort
 end
 
-! { dg-final { scan-tree-dump-times "_gfortran_caf_get \\\(caf_token.0, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) a, 1, &parm.\[0-9\]+, 0B, &parm.\[0-9\]+, 4, 4, 0, 0B\\\);" 1 "original" } }
-! { dg-final { scan-tree-dump-times "_gfortran_caf_get \\\(caf_token.0, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) a, 1, &parm.\[0-9\]+, 0B, &parm.\[0-9\]+, 4, 4, 1, 0B\\\);" 1 "original" } }
+! { dg-final { scan-tree-dump-times "_gfortran_caf_get \\\(caf_token.0, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) a, 1, &parm.\[0-9\]+, 0B, &parm.\[0-9\]+, 4, 4, 1, 0B\\\);" 2 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_get \\\(caf_token.0, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) a, 1, &parm.\[0-9\]+, 0B, &p, 4, 4, 1, 0B\\\);" 1 "original" } }
 ! { dg-final { scan-tree-dump-times "_gfortran_caf_get \\\(caf_token.1, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) b, 1, &parm.\[0-9\]+, 0B, &p, 4, 4, 0, 0B\\\);" 1 "original" } }
-! { dg-final { scan-tree-dump-times "_gfortran_caf_sendget \\\(caf_token.0, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) a, 1, &parm.\[0-9\]+, 0B, caf_token.0, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) a, 1, &parm.\[0-9\]+, 0B, 4, 4, 0, 0B\\\);" 1 "original" } }
+! { dg-final { scan-tree-dump-times "_gfortran_caf_sendget \\\(caf_token.0, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) a, 1, &parm.\[0-9\]+, 0B, caf_token.0, \\\(integer\\\(kind=\[48\]\\\)\\\) parm.\[0-9\]+.data - \\\(integer\\\(kind=\[48\]\\\)\\\) a, 1, &parm.\[0-9\]+, 0B, 4, 4, 1, 0B\\\);" 1 "original" } }
 
Index: gcc/testsuite/gfortran.dg/data_bounds_1.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/data_bounds_1.f90 b/gcc/testsuite/gfortran.dg/data_bounds_1.f90
--- a/gcc/testsuite/gfortran.dg/data_bounds_1.f90	(revision 262353)
+++ b/gcc/testsuite/gfortran.dg/data_bounds_1.f90	(revision 262353)
@@ -1,4 +1,5 @@
 ! { dg-do compile }
+! { dg-options "-std=gnu" }
 ! Checks the fix for PR32315, in which the bounds checks below were not being done.
 !
 ! Contributed by Tobias Burnus <burnus@gcc.gnu.org>
Index: gcc/testsuite/gfortran.dg/inquire_18.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/inquire_18.f90 b/gcc/testsuite/gfortran.dg/inquire_18.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/inquire_18.f90	(revision 262353)
@@ -0,0 +1,11 @@
+! { dg-do run }
+! PR84412 Wrong "Inquire statement identifies an internal file" error 
+program bug
+  implicit none
+  integer          :: i
+  character(len=1) :: s
+  write (s,'(i1)') 0
+  open(newUnit=i,file='inquire_18.txt',status='unknown')
+  inquire(unit=i)
+  close(i, status="delete")
+end program bug
Index: gcc/testsuite/gfortran.dg/pr64124.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr64124.f90 b/gcc/testsuite/gfortran.dg/pr64124.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr64124.f90	(revision 262353)
@@ -0,0 +1,5 @@
+! { dg-do compile }
+! PR fortran/64124.f90
+  character(len=kind(1)) x
+  integer(len(x)) y
+  end
Index: gcc/testsuite/gfortran.dg/data_char_1.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/data_char_1.f90 b/gcc/testsuite/gfortran.dg/data_char_1.f90
--- a/gcc/testsuite/gfortran.dg/data_char_1.f90	(revision 262353)
+++ b/gcc/testsuite/gfortran.dg/data_char_1.f90	(revision 262353)
@@ -1,4 +1,5 @@
 ! { dg-do run }
+! { dg-options "-std=gnu" }
 ! Test character variables in data statements
 ! Also substrings of character variables.
 ! PR14976 PR16228 
Index: gcc/testsuite/gfortran.dg/pr86110.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.dg/pr86110.f90 b/gcc/testsuite/gfortran.dg/pr86110.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.dg/pr86110.f90	(revision 262353)
@@ -0,0 +1,7 @@
+! { dg-do compile }
+! PR fortran/86110
+program p
+   character(:), allocatable :: x, y
+   x = 'abc'
+   y = [x(:)]  ! { dg-error "Incompatible ranks 0 and 1" }
+end
Index: gcc/testsuite/gcc.c-torture/execute/pr86231.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr86231.c b/gcc/testsuite/gcc.c-torture/execute/pr86231.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/execute/pr86231.c	(revision 262353)
@@ -0,0 +1,30 @@
+/* PR tree-optimization/86231 */
+
+#define ONE ((void *) 1)
+#define TWO ((void *) 2)
+
+__attribute__((noinline, noclone)) int
+foo (void *p, int x)
+{
+  if (p == ONE) return 0;
+  if (!p)
+    p = x ? TWO : ONE;
+  return p == ONE ? 0 : 1;
+}
+
+int v[8];
+
+int
+main ()
+{
+  if (foo ((void *) 0, 0) != 0
+      || foo ((void *) 0, 1) != 1
+      || foo (ONE, 0) != 0
+      || foo (ONE, 1) != 0
+      || foo (TWO, 0) != 1
+      || foo (TWO, 1) != 1
+      || foo (&v[7], 0) != 1
+      || foo (&v[7], 1) != 1)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr85529-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr85529-2.c b/gcc/testsuite/gcc.c-torture/execute/pr85529-2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/execute/pr85529-2.c	(revision 262353)
@@ -0,0 +1,25 @@
+/* PR tree-optimization/85529 */
+
+__attribute__((noinline, noclone)) int
+foo (int x)
+{
+  x &= 63;
+  x -= 50;
+  x |= 1;
+  if (x < 0)
+    return 1;
+  int y = x >> 2;
+  if (x >= y)
+    return 1;
+  return 0;
+}
+
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 63; i++)
+    if (foo (i) != 1)
+      __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/20180131-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/execute/20180131-1.c b/gcc/testsuite/gcc.c-torture/execute/20180131-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/execute/20180131-1.c	(revision 262353)
@@ -0,0 +1,28 @@
+/* PR rtl-optimization/84071 */
+/* Reported by Wilco <wilco@gcc.gnu.org> */
+
+extern void abort (void);
+
+typedef union 
+{
+  signed short ss;
+  unsigned short us;
+  int x;
+} U;
+
+int f(int x, int y, int z, int a, U u) __attribute__((noclone, noinline));
+
+int f(int x, int y, int z, int a, U u)
+{
+  return (u.ss <= 0) + u.us;
+}
+
+int main (void)
+{
+  U u = { .ss = -1 };
+
+  if (f (0, 0, 0, 0, u) != (1 << sizeof (short) * 8))
+    abort ();
+
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr82210.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr82210.c b/gcc/testsuite/gcc.c-torture/execute/pr82210.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/execute/pr82210.c	(revision 262353)
@@ -0,0 +1,26 @@
+/* PR c/82210 */
+
+void
+foo (int size)
+{
+  int i;
+  struct S {
+    __attribute__((aligned (16))) struct T { short c; } a[size];
+    int b[size];
+  } s;
+
+  for (i = 0; i < size; i++)
+    s.a[i].c = 0x1234;
+  for (i = 0; i < size; i++)
+    s.b[i] = 0;
+  for (i = 0; i < size; i++)
+    if (s.a[i].c != 0x1234 || s.b[i] != 0)
+      __builtin_abort ();
+}
+
+int
+main ()
+{
+  foo (15);
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr84524.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr84524.c b/gcc/testsuite/gcc.c-torture/execute/pr84524.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/execute/pr84524.c	(revision 262353)
@@ -0,0 +1,41 @@
+/* PR target/84524 */
+
+__attribute__((noinline,noclone)) void
+foo (unsigned short *x)
+{
+  unsigned short i, v;
+  unsigned char j;
+  for (i = 0; i < 256; i++)
+    {
+      v = i << 8;
+      for (j = 0; j < 8; j++)
+	if (v & 0x8000)
+	  v = (v << 1) ^ 0x1021;
+	else
+	  v = v << 1;
+      x[i] = v;
+    }
+}
+
+int
+main ()
+{
+  unsigned short a[256];
+
+  foo (a);
+  for (int i = 0; i < 256; i++)
+    {
+      unsigned short v = i << 8;
+      for (int j = 0; j < 8; j++)
+	{
+	  asm volatile ("" : "+r" (v));
+	  if (v & 0x8000)
+	    v = (v << 1) ^ 0x1021;
+	  else
+	    v = v << 1;
+	}
+      if (a[i] != v)
+	__builtin_abort ();
+    }
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr85095.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr85095.c b/gcc/testsuite/gcc.c-torture/execute/pr85095.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/execute/pr85095.c	(revision 262353)
@@ -0,0 +1,52 @@
+/* PR target/85095 */
+
+__attribute__((noinline, noclone)) unsigned long
+f1 (unsigned long a, unsigned long b)
+{
+  unsigned long i = __builtin_add_overflow (a, b, &a);
+  return a + i;
+}
+
+__attribute__((noinline, noclone)) unsigned long
+f2 (unsigned long a, unsigned long b)
+{
+  unsigned long i = __builtin_add_overflow (a, b, &a);
+  return a - i;
+}
+
+__attribute__((noinline, noclone)) unsigned long
+f3 (unsigned int a, unsigned int b)
+{
+  unsigned int i = __builtin_add_overflow (a, b, &a);
+  return a + i;
+}
+
+__attribute__((noinline, noclone)) unsigned long
+f4 (unsigned int a, unsigned int b)
+{
+  unsigned int i = __builtin_add_overflow (a, b, &a);
+  return a - i;
+}
+
+int
+main ()
+{
+  if (f1 (16UL, -18UL) != -2UL
+      || f1 (16UL, -17UL) != -1UL
+      || f1 (16UL, -16UL) != 1UL
+      || f1 (16UL, -15UL) != 2UL
+      || f2 (24UL, -26UL) != -2UL
+      || f2 (24UL, -25UL) != -1UL
+      || f2 (24UL, -24UL) != -1UL
+      || f2 (24UL, -23UL) != 0UL
+      || f3 (32U, -34U) != -2U
+      || f3 (32U, -33U) != -1U
+      || f3 (32U, -32U) != 1U
+      || f3 (32U, -31U) != 2U
+      || f4 (35U, -37U) != -2U
+      || f4 (35U, -36U) != -1U
+      || f4 (35U, -35U) != -1U
+      || f4 (35U, -34U) != 0U)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr84748.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr84748.c b/gcc/testsuite/gcc.c-torture/execute/pr84748.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/execute/pr84748.c	(revision 262353)
@@ -0,0 +1,34 @@
+/* { dg-require-effective-target int128 } */
+
+typedef unsigned __int128 u128;
+
+int a, c, d;
+u128 b;
+
+unsigned long long g0, g1;
+
+void
+store (unsigned long long a0, unsigned long long a1)
+{
+  g0 = a0;
+  g1 = a1;
+}
+
+void
+foo (void)
+{
+  b += a;
+  c = d != 84347;
+  b /= c;
+  u128 x = b;
+  store (x >> 0, x >> 64);
+}
+
+int
+main (void)
+{
+  foo ();
+  if (g0 != 0 || g1 != 0)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr85529-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/execute/pr85529-1.c b/gcc/testsuite/gcc.c-torture/execute/pr85529-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/execute/pr85529-1.c	(revision 262353)
@@ -0,0 +1,28 @@
+/* PR tree-optimization/85529 */
+
+struct S { int a; };
+
+int b, c = 1, d, e, f;
+static int g;
+volatile struct S s;
+
+signed char
+foo (signed char i, int j)
+{
+  return i < 0 ? i : i << j;
+}
+
+int
+main ()
+{
+  signed char k = -83;
+  if (!d)
+    goto L;
+  k = e || f;
+L:
+  for (; b < 1; b++)
+    s.a != (k < foo (k, 2) && (c = k = g));
+  if (c != 1)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/20180226-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/execute/20180226-1.c b/gcc/testsuite/gcc.c-torture/execute/20180226-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/execute/20180226-1.c	(revision 262353)
@@ -0,0 +1,31 @@
+/* PR rtl-optimization/83496 */
+/* Reported by Hauke Mehrtens <gcc@hauke-m.de> */
+
+extern void abort (void);
+
+typedef unsigned long mp_digit;
+
+typedef struct { int used, alloc, sign; mp_digit *dp; } mp_int;
+
+int mytest(mp_int *a, mp_digit b) __attribute__((noclone, noinline));
+
+int mytest(mp_int *a, mp_digit b)
+{
+  if (a->sign == 1)
+    return -1;
+  if (a->used > 1)
+    return 1;
+  if (a->dp[0] > b)
+    return 1;
+  if (a->dp[0] < b)
+    return -1;
+  return 0;
+}
+
+int main (void)
+{
+  mp_int i = { 2, 0, -1 };
+  if (mytest (&i, 0) != 1)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/unsorted/dump-noaddr.x
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/unsorted/dump-noaddr.x b/gcc/testsuite/gcc.c-torture/unsorted/dump-noaddr.x
--- a/gcc/testsuite/gcc.c-torture/unsorted/dump-noaddr.x	(revision 262353)
+++ b/gcc/testsuite/gcc.c-torture/unsorted/dump-noaddr.x	(revision 262353)
@@ -9,14 +9,14 @@
 
     # loop through all the options
     foreach option $option_list {
-	file delete -force dump1
-	file mkdir dump1
+	file delete -force $tmpdir/dump1
+	file mkdir $tmpdir/dump1
 	c-torture-compile $src "$option $options -dumpbase dump1/$dumpbase -DMASK=1 -x c --param ggc-min-heapsize=1 -fdump-ipa-all -fdump-rtl-all -fdump-tree-all -fdump-noaddr"
-	file delete -force dump2
-	file mkdir dump2
+	file delete -force $tmpdir/dump2
+	file mkdir $tmpdir/dump2
 	c-torture-compile $src "$option $options -dumpbase dump2/$dumpbase -DMASK=2 -x c -fdump-ipa-all -fdump-rtl-all -fdump-tree-all -fdump-noaddr"
-	foreach dump1 [lsort [glob -nocomplain dump1/*]] {
-	    regsub dump1/ $dump1 dump2/ dump2
+	foreach dump1 [lsort [glob -nocomplain $tmpdir/dump1/*]] {
+	    set dump2 "$tmpdir/dump2/[file tail $dump1]"
 	    set dumptail "gcc.c-torture/unsorted/[file tail $dump1]"
 	    regsub {\.\d+((t|r|i)\.[^.]+)$} $dumptail {.*\1} dumptail
 	    set tmp [ diff "$dump1" "$dump2" ]
@@ -29,8 +29,8 @@
 	    }
 	}
     }
-    file delete -force dump1
-    file delete -force dump2
+    file delete -force $tmpdir/dump1
+    file delete -force $tmpdir/dump2
 }
 
 dump_compare $src $options
Index: gcc/testsuite/gcc.c-torture/compile/pr85945.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr85945.c b/gcc/testsuite/gcc.c-torture/compile/pr85945.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/compile/pr85945.c	(revision 262353)
@@ -0,0 +1,16 @@
+/* PR target/85945 */
+
+typedef float V __attribute__((vector_size(16)));
+union U { V v; float f[4]; };
+int f;
+float g[4];
+
+void
+foo (void)
+{
+  V d;
+  union U i;
+  i.v = d;
+  for (f = 0; f < 4; f++)
+    g[f] = i.f[f];
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr84860.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr84860.c b/gcc/testsuite/gcc.c-torture/compile/pr84860.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/compile/pr84860.c	(revision 262353)
@@ -0,0 +1,11 @@
+/* PR target/84860 */
+
+void
+foo (int x, int y)
+{
+  while (x < 1)
+    {
+      x = y;
+      y = ((float)1 / 0) ? 2 : 0;
+    }
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr82096.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr82096.c b/gcc/testsuite/gcc.c-torture/compile/pr82096.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/compile/pr82096.c	(revision 262353)
@@ -0,0 +1,11 @@
+/* { dg-require-effective-target arm_arch_v5t_ok { target arm*-*-* } } */
+/* { dg-skip-if "Do not combine float-abi values" { arm*-*-* } { "-mfloat-abi=*" } { "-mfloat-abi=soft" } } */
+/* { dg-additional-options "-march=armv5t -mthumb -mfloat-abi=soft" { target arm*-*-* } } */
+
+static long long AL[24];
+
+int
+check_ok (void)
+{
+  return (__sync_bool_compare_and_swap (AL+1, 0x200000003ll, 0x1234567890ll));
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr84425.c
===================================================================
diff --git a/gcc/testsuite/gcc.c-torture/compile/pr84425.c b/gcc/testsuite/gcc.c-torture/compile/pr84425.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.c-torture/compile/pr84425.c	(revision 262353)
@@ -0,0 +1,17 @@
+/* PR ipa/84425 */
+
+void bar (int);
+
+void
+foo (int x)
+{
+  if (x < 5)
+    bar (x);
+}
+
+__attribute__((optimize(0))) void
+bar (int x)
+{
+  if (x > 10)
+    foo (x);
+}
Index: gcc/testsuite/gnat.dg/dispatch1.adb
===================================================================
diff --git a/gcc/testsuite/gnat.dg/dispatch1.adb b/gcc/testsuite/gnat.dg/dispatch1.adb
deleted file mode 10644
--- a/gcc/testsuite/gnat.dg/dispatch1.adb	(revision 262353)
+++ /dev/null	(nonexistent)
@@ -1,9 +0,0 @@
--- { dg-do run }
-
-with dispatch1_p; use dispatch1_p;
-procedure dispatch1 is
-   O   : DT_I1;
-   Ptr : access I1'Class;
-begin
-   Ptr := new I1'Class'(I1'Class (O));
-end;
Index: gcc/testsuite/gnat.dg/generic_dispatch_p.adb
===================================================================
diff --git a/gcc/testsuite/gnat.dg/generic_dispatch_p.adb b/gcc/testsuite/gnat.dg/generic_dispatch_p.adb
deleted file mode 10644
--- a/gcc/testsuite/gnat.dg/generic_dispatch_p.adb	(revision 262353)
+++ /dev/null	(nonexistent)
@@ -1,7 +0,0 @@
-package body generic_dispatch_p is
-   function Constructor (I : not null access Integer) return DT is
-      R : DT; 
-  begin
-      return R;
-   end Constructor;
-end;
Index: gcc/testsuite/gnat.dg/generic_dispatch_p.ads
===================================================================
diff --git a/gcc/testsuite/gnat.dg/generic_dispatch_p.ads b/gcc/testsuite/gnat.dg/generic_dispatch_p.ads
deleted file mode 10644
--- a/gcc/testsuite/gnat.dg/generic_dispatch_p.ads	(revision 262353)
+++ /dev/null	(nonexistent)
@@ -1,13 +0,0 @@
-with Ada.Tags.Generic_Dispatching_Constructor;
-package generic_dispatch_p is
-   type Iface is interface;
-   function Constructor (I : not null access Integer) return Iface is abstract;
-   function Dispatching_Constructor
-      is new Ada.Tags.Generic_Dispatching_Constructor
-               (T           => Iface,
-                Parameters  => Integer,
-                Constructor => Constructor);
-   type DT is new Iface with null record; 
-   overriding
-   function Constructor (I : not null access Integer) return DT;
-end;
Index: gcc/testsuite/gnat.dg/dispatch1_p.ads
===================================================================
diff --git a/gcc/testsuite/gnat.dg/dispatch1_p.ads b/gcc/testsuite/gnat.dg/dispatch1_p.ads
deleted file mode 10644
--- a/gcc/testsuite/gnat.dg/dispatch1_p.ads	(revision 262353)
+++ /dev/null	(nonexistent)
@@ -1,4 +0,0 @@
-package dispatch1_p is
-   type I1 is interface;
-   type DT_I1 is new I1 with null record;
-end;
Index: gcc/testsuite/gnat.dg/dispatch2.adb
===================================================================
diff --git a/gcc/testsuite/gnat.dg/dispatch2.adb b/gcc/testsuite/gnat.dg/dispatch2.adb
deleted file mode 10644
--- a/gcc/testsuite/gnat.dg/dispatch2.adb	(revision 262353)
+++ /dev/null	(nonexistent)
@@ -1,10 +0,0 @@
---  { dg-do run }
-
-with dispatch2_p; use dispatch2_p;
-procedure dispatch2 is
-   Obj : Object_Ptr := new Object;
-begin
-   if Obj.Get_Ptr /= Obj.Impl_Of then
-      raise Program_Error;
-   end if;
-end;
Index: gcc/testsuite/gnat.dg/generic_dispatch.adb
===================================================================
diff --git a/gcc/testsuite/gnat.dg/generic_dispatch.adb b/gcc/testsuite/gnat.dg/generic_dispatch.adb
deleted file mode 10644
--- a/gcc/testsuite/gnat.dg/generic_dispatch.adb	(revision 262353)
+++ /dev/null	(nonexistent)
@@ -1,9 +0,0 @@
---  { dg-do run }
-
-with generic_dispatch_p; use generic_dispatch_p;
-procedure generic_dispatch is
-   I : aliased Integer := 0;
-   D : Iface'Class := Dispatching_Constructor (DT'Tag, I'access);
-begin   
-   null;   
-end generic_dispatch;
Index: gcc/testsuite/gnat.dg/dispatch2_p.adb
===================================================================
diff --git a/gcc/testsuite/gnat.dg/dispatch2_p.adb b/gcc/testsuite/gnat.dg/dispatch2_p.adb
deleted file mode 10644
--- a/gcc/testsuite/gnat.dg/dispatch2_p.adb	(revision 262353)
+++ /dev/null	(nonexistent)
@@ -1,7 +0,0 @@
---
-package body dispatch2_p is
-  function Impl_Of (Self : access Object) return Object_Ptr is
-  begin
-    return Object_Ptr (Self);
-  end Impl_Of;
-end;
Index: gcc/testsuite/gnat.dg/dispatch2_p.ads
===================================================================
diff --git a/gcc/testsuite/gnat.dg/dispatch2_p.ads b/gcc/testsuite/gnat.dg/dispatch2_p.ads
deleted file mode 10644
--- a/gcc/testsuite/gnat.dg/dispatch2_p.ads	(revision 262353)
+++ /dev/null	(nonexistent)
@@ -1,8 +0,0 @@
-package dispatch2_p is
-  type Object     is tagged null record;
-  type Object_Ptr is access all Object'CLASS;
---
-  function Impl_Of (Self : access Object) return Object_Ptr;
-  function Get_Ptr (Self : access Object) return Object_Ptr
-    renames Impl_Of;
-end;
Index: gcc/testsuite/gnat.dg/discr53_pkg.ads
===================================================================
diff --git a/gcc/testsuite/gnat.dg/discr53_pkg.ads b/gcc/testsuite/gnat.dg/discr53_pkg.ads
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/discr53_pkg.ads	(revision 262353)
@@ -0,0 +1,5 @@
+package Discr53_Pkg is
+
+  function Max return Natural;
+
+end Discr53_Pkg;
Index: gcc/testsuite/gnat.dg/generic_disp.adb
===================================================================
diff --git a/gcc/testsuite/gnat.dg/generic_disp.adb b/gcc/testsuite/gnat.dg/generic_disp.adb
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/generic_disp.adb	(revision 262353)
@@ -0,0 +1,10 @@
+--  { dg-do run }
+
+with Generic_Disp_Pkg; use Generic_Disp_Pkg;
+
+procedure Generic_Disp is
+   I : aliased Integer := 0;
+   D : Iface'Class := Dispatching_Constructor (DT'Tag, I'access);
+begin   
+   null;   
+end Generic_Disp;
Index: gcc/testsuite/gnat.dg/prot3_pkg.adb
===================================================================
diff --git a/gcc/testsuite/gnat.dg/prot3_pkg.adb b/gcc/testsuite/gnat.dg/prot3_pkg.adb
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/prot3_pkg.adb	(revision 262353)
@@ -0,0 +1,17 @@
+package body Prot3_Pkg is
+   
+   protected body Prot is
+      function Fn (J : Short_Integer) return Rec
+      is
+      begin
+	 return (V1 => J * J,
+		 V2 => J);
+      end;
+      
+      procedure Foo (J : Short_Integer) is
+      begin
+	 Val := Fn (J);
+      end;
+   end Prot;
+   
+end Prot3_Pkg;
Index: gcc/testsuite/gnat.dg/prot3_pkg.ads
===================================================================
diff --git a/gcc/testsuite/gnat.dg/prot3_pkg.ads b/gcc/testsuite/gnat.dg/prot3_pkg.ads
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/prot3_pkg.ads	(revision 262353)
@@ -0,0 +1,16 @@
+package Prot3_Pkg is
+   
+   type Rec is record
+      V1 : Short_Integer;
+      V2 : Short_Integer;
+   end record with Volatile_Full_Access;
+   
+   protected type Prot is
+      procedure Foo (J : Short_Integer);
+   private
+      Val : Rec;
+   end Prot;
+   
+   P : Prot;
+   
+end Prot3_Pkg;
Index: gcc/testsuite/gnat.dg/disp1.adb
===================================================================
diff --git a/gcc/testsuite/gnat.dg/disp1.adb b/gcc/testsuite/gnat.dg/disp1.adb
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/disp1.adb	(revision 262353)
@@ -0,0 +1,10 @@
+-- { dg-do run }
+
+with Disp1_Pkg; use Disp1_Pkg;
+
+procedure Disp1 is
+   O   : DT_I1;
+   Ptr : access I1'Class;
+begin
+   Ptr := new I1'Class'(I1'Class (O));
+end;
Index: gcc/testsuite/gnat.dg/generic_disp_pkg.adb
===================================================================
diff --git a/gcc/testsuite/gnat.dg/generic_disp_pkg.adb b/gcc/testsuite/gnat.dg/generic_disp_pkg.adb
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/generic_disp_pkg.adb	(revision 262353)
@@ -0,0 +1,9 @@
+package body Generic_Disp_Pkg is
+
+   function Constructor (I : not null access Integer) return DT is
+      R : DT; 
+   begin
+      return R;
+   end Constructor;
+
+end Generic_Disp_Pkg;
Index: gcc/testsuite/gnat.dg/object_overflow1.adb
===================================================================
diff --git a/gcc/testsuite/gnat.dg/object_overflow1.adb b/gcc/testsuite/gnat.dg/object_overflow1.adb
--- a/gcc/testsuite/gnat.dg/object_overflow1.adb	(revision 262353)
+++ b/gcc/testsuite/gnat.dg/object_overflow1.adb	(revision 262353)
@@ -1,10 +1,12 @@
 -- { dg-do compile }
 
+with Interfaces.C; use Interfaces.C;
+
 procedure Object_Overflow1 is
 
   procedure Proc (x : Boolean) is begin null; end;
 
-  type Arr is array(Long_Integer) of Boolean;
+  type Arr is array(ptrdiff_t) of Boolean;
   Obj : Arr; -- { dg-warning "Storage_Error" }
 
 begin
Index: gcc/testsuite/gnat.dg/generic_disp_pkg.ads
===================================================================
diff --git a/gcc/testsuite/gnat.dg/generic_disp_pkg.ads b/gcc/testsuite/gnat.dg/generic_disp_pkg.ads
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/generic_disp_pkg.ads	(revision 262353)
@@ -0,0 +1,14 @@
+with Ada.Tags.Generic_Dispatching_Constructor;
+
+package Generic_Disp_Pkg is
+   type Iface is interface;
+   function Constructor (I : not null access Integer) return Iface is abstract;
+   function Dispatching_Constructor
+      is new Ada.Tags.Generic_Dispatching_Constructor
+               (T           => Iface,
+                Parameters  => Integer,
+                Constructor => Constructor);
+   type DT is new Iface with null record; 
+   overriding
+   function Constructor (I : not null access Integer) return DT;
+end Generic_Disp_Pkg;
Index: gcc/testsuite/gnat.dg/prot3.adb
===================================================================
diff --git a/gcc/testsuite/gnat.dg/prot3.adb b/gcc/testsuite/gnat.dg/prot3.adb
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/prot3.adb	(revision 262353)
@@ -0,0 +1,8 @@
+--  { dg-do run }
+
+with Prot3_Pkg; use Prot3_Pkg;
+
+procedure Prot3 is
+begin
+   P.Foo (4);
+end;
Index: gcc/testsuite/gnat.dg/disp2.adb
===================================================================
diff --git a/gcc/testsuite/gnat.dg/disp2.adb b/gcc/testsuite/gnat.dg/disp2.adb
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/disp2.adb	(revision 262353)
@@ -0,0 +1,11 @@
+--  { dg-do run }
+
+with Disp2_Pkg; use Disp2_Pkg;
+
+procedure Disp2 is
+   Obj : Object_Ptr := new Object;
+begin
+   if Obj.Get_Ptr /= Obj.Impl_Of then
+      raise Program_Error;
+   end if;
+end;
Index: gcc/testsuite/gnat.dg/object_overflow2.adb
===================================================================
diff --git a/gcc/testsuite/gnat.dg/object_overflow2.adb b/gcc/testsuite/gnat.dg/object_overflow2.adb
--- a/gcc/testsuite/gnat.dg/object_overflow2.adb	(revision 262353)
+++ b/gcc/testsuite/gnat.dg/object_overflow2.adb	(revision 262353)
@@ -1,10 +1,12 @@
 -- { dg-do compile }
 
+with Interfaces.C; use Interfaces.C;
+
 procedure Object_Overflow2 is
 
   procedure Proc (x : Boolean) is begin null; end;
 
-  type Arr is array(0 .. Long_Integer'Last) of Boolean;
+  type Arr is array(0 .. ptrdiff_t'Last) of Boolean;
   Obj : Arr; -- { dg-warning "Storage_Error" }
 
 begin
Index: gcc/testsuite/gnat.dg/object_overflow3.adb
===================================================================
diff --git a/gcc/testsuite/gnat.dg/object_overflow3.adb b/gcc/testsuite/gnat.dg/object_overflow3.adb
--- a/gcc/testsuite/gnat.dg/object_overflow3.adb	(revision 262353)
+++ b/gcc/testsuite/gnat.dg/object_overflow3.adb	(revision 262353)
@@ -1,10 +1,12 @@
 -- { dg-do compile }
 
+with Interfaces.C; use Interfaces.C;
+
 procedure Object_Overflow3 is
 
   procedure Proc (x : Boolean) is begin null; end;
 
-  type Arr is array(0 .. Long_Integer'Last) of Boolean;
+  type Arr is array(0 .. ptrdiff_t'Last) of Boolean;
 
   type Rec is record
     A : Arr;
Index: gcc/testsuite/gnat.dg/object_overflow4.adb
===================================================================
diff --git a/gcc/testsuite/gnat.dg/object_overflow4.adb b/gcc/testsuite/gnat.dg/object_overflow4.adb
--- a/gcc/testsuite/gnat.dg/object_overflow4.adb	(revision 262353)
+++ b/gcc/testsuite/gnat.dg/object_overflow4.adb	(revision 262353)
@@ -1,14 +1,16 @@
 -- { dg-do compile }
 
+with Interfaces.C; use Interfaces.C;
+
 procedure Object_Overflow4 is
 
   procedure Proc (x : Integer) is begin null; end;
 
-  type Index is new Long_Integer range 0 .. Long_Integer'Last;
+  type Index_T is new ptrdiff_t range 0 .. ptrdiff_t'Last;
 
-  type Arr is array(Index range <>) of Integer;
+  type Arr is array(Index_T range <>) of Integer;
 
-  type Rec (Size: Index := 6) is record -- { dg-warning "Storage_Error" }
+  type Rec (Size: Index_T := 6) is record -- { dg-warning "Storage_Error" }
     A: Arr (0..Size);
   end record;
 
Index: gcc/testsuite/gnat.dg/object_overflow5.adb
===================================================================
diff --git a/gcc/testsuite/gnat.dg/object_overflow5.adb b/gcc/testsuite/gnat.dg/object_overflow5.adb
--- a/gcc/testsuite/gnat.dg/object_overflow5.adb	(revision 262353)
+++ b/gcc/testsuite/gnat.dg/object_overflow5.adb	(revision 262353)
@@ -1,14 +1,16 @@
 -- { dg-do compile }
 
+with Interfaces.C; use Interfaces.C;
+
 procedure Object_Overflow5 is
 
   procedure Proc (c : Character) is begin null; end;
 
-  type Index is new Long_Integer range 0 .. Long_Integer'Last;
+  type Index_T is new ptrdiff_t range 0 .. ptrdiff_t'Last;
 
-  type Arr is array(Index range <>) of Character;
+  type Arr is array(Index_T range <>) of Character;
 
-  type Rec (Size: Index := 6) is record -- { dg-warning "Storage_Error" }
+  type Rec (Size: Index_T := 6) is record -- { dg-warning "Storage_Error" }
     A: Arr (0..Size);
   end record;
 
Index: gcc/testsuite/gnat.dg/array11.adb
===================================================================
diff --git a/gcc/testsuite/gnat.dg/array11.adb b/gcc/testsuite/gnat.dg/array11.adb
--- a/gcc/testsuite/gnat.dg/array11.adb	(revision 262353)
+++ b/gcc/testsuite/gnat.dg/array11.adb	(revision 262353)
@@ -1,15 +1,17 @@
 -- { dg-do compile }
 
+with System;
+
 procedure Array11 is
 
   type Rec is null record;
-  type Ptr is access all Rec;
+  type Index_T is mod System.Memory_Size;
 
-  type Arr1 is array (1..8) of aliased Rec; -- { dg-warning "padded" }
-  type Arr2 is array (Long_Integer) of aliased Rec; -- { dg-warning "padded" }
+  type Arr1 is array (1 .. 8) of aliased Rec; -- { dg-warning "padded" }
+  type Arr2 is array (Index_T) of aliased Rec; -- { dg-warning "padded" }
 
   A1 : Arr1;
-  A2 : Arr2; -- { dg-warning "Storage_Error" }
+  A2 : Arr2;
 
 begin
   null;
Index: gcc/testsuite/gnat.dg/aggr24_pkg.adb
===================================================================
diff --git a/gcc/testsuite/gnat.dg/aggr24_pkg.adb b/gcc/testsuite/gnat.dg/aggr24_pkg.adb
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/aggr24_pkg.adb	(revision 262353)
@@ -0,0 +1,15 @@
+package body Aggr24_Pkg is
+
+   procedure Init (R : out Rec) is
+   begin
+      R := (I1 => 0,
+            I2 => 0,
+            I3 => 0,
+            I4 => 0,
+            I5 => 0,
+            I6 => 0,
+            I7 => 0,
+            S => <>);
+   end;
+   
+end Aggr24_Pkg;
Index: gcc/testsuite/gnat.dg/aggr24_pkg.ads
===================================================================
diff --git a/gcc/testsuite/gnat.dg/aggr24_pkg.ads b/gcc/testsuite/gnat.dg/aggr24_pkg.ads
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/aggr24_pkg.ads	(revision 262353)
@@ -0,0 +1,16 @@
+package Aggr24_Pkg is
+
+   type Rec is record
+      I1 : Integer;
+      I2 : Integer;
+      I3 : Integer;
+      I4 : Integer;
+      I5 : Integer;
+      I6 : Integer;
+      I7 : Integer;
+      S : String (1 .. 5);
+   end record;
+
+   procedure Init (R : out Rec);
+
+end Aggr24_Pkg;
Index: gcc/testsuite/gnat.dg/disp1_pkg.ads
===================================================================
diff --git a/gcc/testsuite/gnat.dg/disp1_pkg.ads b/gcc/testsuite/gnat.dg/disp1_pkg.ads
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/disp1_pkg.ads	(revision 262353)
@@ -0,0 +1,6 @@
+package Disp1_Pkg is
+
+   type I1 is interface;
+   type DT_I1 is new I1 with null record;
+
+end Disp1_Pkg;
Index: gcc/testsuite/gnat.dg/aggr24.adb
===================================================================
diff --git a/gcc/testsuite/gnat.dg/aggr24.adb b/gcc/testsuite/gnat.dg/aggr24.adb
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/aggr24.adb	(revision 262353)
@@ -0,0 +1,13 @@
+-- { dg-do run }
+
+with Aggr24_Pkg; use Aggr24_Pkg;
+
+procedure Aggr24 is
+  V : Rec;
+begin
+  V.S := "Hello";
+  Init (V);
+  if V.S /= "Hello" then
+    raise Program_Error;
+  end if;
+end;
Index: gcc/testsuite/gnat.dg/disp2_pkg.adb
===================================================================
diff --git a/gcc/testsuite/gnat.dg/disp2_pkg.adb b/gcc/testsuite/gnat.dg/disp2_pkg.adb
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/disp2_pkg.adb	(revision 262353)
@@ -0,0 +1,8 @@
+package body Disp2_Pkg is
+
+  function Impl_Of (Self : access Object) return Object_Ptr is
+  begin
+    return Object_Ptr (Self);
+  end Impl_Of;
+
+end Disp2_Pkg;
Index: gcc/testsuite/gnat.dg/disp2_pkg.ads
===================================================================
diff --git a/gcc/testsuite/gnat.dg/disp2_pkg.ads b/gcc/testsuite/gnat.dg/disp2_pkg.ads
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/disp2_pkg.ads	(revision 262353)
@@ -0,0 +1,11 @@
+package Disp2_Pkg is
+
+  type Object     is tagged null record;
+  type Object_Ptr is access all Object'CLASS;
+
+  function Impl_Of (Self : access Object) return Object_Ptr;
+  function Get_Ptr (Self : access Object) return Object_Ptr
+    renames Impl_Of;
+
+end Disp2_Pkg;
+
Index: gcc/testsuite/gnat.dg/discr53.adb
===================================================================
diff --git a/gcc/testsuite/gnat.dg/discr53.adb b/gcc/testsuite/gnat.dg/discr53.adb
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/discr53.adb	(revision 262353)
@@ -0,0 +1,19 @@
+--  { dg-do compile }
+
+package body Discr53 is
+
+   function F return Rec is
+      Data : Rec;
+   begin
+      return Data;
+   end;
+
+   type Ptr is access Rec;
+
+   procedure Proc is
+      Local : Ptr;
+   begin
+      Local := new Rec'(F);
+   end;
+
+end Discr53;
Index: gcc/testsuite/gnat.dg/discr53.ads
===================================================================
diff --git a/gcc/testsuite/gnat.dg/discr53.ads b/gcc/testsuite/gnat.dg/discr53.ads
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/discr53.ads	(revision 262353)
@@ -0,0 +1,16 @@
+with Discr53_Pkg;
+
+package Discr53 is
+
+   type Rec (D : Boolean := False) is record
+      case D is
+         when True  => S : String (1 .. Discr53_Pkg.Max);
+         when False => null;
+      end case;
+   end record;
+
+   function F return Rec;
+
+   procedure Proc;
+
+end Discr53;
Index: gcc/testsuite/gnat.dg/null_pointer_deref1.adb
===================================================================
diff --git a/gcc/testsuite/gnat.dg/null_pointer_deref1.adb b/gcc/testsuite/gnat.dg/null_pointer_deref1.adb
--- a/gcc/testsuite/gnat.dg/null_pointer_deref1.adb	(revision 262353)
+++ b/gcc/testsuite/gnat.dg/null_pointer_deref1.adb	(revision 262353)
@@ -17,5 +17,5 @@
 begin
    Data.all := 1;
 exception
-   when Constraint_Error | Storage_Error => null;
+   when others => null;
 end;
Index: gcc/testsuite/gnat.dg/specs/opt3.ads
===================================================================
diff --git a/gcc/testsuite/gnat.dg/specs/opt3.ads b/gcc/testsuite/gnat.dg/specs/opt3.ads
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/specs/opt3.ads	(revision 262353)
@@ -0,0 +1,13 @@
+-- { dg-do compile }
+-- { dg-options "-O3" }
+
+with Ada.Containers.Vectors;
+with Opt3_Pkg;
+
+package Opt3 is
+
+  type Arr is array (1 .. Opt3_Pkg.Max) of Integer;
+
+  package Arr_Container is new Ada.Containers.Vectors (Natural, Arr);
+
+end Opt3;
Index: gcc/testsuite/gnat.dg/specs/opt3_pkg.ads
===================================================================
diff --git a/gcc/testsuite/gnat.dg/specs/opt3_pkg.ads b/gcc/testsuite/gnat.dg/specs/opt3_pkg.ads
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gnat.dg/specs/opt3_pkg.ads	(revision 262353)
@@ -0,0 +1,7 @@
+-- { dg-excess-errors "no code generated" }
+
+package Opt3_Pkg is
+
+  function Max return Natural;
+
+end Opt3_Pkg;
Index: gcc/testsuite/gnat.dg/null_pointer_deref2.adb
===================================================================
diff --git a/gcc/testsuite/gnat.dg/null_pointer_deref2.adb b/gcc/testsuite/gnat.dg/null_pointer_deref2.adb
--- a/gcc/testsuite/gnat.dg/null_pointer_deref2.adb	(revision 262353)
+++ b/gcc/testsuite/gnat.dg/null_pointer_deref2.adb	(revision 262353)
@@ -20,7 +20,7 @@
    begin
       Data.all := 1;
    exception
-      when Constraint_Error | Storage_Error => null;
+      when others => null;
    end T;
 
 begin
Index: gcc/testsuite/gcc.dg/Walloc-size-larger-than-5.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-5.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-5.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-5.c	(revision 262353)
@@ -0,0 +1,25 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-options "-O -Walloc-size-larger-than=1MB -ftrack-macro-expansion=0" } */
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  __SIZE_TYPE__ n = 0;
+  T (__builtin_malloc (n));
+
+  n = 1000 * 1000;   /* 1 megabyte (MB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1000001. exceeds maximum object size 1000000" } */
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size 1000000" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size 1000000" } */
+}
Index: gcc/testsuite/gcc.dg/pr83985.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr83985.c b/gcc/testsuite/gcc.dg/pr83985.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr83985.c	(revision 262353)
@@ -0,0 +1,25 @@
+/* PR rtl-optimization/83985 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+/* { dg-additional-options "-mcpu=e300c3 -mtune=e300c3" { target { powerpc*-*-* && ilp32 } } } */
+
+long long int v;
+
+void
+foo (int x)
+{
+  if (x == 0)
+    return;
+
+  while (v < 2)
+    {
+      signed char *a;
+      v /= x;
+      a = v == 0 ? (signed char *) &x : (signed char *) &v;
+      ++*a;
+      ++v;
+    }
+
+  while (1)
+    ;
+}
Index: gcc/testsuite/gcc.dg/Walloc-size-larger-than-10.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-10.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-10.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-10.c	(revision 262353)
@@ -0,0 +1,27 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile { target lp64 } }
+   { dg-options "-O -Walloc-size-larger-than=1PiB -ftrack-macro-expansion=0" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  size_t n = 0;
+  T (__builtin_malloc (n));
+
+  n = (size_t)1024 * 1024 * 1024 * 1024 * 1024;   /* 1 pebibyte (PiB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1125899906842625. exceeds maximum object size 1125899906842624" } */
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+}
Index: gcc/testsuite/gcc.dg/Walloc-size-larger-than-9.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-9.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-9.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-9.c	(revision 262353)
@@ -0,0 +1,27 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile { target lp64 } }
+   { dg-options "-O -Walloc-size-larger-than=1TB -ftrack-macro-expansion=0" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  size_t n = 0;
+  T (__builtin_malloc (n));
+
+  n = (size_t)1000 * 1000 * 1000 * 1000;   /* 1 terabyte (TB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1000000000001. exceeds maximum object size 1000000000000" } */
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+}
Index: gcc/testsuite/gcc.dg/Walloc-size-larger-than-14.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-14.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-14.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-14.c	(revision 262353)
@@ -0,0 +1,30 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-options "-O -Walloc-size-larger-than=123456789123456789123456789123456789 -ftrack-macro-expansion=0" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+/* Verify that an exceedingly large -Walloc-size-larger-than argument
+   with no suffix is accepted and treated as infinite.  */
+
+void f (void)
+{
+  size_t n = 0;
+  T (__builtin_malloc (n));
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));
+
+  n = __SIZE_MAX__ - 1;
+  T (__builtin_malloc (n));
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));
+}
Index: gcc/testsuite/gcc.dg/pr84628.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr84628.c b/gcc/testsuite/gcc.dg/pr84628.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr84628.c	(revision 262353)
@@ -0,0 +1,8 @@
+/* PR ipa/84628 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+int f0 (void);
+__attribute__((error ("err"))) void f1 (void) { f0 (); f0 (); }
+__attribute__((error ("err"))) void f2 (void) { f0 (); f0 (); }
+/* { dg-bogus "declared with attribute error" "" { target *-*-* } 0 } */
Index: gcc/testsuite/gcc.dg/pr84853.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr84853.c b/gcc/testsuite/gcc.dg/pr84853.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr84853.c	(revision 262353)
@@ -0,0 +1,19 @@
+/* PR c/84853 */
+/* { dg-do compile } */
+
+typedef float V __attribute__((__vector_size__ (16)));
+typedef int W __attribute__((__vector_size__ (16)));
+
+void
+foo (int x, V *y, V *z, W *w)
+{
+  *y = *y << x;		/* { dg-error "invalid operands to binary <<" } */
+  *z = *z << *w;	/* { dg-error "invalid operands to binary <<" } */
+}
+
+void
+bar (int x, V *y, V *z, W *w)
+{
+  *y = *y >> x;		/* { dg-error "invalid operands to binary >>" } */
+  *z = *z >> *w;	/* { dg-error "invalid operands to binary >>" } */
+}
Index: gcc/testsuite/gcc.dg/Walloc-size-larger-than-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-2.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-2.c	(revision 262353)
@@ -0,0 +1,20 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-options "-O -Walloc-size-larger-than=1KiB -ftrack-macro-expansion=0" }
+*/
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  unsigned n = 0;
+  T (__builtin_malloc (n));
+
+  n = 1024;   /* 1 kibibyte (KB or KiB) */
+  T (__builtin_malloc (n));
+
+  n = 1025;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1025. exceeds maximum object size 1024" } */
+}
Index: gcc/testsuite/gcc.dg/cpp/trad/pr69869.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/cpp/trad/pr69869.c b/gcc/testsuite/gcc.dg/cpp/trad/pr69869.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/cpp/trad/pr69869.c	(revision 262353)
@@ -0,0 +1,8 @@
+/* PR preprocessor/69869 */
+/* { dg-do preprocess } */
+/* { dg-options "-traditional-cpp" } */
+
+#define C(a,b)a/**/b
+C (foo/,**/)
+C (foo/,*)
+/* { dg-error "unterminated comment" "" {target "*-*-*"} .-1 } */
Index: gcc/testsuite/gcc.dg/pr83605.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr83605.c b/gcc/testsuite/gcc.dg/pr83605.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr83605.c	(revision 262353)
@@ -0,0 +1,20 @@
+/* PR tree-optimization/83605 */
+/* { dg-do compile } */
+/* { dg-options "-O1 -ftrapv -fexceptions -fnon-call-exceptions" } */
+
+int a;
+
+int
+foo (int x)
+{
+  int b = a;
+  {
+    int c;
+    int *d = (x == 0) ? &c : &b;
+
+    for (a = 0; a < 2; ++a)
+      c = (x + b) < a;
+
+    return *d;
+  }
+}
Index: gcc/testsuite/gcc.dg/pr85430.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr85430.c b/gcc/testsuite/gcc.dg/pr85430.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr85430.c	(revision 262353)
@@ -0,0 +1,12 @@
+/* PR target/85430 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fno-tree-ccp -fno-tree-fre" } */
+
+typedef char V __attribute__((vector_size (4)));
+
+V
+foo (V v)
+{
+  v[(V){}[0]] <<= 1;
+  return v;
+}
Index: gcc/testsuite/gcc.dg/rtl/x86_64/final.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/rtl/x86_64/final.c b/gcc/testsuite/gcc.dg/rtl/x86_64/final.c
--- a/gcc/testsuite/gcc.dg/rtl/x86_64/final.c	(revision 262353)
+++ b/gcc/testsuite/gcc.dg/rtl/x86_64/final.c	(revision 262353)
@@ -1,5 +1,5 @@
 /* { dg-do compile { target { { i?86-*-* x86_64-*-* } && lp64 } } } */
-/* { dg-options "-fdump-rtl-final" } */
+/* { dg-options "-fdwarf2-cfi-asm -fdump-rtl-final" } */
 
 /* Lightly-modified dump of test.c.304r.dwarf2 for x86_64 target,
    with various NOTE_INSN_CFI deleted by hand for now.  */
Index: gcc/testsuite/gcc.dg/pr84875.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr84875.c b/gcc/testsuite/gcc.dg/pr84875.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr84875.c	(revision 262353)
@@ -0,0 +1,28 @@
+/* PR debug/84875 */
+/* { dg-do compile } */
+/* { dg-options "-Os" } */
+/* { dg-additional-options "-fpie" { target pie } } */
+/* { dg-additional-options "-march=z196" { target s390*-*-* } } */
+
+static long *a[100];
+static int b[100];
+long *c;
+int d;
+void foo (long *);
+
+void
+bar ()
+{
+  long *g = c;
+  g--;
+  d = *g;
+  if (d)
+    if (b[d] < 8)
+      {
+	*(void **)g = a[d];
+	a[d] = g;
+	b[d]++;
+	return;
+      }
+  foo (g);
+}
Index: gcc/testsuite/gcc.dg/Walloc-size-larger-than-6.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-6.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-6.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-6.c	(revision 262353)
@@ -0,0 +1,25 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-options "-O -Walloc-size-larger-than=1GiB -ftrack-macro-expansion=0" } */
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  __SIZE_TYPE__ n = 0;
+  T (__builtin_malloc (n));
+
+  n = 1024 * 1024 * 1024;   /* 1 gigibyte (GiB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1073741825. exceeds maximum object size 1073741824" } */
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+}
Index: gcc/testsuite/gcc.dg/pr83986.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr83986.c b/gcc/testsuite/gcc.dg/pr83986.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr83986.c	(revision 262353)
@@ -0,0 +1,14 @@
+/* PR rtl-optimization/83986 */
+/* { dg-do compile } */
+/* { dg-options "-g -O2 -fsched2-use-superblocks -funwind-tables --param max-pending-list-length=1" } */
+
+int v;
+
+int
+foo (int x)
+{
+  v &= !!v && !!x;
+  if (v != 0)
+    foo (0);
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/debug/dwarf2/prod-options.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/debug/dwarf2/prod-options.c b/gcc/testsuite/gcc.dg/debug/dwarf2/prod-options.c
--- a/gcc/testsuite/gcc.dg/debug/dwarf2/prod-options.c	(revision 262353)
+++ b/gcc/testsuite/gcc.dg/debug/dwarf2/prod-options.c	(revision 262353)
@@ -3,9 +3,8 @@
    the build not reproducible.  Other skipped options could be tested here
    as well.  */
 /* { dg-do compile } */
-/* { dg-options "-O2 -gdwarf -dA -fdebug-prefix-map=a=b" } */
-/* { dg-final { scan-assembler "DW_AT_producer: \"GNU C" { target { { { ! *-*-solaris2* } || gas } && { { ! hppa*64*-*-* } && { ! powerpc-ibm-aix* } } } } } } */
-/* { dg-final { scan-assembler "\"GNU C\[^\\n\\r\]+ DW_AT_producer" { target { { *-*-solaris2* && { ! gas } } || { hppa*64*-*-* } } } } } */
+/* { dg-options "-O2 -gdwarf -dA -fno-merge-debug-strings -fdebug-prefix-map=a=b" } */
+/* { dg-final { scan-assembler "\"GNU C\[^\\n\\r\]+ DW_AT_producer" } } */
 /* { dg-final { scan-assembler-not "debug-prefix-map" } } */
 
 void func (void)
Index: gcc/testsuite/gcc.dg/debug/pr85252.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/debug/pr85252.c b/gcc/testsuite/gcc.dg/debug/pr85252.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/debug/pr85252.c	(revision 262353)
@@ -0,0 +1,11 @@
+/* PR debug/85252 */
+/* { dg-do compile } */
+
+void
+foo (void)
+{
+  static char a[0] = "";
+  static char b[0] = "b";	/* { dg-warning "initializer-string for array of chars is too long" } */
+  static char c[1] = "c";
+  static char d[1] = "de";	/* { dg-warning "initializer-string for array of chars is too long" } */
+}
Index: gcc/testsuite/gcc.dg/Walloc-size-larger-than-11.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-11.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-11.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-11.c	(revision 262353)
@@ -0,0 +1,27 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile { target lp64 } }
+   { dg-options "-O -Walloc-size-larger-than=1PB -ftrack-macro-expansion=0" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  size_t n = 0;
+  T (__builtin_malloc (n));
+
+  n = (size_t)1000 * 1000 * 1000 * 1000 * 1000;   /* 1 petabyte (PB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1000000000000001. exceeds maximum object size 1000000000000000" } */
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+}
Index: gcc/testsuite/gcc.dg/pr84607.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr84607.c b/gcc/testsuite/gcc.dg/pr84607.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr84607.c	(revision 262353)
@@ -0,0 +1,16 @@
+/* { dg-do run } */
+
+extern void exit(int);
+extern void abort(void);
+int a[10];
+int foo()
+{
+  exit (0);
+  return 0;
+}
+int main()
+{
+  if (&a[foo()])
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr82916.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr82916.c b/gcc/testsuite/gcc.dg/pr82916.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr82916.c	(revision 262353)
@@ -0,0 +1,47 @@
+/* PR bootstrap/82916 */
+/* { dg-do run } */
+/* { dg-options "-O2 -fno-tree-dse" } */
+
+struct A { struct A *next; };
+struct C
+{
+  int *of;
+  struct C *parent, *prev, *next;
+  int depth;
+  int min;
+  struct C *min_occ;
+};
+
+__attribute__((noinline, noclone)) struct C *
+foo (int *node)
+{
+  struct A *p = __builtin_malloc (sizeof (struct C));
+  if (!p)
+    return 0;
+  p->next = 0;
+  /* Originally placement new.  */
+  struct C *nw = (struct C *)(void *)p;
+  nw->of = node;
+  nw->parent = 0;
+  nw->prev = 0;
+  nw->next = 0;
+  nw->depth = 0;
+  nw->min_occ = nw;
+  nw->min = 0;
+  return nw;
+}
+
+int
+main ()
+{
+  int o;
+  struct C *p = foo (&o);
+  if (p)
+    {
+      if (p->of != &o || p->parent || p->prev || p->next || p->depth
+	  || p->min || p->min_occ != p)
+	__builtin_abort ();
+    }
+  __builtin_free (p);
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/Walloc-size-larger-than-15.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-15.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-15.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-15.c	(revision 262353)
@@ -0,0 +1,30 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-options "-O -Walloc-size-larger-than=123456789123456789123456789123456789gb -ftrack-macro-expansion=0" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+/* Verify that an exceeingly large -Walloc-size-larger-than argument
+   with a valid suffic is accepted and treated as infinite.  */
+
+void f (void)
+{
+  size_t n = 0;
+  T (__builtin_malloc (n));
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));
+
+  n = __SIZE_MAX__ - 1;
+  T (__builtin_malloc (n));
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));
+}
Index: gcc/testsuite/gcc.dg/ubsan/bounds-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/ubsan/bounds-3.c b/gcc/testsuite/gcc.dg/ubsan/bounds-3.c
--- a/gcc/testsuite/gcc.dg/ubsan/bounds-3.c	(revision 262353)
+++ b/gcc/testsuite/gcc.dg/ubsan/bounds-3.c	(revision 262353)
@@ -1,6 +1,7 @@
 /* PR sanitizer/70875 */
 /* { dg-do run } */
-/* { dg-options "-fsanitize=bounds" } */
+/* { dg-options "-fsanitize=bounds -fno-sanitize-recover=bounds" } */
+/* { dg-shouldfail "ubsan" } */
 
 int
 foo (int n, int k)
Index: gcc/testsuite/gcc.dg/pr81228.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr81228.c b/gcc/testsuite/gcc.dg/pr81228.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr81228.c	(revision 262353)
@@ -0,0 +1,21 @@
+/* PR target/81228.  */
+/* { dg-do compile } */
+/* { dg-options "-O3 -fdump-tree-ssa" } */
+
+void *a;
+
+void b ()
+{
+  char c;
+  long d;
+  char *e = a;
+  for (; d; d++)
+  {
+    double f, g;
+    c = g < f || g > f;
+    e[d] = c;
+  }
+}
+
+/* Let's make sure we do have a LTGT.  */
+/* { dg-final { scan-tree-dump "<>" "ssa" } } */
Index: gcc/testsuite/gcc.dg/pr85300.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr85300.c b/gcc/testsuite/gcc.dg/pr85300.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr85300.c	(revision 262353)
@@ -0,0 +1,16 @@
+/* PR rtl-optimization/85300 */
+/* { dg-do compile } */
+/* { dg-options "-O1 -g -funroll-all-loops -fno-tree-ter -fno-web" } */
+
+void
+foo (double x, unsigned char y)
+{
+  while ((int) x < 1)
+    {
+      float a;
+
+      a = y | 0x100;
+      y = 0;
+      x = a;
+    }
+}
Index: gcc/testsuite/gcc.dg/pr85529.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr85529.c b/gcc/testsuite/gcc.dg/pr85529.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr85529.c	(revision 262353)
@@ -0,0 +1,27 @@
+/* PR tree-optimization/85529 */
+/* { dg-do run } */
+/* { dg-options "-O2 -fno-ssa-phiopt" } */
+
+__attribute__((noinline, noclone)) int
+foo (int x)
+{
+  x &= 31;
+  x -= 25;
+  x *= 2;
+  if (x < 0)
+    return 1;
+  int y = x >> 2;
+  if (x >= y)
+    return 1;
+  return 0;
+}
+
+int
+main ()
+{
+  int i;
+  for (i = 0; i < 63; i++)
+    if (foo (i) != 1)
+      __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/pr84941.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr84941.c b/gcc/testsuite/gcc.dg/pr84941.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr84941.c	(revision 262353)
@@ -0,0 +1,10 @@
+/* PR inline-asm/84941 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void
+foo (void)
+{
+  short *b[1] = { 0 };
+  asm volatile ("" : "=m,m" (b), "=r,r" (b) : "1,p" (b));
+}
Index: gcc/testsuite/gcc.dg/Walloc-size-larger-than.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than.c	(revision 262353)
@@ -0,0 +1,13 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-options "-Walloc-size-larger-than=0 -ftrack-macro-expansion=0" } */
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  T (__builtin_malloc (0));
+  T (__builtin_malloc (1));   /* { dg-warning "argument 1 value .1. exceeds maximum object size 0" } */
+}
Index: gcc/testsuite/gcc.dg/Walloc-size-larger-than-3.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-3.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-3.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-3.c	(revision 262353)
@@ -0,0 +1,19 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-options "-O -Walloc-size-larger-than=1kB -ftrack-macro-expansion=0" } */
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  unsigned n = 0;
+  T (__builtin_malloc (n));
+
+  n = 1000;   /* 1 kilobyte (kB, not to be confused with KB or KiB) */
+  T (__builtin_malloc (n));
+
+  n = 1001;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1001. exceeds maximum object size 1000" } */
+}
Index: gcc/testsuite/gcc.dg/pr84956.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr84956.c b/gcc/testsuite/gcc.dg/pr84956.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr84956.c	(revision 262353)
@@ -0,0 +1,27 @@
+/* { dg-options "-O2 -ftree-tail-merge" } */
+
+char a;
+int c;
+unsigned b ();
+
+unsigned
+setjmp ()
+{
+}
+
+static void
+d ()
+{
+  if (b ())
+    c = 3;
+}
+
+void
+e ()
+{
+  d ();
+  a && ({ setjmp (); });
+  a && ({ setjmp (); });
+  a && ({ setjmp (); });
+}
+
Index: gcc/testsuite/gcc.dg/Walloc-size-larger-than-7.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-7.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-7.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-7.c	(revision 262353)
@@ -0,0 +1,25 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-options "-O -Walloc-size-larger-than=1GB -ftrack-macro-expansion=0" } */
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  __SIZE_TYPE__ n = 0;
+  T (__builtin_malloc (n));
+
+  n = 1000 * 1000 * 1000;   /* 1 gigabyte (GB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1000000001. exceeds maximum object size 1000000000" } */
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+}
Index: gcc/testsuite/gcc.dg/Walloc-size-larger-than-12.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-12.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-12.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-12.c	(revision 262353)
@@ -0,0 +1,27 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile { target lp64 } }
+   { dg-options "-O -Walloc-size-larger-than=1EiB -ftrack-macro-expansion=0" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  size_t n = 0;
+  T (__builtin_malloc (n));
+
+  n = (size_t)1024 * 1024 * 1024 * 1024 * 1024 * 1024;   /* 1 exbibyte (EiB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1152921504606846977. exceeds maximum object size 1152921504606846976" } */
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+}
Index: gcc/testsuite/gcc.dg/pr85257.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr85257.c b/gcc/testsuite/gcc.dg/pr85257.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr85257.c	(revision 262353)
@@ -0,0 +1,20 @@
+/* PR tree-optimization/85257 */
+/* { dg-do run { target int128 } } */
+/* { dg-options "-O2 -fno-tree-ccp" } */
+
+typedef __int128 V __attribute__ ((__vector_size__ (16 * sizeof (__int128))));
+
+__int128 __attribute__ ((noinline, noclone))
+foo (void)
+{
+  V v = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 };
+  return v[5];
+}
+
+int
+main ()
+{
+  if (foo () != 6)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/Walloc-size-larger-than-16.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-16.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-16.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-16.c	(revision 262353)
@@ -0,0 +1,32 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-options "-O -Walloc-size-larger-than=1zb -ftrack-macro-expansion=0" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+/* Verify that an invalid -Walloc-size-larger-than argument is diagnosed
+   and rejected without changing the default setting of PTRDIFF_MAX.  */
+
+void f (void)
+{
+  size_t n = 0;
+  T (__builtin_malloc (n));
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__ - 1;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+}
+
+/* { dg-warning "invalid argument .1zb. to .-Walloc-size-larger-than=." "" { target *-*-* } 0 } */
Index: gcc/testsuite/gcc.dg/pr84503-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr84503-1.c b/gcc/testsuite/gcc.dg/pr84503-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr84503-1.c	(revision 262353)
@@ -0,0 +1,68 @@
+/* PR tree-optimization/84503 */
+/* { dg-do run } */
+/* { dg-options "-O3" } */
+
+typedef __SIZE_TYPE__ size_t;
+typedef __UINTPTR_TYPE__ uintptr_t;
+
+struct S { int a; unsigned short b; int c, d, e; long f, g, h; int i, j; };
+static struct S *k;
+static size_t l = 0;
+int m;
+
+static int
+bar (void)
+{
+  unsigned i;
+  int j;
+  if (k[0].c == 0)
+    {
+      ++m;
+      size_t n = l * 2;
+      struct S *o;
+      o = (struct S *) __builtin_realloc (k, sizeof (struct S) * n);
+      if (!o)
+	__builtin_exit (0);
+      k = o;
+      for (i = l; i < n; i++)
+	{
+	  void *p = (void *) &k[i];
+	  int q = 0;
+	  size_t r = sizeof (struct S);
+	  if ((((uintptr_t) p) % __alignof__ (long)) == 0
+	      && r % sizeof (long) == 0)
+	    {
+	      long __attribute__ ((may_alias)) *s = (long *) p;
+	      long *t = (long *) ((char *) s + r);
+	      while (s < t)
+		*s++ = 0;
+	    }
+	  else
+	    __builtin_memset (p, q, r);
+	  k[i].c = i + 1;
+	  k[i].a = -1;
+	}
+      k[n - 1].c = 0;
+      k[0].c = l;
+      l = n;
+    }
+  j = k[0].c;
+  k[0].c = k[j].c;
+  return j;
+}
+
+int
+main ()
+{
+  k = (struct S *) __builtin_malloc (sizeof (struct S));
+  if (!k)
+    __builtin_exit (0);
+  __builtin_memset (k, '\0', sizeof (struct S));
+  k->a = -1;
+  l = 1;
+  for (int i = 0; i < 15; ++i)
+    bar ();
+  if (m != 4)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/lto/pr81440.h
===================================================================
diff --git a/gcc/testsuite/gcc.dg/lto/pr81440.h b/gcc/testsuite/gcc.dg/lto/pr81440.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/lto/pr81440.h	(revision 262353)
@@ -0,0 +1,4 @@
+typedef struct {
+  int i;
+  int ints[];
+} struct_t;
Index: gcc/testsuite/gcc.dg/lto/pr81440_0.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/lto/pr81440_0.c b/gcc/testsuite/gcc.dg/lto/pr81440_0.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/lto/pr81440_0.c	(revision 262353)
@@ -0,0 +1,9 @@
+/* { dg-lto-do link } */
+
+#include "pr81440.h"
+
+extern struct_t my_struct;
+
+int main() {
+ return my_struct.ints[0];
+}
Index: gcc/testsuite/gcc.dg/lto/pr85248_0.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/lto/pr85248_0.c b/gcc/testsuite/gcc.dg/lto/pr85248_0.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/lto/pr85248_0.c	(revision 262353)
@@ -0,0 +1,45 @@
+/* PR lto/85248 */
+/* { dg-lto-do run } */
+/* { dg-lto-options { { -flto -O2 } } } */
+
+extern void test_alias (int s, int e) __asm__ (__USER_LABEL_PREFIX__ "test");
+extern void test_noreturn (int s, int e) __asm__ (__USER_LABEL_PREFIX__ "test")
+  __attribute__ ((__noreturn__));
+
+extern inline __attribute__ ((__always_inline__, __gnu_inline__)) void
+test (int s, int e)
+{
+  if (__builtin_constant_p (s) && s != 0)
+    test_noreturn (s, e);
+  else
+    test_alias (s, e);
+}
+
+int
+foo (void)
+{
+  static volatile int a;
+  return a;
+}
+
+static void
+bar (void)
+{
+  test (0, 1);
+  __builtin_exit (0);
+}
+
+static void
+baz ()
+{
+  test (1, 0);
+}
+
+int
+main ()
+{
+  if (foo ())
+    baz ();
+  bar ();
+  __builtin_abort ();
+}
Index: gcc/testsuite/gcc.dg/lto/pr83954_0.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/lto/pr83954_0.c b/gcc/testsuite/gcc.dg/lto/pr83954_0.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/lto/pr83954_0.c	(revision 262353)
@@ -0,0 +1,8 @@
+/* { dg-lto-do link } */
+#include "pr83954.h"
+
+int main() {
+  // just to prevent symbol removal
+  FOO_PTR_ARR[1] = 0;
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/lto/pr81440_1.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/lto/pr81440_1.c b/gcc/testsuite/gcc.dg/lto/pr81440_1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/lto/pr81440_1.c	(revision 262353)
@@ -0,0 +1,6 @@
+#include "pr81440.h"
+
+struct_t my_struct = {
+ 20,
+ { 1, 2 }
+};
Index: gcc/testsuite/gcc.dg/lto/pr83954.h
===================================================================
diff --git a/gcc/testsuite/gcc.dg/lto/pr83954.h b/gcc/testsuite/gcc.dg/lto/pr83954.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/lto/pr83954.h	(revision 262353)
@@ -0,0 +1,3 @@
+struct foo;
+extern struct foo *FOO_PTR_ARR[1];
+
Index: gcc/testsuite/gcc.dg/lto/pr85248_1.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/lto/pr85248_1.c b/gcc/testsuite/gcc.dg/lto/pr85248_1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/lto/pr85248_1.c	(revision 262353)
@@ -0,0 +1,9 @@
+/* { dg-options "-fno-lto" } */
+
+void
+test (int s, int e)
+{
+  asm volatile ("" : "+g" (s), "+g" (e) : : "memory");
+  if (s)
+    __builtin_abort ();
+}
Index: gcc/testsuite/gcc.dg/lto/pr83954_1.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/lto/pr83954_1.c b/gcc/testsuite/gcc.dg/lto/pr83954_1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/lto/pr83954_1.c	(revision 262353)
@@ -0,0 +1,7 @@
+#include "pr83954.h"
+
+struct foo {
+ int x;
+};
+struct foo *FOO_PTR_ARR[1] = { 0 };
+
Index: gcc/testsuite/gcc.dg/pr84739.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr84739.c b/gcc/testsuite/gcc.dg/pr84739.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr84739.c	(revision 262353)
@@ -0,0 +1,26 @@
+/* PR tree-optimization/84739 */
+/* { dg-do compile } */
+/* { dg-require-weak "" } */
+/* { dg-options "-O2 -w" } */
+
+static void baz (void) __attribute__((weakref("bar")));
+
+int
+foo (int x, int y)
+{
+  if (x)
+    y = 0;
+  if (y)
+    goto lab;
+  y = 0;
+lab:
+  return y;
+}
+
+void
+bar (int x, int y)
+{
+  y = foo (x, y);
+  if (y != 0)
+    baz ();
+}
Index: gcc/testsuite/gcc.dg/torture/pr85244-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/torture/pr85244-2.c b/gcc/testsuite/gcc.dg/torture/pr85244-2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/torture/pr85244-2.c	(revision 262353)
@@ -0,0 +1,8 @@
+struct s {
+    long a;
+    int b;
+    int tab[];
+};
+
+int idx = 1;
+const struct s val = { 0, 0, { 42, 1337 } };
Index: gcc/testsuite/gcc.dg/torture/pr85168.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/torture/pr85168.c b/gcc/testsuite/gcc.dg/torture/pr85168.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/torture/pr85168.c	(revision 262353)
@@ -0,0 +1,30 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target indirect_jumps } */
+
+typedef struct {
+    struct {
+	char a;
+    } b;
+} c;
+
+int d, f;
+c *e;
+
+extern void i(void);
+extern void sejtmp () __attribute__((returns_twice));
+
+void g(void)
+{
+  c *h = e;
+  if (f)
+    {
+      i();
+      h--;
+      if (d)
+	if (h->b.a)
+	  i();
+    }
+  if (h->b.a)
+    sejtmp();
+  e = h;
+}
Index: gcc/testsuite/gcc.dg/torture/pr85284.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/torture/pr85284.c b/gcc/testsuite/gcc.dg/torture/pr85284.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/torture/pr85284.c	(revision 262353)
@@ -0,0 +1,20 @@
+/* { dg-do run } */
+
+static int p[48], v;
+
+int
+main ()
+{
+  p[32] = 1;
+  for (int i = 48; i--;)
+    {
+      if (!p[i])
+	continue;
+      if ((i & 7) > 2)
+	break;
+      v = i & 1;
+    }
+  if (v != 0)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr57656.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/torture/pr57656.c b/gcc/testsuite/gcc.dg/torture/pr57656.c
--- a/gcc/testsuite/gcc.dg/torture/pr57656.c	(revision 262353)
+++ b/gcc/testsuite/gcc.dg/torture/pr57656.c	(revision 262353)
@@ -1,5 +1,5 @@
 /* { dg-do run } */
-/* { dg-options "-fstrict-overflow" } */
+/* { dg-additional-options "-fstrict-overflow" } */
 
 int main (void)
 {
Index: gcc/testsuite/gcc.dg/torture/pr85989.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/torture/pr85989.c b/gcc/testsuite/gcc.dg/torture/pr85989.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/torture/pr85989.c	(revision 262353)
@@ -0,0 +1,31 @@
+/* { dg-do run } */
+
+#define N 9
+
+void __attribute__((noinline, noclone))
+f (double x, double y, double *res)
+{
+  y = -y;
+  for (int i = 0; i < N; ++i)
+    {
+      double tmp = y;
+      y = x;
+      x = tmp;
+      res[i] = i;
+    }
+  res[N] = y * y;
+  res[N + 1] = x;
+}
+
+int
+main (void)
+{
+  double res[N + 2];
+  f (10, 20, res);
+  for (int i = 0; i < N; ++i)
+    if (res[i] != i)
+      __builtin_abort ();
+  if (res[N] != 100 || res[N + 1] != -20)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr85244-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/torture/pr85244-1.c b/gcc/testsuite/gcc.dg/torture/pr85244-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/torture/pr85244-1.c	(revision 262353)
@@ -0,0 +1,19 @@
+/* { dg-do run } */
+/* { dg-additional-sources "pr85244-2.c" } */
+
+struct s {
+ long a;
+ int b;
+ int tab[];
+};
+
+extern const struct s val;
+extern int idx;
+extern void abort (void);
+
+int main()
+{
+  if (val.tab[0] != 42 || val.tab[1] != 1337 || val.tab[idx] != 1337)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/torture/pr85588.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/torture/pr85588.c b/gcc/testsuite/gcc.dg/torture/pr85588.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/torture/pr85588.c	(revision 262353)
@@ -0,0 +1,4 @@
+/* { dg-do run } */
+/* { dg-additional-options "-fwrapv" } */
+
+#include "pr57656.c"
Index: gcc/testsuite/gcc.dg/torture/pr85567.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/torture/pr85567.c b/gcc/testsuite/gcc.dg/torture/pr85567.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/torture/pr85567.c	(revision 262353)
@@ -0,0 +1,16 @@
+/* { dg-do compile } */
+
+extern void sincos(double x, double *sinx, double *cosx);
+
+void apply(void (*f)(double, double *, double *),
+	   double x, double *sinx, double *cosx)
+{
+  f(x, sinx, cosx);
+  return;
+}
+
+void apply_sincos(double x, double *sinx, double *cosx)
+{
+  apply(sincos, x, sinx, cosx);
+  return;
+}
Index: gcc/testsuite/gcc.dg/pr84953.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr84953.c b/gcc/testsuite/gcc.dg/pr84953.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr84953.c	(revision 262353)
@@ -0,0 +1,11 @@
+/* PR c/84953 */
+/* { dg-do compile } */
+
+char *strpbrk (const char *, const char *);
+
+char *
+test (char *p)
+{
+  p = strpbrk (p, "");	/* { dg-bogus "assignment discards 'const' qualifier from pointer target type" } */
+  return p;
+}
Index: gcc/testsuite/gcc.dg/tree-ssa/vrp119.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/tree-ssa/vrp119.c b/gcc/testsuite/gcc.dg/tree-ssa/vrp119.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/tree-ssa/vrp119.c	(revision 262353)
@@ -0,0 +1,20 @@
+/* PR tree-optimization/86231 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-vrp1" } */
+/* { dg-final { scan-tree-dump-not "link_error" "vrp1" } } */
+
+int bar (int);
+void link_error (void);
+
+int
+foo (int x, int y, int z)
+{
+  if (x < 4 || x > 8) __builtin_unreachable ();
+  if (y >= 2 && y <= 6) __builtin_unreachable ();
+  /* x is [4, 8], y is ~[2, 6], resulting range of e should be ~[2, 3].  */
+  int e = (z ? x : y);
+  bar (bar (bar (bar (bar (bar (bar (bar (bar (bar (bar (bar (e))))))))))));
+  if (e == 2 || e == 3)
+    link_error ();
+  return e;
+}
Index: gcc/testsuite/gcc.dg/tls/pr83945.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/tls/pr83945.c b/gcc/testsuite/gcc.dg/tls/pr83945.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/tls/pr83945.c	(revision 262353)
@@ -0,0 +1,21 @@
+/* PR middle-end/83945 */
+/* { dg-do compile { target tls } } */
+/* { dg-options "-O2" } */
+
+struct S { int a[1]; };
+__thread struct T { int c; } e;
+int f;
+void bar (int);
+
+void
+foo (int f, int x)
+{
+  struct S *h = (struct S *) &e.c;
+  for (;;)
+    {
+      int *a = h->a, i;
+      for (i = x; i; i--)
+	bar (a[f]);
+      bar (a[f]);
+    }
+}
Index: gcc/testsuite/gcc.dg/pr81661.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr81661.c b/gcc/testsuite/gcc.dg/pr81661.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr81661.c	(revision 262353)
@@ -0,0 +1,12 @@
+/* PR tree-optimization/81661 */
+/* { dg-do compile } */
+/* { dg-options "-O3 -ftrapv" } */
+
+int a, b, c;
+
+void
+foo (void)
+{
+  while (a + c > b)
+    a--;
+}
Index: gcc/testsuite/gcc.dg/Walloc-size-larger-than-4.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-4.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-4.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-4.c	(revision 262353)
@@ -0,0 +1,19 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-options "-O -Walloc-size-larger-than=1MiB -ftrack-macro-expansion=0" } */
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  unsigned n = 0;
+  T (__builtin_malloc (n));
+
+  n = 1024 * 1024;   /* 1 mebibyte (MiB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1048577. exceeds maximum object size 1048576" } */
+}
Index: gcc/testsuite/gcc.dg/pr86314.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr86314.c b/gcc/testsuite/gcc.dg/pr86314.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr86314.c	(revision 262353)
@@ -0,0 +1,20 @@
+// PR target/86314
+// { dg-do run { target sync_int_long } }
+// { dg-options "-O2" }
+
+__attribute__((noinline, noclone)) unsigned long
+foo (unsigned long *p)
+{
+  unsigned long m = 1UL << ((*p & 1) ? 1 : 0);
+  unsigned long n = __atomic_fetch_or (p, m, __ATOMIC_SEQ_CST);
+  return (n & m) == 0;
+}
+
+int
+main ()
+{
+  unsigned long v = 1;
+  if (foo (&v) != 1)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.dg/Walloc-size-larger-than-8.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-8.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-8.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-8.c	(revision 262353)
@@ -0,0 +1,27 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile { target lp64 } }
+   { dg-options "-O -Walloc-size-larger-than=1TiB -ftrack-macro-expansion=0" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  size_t n = 0;
+  T (__builtin_malloc (n));
+
+  n = (size_t)1024 * 1024 * 1024 * 1024;   /* 1 tebibyte (TiB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1099511627777. exceeds maximum object size 1099511627776" } */
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+}
Index: gcc/testsuite/gcc.dg/pr83930.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr83930.c b/gcc/testsuite/gcc.dg/pr83930.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr83930.c	(revision 262353)
@@ -0,0 +1,17 @@
+/* PR target/83930 */
+/* { dg-do compile } */
+/* { dg-options "-Og -fno-tree-ccp -w" } */
+
+unsigned __attribute__ ((__vector_size__ (16))) v;
+
+static inline void
+bar (unsigned char d)
+{
+  v /= d;
+}
+
+__attribute__ ((always_inline)) void
+foo (void)
+{
+  bar (4);
+}
Index: gcc/testsuite/gcc.dg/pr85167.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr85167.c b/gcc/testsuite/gcc.dg/pr85167.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr85167.c	(revision 262353)
@@ -0,0 +1,16 @@
+/* PR rtl-optimization/85167 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -w" } */
+
+struct A { long b; };
+int c, d, e;
+int bar (void);
+
+int
+foo (void)
+{
+  long g;
+  for (; g == c ? 0 : (e = 1); g = ((struct A *)g)->b)
+    if (bar ())
+      return d;
+}
Index: gcc/testsuite/gcc.dg/Walloc-size-larger-than-13.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-13.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-13.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-13.c	(revision 262353)
@@ -0,0 +1,27 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile { target lp64 } }
+   { dg-options "-O -Walloc-size-larger-than=1EB -ftrack-macro-expansion=0" } */
+
+typedef __SIZE_TYPE__ size_t;
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  size_t n = 0;
+  T (__builtin_malloc (n));
+
+  n = (size_t)1000 * 1000 * 1000 * 1000 * 1000 * 1000;   /* 1 exabyte (EB) */
+  T (__builtin_malloc (n));
+
+  n += 1;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1000000000000000001. exceeds maximum object size 1000000000000000000" } */
+
+  n = __PTRDIFF_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+
+  n = __SIZE_MAX__;
+  T (__builtin_malloc (n));   /* { dg-warning "exceeds maximum object size" } */
+}
Index: gcc/testsuite/gcc.dg/pr84899.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr84899.c b/gcc/testsuite/gcc.dg/pr84899.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr84899.c	(revision 262353)
@@ -0,0 +1,12 @@
+/* PR target/84899 */
+/* { dg-do compile } */
+/* { dg-options "-O -funroll-all-loops -fno-move-loop-invariants" } */
+
+void
+foo (int x)
+{
+  int a = 1 / x, b = 0;
+
+  while ((a + b + 1) < x)
+    b = __INT_MAX__;
+}
Index: gcc/testsuite/gcc.dg/pr84841.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr84841.c b/gcc/testsuite/gcc.dg/pr84841.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr84841.c	(revision 262353)
@@ -0,0 +1,9 @@
+/* PR tree-optimization/84841 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fassociative-math -frounding-math -fno-signed-zeros -fno-trapping-math -fno-tree-forwprop" } */
+
+double
+foo (double x)
+{
+  return -x * 0.1 * 0.1;
+}
Index: gcc/testsuite/gcc.dg/pr84834.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr84834.c b/gcc/testsuite/gcc.dg/pr84834.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr84834.c	(revision 262353)
@@ -0,0 +1,15 @@
+/* PR middle-end/84834 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+_Complex int
+foo (int a)
+{
+  return a < 0;
+}
+
+_Complex int
+bar (int a)
+{
+  return (a & 8) ? (_Complex int) 16 : (_Complex int) 0;
+}
Index: gcc/testsuite/gcc.dg/pr84503-2.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr84503-2.c b/gcc/testsuite/gcc.dg/pr84503-2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr84503-2.c	(revision 262353)
@@ -0,0 +1,5 @@
+/* PR tree-optimization/84503 */
+/* { dg-do run } */
+/* { dg-options "-O3 -fno-tree-vectorize -fno-ivopts" } */
+
+#include "pr84503-1.c"
Index: gcc/testsuite/gcc.dg/pr84772.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/pr84772.c b/gcc/testsuite/gcc.dg/pr84772.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/pr84772.c	(revision 262353)
@@ -0,0 +1,13 @@
+/* PR target/84772 */
+/* { dg-do compile } */
+/* { dg-options "-O -Wuninitialized" } */
+
+#include <stdarg.h>
+
+void
+foo (int *x, int y, va_list ap)
+{
+  __builtin_memset (x, 0, sizeof (int));
+  for (int i = 0; i < y; i++)
+    va_arg (ap, long double);			/* { dg-bogus "uninitialized" } */  
+}
Index: gcc/testsuite/gcc.dg/Walloc-size-larger-than-1.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/Walloc-size-larger-than-1.c b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/Walloc-size-larger-than-1.c	(revision 262353)
@@ -0,0 +1,19 @@
+/* PR middle-end/82063 - issues with arguments enabled by -Wall
+   { dg-do compile }
+   { dg-options "-O -Walloc-size-larger-than=1KB -ftrack-macro-expansion=0" } */
+
+void sink (void*);
+
+#define T(x) sink (x)
+
+void f (void)
+{
+  unsigned n = 0;
+  T (__builtin_malloc (n));
+
+  n = 1024;   /* 1 kibibyte (KB or KiB) */
+  T (__builtin_malloc (n));
+
+  n = 1025;
+  T (__builtin_malloc (n));   /* { dg-warning "argument 1 value .1025. exceeds maximum object size 1024" } */
+}
Index: gcc/testsuite/gcc.dg/vect/pr85597.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/vect/pr85597.c b/gcc/testsuite/gcc.dg/vect/pr85597.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/vect/pr85597.c	(revision 262353)
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+/* { dg-options "-O3" } */
+/* { dg-additional-options "-mfma" { target { x86_64-*-* i?86-*-* } } } */
+
+extern double fma (double, double, double);
+
+static inline void
+bar (int i, double *D, double *S)
+{
+  while (i-- > 0)
+    {
+      D[0] = fma (1, S[0], D[0]);
+      D[1] = fma (1, S[1], D[1]);
+      D[2] = fma (1, S[2], D[2]);
+      D[3] = fma (1, S[3], D[3]);
+      D += 4;
+      S += 4;
+    }
+}
+
+void
+foo (double *d, double *s)
+{
+  bar (10, d, s);
+}
+
Index: gcc/testsuite/gcc.dg/vect/pr84485.c
===================================================================
diff --git a/gcc/testsuite/gcc.dg/vect/pr84485.c b/gcc/testsuite/gcc.dg/vect/pr84485.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gcc.dg/vect/pr84485.c	(revision 262353)
@@ -0,0 +1,34 @@
+/* { dg-do run } */
+
+#include "tree-vect.h"
+
+#define N 256
+
+void __attribute__ ((noinline, noclone))
+f (unsigned long incx, unsigned long incy,
+   float *restrict dx, float *restrict dy)
+{
+  unsigned long ix = 0, iy = 0;
+  for (unsigned long i = 0; i < N; ++i)
+    {
+      dy[iy] += dx[ix];
+      ix += incx;
+      iy += incy;
+    }
+}
+
+float a = 0.0;
+float b[N];
+
+int
+main (void)
+{
+  check_vect ();
+
+  for (int i = 0; i < N; ++i)
+    b[i] = i;
+  f (1, 0, b, &a);
+  if (a != N * (N - 1) / 2)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/ChangeLog
===================================================================
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
--- a/gcc/testsuite/ChangeLog	(revision 262353)
+++ b/gcc/testsuite/ChangeLog	(revision 262353)
@@ -1,3 +1,1653 @@
+2018-07-03  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/82969
+	PR fortran/86242
+	* gfortran.dg/proc_ptr_50.f90: New test.
+
+2018-06-26  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	Backported from mainline
+	2018-06-20  Kelvin Nilsen  <kelvin@gcc.gnu.org>
+
+	* gcc.target/powerpc/builtins-1.c: Add dg directives to scan
+	for vpkudus.
+
+2018-06-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/86314
+	* gcc.dg/pr86314.c: New test.
+
+2018-06-25  Fritz Reese  <fritzoreese@gmail.com>
+
+	PR fortran/82972
+	PR fortran/83088
+	PR fortran/85851
+	Backport from trunk.
+	* gfortran.dg/init_flag_17.f90: New testcase.
+
+2018-06-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84786
+	* gcc.target/i386/avx512f-pr84786-3.c: New test.
+
+2018-06-25  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/83118
+	Back port from trunk
+	* gfortran.dg/unlimited_polymorphic_30.f03: New test.
+
+2018-06-23  Richard Sandiford  <richard.sandiford@linaro.org>
+
+	PR tree-optimization/85989
+	* gcc.dg/torture/pr85989.c: New test.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85662
+	* g++.dg/ext/offsetof3.C: New test.
+
+	2018-06-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/86210
+	* g++.dg/warn/Wnonnull4.C: New test.
+
+	PR tree-optimization/86231
+	* gcc.dg/tree-ssa/vrp119.c: New test.
+	* gcc.c-torture/execute/pr86231.c: New test.
+
+	2018-06-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/85878
+	* gfortran.fortran-torture/compile/pr85878.f90: New test.
+
+	2018-06-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/85945
+	* gcc.c-torture/compile/pr85945.c: New test.
+
+	2018-06-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/86025
+	* c-c++-common/gomp/pr86025.c: New test.
+
+	2018-05-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85952
+	* g++.dg/warn/Wunused-var-33.C: New test.
+
+	2018-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/85696
+	* c-c++-common/gomp/pr85696.c: New test.
+
+	2018-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85662
+	* g++.dg/ext/offsetof2.C: New test.
+
+	2018-05-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85659
+	* g++.dg/ext/asm14.C: New test.
+	* g++.dg/ext/asm15.C: New test.
+	* g++.dg/ext/asm16.C: New test.
+
+	2018-04-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/85529
+	* gcc.c-torture/execute/pr85529-1.c: New test.
+	* gcc.c-torture/execute/pr85529-2.c: New test.
+	* gcc.dg/pr85529.c: New test.
+
+	2018-04-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84463
+	* g++.dg/cpp0x/constexpr-nullptr-1.C: Add -O1 to dg-options.
+	* g++.dg/cpp0x/constexpr-nullptr-2.C: Expect different diagnostics
+	in two cases.  Uncomment two other tests and add expected dg-error for
+	them.
+	* g++.dg/init/struct2.C: Cast to int rather than long to avoid
+	-Wnarrowing diagnostics on some targets for c++11.
+	* g++.dg/parse/array-size2.C: Remove xfail.
+	* g++.dg/cpp0x/constexpr-84463.C: New test.
+
+	2018-04-17  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/85430
+	* gcc.dg/pr85430.c: New test.
+
+	2018-04-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/85300
+	* gcc.dg/pr85300.c: New test.
+
+	PR fortran/85313
+	* gfortran.dg/gomp/pr85313.f90: New test.
+
+	2018-04-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/85257
+	* gcc.dg/pr85257.c: New test.
+
+	2018-04-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/85252
+	* gcc.dg/debug/pr85252.c: New test.
+
+	PR c++/85210
+	* g++.dg/cpp1z/decomp42.C: New test.
+
+	2018-04-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85208
+	* g++.dg/cpp1z/decomp41.C: New test.
+
+	2018-04-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/85172
+	* g++.dg/ext/builtin13.C: New test.
+	* g++.dg/ext/atomic-4.C: New test.
+
+	2018-04-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/85167
+	* gcc.dg/pr85167.c: New test.
+
+	PR c++/85147
+	* g++.dg/cpp0x/pr85147.C: New test.
+
+	PR c++/85140
+	* g++.dg/cpp0x/gen-attrs-64.C: New test.
+
+	2018-03-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84791
+	* g++.dg/gomp/pr84791.C: New test.
+
+	2018-03-28  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/85095
+	* gcc.target/i386/pr85095-1.c: New test.
+	* gcc.target/i386/pr85095-2.c: New test.
+	* gcc.c-torture/execute/pr85095.c: New test.
+
+	2018-03-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85076
+	* g++.dg/cpp1y/pr85076.C: New test.
+
+	PR c++/85068
+	* g++.dg/inherit/covariant22.C: New test.
+
+	2018-03-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/85034
+	* gcc.target/i386/pr85034.c: New test.
+
+	PR inline-asm/85022
+	* c-c++-common/torture/pr85022.c: New test.
+
+	2018-03-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/84941
+	* gcc.dg/pr84941.c: New test.
+
+	2018-03-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/84999
+	* c-c++-common/pr84999.c: New test.
+
+	PR c++/84961
+	* c-c++-common/pr43690.c: Don't expect errors on "m" (--x) and
+	"m" (++x) in C++.
+	* g++.dg/torture/pr84961-1.C: New test.
+	* g++.dg/torture/pr84961-2.C: New test.
+
+	2018-03-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR debug/84875
+	* gcc.dg/pr84875.c: New test.
+
+	PR c/84953
+	* gcc.dg/pr84953.c: New test.
+
+	2018-03-19  Maxim Ostapenko  <m.ostapenko@samsung.com>
+
+	PR sanitizer/78651
+	* g++.dg/asan/pr78651.C: New test.
+
+	2018-03-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84899
+	* gcc.dg/pr84899.c: New test.
+
+	PR c++/84874
+	* g++.dg/cpp1z/desig8.C: New test.
+
+	PR tree-optimization/84841
+	* gcc.dg/pr84841.c: New test.
+
+	PR c++/84874
+	* g++.dg/cpp1z/desig7.C: New test.
+
+	2018-03-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/79085
+	* g++.dg/opt/pr79085.C: New test.
+
+	PR c++/84222
+	* g++.dg/warn/deprecated.C (T::member3): Change dg-warning to dg-bogus.
+	* g++.dg/warn/deprecated-6.C (T::member3): Likewise.
+	* g++.dg/warn/deprecated-13.C: New test.
+
+	PR target/84860
+	* gcc.c-torture/compile/pr84860.c: New test.
+
+	PR c/84853
+	* gcc.dg/pr84853.c: New test.
+
+	2018-03-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/84834
+	* gcc.dg/pr84834.c: New test.
+
+	PR target/84827
+	* gcc.target/i386/pr84827.c: New test.
+
+	PR target/84786
+	* gcc.target/i386/avx512f-pr84786-1.c: New test.
+	* gcc.target/i386/avx512f-pr84786-2.c: New test.
+
+	2018-03-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84772
+	* gcc.dg/pr84772.c: New test.
+
+	2018-03-09  Jason Merrill  <jason@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84076
+	* g++.dg/warn/Wformat-2.C: New test.
+
+	2018-03-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84767
+	* g++.dg/ext/vla18.C: New test.
+
+	2018-03-08  Jason Merrill  <jason@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/80598
+	* g++.dg/warn/Wunused-function4.C: New test.
+
+	2018-03-08  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/84739
+	* gcc.dg/pr84739.c: New test.
+
+	2018-03-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84700
+	* gcc.target/powerpc/pr84700.c: New test.
+
+	2018-03-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84662
+	* g++.dg/cpp1y/pr84662.C: New test.
+
+2018-06-22  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	Backport from mainline
+	2018-06-05  Andre Vieira  <andre.simoesdiasvieira@arm.com>
+
+	* gcc.target/arm/cmse/cmse-1c99.c: New test.
+
+2018-06-19  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/aggr24.adb: New test.
+	* gnat.dg/aggr24_pkg.ad[sb]: New helper.
+
+2018-06-18  Martin Sebor  <msebor@redhat.com>
+
+        PR middle-end/82063
+        * gcc.dg/Walloc-size-larger-than-1.c: New test.
+        * gcc.dg/Walloc-size-larger-than-10.c: New test.
+        * gcc.dg/Walloc-size-larger-than-11.c: New test.
+        * gcc.dg/Walloc-size-larger-than-12.c: New test.
+        * gcc.dg/Walloc-size-larger-than-13.c: New test.
+        * gcc.dg/Walloc-size-larger-than-14.c: New test.
+        * gcc.dg/Walloc-size-larger-than-15.c: New test.
+        * gcc.dg/Walloc-size-larger-than-16.c: New test.
+        * gcc.dg/Walloc-size-larger-than-2.c: New test.
+        * gcc.dg/Walloc-size-larger-than-3.c: New test.
+        * gcc.dg/Walloc-size-larger-than-4.c: New test.
+        * gcc.dg/Walloc-size-larger-than-5.c: New test.
+        * gcc.dg/Walloc-size-larger-than-6.c: New test.
+        * gcc.dg/Walloc-size-larger-than-7.c: New test.
+        * gcc.dg/Walloc-size-larger-than-8.c: New test.
+        * gcc.dg/Walloc-size-larger-than-9.c: New test.
+        * gcc.dg/Walloc-size-larger-than.c: New test.
+
+2018-06-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/86110
+	* gfortran.dg/pr86110.f90: New test.
+
+2018-06-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/44491
+	* gfortran.dg/pr44491.f90: New testcase
+
+2018-06-11  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-06-08  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/85755
+	* gcc.target/powerpc/pr85755.c: New test.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/38351
+	* gfortran.dg/pr38351.f90: New test.
+	* gfortran.dg/typebound_operator_4.f03: Adjust for new error message.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/63514
+	* gfortran.dg/pr63514.f90: New test.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/78278
+	* gfortran.dg/data_bounds_1.f90: Add -std=gnu option.
+	* gfortran.dg/data_char_1.f90: Ditto.
+	* gfortran.dg/pr78571.f90: Ditto.
+	* gfortran.dg/pr78278.f90: New test.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/86059
+	* gfortran.dg/associate_30.f90: Remove code tested ...
+	* gfortran.dg/pr67803.f90: Ditto.
+	* gfortran.dg/pr67805.f90: Ditto.
+	* gfortran.dg/pr86059.f90: ... here.  New test.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85138
+	PR fortran/85996
+	PR fortran/86051
+	* gfortran.dg/pr85138_1.f90: New test.
+	* gfortran.dg/pr85138_2.f90: Ditto.
+	* gfortran.dg/pr85996.f90: Ditto.
+
+2018-06-07  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/86045
+	Backport from trunk.
+	* gfortran.dg/pr86045.f90: New test.
+
+2018-06-07  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/85641
+	Backport from trunk.
+	* gfortran.dg/realloc_on_assign_30.f90: New test.
+
+2018-06-07  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-05-04  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/85588
+	* gcc.dg/torture/pr85588.c: New testcase.
+	* gcc.dg/torture/pr57656.c: Use dg-additional-options.
+
+	2018-05-02  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/85567
+	* gcc.dg/torture/pr85567.c: New testcase.
+
+	2018-05-02  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/85597
+	* gcc.dg/vect/pr85597.c: New testcase.
+
+2018-06-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	Backport from mainline
+	2018-06-05  Andreas Krebbel  <krebbel@linux.ibm.com>
+
+	* gcc.target/s390/htm-builtins-compile-4.c: New test.
+
+2018-06-04  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85981
+	* gfortran.dg/allocate_alloc_opt_14.f90: New test.
+	* gfortran.dg/allocate_alloc_opt_1.f90: Update error string.
+	* gfortran.dg/allocate_stat_2.f90: Ditto.
+	* gfortran.dg/deallocate_alloc_opt_1.f90: Ditto.
+
+2018-06-02  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/specs/opt3.ads: New test.
+	* gnat.dg/specs/opt3_pkg.ads: New helper.
+
+2018-06-02  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/discr53.ad[sb]: New test.
+	* gnat.dg/discr53_pkg.ads: New helper.
+
+2018-05-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85543
+	Backport from trunk
+	* gfortran.dg/pr85543.f90: New test.
+
+2018-05-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85779
+	Backport from trunk
+	* gfortran.dg/pr85779_1.f90: New test.
+	* gfortran.dg/pr85779_2.f90: Ditto.
+	* gfortran.dg/pr85779_3.f90: Ditto.
+
+2018-05-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85780
+	Backport from trunk
+	* gfortran.dg/pr85780.f90: New test.
+
+2018-05-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85895
+	Backport from trunk
+	* gfortran.dg/coarray_3.f90: Fix invalid testcase.
+	* gfortran.dg/pr85895.f90: New test.
+
+2018-05-24  Uros Bizjak  <ubizjak@gmail.com>
+
+	* gcc.target/i386/avx512f-vcvtusi2sd64-1.c: Update scan string.
+	* gcc.target/i386/avx512f-vcvtusi2ss64-1.c: Ditto.
+
+2018-05-21  Pat Haugen  <pthaugen@us.ibm.com>
+
+	Backport from mainline:
+	2018-05-17  Pat Haugen  <pthaugen@us.ibm.com>
+
+	PR target/85698
+	* gcc.target/powerpc/pr85698.c: New test.
+
+2018-05-20  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/80657
+	Backport from trunk
+	* gfortran.dg/char_result_18.f90: New test.
+
+2018-05-20  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/82275
+	Backport from trunk
+	* gfortran.dg/select_type_42.f90: New test.
+
+2018-05-19  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/82923
+	Backport from trunk
+	* gfortran.dg/allocate_assumed_charlen_4.f90: New test. Note
+	that the patch fixes PR66694 & PR82617, although the testcases
+	are not explicitly included.
+
+2017-05-17  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/82814
+	Backport from trunk
+	* gfortran.dg/submodule_31.f08: New test.
+
+2018-05-16  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/83149
+	Backport from trunk
+	* gfortran.dg/pr83149_1.f90: New test.
+	* gfortran.dg/pr83149.f90: Additional source for previous.
+	* gfortran.dg/pr83149_b.f90: New test.
+	* gfortran.dg/pr83149_a.f90: Additional source for previous.
+
+2018-16-05  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/83898
+	Backport from trunk
+	* gfortran.dg/associate_33.f03 : New test.
+
+2018-05-16  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/84546
+	Backport from trunk
+	* gfortran.dg/unlimited_polymorphic_29.f90 : New test.
+
+2018-05-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85542
+	Backport from trunk
+	* gfortran.dg/pr85542.f90: New test.
+
+2018-05-12  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/68846
+	Backport from trunk
+	* gfortran.dg/temporary_3.f90 : New test.
+
+	PR fortran/70864
+	Backport from trunk
+	* gfortran.dg/temporary_2.f90 : New test.
+
+2018-05-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/70870
+	Backport from trunk
+	* gfortran.dg/pr70870_1.f90: New test.
+
+2018-05-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85521
+	Backport from trunk
+	* gfortran.dg/pr85521_1.f90: New test.
+	* gfortran.dg/pr85521_2.f90: New test.
+
+2018-05-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85687
+	Backport from trunk
+	* gfortran.dg/pr85687.f90: new test.
+
+2018-05-06  Andre Vehreschild  <vehre@gcc.gnu.org>
+
+	PR fortran/85507
+	Backport from trunk.
+	* gfortran.dg/coarray_dependency_1.f90: New test.
+	* gfortran.dg/coarray_lib_comm_1.f90: Fix counting caf-expressions.
+
+2018-05-01  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from trunk
+	2018-04-27  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/82518
+	* lib/target-supports.exp (check_effective_target_vect_load_lanes):
+	Use check_effective_target_arm_little_endian.
+
+2018-04-28  Andre Vehreschild  <vehre@gcc.gnu.org>
+
+	PR fortran/81773
+	PR fortran/83606
+	Backport from trunk.
+	* gfortran.dg/coarray/get_to_indexed_array_1.f90: New test.
+	* gfortran.dg/coarray/get_to_indirect_array.f90: New test.
+
+2018-04-26  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-04-09  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/85284
+	* gcc.dg/torture/pr85284.c: New testcase.
+
+	2018-04-06  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/85244
+	* gcc.dg/torture/pr85244-1.c: New testcase.
+	* gcc.dg/torture/pr85244-2.c: Likewise.
+
+	2018-04-04  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/85168
+	* gcc.dg/torture/pr85168.c: New testcase.
+
+	2018-03-15  Richard Biener  <rguenther@suse.de>
+
+	PR c/84873
+	* c-c++-common/pr84873.c: New testcase.
+
+2018-04-24  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85520
+	* gfortran.dg/pr85520.f90: New test.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-04-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR lto/85248
+	* gcc.dg/lto/pr85248_0.c: New test.
+	* gcc.dg/lto/pr85248_1.c: New test.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-03-28  Jakub Jelinek  <jakub@redhat.com>
+		    Martin Liska  <mliska@suse.cz>
+
+	PR sanitizer/85081
+	* g++.dg/asan/pr85081.C: New test.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-03-21  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/84963
+	* gfortran.dg/goacc/pr84963.f90: New test.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-03-13  Martin Liska  <mliska@suse.cz>
+
+	PR ipa/84658.
+	* g++.dg/ipa/pr84658.C: New test.
+
+2018-04-23  Aaron Sawdey  <acsawdey@linux.ibm.com>
+
+	Backport from mainline
+	2018-04-16  Aaron Sawdey  <acsawdey@linux.ibm.com>
+
+	PR target/83660
+	* gcc.target/powerpc/pr83660.C: New test.
+
+2018-04-23  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* g++.dg/torture/pr85496.C: New test.
+
+2018-04-20  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/85436
+	* go.dg/pr85436.go: New test.
+
+	Backport from mainline
+	2018-03-09  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/83969
+	* gcc.target/powerpc/pr83969.c: New test.
+
+2018-04-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/85464 - missing location for -Wignored-qualifiers diagnostic
+	* g++.dg/diagnostic/pr85464.C: New.
+
+2018-04-18  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2018-04-11  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	PR target/85261
+	* gcc.target/arm/fpscr.c: Add call to __builtin_arm_set_fpscr with
+	literal value.  Expect 2 MCR instruction.  Fix function prototype.
+	Remove volatile keyword.
+
+2018-04-12  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-04-12  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* gcc.target/s390/nobp-no-dwarf2-cfi.c: New test.
+
+2018-04-11  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2018-04-04  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	PR target/85203
+	* gcc.target/arm/cmse/cmse-1.c: Tighten cmse_nonsecure_caller RTL scan
+	to match a single insn of the baz function.  Move scan directives at
+	the end of the file below the functions they are trying to test for
+	better readability.
+	* gcc.target/arm/cmse/cmse-16.c: New testcase.
+
+2018-04-10  Thomas Schwinge  <thomas@codesourcery.com>
+
+	PR target/85056
+	* gcc.target/nvptx/pr85056.c (main): Initialize "sum".
+
+2018-04-10  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2018-03-08  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/84748
+	* gcc.c-torture/execute/pr84748.c: New test.
+
+2018-04-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* g++.dg/opt/pr85196.C: New test.
+
+2018-04-05  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/85193
+	* gcc.target/i386/pr85193.c: New test.
+
+2018-04-04  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-04-04  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR rtl-optimization/84878
+	* gcc.target/powerpc/pr84878.c: New test.
+
+2018-04-03  Cesar Philippidis  <cesar@codesourcery.com>
+
+	Backport from mainline
+	2018-03-27  Cesar Philippidis  <cesar@codesourcery.com>
+
+	PR target/85056
+	* testsuite/gcc.target/nvptx/pr85056.c: New test.
+	* testsuite/gcc.target/nvptx/pr85056a.c: New test.
+
+2018-04-02  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-03-28  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/84912
+	* gcc.target/powerpc/extend-divide-1.c (div_weo): Remove test for
+	deleted builtin function.
+	(div_weuo): Likewise.
+	* gcc.target/powerpc/extend-divide-2.c (div_deo): Likewise.
+	(div_deuo): Likewise.
+
+2018-04-02  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-02-08  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/81143
+	* gcc.target/powerpc/pr79799-2.c: Use __LITTLE_ENDIAN__.
+
+2018-03-29  Sebastian Peryt  <sebastian.peryt@intel.com>
+
+	PR c++/84783
+	* gcc.target/i386/avx512vl-vpermd-1.c (_mm256_permutexvar_epi32):
+	Test new intrinsic.
+	* gcc.target/i386/avx512vl-vpermq-imm-1.c (_mm256_permutex_epi64):
+	Ditto.
+	* gcc.target/i386/avx512vl-vpermq-var-1.c (_mm256_permutexvar_epi64):
+	Ditto.
+	* gcc.target/i386/avx512f-vpermd-2.c: Do not check for AVX512F_LEN.
+	* gcc.target/i386/avx512f-vpermq-imm-2.c: Ditto.
+	* gcc.target/i386/avx512f-vpermq-var-2.c: Ditto.
+
+2018-03-29  Sudakshina Das  <sudi.das@arm.com>
+
+	* gcc.target/arm/pr84826.c: Change dg-option to -fstack-check.
+
+	Backport from mainline
+	2018-03-23  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/84826
+	* gcc.target/arm/pr84826.c: Add dg directive.
+
+	Backport from mainline
+	2018-03-22  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/84826
+	* gcc.target/arm/pr84826.c: New test.
+
+2018-03-28  Carl Love  <cel@us.ibm.com>
+
+	* gcc.target/powerpc/crypto-builtin-1-runnable:  Add
+	p8vector_hw to dg-do run.
+
+2018-03-28  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/85084
+	Backport from trunk.
+	* gfortran.dg/matmul_rank_1.f90: New test.
+
+2018-03-28  Sudakshina Das  <sudi.das@arm.com>
+	    Christophe Lyon  <christophe.lyon@linaro.org>
+
+	2018-03-20  Christophe Lyon  <christophe.lyon@linaro.org>
+
+	PR target/81647
+	* gcc.target/aarch64/pr81647.c: Require fenv_exceptions.
+
+	2018-03-19  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/81647
+	* gcc.target/aarch64/pr81647.c: New.
+
+2018-03-28  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2018-03-23  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/85026
+	* g++.dg/pr85026.C: New test.
+
+2018-03-28  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from mainline
+	2018-03-08  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR target/82411
+	* gcc.target/powerpc/ppc-sdata-2.c: Skip if -mno-readonly-in-sdata.
+
+2018-03-27  Sudakshina Das  <sudi.das@arm.com>
+
+	Backport from mainline:
+	2018-03-20  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/82989
+	* gcc.target/arm/pr82989.c: New test.
+
+	Backport from mainline:
+	2018-03-21  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/82989
+	* gcc.target/arm/pr82989.c: Change dg scan-assembly directives.
+
+2018-03-27  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	Backport from mainline
+	2018-03-20  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>
+
+	PR target/82518
+	* lib/target-supports.exp (check_effective_target_vect_load_lanes):
+	Disable for armeb targets.
+	* gcc.target/arm/pr82518.c: New test.
+
+2018-03-23  Carl Love  <cel@us.ibm.com>
+
+	* gcc.target/powerpc/crypto-builtin-1-runnable.c: New test file.
+
+2018-03-22  Tom de Vries  <tom@codesourcery.com>
+
+	backport from trunk:
+	2018-03-22  Tom de Vries  <tom@codesourcery.com>
+
+	PR tree-optimization/84956
+	* gcc.dg/pr84956.c: New test.
+
+2018-03-20  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85001
+	* gfortran.dg/interface_41.f90: New test.
+
+2018-03-19  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/84931
+	Backport from trunk
+	* gfortran.dg/array_constructor_52.f90: New test.
+
+2018-03-19  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/77414
+	* gfortran.dg/pr77414.f90: New test.
+	* gfortran.dg/internal_references_1.f90: Adjust error message.
+
+2018-03-19  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/65453
+	* gfortran.dg/pr65453.f90: New test.
+
+2018-03-19  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-03-15  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/84574
+	* gcc.target/i386/ret-thunk-9.c: Expect __x86_return_thunk
+	label instead of __x86_indirect_thunk label.
+
+2018-03-15  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/78741
+	* gfortran.dg/pr78741.f90: New test.
+
+2018-03-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/83939
+	* gfortran.dg/pr83939.f90
+
+2018-03-12  Richard Sandiford  <richard.sandiford@linaro.org>
+
+	PR tree-optimization/84485
+	* gcc.dg/vect/pr84485.c: New test.
+
+2018-03-10  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/84734
+	* gfortran.dg/pr84734.f90: New test.
+
+2018-03-10  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/prot3.adb: New test.
+	* gnat.dg/prot3_pkg.ad[sb]: New helper.
+
+2018-03-09  Kugan Vivekanandarajah  <kuganv@linaro.org>
+
+	Backport from mainline
+	2017-09-13  Kugan Vivekanandarajah  <kuganv@linaro.org>
+
+	* gcc.target/aarch64/pr63304_1.c: Remove-mno-fix-cortex-a53-843419.
+
+2018-03-08  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/64124
+	PR fortran/70409
+	* gfortran.dg/pr64124.f90: New tests.
+	* gfortran.dg/pr70409.f90: New tests.
+
+2018-03-06  Carl Love  <cel@us.ibm.com>
+
+	Backport from mainline
+	2/16/18  commit 257748  Carl Love  <cel@us.ibm.com>
+
+	* gcc.target/powerpc/p9-vinsert4b-1.c: Remove test file for non-ABI
+	tests.
+	* gcc.target/powerpc/p9-vinsert4b-2.c: Remove test file for non-ABI
+	tests.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-23  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	PR testsuite/80551
+	* c-c++-common/tsan/race_on_mutex.c: Change regexp to allow
+	__GI___pthread_mutex_init as well.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-20  Martin Liska  <mliska@suse.cz>
+
+	PR c/84310
+	PR target/79747
+	* gcc.target/i386/pr84310.c: New test.
+	* gcc.target/i386/pr84310-2.c: Likewise.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-01-23  Martin Liska  <mliska@suse.cz>
+
+	PR lto/81440
+	* gcc.dg/lto/pr81440.h: New test.
+	* gcc.dg/lto/pr81440_0.c: New test.
+	* gcc.dg/lto/pr81440_1.c: New test.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2017-04-27  Martin Liska  <mliska@suse.cz>
+
+	PR testsuite/79455
+	* c-c++-common/tsan/race_on_mutex.c: Make the scanned pattern
+	more generic.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-01-30  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR lto/83954
+	* gcc.dg/lto/pr83954.h: New testcase.
+	* gcc.dg/lto/pr83954_0.c: New testcase.
+	* gcc.dg/lto/pr83954_1.c: New testcase.
+
+2018-03-06  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/56667
+	* gfortran.dg/implied_do_2.f90: New test.
+	* gfortran.dg/coarray_8.f90: Update for new error message.
+
+2018-03-06  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Backport from mainline
+	2018-02-22  Vladimir Makarov  <vmakarov@redhat.com>
+
+	PR target/81572
+	* gcc.target/powerpc/pr81572.c: New.
+
+2018-03-06  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2018-02-28  Richard Biener  <rguenther@suse.de>
+
+	PR middle-end/84607
+	* gcc.dg/pr84607.c: New testcase.
+
+2018-03-05  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	Backport from trunk.
+
+	2018-02-16  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	PR target/84371
+	* gcc.target/powerpc/builtins-3.c: Update dg-options and dg-skip-if
+	stanzas.
+	* gcc.target/powerpc/builtins-3.p8.c: Add dg-skip-if stanza.
+	* gcc.target/powerpc/builtins-3.p9.c: Add dg-skip-if stanza.
+
+2018-03-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/84524
+	* gcc.c-torture/execute/pr84524.c: New test.
+	* gcc.target/i386/avx512bw-pr84524.c: New test.
+
+2018-03-04  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/83076
+	* gfortran.dg/coarray_45.f90: New test.
+
+	PR fortran/83319
+	* gfortran.dg/coarray_46.f90: New test.
+
+2018-03-03  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/71085
+	* gfortran.dg/pr71085.f90: New test.
+
+2018-03-03  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/51434
+	* gfortran.dg/pr51434.f90: New test.
+
+2018-03-03  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/80965
+	* gfortran.dg/select_type_41.f90: New test.
+
+2018-03-03  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from trunk.
+	PR fortran/78990
+	* gfortran.dg/class_67.f90: New test.
+
+2018-03-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-03-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR ipa/84628
+	* gcc.dg/pr84628.c: New test.
+
+	PR inline-asm/84625
+	* gcc.target/i386/pr84625.c: New test.
+
+	2018-03-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/70875
+	* gcc.dg/ubsan/bounds-3.c: Add -fno-sanitize-recover=bounds to
+	dg-options and dg-shouldfail "ubsan" directive.
+
+	2018-02-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84558
+	* g++.dg/cpp1y/pr84558.C: New test.
+
+	PR c++/84557
+	* g++.dg/gomp/pr84557.C: New test.
+
+	PR c++/84556
+	* g++.dg/gomp/pr84556.C: New test.
+	* g++.dg/vect/pr84556.cc: New test.
+
+	2018-02-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/84503
+	* gcc.dg/pr84503-1.c: New test.
+	* gcc.dg/pr84503-2.c: New test.
+
+	2017-11-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR bootstrap/82916
+	* gcc.dg/pr82916.c: New test.
+
+	2018-02-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84445
+	* g++.dg/cpp1z/launder7.C: New test.
+
+	PR c++/84449
+	* g++.dg/cpp0x/constexpr-84449.C: New test.
+
+	2018-02-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84444
+	* g++.dg/cpp1z/launder8.C: New test.
+
+	PR c++/84448
+	* g++.dg/gomp/pr84448.C: New test.
+
+	PR c++/84430
+	* g++.dg/gomp/pr84430.C: New test.
+
+	2018-02-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR ipa/84425
+	* gcc.c-torture/compile/pr84425.c: New test.
+
+	2018-02-16  Marek Polacek  <polacek@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84192
+	* g++.dg/cpp1y/constexpr-84192.C: New test.
+
+	2018-02-13  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/82210
+	* gcc.c-torture/execute/pr82210.c: New test.
+
+	2018-02-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84341
+	* c-c++-common/gomp/pr84341.c: New test.
+
+	2018-02-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/83987
+	* g++.dg/ubsan/pr83987-2.C: New test.
+
+	2018-02-09  Marek Polacek  <polacek@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/83659
+	* g++.dg/torture/pr83659.C: New test.
+
+	2018-02-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84082
+	* g++.dg/template/incomplete11.C: New test.
+	* g++.dg/parse/crash67.C: Expect an incomplete type diagnostics too.
+
+	2018-02-01  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/81661
+	PR tree-optimization/84117
+	* gcc.dg/pr81661.c: New test.
+	* gfortran.dg/pr84117.f90: New test.
+
+	2018-01-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/84116
+	* gfortran.dg/gomp/pr84116.f90: New test.
+
+	PR c++/83993
+	* g++.dg/init/pr83993-2.C: New test.
+
+	PR preprocessor/69869
+	* gcc.dg/cpp/trad/pr69869.c: New test.
+
+	2018-01-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/83986
+	* gcc.dg/pr83986.c: New test.
+
+	2018-01-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84031
+	* g++.dg/cpp1z/decomp36.C: New test.
+
+	2018-01-24  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/83977
+	* c-c++-common/gomp/pr83977-1.c: New test.
+	* c-c++-common/gomp/pr83977-2.c: New test.
+	* c-c++-common/gomp/pr83977-3.c: New test.
+	* gfortran.dg/gomp/pr83977.f90: New test.
+
+	2018-01-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/83987
+	* g++.dg/ubsan/pr83987.C: New test.
+
+	PR c++/83958
+	* g++.dg/cpp1z/decomp35.C: New test.
+
+	2018-01-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/83945
+	* gcc.dg/tls/pr83945.c: New test.
+
+	PR target/83930
+	* gcc.dg/pr83930.c: New test.
+
+	2018-01-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/83824
+	* g++.dg/cpp0x/pr83824.C: New test.
+
+	2018-01-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/83817
+	* g++.dg/cpp1y/pr83817.C: New test.
+
+	2018-01-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/83605
+	* gcc.dg/pr83605.c: New test.
+
+2018-03-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-02-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/84039
+	* gcc.target/i386/indirect-thunk-1.c: Updated.
+	* gcc.target/i386/indirect-thunk-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-5.c: Likewise.
+	* gcc.target/i386/indirect-thunk-6.c: Likewise.
+	* gcc.target/i386/indirect-thunk-7.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-5.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-6.c: Likewise.
+	* gcc.target/i386/indirect-thunk-attr-7.c: Likewise.
+	* gcc.target/i386/indirect-thunk-bnd-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-bnd-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-bnd-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-bnd-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-5.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-6.c: Likewise.
+	* gcc.target/i386/indirect-thunk-extern-7.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-1.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-2.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-3.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-4.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-5.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-6.c: Likewise.
+	* gcc.target/i386/indirect-thunk-inline-7.c: Likewise.
+	* gcc.target/i386/ret-thunk-9.c: Likewise.
+	* gcc.target/i386/ret-thunk-10.c: Likewise.
+	* gcc.target/i386/ret-thunk-11.c: Likewise.
+	* gcc.target/i386/ret-thunk-12.c: Likewise.
+	* gcc.target/i386/ret-thunk-13.c: Likewise.
+	* gcc.target/i386/ret-thunk-14.c: Likewise.
+	* gcc.target/i386/ret-thunk-15.c: Likewise.
+
+2018-03-01  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2018-02-26  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/84530
+	* gcc.target/i386/ret-thunk-22.c: New test.
+	* gcc.target/i386/ret-thunk-23.c: Likewise.
+	* gcc.target/i386/ret-thunk-24.c: Likewise.
+	* gcc.target/i386/ret-thunk-25.c: Likewise.
+	* gcc.target/i386/ret-thunk-26.c: Likewise.
+
+2017-03-02  Thomas Schwinge  <thomas@codesourcery.com>
+
+	Backport from trunk r256891:
+	2018-01-19  Cesar Philippidis  <cesar@codesourcery.com>
+
+	PR target/83790
+	* gcc.target/nvptx/indirect_call.c: New test.
+
+2017-03-01  Thomas Preud'homme  <thomas.preudhomme@arm.com>
+
+	Backport from mainline
+	2017-12-05  Matthew Gretton-Dann  <matthew.gretton-dann@arm.com>
+	with follow-up r255433 commit.
+
+	* gcc.c-torture/unsorted/dump-noaddr.x: Generate dump files in
+	tmpdir.
+
+2018-02-28  Alan Modra  <amodra@gmail.com>
+
+	* lib/prune.exp (prune_gcc_output): Match lower case "in function"
+	GNU ld message.
+	* g++.dg/other/anon5.C: Match lower case "bad value" GNU ld message.
+
+2018-02-26  Carl Love  <cel@us.ibm.com>
+
+	Backport from mainline: commit 257747 on 2018-02-16.
+
+	* gcc.target/powerpc/builtins-7-p9-runnable.c: New runnable test file
+	for the ABI definitions for vec_extract4b and vec_insert4b.
+
+2018-02-26  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/execute/20180226-1.c: New test.
+
+2018-02-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	ChangeLog for r257972
+	PR fortran/83633
+	* gfortran.dg/explicit_shape_1.f90: New test.
+	* gfortran.dg/automatic_module_variable.f90: Update regex.
+	* gfortran.dg/bad_automatic_objects_1.f90: Ditto.
+
+2018-02-25  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/78238
+	Backport from trunk
+	* gfortran.dg/select_type_40.f90: New test.
+
+2018-02-24  Steven G. Kargl <kargl@gcc.gnu.org>
+
+	PR fortran/30792
+	* gfortran.dg/data_substring.f90: New test.
+
+2018-02-23  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/84346
+	* gfortran.dg/statement_function_1.f90: Update test.
+
+2018-02-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/84506
+	* gfortran.dg/inquire_19.f90: New test.
+
+2018-02-22  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/81116
+	PR fortran/84495
+	* gfortran.dg/realloc_on_assignment_29.f90:  New test.
+
+2017-02-22  Sudakshina Das  <sudi.das@arm.com>
+
+	Backport from mainline:
+	2017-12-14  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/81228
+	* gcc.dg/pr81228.c: New.
+
+2018-02-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2018-01-02  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/81860
+	* g++.dg/cpp0x/inh-ctor30.C: New test.
+
+2018-02-18  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk
+	PR libgfortran/84412
+	* gfortran.dg/inquire_18.f90: New test.
+
+2018-02-17  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/84270
+	* gfortran.dg/inline_matmul_22.f90: New test.
+
+2018-02-16  Jozef Lawrynowicz <jozefl.gcc@gmail.com>
+
+	PR target/79242
+	gcc.target/msp430/pr79242.c: New test.
+
+2018-02-16  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/84277
+	* gnat.dg/array11.adb (Array11): Tweak index and remove warning.
+	* gnat.dg/dispatch1.adb: Rename into...
+	* gnat.dg/disp1.adb: ...this.
+	* gnat.dg/dispatch1_p.ads: Rename into...
+	* gnat.dg/disp1_pkg.ads: ...this.
+	* gnat.dg/disp2.adb: Rename into...
+	* gnat.dg/dispatch2.adb: ...this.
+	* gnat.dg/dispatch2_p.ads: Rename into...
+	* gnat.dg/disp2_pkg.ads: ...this.
+	* gnat.dg/dispatch2_p.adb: Rename into...
+	* gnat.dg/disp2_pkg.adb: this.
+	* gnat.dg/generic_dispatch.adb: Rename into...
+	* gnat.dg/generic_disp.adb: this.
+	* gnat.dg/generic_dispatch_p.ads: Rename into...
+	* gnat.dg/generic_disp_pkg.ads: ...this.
+	* gnat.dg/generic_dispatch_p.adb: Rename into...
+	* gnat.dg/generic_disp_pkg.adb: ...this.
+	* gnat.dg/null_pointer_deref1.adb (Null_Pointer_Deref1): Robustify.
+	* gnat.dg/null_pointer_deref2.adb (Null_Pointer_Deref2): Likewise.
+	* gnat.dg/object_overflow1.adb: Tweak index.
+	* gnat.dg/object_overflow2.adb: Likewise.
+	* gnat.dg/object_overflow3.adb: Likewise.
+	* gnat.dg/object_overflow4.adb: Likewise.
+	* gnat.dg/object_overflow5.adb: Likewise.
+
+2018-02-16  Sudakshina Das  <sudi.das@arm.com>
+
+	Backport from trunk
+	2018-01-12  Sudakshina Das  <sudi.das@arm.com>
+
+	* gcc.c-torture/compile/pr82096.c: Add dg-skip-if
+	directive.
+
+	Backport from trunk
+	2018-01-10  Sudakshina Das  <sudi.das@arm.com>
+
+	PR target/82096
+	* gcc.c-torture/compile/pr82096.c: New test.
+
+2018-02-16  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/84190
+	* g++.dg/torture/pr84190.C: New testcase.
+
+2018-02-15  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk
+	2018-02-07  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/84154
+	* gcc.target/powerpc/pr84154-1.c: New tests.
+	* gcc.target/powerpc/pr84154-2.c: Likewise.
+	* gcc.target/powerpc/pr84154-3.c: Likewise.
+
+2018-02-15  Will Schmidt  <will_schmidt@vnet.ibm.com>
+
+	PR target/84388
+	* gcc.target/powerpc/fold-vec-mult-int128-p8.c: Update dg-options
+	and scan-assembler stanzas.
+	* gcc.target/powerpc/fold-vec-mult-int128-p9.c: Same.
+
+2018-02-14  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/84390
+	* gcc.target/powerpc/vsxcopy.c: Also match lxv when compiling
+	with -mcpu=power9.
+
+2018-02-14  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Back port from mainline
+	2018-02-13  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/84279
+	* g++.dg/pr84279.C: New test.
+
+2018-02-12  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/68560
+	* gfortran.dg/shape_9.f90: New test.
+
+2018-02-12  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>
+
+	PR fortran/35299
+	ChangeLog for r257566
+	* gfortran.dg/statement_function_3.f: New test.
+
+2018-02-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/54223
+	PR fortran/84276
+	* gfortran.dg/statement_function_1.f90: New test.
+	* gfortran.dg/statement_function_2.f90: New test.
+
+2018-02-09  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-02-09  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	PR target/PR84295
+	* gcc.target/s390/pr84295.c: New test.
+
+2018-02-08  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-02-08  Andreas Krebbel  <krebbel@linux.vnet.ibm.com>
+
+	* gcc.target/s390/nobp-function-pointer-attr.c: New test.
+	* gcc.target/s390/nobp-function-pointer-nothunk.c: New test.
+	* gcc.target/s390/nobp-function-pointer-z10.c: New test.
+	* gcc.target/s390/nobp-function-pointer-z900.c: New test.
+	* gcc.target/s390/nobp-indirect-jump-attr.c: New test.
+	* gcc.target/s390/nobp-indirect-jump-inline-attr.c: New test.
+	* gcc.target/s390/nobp-indirect-jump-inline-z10.c: New test.
+	* gcc.target/s390/nobp-indirect-jump-inline-z900.c: New test.
+	* gcc.target/s390/nobp-indirect-jump-nothunk.c: New test.
+	* gcc.target/s390/nobp-indirect-jump-z10.c: New test.
+	* gcc.target/s390/nobp-indirect-jump-z900.c: New test.
+	* gcc.target/s390/nobp-return-attr-all.c: New test.
+	* gcc.target/s390/nobp-return-attr-neg.c: New test.
+	* gcc.target/s390/nobp-return-mem-attr.c: New test.
+	* gcc.target/s390/nobp-return-mem-nothunk.c: New test.
+	* gcc.target/s390/nobp-return-mem-z10.c: New test.
+	* gcc.target/s390/nobp-return-mem-z900.c: New test.
+	* gcc.target/s390/nobp-return-reg-attr.c: New test.
+	* gcc.target/s390/nobp-return-reg-mixed.c: New test.
+	* gcc.target/s390/nobp-return-reg-nothunk.c: New test.
+	* gcc.target/s390/nobp-return-reg-z10.c: New test.
+	* gcc.target/s390/nobp-return-reg-z900.c: New test.
+	* gcc.target/s390/nobp-table-jump-inline-z10.c: New test.
+	* gcc.target/s390/nobp-table-jump-inline-z900.c: New test.
+	* gcc.target/s390/nobp-table-jump-z10.c: New test.
+	* gcc.target/s390/nobp-table-jump-z900.c: New test.
+
+2018-02-08  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/84233
+	* g++.dg/torture/pr84233.C: New testcase.
+
+2018-02-07  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/82994
+	* gfortran.dg/deallocate_error_3.f90: New test.
+	* gfortran.dg/deallocate_error_4.f90: New test.
+
+2018-02-07  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/82049
+	* gfortran.dg/assumed_charlen_parameter.f90: New test.
+
+2018-02-07  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	Backport from mainline
+	2018-02-06  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	* gcc.target/powerpc/safe-indirect-jump-1.c: Detect deprecation
+	warning for -mno-speculate-indirect-jumps.
+	* gcc.target/powerpc/safe-indirect-jump-2.c: Likewise.
+	* gcc.target/powerpc/safe-indirect-jump-3.c: Likewise.
+	* gcc.target/powerpc/safe-indirect-jump-4.c: Likewise.
+	* gcc.target/powerpc/safe-indirect-jump-5.c: Likewise.
+	* gcc.target/powerpc/safe-indirect-jump-6.c: Likewise.
+	* gcc.target/powerpc/safe-indirect-jump-7.c: Likewise.
+
+2018-02-06  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR target/79975
+	* gcc.dg/rtl/x86_64/final.c: Add -fdwarf2-cfi-asm to dg-options.
+
+2017-02-02  Uros Bizjak  <ubizjak@gmail.com>
+
+	* gfortran.dg/dec_parameter_1.f (sub1): Remove statement with no effect.
+	* gfortran.dg/dec_parameter_2.f90 (sub1): Ditto.
+
+2018-02-01  Renlin Li  <renlin.li@arm.com>
+
+	Backport from mainline
+	2018-02-01  Richard Sandiford  <richard.sandiford@linaro.org>
+
+	PR target/83370
+	* gcc.target/aarch64/pr83370.c: New.
+
+2018-02-01  Richard Biener  <rguenther@suse.de>
+
+	Backport from mainline
+	2017-11-02  Richard Biener  <rguenther@suse.de>
+
+	PR tree-optimization/82795
+	* gcc.target/i386/pr82795.c: New testcase.
+
+2018-02-01  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline
+	2018-01-12  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* lib/target-supports.exp (check_effective_target_avx512f): Also
+	check for __builtin_ia32_addsd_round,
+	__builtin_ia32_getmantsd_round.
+	* gcc.target/i386/i386.exp (check_effective_target_avx512f):
+	Remove.
+
+2018-01-31  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.c-torture/execute/20180131-1.c: New test.
+
+2018-01-29  Alan Modra  <amodra@gmail.com>
+
+	PR target/84033
+	* gcc.target/powerpc/swaps-p8-46.c: New.
+
+2018-01-26  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	Backport from trunk
+	2018-01-26  Segher Boessenkool  <segher@kernel.crashing.org>
+
+	* gcc.target/powerpc/safe-indirect-jump-1.c: Build on all targets.
+	Make expected output depend on whether we expect sibcalls or not.
+	* gcc.target/powerpc/safe-indirect-jump-8.c: Delete (merged into
+	safe-indirect-jump-1.c).
+
+	Backport from trunk
+	2018-01-21  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>
+
+	PR target/83946
+	* gcc.target/powerpc/safe-indirect-jump-8.c: Skip for AIX.
+
+2018-01-26  Nathan Sidwell  <nathan@acm.org>
+
+	PR c++/82878
+	* g++.dg/cpp0x/pr82878.C: New.
+	* g++.dg/cpp1z/inh-ctor38.C: Check moves too.
+
+2018-01-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/83985
+	* gcc.dg/pr83985.c: New test.
+
+2018-01-25  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	Back port from trunk
+	2018-01-22  Michael Meissner  <meissner@linux.vnet.ibm.com>
+
+	PR target/83862
+	* gcc.target/powerpc/pr83862.c: New test.
+
+2018-01-25  Peter Bergner  <bergner@vnet.ibm.com>
+
+	Back port from mainline
+	2018-01-10  Peter Bergner  <bergner@vnet.ibm.com>
+
+	PR target/83399
+	* gcc.target/powerpc/pr83399.c: New test.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
@@ -920,7 +2570,7 @@
 
 	Backported from trunk
 	PR fortran/80850
-	* gfortran.dg/class_64_f90 : New test.
+	* gfortran.dg/class_64_f90: New test.
 
 2017-10-30  Paolo Carlini  <paolo.carlini@oracle.com>
 
@@ -971,7 +2621,7 @@
 
 	Backport from trunk
 	PR fortran/82312
-	* gfortran.dg/typebound_proc_36.f90 : New test.
+	* gfortran.dg/typebound_proc_36.f90: New test.
 
 2017-10-20  Thomas Koenig  <tkoenig@gcc.gnu.org>
 
Index: gcc/testsuite/go.dg/pr85436.go
===================================================================
diff --git a/gcc/testsuite/go.dg/pr85436.go b/gcc/testsuite/go.dg/pr85436.go
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/go.dg/pr85436.go	(revision 262353)
@@ -0,0 +1,21 @@
+/* { dg-do compile } */
+/* { dg-options "-O3 -mcpu=power9" { target { powerpc*-*-* } } } */
+
+package main
+import (
+	"go/ast"
+	"go/parser"
+	"go/token"
+)
+type testFuncs struct { }
+func (t *testFuncs) load(filename, pkg string, doImport, seen *bool) {
+	var testFileSet = token.NewFileSet()
+	f, err := parser.ParseFile(testFileSet, filename, nil, parser.ParseComments)
+	if err != nil { }
+	for _, d := range f.Decls {
+		n, ok := d.(*ast.FuncDecl)
+		if !ok { }
+		ptr := n.Type.Params.List[0].Type.(*ast.StarExpr)
+		if sel := ptr.X.(*ast.SelectorExpr); sel.Sel.Name == "M" { }
+	}
+}
Index: gcc/testsuite/gfortran.fortran-torture/compile/pr85878.f90
===================================================================
diff --git a/gcc/testsuite/gfortran.fortran-torture/compile/pr85878.f90 b/gcc/testsuite/gfortran.fortran-torture/compile/pr85878.f90
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/gfortran.fortran-torture/compile/pr85878.f90	(revision 262353)
@@ -0,0 +1,8 @@
+! PR middle-end/85878
+
+program pr85878
+  real :: a
+  complex :: c = (2.0, 3.0)
+  print *, c
+  print *, transfer (a, c)
+end
Index: gcc/testsuite/g++.dg/opt/pr85196.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/opt/pr85196.C b/gcc/testsuite/g++.dg/opt/pr85196.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/opt/pr85196.C	(revision 262353)
@@ -0,0 +1,89 @@
+// PR target/85196
+// Testcase by Rainer Orth <ro@gcc.gnu.org>
+
+// { dg-do compile }
+// { dg-options "-O -fpermissive -w" }
+// { dg-additional-options "-fPIC" { target fpic } }
+
+class a;
+template <typename> class b;
+template <typename k> class d : public b<k> {};
+class e {};
+void f(int);
+template <class> class g {
+public:
+  h();
+  a i();
+};
+template <> class b<e> : public g<e> {};
+typedef (*j)(d<e>);
+template <class k> class l {
+public:
+  k operator->() { return 0; }
+};
+enum m { n, aa, o, ab, q, p };
+inline s(m ac) {
+  switch (ac) {
+  case n:
+  case aa:
+  case p:
+    return 1;
+  case o:
+  case ab:
+    return 2;
+  }
+}
+class D {
+  int ad;
+
+public:
+  *ae() { return &ad; }
+};
+class a {
+  l<D *> af;
+
+public:
+  *r() { return af->ae(); }
+  t(int *c) {
+    int *w = af->ae();
+    return w == c;
+  }
+};
+class F : a {
+public:
+  static int ah[];
+  static e v(F *);
+  unsigned long ai() const;
+};
+inline unsigned long F::ai() const {
+  m aj = r() - &ah[0];
+  return s(aj);
+}
+inline e F::v(F *ak) {
+  long al = ak->ai();
+  f(al);
+}
+template <typename> am() { return q; }
+class an : F {
+public:
+  static ao(d<e> u) {
+    int *ap;
+    m aq = am<unsigned>();
+    ap = &ah[aq];
+    return u.h() && u.i().t(ap);
+  }
+  template <e ar(F *)> static as() {
+    F at;
+    ar(&at);
+  }
+  template <e ar(F *)> static au(int *, unsigned, e *) {
+    j av = ao;
+    d<e> aw;
+    if (av(aw))
+      as<ar>();
+  }
+};
+int *ax;
+int ay;
+e az;
+ba() { an::au<an::v>(ax, ay, &az); }
Index: gcc/testsuite/g++.dg/opt/pr79085.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/opt/pr79085.C b/gcc/testsuite/g++.dg/opt/pr79085.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/opt/pr79085.C	(revision 262353)
@@ -0,0 +1,24 @@
+// PR c++/79085
+// { dg-do compile }
+// { dg-options "-Os" }
+// { dg-additional-options "-mstrict-align" { target { aarch64*-*-* powerpc*-*-linux* powerpc*-*-elf* } } }
+
+void *operator new (__SIZE_TYPE__, void *p) { return p; }
+
+struct S
+{
+  S ();
+  S (const S &);
+  ~S (void);
+  int i;
+};
+
+S foo ();
+
+static char buf [sizeof (S) + 1];
+
+S *
+bar ()
+{
+  return new (buf + 1) S (foo ());
+}
Index: gcc/testsuite/g++.dg/pr85026.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/pr85026.C b/gcc/testsuite/g++.dg/pr85026.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/pr85026.C	(revision 262353)
@@ -0,0 +1,61 @@
+/* PR target/85026.  */
+/* { dg-do assemble } */
+/* { dg-options "-O2 -std=gnu++11" } */
+
+template <class> class a;
+class b;
+struct c {
+  typedef a<b> &g;
+};
+template <typename d> struct e { typedef typename d::f iter; };
+class h {
+public:
+  void __attribute__((noreturn)) i();
+} ab;
+template <class> class a {
+public:
+  typedef b *f;
+  b &operator[](unsigned m) {
+    if (ac)
+      ab.i();
+    return ad[m];
+  }
+  f n() { return ad; }
+  f m_fn3();
+  b *ad;
+  unsigned ac;
+};
+class b {
+public:
+  short j;
+  short k;
+  signed l;
+} __attribute__((__packed__));
+void o(a<b> &m, b &p2, b &p) {
+  p2 = p = m[0];
+  if (bool at = false)
+    ;
+  else
+    for (c::g au(m);; at = true)
+      if (bool av = false)
+        ;
+      else
+        for (e<a<int>>::iter aw = au.n(), ax = au.m_fn3(); ax;
+             av ? (void)0 : (void)0)
+          if (bool ay = 0)
+            ;
+          else
+            for (b az = *aw; !ay; ay = true) {
+              if (p2.j)
+                p2.j = az.j;
+              else if (p.j)
+                p.j = az.j;
+              if (p2.k)
+                p2.k = az.k;
+              else if (az.k > p.k)
+                p.k = az.k;
+              if (az.l < p2.l)
+                if (az.l > p.l)
+                  p.l = az.l;
+            }
+}
Index: gcc/testsuite/g++.dg/ubsan/pr83987-2.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/ubsan/pr83987-2.C b/gcc/testsuite/g++.dg/ubsan/pr83987-2.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/ubsan/pr83987-2.C	(revision 262353)
@@ -0,0 +1,24 @@
+// PR sanitizer/83987
+// { dg-do compile { target fopenmp } }
+// { dg-options "-fopenmp -fsanitize=vptr" }
+
+struct A
+{
+  int i;
+};
+
+struct B : virtual A
+{
+  void foo();
+};
+
+void B::foo()
+{
+#pragma omp parallel
+  {
+  #pragma omp sections lastprivate (i)
+    {
+      i = 0;
+    }
+  }
+}
Index: gcc/testsuite/g++.dg/ubsan/pr83987.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/ubsan/pr83987.C b/gcc/testsuite/g++.dg/ubsan/pr83987.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/ubsan/pr83987.C	(revision 262353)
@@ -0,0 +1,15 @@
+// PR sanitizer/83987
+// { dg-do compile { target fopenmp } }
+// { dg-options "-fopenmp -fsanitize=vptr -O0" }
+
+struct A { int i; };
+struct B : virtual A { void foo (); };
+
+void
+B::foo ()
+{
+#pragma omp sections lastprivate (i)
+  {
+    i = 0;
+  }
+}
Index: gcc/testsuite/g++.dg/pr84279.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/pr84279.C b/gcc/testsuite/g++.dg/pr84279.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/pr84279.C	(revision 262353)
@@ -0,0 +1,35 @@
+/* { dg-do compile { target { powerpc*-*-* } } } */
+/* { dg-skip-if "" { powerpc*-*-darwin* } } */
+/* { dg-require-effective-target powerpc_p8vector_ok } */
+/* { dg-skip-if "do not override -mcpu" { powerpc*-*-* } { "-mcpu=*" } { "-mcpu=power8" } } */
+/* { dg-options "-O3 -mcpu=power8 -g -fPIC -fvisibility=hidden -fstack-protector-strong" } */
+
+template <typename, typename T> struct E { T e; };
+struct J {
+  unsigned k, l;
+  J (unsigned x, unsigned y) : k(x), l(y) {}
+};
+typedef struct A {
+  J n, p;
+  A ();
+  A (J x, J y) : n(x), p(y) {}
+} *S;
+S t;
+struct B {
+  struct C {
+    S q, r;
+    int u, v;
+    bool m1 (S, A &);
+    J m2 () const;
+    J m3 () const;
+    A m4 () const;
+  };
+  typedef E<unsigned, S> D;
+  void m5 (D *);
+  void m6 (unsigned, A);
+};
+bool B::C::m1 (S, A &x) { bool o; x = m4 (); return o; }
+J B::C::m2 () const { unsigned g (u == 0); unsigned h (v); return J (g, h); }
+J B::C::m3 () const { unsigned g (q != t); unsigned h (r != t); return J (g, h); }
+A B::C::m4 () const { return A (m2 (), m3 ()); }
+void B::m5 (D *c) { unsigned x; C ar; A am; if (ar.m1 (c->e, am)) m6 (x, am); }
Index: gcc/testsuite/g++.dg/diagnostic/pr85464.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/diagnostic/pr85464.C b/gcc/testsuite/g++.dg/diagnostic/pr85464.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/diagnostic/pr85464.C	(revision 262353)
@@ -0,0 +1,5 @@
+// { dg-options "-Wignored-qualifiers" }
+struct Test {
+   operator int const(); // { dg-warning "type qualifiers ignored" }
+   operator int const() const; // { dg-warning "type qualifiers ignored" }
+};
Index: gcc/testsuite/g++.dg/parse/crash67.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/parse/crash67.C b/gcc/testsuite/g++.dg/parse/crash67.C
--- a/gcc/testsuite/g++.dg/parse/crash67.C	(revision 262353)
+++ b/gcc/testsuite/g++.dg/parse/crash67.C	(revision 262353)
@@ -2,4 +2,4 @@
 
 class x0;
 template <x1> x2() {  // { dg-error "declared|type" }
-x0 x3 = x3.  // { dg-error "expected" }
+x0 x3 = x3.  // { dg-error "expected|incomplete type" }
Index: gcc/testsuite/g++.dg/parse/array-size2.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/parse/array-size2.C b/gcc/testsuite/g++.dg/parse/array-size2.C
--- a/gcc/testsuite/g++.dg/parse/array-size2.C	(revision 262353)
+++ b/gcc/testsuite/g++.dg/parse/array-size2.C	(revision 262353)
@@ -15,6 +15,6 @@
 foo (void)
 {
   char g[(char *) &((struct S *) 0)->b - (char *) 0]; // { dg-error "constant" }
-  char h[(__SIZE_TYPE__) &((struct S *) 8)->b];	      // { dg-error "constant" "" { xfail *-*-* } }
+  char h[(__SIZE_TYPE__) &((struct S *) 8)->b];	      // { dg-error "constant" }
   bar (g, h);
 }
Index: gcc/testsuite/g++.dg/cpp0x/lambda/lambda-mangle5.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-mangle5.C b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-mangle5.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-mangle5.C	(revision 262353)
@@ -0,0 +1,15 @@
+// { dg-do compile { target c++11 } }
+// { dg-final { scan-assembler "_ZZN1AIiEC4IiEET_S2_Ed_NKUlvE_clEv" } }
+
+template <class T> struct A
+{
+  template <class U>
+  A(U, U = []{ return 42; }());
+};
+
+struct B: A<int>
+{
+  using A::A;
+};
+
+B b(24);
Index: gcc/testsuite/g++.dg/cpp0x/lambda/lambda-dependent1.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-dependent1.C b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-dependent1.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-dependent1.C	(revision 262353)
@@ -0,0 +1,19 @@
+// PR c++/85815
+// { dg-do compile { target c++11 } }
+
+template<class T>
+class A {
+    static A* INSTANCE;
+    void foobar();
+    void moo() {}
+};
+
+template<class T>
+A<T>* A<T>::INSTANCE = nullptr;
+
+template<class T>
+void A<T>::foobar() {
+    auto x = []() {
+        INSTANCE->moo();
+    };
+}
Index: gcc/testsuite/g++.dg/cpp0x/gen-attrs-64.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/gen-attrs-64.C b/gcc/testsuite/g++.dg/cpp0x/gen-attrs-64.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/gen-attrs-64.C	(revision 262353)
@@ -0,0 +1,4 @@
+// PR c++/85140
+// { dg-do compile { target c++11 } }
+
+namespace N alignas() {}	// { dg-error "expected" }
Index: gcc/testsuite/g++.dg/cpp0x/constexpr-84463.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-84463.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-84463.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-84463.C	(revision 262353)
@@ -0,0 +1,22 @@
+// PR c++/84463
+// { dg-do compile { target c++11 } }
+
+struct S { int r; const unsigned char s[5]; };
+static constexpr S a[] = { { 0, "abcd" } };
+struct T { const unsigned char s[5]; };
+static constexpr T b[] = { { "abcd" } };
+
+constexpr int
+foo (const unsigned char *x)
+{
+  return x[0];
+}
+
+constexpr static const S *j = &a[0];
+constexpr static const int k = j->s[0];
+constexpr static int l = foo (a[0].s);
+constexpr static int m = foo (j->s);
+constexpr static const T *n = &b[0];
+constexpr static const int o = n->s[0];
+constexpr static int p = foo (b[0].s);
+constexpr static int q = foo (n->s);
Index: gcc/testsuite/g++.dg/cpp0x/constexpr-84449.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-84449.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-84449.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-84449.C	(revision 262353)
@@ -0,0 +1,14 @@
+// PR c++/84449
+// { dg-do compile { target c++11 } }
+
+struct A
+{
+  constexpr A (int) {}
+  ~A () = delete;
+};
+
+struct B
+{
+  A a;
+  constexpr B () : a (0) {}	// { dg-error "use of deleted function" }
+};
Index: gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-2.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-2.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-2.C
--- a/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-2.C	(revision 262353)
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-2.C	(revision 262353)
@@ -192,12 +192,11 @@
 constexpr S* ps1 = ps;
 constexpr S* ps2 = ps1;
 
-// The following aren't diagnosed due to a bug.
-// constexpr int* pi0 = &((S*)0)->i;
-// constexpr int* pi1 = &((S*)nullptr)->i;
+constexpr int* pi0 = &((S*)0)->i;	// { dg-error "null pointer|not a constant" }
+constexpr int* pi1 = &((S*)nullptr)->i;	// { dg-error "null pointer|not a constant" }
 
-constexpr int* pj0 = &((S*)0)->j;	// { dg-error "not a constant expression" }
-constexpr int* pj1 = &((S*)nullptr)->j;  // { dg-error "not a constant expression" }
+constexpr int* pj0 = &((S*)0)->j;	// { dg-error "null pointer|not a constant" }
+constexpr int* pj1 = &((S*)nullptr)->j;	// { dg-error "null pointer|not a constant" }
 
 constexpr int* psi = &ps->i;	    // { dg-error "null pointer|not a constant" }
 constexpr int* psj = &ps->j;	    // { dg-error "null pointer|not a constant" }
Index: gcc/testsuite/g++.dg/cpp0x/pr83824.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/pr83824.C b/gcc/testsuite/g++.dg/cpp0x/pr83824.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/pr83824.C	(revision 262353)
@@ -0,0 +1,9 @@
+// PR c++/83824
+// { dg-do compile { target c++11 } }
+
+void
+foo ()
+{
+  if (alignas(1 alignas(1)))	// { dg-error "expected" }
+    ;
+}
Index: gcc/testsuite/g++.dg/cpp0x/extern_template-4.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/extern_template-4.C b/gcc/testsuite/g++.dg/cpp0x/extern_template-4.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/extern_template-4.C	(revision 262353)
@@ -0,0 +1,23 @@
+// PR c++/85470
+// { dg-do compile { target c++11 } }
+
+template <class T>
+struct StaticObject
+{
+    static T& create()
+    {
+      static T t;
+      return t;
+    }
+
+    static T & instance;
+};
+
+template <class T> T & StaticObject<T>::instance = StaticObject<T>::create();
+
+extern template class StaticObject<int>;
+
+void test()
+{
+    StaticObject<int>::instance;
+}
Index: gcc/testsuite/g++.dg/cpp0x/decltype43.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/decltype43.C b/gcc/testsuite/g++.dg/cpp0x/decltype43.C
--- a/gcc/testsuite/g++.dg/cpp0x/decltype43.C	(revision 262353)
+++ b/gcc/testsuite/g++.dg/cpp0x/decltype43.C	(revision 262353)
@@ -22,6 +22,6 @@
 int main()
 {
   int x = B<decltype(A<int>::a(1))>::b(A<int>::a(1));
-  int y = B<decltype(A     ::a(2))>::b(A<int>::a(2)); // { dg-error "template argument" }
+  int y = B<decltype(A     ::a(2))>::b(A<int>::a(2)); // { dg-error "template" }
   return x + y;
 }
Index: gcc/testsuite/g++.dg/cpp0x/ref-qual18.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/ref-qual18.C b/gcc/testsuite/g++.dg/cpp0x/ref-qual18.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/ref-qual18.C	(revision 262353)
@@ -0,0 +1,18 @@
+// PR c++/71784
+// { dg-do compile { target c++11 } }
+
+template<typename T> struct A {
+  template<typename U> void f(U const&) & { }
+  template<typename U> void f(U const&) && { }
+};
+
+template void A<int>::f<int>(int const&) &;
+template void A<float>::f<int>(int const&) &&;
+
+template<typename T> struct B {
+  void f(int const&) & { }
+  void f(int const&) && { }
+};
+
+template void B<int>::f(int const&) &;
+template void B<float>::f(int const&) &&;
Index: gcc/testsuite/g++.dg/cpp0x/sfinae60.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/sfinae60.C b/gcc/testsuite/g++.dg/cpp0x/sfinae60.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/sfinae60.C	(revision 262353)
@@ -0,0 +1,25 @@
+// PR c++/78489
+// { dg-do compile { target c++11 } }
+
+template <bool P, class T = void> struct enable_if { using type = T; };
+template <class T> struct enable_if<false, T> {};
+
+template <class Dummy> struct use_type { using type = int; };
+
+template <bool Pred>
+struct get_type {
+    static_assert(Pred, "");
+    using type = int;
+};
+
+template <bool Val,
+              class      = typename enable_if<Val>::type, // Evaluation/Substitution should end here
+              class ValT = typename get_type<Val>::type,  // This should not be instantiated
+              typename use_type<ValT>::type = 0           // This NTTP causes ValT to be required
+            >
+constexpr bool test(int) { return false; }
+
+template <bool>
+constexpr bool test(long) { return true; }
+
+static_assert(test<false>(0), ""); // should call test(long)
Index: gcc/testsuite/g++.dg/cpp0x/fntmpdefarg8.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/fntmpdefarg8.C b/gcc/testsuite/g++.dg/cpp0x/fntmpdefarg8.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/fntmpdefarg8.C	(revision 262353)
@@ -0,0 +1,10 @@
+// PR c++/80227
+// { dg-do compile { target c++11 } }
+
+template <class T>
+int foo (T);
+
+template <class T, class U = T [sizeof (T) - 5]>
+int foo (T, U* = 0);
+
+int i = foo (123);
Index: gcc/testsuite/g++.dg/cpp0x/variadic-nested3.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/variadic-nested3.C b/gcc/testsuite/g++.dg/cpp0x/variadic-nested3.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/variadic-nested3.C	(revision 262353)
@@ -0,0 +1,10 @@
+// PR c++/71834
+// { dg-do compile { target c++11 } }
+
+template < typename ... Ts > struct A 
+{
+  template < Ts ..., typename U > struct B {};
+};
+
+// should be, e.g.: A < int >::B < 0, int > e; 
+A < int >::B < 0 > e;	   // { dg-error "wrong number of template arguments" }
Index: gcc/testsuite/g++.dg/cpp0x/decltype67.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/decltype67.C b/gcc/testsuite/g++.dg/cpp0x/decltype67.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/decltype67.C	(revision 262353)
@@ -0,0 +1,7 @@
+// PR c++/85279
+// { dg-do compile { target c++11 } }
+
+template<typename T> struct A
+{
+  void foo(decltype(T())::Y);	// { dg-error {decltype\(T\(\)\)::Y} }
+};
Index: gcc/testsuite/g++.dg/cpp0x/noexcept33.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/noexcept33.C b/gcc/testsuite/g++.dg/cpp0x/noexcept33.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/noexcept33.C	(revision 262353)
@@ -0,0 +1,28 @@
+// PR c++/86378
+// { dg-do compile { target c++11 } }
+
+struct Pepper {};
+struct Apple { Apple(int) {} };
+
+struct Combination : Apple, Pepper
+{
+  Combination(Pepper p, Apple a)
+    : Apple(a), Pepper(p)
+  {}
+};
+
+struct MyCombination
+{
+  using Spice = Pepper;
+  using Fruit = Apple;
+
+  Combination combination;
+
+  template<typename T>
+  constexpr MyCombination(T&& t)
+  noexcept(noexcept(Combination(Spice(), Fruit(t))))
+    : combination(Spice(), Fruit(t))
+  {}
+};
+
+MyCombination obj(Apple(4));
Index: gcc/testsuite/g++.dg/cpp0x/constexpr-list2.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-list2.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-list2.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-list2.C	(revision 262353)
@@ -0,0 +1,20 @@
+// PR c++/82461
+// { dg-do compile { target c++11 } }
+
+class A {
+private:
+public:
+  constexpr A() {}
+  ~A() {}
+};
+
+class B {
+private:
+  A  a;
+public:
+  constexpr B() : a{} {}
+// works
+// constexpr B() : a() {}
+
+  ~B() {}
+};
Index: gcc/testsuite/g++.dg/cpp0x/elision3.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/elision3.C b/gcc/testsuite/g++.dg/cpp0x/elision3.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/elision3.C	(revision 262353)
@@ -0,0 +1,21 @@
+// PR c++/84441
+// { dg-do compile { target c++11 } }
+
+struct B {
+  int *b;
+};
+struct A {
+  B b;
+  A (A &&);
+};
+struct C {
+  A c;
+  int d;
+};
+C bar ();
+struct D : C {
+  D ()
+    : C (0 ? bar () : bar ())
+  {}
+};
+D d;
Index: gcc/testsuite/g++.dg/cpp0x/initlist98.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/initlist98.C b/gcc/testsuite/g++.dg/cpp0x/initlist98.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/initlist98.C	(revision 262353)
@@ -0,0 +1,17 @@
+// PR c++/83227
+// { dg-do compile { target c++11 } }
+
+#include <initializer_list>
+
+template <typename d> struct f {
+  f(std::initializer_list<d>) {}
+};
+
+struct h {};
+struct i : h {
+  i();
+};
+void foo(f<h>);
+int main() {
+  foo({i{}});
+}
Index: gcc/testsuite/g++.dg/cpp0x/inh-ctor30.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/inh-ctor30.C b/gcc/testsuite/g++.dg/cpp0x/inh-ctor30.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/inh-ctor30.C	(revision 262353)
@@ -0,0 +1,27 @@
+// PR c++/81860
+// { dg-do compile { target c++11 } }
+// { dg-final { scan-assembler "_ZN1AIjEC\[12\]Ev" } }
+
+template <typename T>
+struct A
+{
+  A() {}
+};
+
+struct B
+{
+  template <typename D>
+  B(D, const A<unsigned>& a = A<unsigned>()) : a(a) {}
+
+  A<unsigned> a;
+};
+
+struct C : B
+{
+  using B::B;
+};
+
+int main()
+{
+  C c(0);
+}
Index: gcc/testsuite/g++.dg/cpp0x/pr85147.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/pr85147.C b/gcc/testsuite/g++.dg/cpp0x/pr85147.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/pr85147.C	(revision 262353)
@@ -0,0 +1,9 @@
+// PR c++/85147
+// { dg-do compile { target c++11 } }
+
+template<typename T> struct A
+{
+  template<template<...T> class...> struct B {};	// { dg-error "expected|mismatch" }
+};
+
+A<int>::B<> b;						// { dg-error "does not name a template type" }
Index: gcc/testsuite/g++.dg/cpp0x/range-for9.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/range-for9.C b/gcc/testsuite/g++.dg/cpp0x/range-for9.C
--- a/gcc/testsuite/g++.dg/cpp0x/range-for9.C	(revision 262353)
+++ b/gcc/testsuite/g++.dg/cpp0x/range-for9.C	(revision 262353)
@@ -5,6 +5,6 @@
 void test()
 {
     int a[] = {0,1,2};
-    for (int x : a)  // { dg-error "range-based 'for'" }
+    for (int x : a)  // { dg-error "range-based 'for'|forming reference" }
         ;
 }
Index: gcc/testsuite/g++.dg/cpp0x/auto51.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/auto51.C b/gcc/testsuite/g++.dg/cpp0x/auto51.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/auto51.C	(revision 262353)
@@ -0,0 +1,9 @@
+// PR c++/84798
+// { dg-do compile { target c++11 } }
+
+template<typename T>
+struct S {
+    static constexpr T value = 0;
+};
+
+constexpr auto x = S<void(*)(auto)>::value; // { dg-error "auto" }
Index: gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-1.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-1.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-1.C
--- a/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-1.C	(revision 262353)
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-nullptr-1.C	(revision 262353)
@@ -6,7 +6,7 @@
 // c++/67376 on gcc-patches for additional background.
 
 // { dg-do compile { target c++11 } }
-// { dg-options "-fdelete-null-pointer-checks -fdump-tree-optimized" }
+// { dg-options "-O1 -fdelete-null-pointer-checks -fdump-tree-optimized" }
 
 // Runtime assert.  Used for potentially invalid expressions.
 #define RA(e)  ((e) ? (void)0 : __builtin_abort ())
Index: gcc/testsuite/g++.dg/cpp0x/constexpr-ctor21.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/constexpr-ctor21.C b/gcc/testsuite/g++.dg/cpp0x/constexpr-ctor21.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/constexpr-ctor21.C	(revision 262353)
@@ -0,0 +1,15 @@
+// PR c++/83835
+// { dg-do compile { target c++11 } }
+
+struct Z
+{
+  void const * p_;
+  constexpr Z( void const * p ): p_( p ) {}
+  ~Z();
+};
+
+struct Y
+{
+  Z z_;
+  constexpr Y() noexcept: z_( this ) {}
+};
Index: gcc/testsuite/g++.dg/cpp0x/decltype-33837.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/decltype-33837.C b/gcc/testsuite/g++.dg/cpp0x/decltype-33837.C
--- a/gcc/testsuite/g++.dg/cpp0x/decltype-33837.C	(revision 262353)
+++ b/gcc/testsuite/g++.dg/cpp0x/decltype-33837.C	(revision 262353)
@@ -2,6 +2,6 @@
 // PR c++/33837
 void foo()
 {
-  __decltype (A::foo()); // { dg-error "was not declared|expected" }
-  __decltype (B); // { dg-error "was not declared" }
+  __decltype (A::foo()); // { dg-error "A" }
+  __decltype (B); // { dg-error "B" }
 }
Index: gcc/testsuite/g++.dg/cpp0x/range-for13.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/range-for13.C b/gcc/testsuite/g++.dg/cpp0x/range-for13.C
--- a/gcc/testsuite/g++.dg/cpp0x/range-for13.C	(revision 262353)
+++ b/gcc/testsuite/g++.dg/cpp0x/range-for13.C	(revision 262353)
@@ -3,16 +3,6 @@
 
 // { dg-do compile { target c++11 } }
 
-//These should not be used
-template<typename T> int *begin(T &t)
-{
-    T::fail;
-}
-template<typename T> int *end(T &t)
-{
-    T::fail;
-}
-
 struct container1
 {
     int *begin();
@@ -87,10 +77,37 @@
     static function end;
 };
 
+namespace N
+{
+template<typename T> int *begin(T &t)
+{
+    return 0;
+}
+template<typename T> int *end(T &t)
+{
+    return 0;
+}
+struct container11
+{
+    int *begin();
+    //no end
+};
+
+struct container12
+{
+    int *end();
+    //no begin
+};
+
+struct container13
+{
+};
+}
+
 void test1()
 {
-  for (int x : container1()); // { dg-error "member but not" }
-  for (int x : container2()); // { dg-error "member but not" }
+  for (int x : container1()); // { dg-error "'begin' was not declared|'end' was not declared" }
+  for (int x : container2()); // { dg-error "'begin' was not declared|'end' was not declared" }
   for (int x : container3()); // { dg-error "within this context" }
   for (int x : container4()); // { dg-error "cannot be used as a function" }
   for (int x : container5()); // { dg-error "invalid use of" }
@@ -99,4 +116,7 @@
   for (int x : container8());
   for (int x : container9()); // { dg-error "within this context" }
   for (int x : container10());
+  for (int x : N::container11());
+  for (int x : N::container12());
+  for (int x : N::container13());
 }
Index: gcc/testsuite/g++.dg/cpp0x/nsdmi14.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/nsdmi14.C b/gcc/testsuite/g++.dg/cpp0x/nsdmi14.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/nsdmi14.C	(revision 262353)
@@ -0,0 +1,19 @@
+// PR c++/71638
+// { dg-do compile { target c++11 } }
+// { dg-options "-Wall" }
+
+struct A {
+  struct {
+    int i;
+    int &j = i;
+  } b;
+  int a = b.j;
+};
+
+void bar (A);
+
+void
+foo ()
+{
+  bar (A{});
+}
Index: gcc/testsuite/g++.dg/cpp0x/variadic-nested2.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/variadic-nested2.C b/gcc/testsuite/g++.dg/cpp0x/variadic-nested2.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/variadic-nested2.C	(revision 262353)
@@ -0,0 +1,9 @@
+// PR c++/84839
+// { dg-do compile { target c++11 } }
+
+template<typename... T>
+struct S {
+    using fptr = void(*)(T... x, decltype(x)... y);
+};
+
+using F = S<int>::fptr;
Index: gcc/testsuite/g++.dg/cpp0x/nsdmi-empty1.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/nsdmi-empty1.C b/gcc/testsuite/g++.dg/cpp0x/nsdmi-empty1.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/nsdmi-empty1.C	(revision 262353)
@@ -0,0 +1,18 @@
+// PR c++/82764
+// { dg-do compile { target c++11 } }
+
+struct Empty {};
+struct Empty2 : Empty {};
+
+struct A : Empty2
+{
+  int x {1};
+  int y {2};
+};
+
+struct B
+{
+  A a {};
+};
+
+B b;
Index: gcc/testsuite/g++.dg/cpp0x/auto-60626.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/auto-60626.C b/gcc/testsuite/g++.dg/cpp0x/auto-60626.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/auto-60626.C	(revision 262353)
@@ -0,0 +1,6 @@
+// PR c++/60626
+// { dg-do compile { target c++14 } }
+
+struct A {};
+
+void (*A::p)(auto) = 0;  // { dg-error "auto|static data member|template" }
Index: gcc/testsuite/g++.dg/cpp0x/range-for35.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/range-for35.C b/gcc/testsuite/g++.dg/cpp0x/range-for35.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/range-for35.C	(revision 262353)
@@ -0,0 +1,8 @@
+// PR c++/86060
+// { dg-options -Wpedantic }
+
+template <typename T> void foo(T (&a)[8]) {
+  for (int i : a)		// { dg-warning "range-based" "" { target c++98_only } }
+    i;
+}
+void fn1() { foo<int>; }
Index: gcc/testsuite/g++.dg/cpp0x/noexcept32.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/noexcept32.C b/gcc/testsuite/g++.dg/cpp0x/noexcept32.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/noexcept32.C	(revision 262353)
@@ -0,0 +1,14 @@
+// PR c++/84045
+// { dg-do compile { target c++11 } }
+
+template <typename T> struct K {
+  static const bool d = true;
+};
+template <typename T, typename> struct B {
+  typedef K<T> D;
+  void foo () noexcept (D::d);
+};
+template <typename T> struct P {
+  P () noexcept (K<T>::d);
+};
+P<int> p;
Index: gcc/testsuite/g++.dg/cpp0x/pr82878.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/pr82878.C b/gcc/testsuite/g++.dg/cpp0x/pr82878.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/pr82878.C	(revision 262353)
@@ -0,0 +1,20 @@
+// { dg-do compile { target c++11 } }
+// { dg-additional-options "-O" }
+// pr 82878 erroneously unwrapped a reference parm in the lambda::_FUN
+// thunk.
+
+struct A {
+  ~A();
+  operator int ();
+};
+
+void baz ();
+
+void
+bar (A b)
+{
+  void (*lam) (A) = [](A) { baz (); };
+
+  if (auto c = b)
+    lam (c);
+}
Index: gcc/testsuite/g++.dg/cpp0x/initlist-defarg2.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp0x/initlist-defarg2.C b/gcc/testsuite/g++.dg/cpp0x/initlist-defarg2.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp0x/initlist-defarg2.C	(revision 262353)
@@ -0,0 +1,8 @@
+// PR c++/82336
+// { dg-do link { target c++11 } }
+
+struct foo { int x = 5; };
+struct bar : foo { bar() = default; };
+struct baz { bar x; };
+void qux(baz = {}){}
+int main() { qux(); }
Index: gcc/testsuite/g++.dg/torture/pr84190.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/torture/pr84190.C b/gcc/testsuite/g++.dg/torture/pr84190.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/torture/pr84190.C	(revision 262353)
@@ -0,0 +1,20 @@
+// { dg-do compile }
+// For slim LTO there's no optimized dump
+// { dg-skip-if "" { *-*-* } { "-flto" } { "" } }
+// { dg-additional-options "-fdump-tree-optimized" }
+
+typedef double T;
+static int equalfn (volatile T* x, volatile T* y);
+T gx, gy;
+int main ()
+{
+  T x = gx, y = gy;
+  return equalfn (&x, &y);
+}
+static int equalfn (volatile T* x, volatile T* y)
+{
+  return (*x == *y);
+}
+
+// There should be exactly two volatile accesses (ignoring clobbers).
+// { dg-final { scan-tree-dump-times " ={v} \[^\{\]" 2 "optimized" } }
Index: gcc/testsuite/g++.dg/torture/pr84961-1.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/torture/pr84961-1.C b/gcc/testsuite/g++.dg/torture/pr84961-1.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/torture/pr84961-1.C	(revision 262353)
@@ -0,0 +1,24 @@
+// PR c++/84961
+// { dg-do compile }
+
+short a;
+volatile int b;
+int c, d;
+
+void
+foo ()
+{
+  asm volatile ("" : "=r" (b = a));
+}
+
+void
+bar ()
+{
+  asm volatile ("" : "=r" (++c, ++d, b = a));
+}
+
+void
+baz ()
+{
+  asm volatile ("" : "=r" (--b));
+}
Index: gcc/testsuite/g++.dg/torture/pr84961-2.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/torture/pr84961-2.C b/gcc/testsuite/g++.dg/torture/pr84961-2.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/torture/pr84961-2.C	(revision 262353)
@@ -0,0 +1,24 @@
+// PR c++/84961
+// { dg-do compile }
+
+short a;
+volatile int b;
+int c, d;
+
+void
+foo ()
+{
+  asm volatile ("" : : "m" (b = a));
+}
+
+void
+bar ()
+{
+  asm volatile ("" : : "m" (++c, ++d, b = a));
+}
+
+void
+baz ()
+{
+  asm volatile ("" : : "m" (--b));
+}
Index: gcc/testsuite/g++.dg/torture/pr83659.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/torture/pr83659.C b/gcc/testsuite/g++.dg/torture/pr83659.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/torture/pr83659.C	(revision 262353)
@@ -0,0 +1,18 @@
+// PR c++/83659
+// { dg-do compile }
+
+typedef int V __attribute__ ((__vector_size__ (16)));
+V a;
+V b[2];
+
+int
+foo ()
+{
+  return reinterpret_cast <int *> (&a)[-1] += 1;
+}
+
+int
+bar ()
+{
+  return reinterpret_cast <int *> (&a[1])[-1];
+}
Index: gcc/testsuite/g++.dg/torture/pr84233.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/torture/pr84233.C b/gcc/testsuite/g++.dg/torture/pr84233.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/torture/pr84233.C	(revision 262353)
@@ -0,0 +1,25 @@
+// { dg-do compile }
+// { dg-additional-options "-w" }
+
+void a(const char *, int, const char *, const char *);
+template <typename b> void c(b);
+struct d {
+    long e;
+    template <typename> union f;
+    template <typename h> union f<h *> {
+	f(h *i) : j(i) {}
+	h *j;
+	long bits;
+    };
+    static int k(volatile long &i) { return *(int *)f<volatile long *>(&i).bits; }
+    typedef long g;
+    operator g() volatile {
+	int l = k(e);
+	c(l);
+    }
+};
+struct : d {
+	 } m, n;
+bool o;
+void p() { (o ? m : n) ? (void)0 : a("", 5, "", ""); }
+
Index: gcc/testsuite/g++.dg/torture/pr85496.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/torture/pr85496.C b/gcc/testsuite/g++.dg/torture/pr85496.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/torture/pr85496.C	(revision 262353)
@@ -0,0 +1,18 @@
+// PR middle-end/85496
+// Reported by Marek Polacek <mpolacek@gcc.gnu.org>
+
+template <typename> class complex;
+template <typename _Tp> complex<_Tp> operator*(complex<_Tp>, complex<_Tp>);
+template <> struct complex<float> { _Complex float _M_value; };
+class A {
+  complex<float> _f0, _f1;
+
+public:
+  complex<float> &m_fn1() { return _f1; }
+};
+complex<float> a;
+void cos() {
+  A b;
+  complex<float> c;
+  b.m_fn1() = c * a;
+}
Index: gcc/testsuite/g++.dg/ipa/pr84658.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/ipa/pr84658.C b/gcc/testsuite/g++.dg/ipa/pr84658.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/ipa/pr84658.C	(revision 262353)
@@ -0,0 +1,30 @@
+/* PR ipa/84658 */
+/* { dg-do run } */
+/* { dg-options "-O2 -fmerge-all-constants -std=c++11" } */
+
+const int kTestCasesFoo[] = { 0, 1, 2, 3, 4, 5, 8, 15, 16, 17, 512, 1020, 1021, 1022, 1023, 1024 };
+const int kTestCasesBar[] = { 0, 1, 2, 3, 4, 5, 8, 15, 16, 17, 512, 1020, 1021, 1022, 1023, 1024 };
+
+void Foo() {
+    __builtin_printf("foo:");
+    for (int count : kTestCasesFoo) {
+        __builtin_printf("%d,", count);
+    }
+    __builtin_printf(";\n");
+}
+
+void Bar() {
+    __builtin_printf("bar:");
+    for (int count : kTestCasesBar) {
+        __builtin_printf("%d,", count);
+    }
+    __builtin_printf(";\n");
+}
+
+int main() {
+    Foo();
+    Bar();
+}
+
+/* { dg-output "foo:0,1,2,3,4,5,8,15,16,17,512,1020,1021,1022,1023,1024,;(\n|\n\r|\r)*" } */
+/* { dg-output "bar:0,1,2,3,4,5,8,15,16,17,512,1020,1021,1022,1023,1024,;(\n|\n\r|\r)*" } */
Index: gcc/testsuite/g++.dg/cpp1y/pr60626.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1y/pr60626.C b/gcc/testsuite/g++.dg/cpp1y/pr60626.C
deleted file mode 10644
--- a/gcc/testsuite/g++.dg/cpp1y/pr60626.C	(revision 262353)
+++ /dev/null	(nonexistent)
@@ -1,7 +0,0 @@
-// PR c++/60626
-// { dg-do compile { target c++14 } }
-// { dg-options "" }
-
-struct A {};
-
-void (*A::p)(auto) = 0;  // { dg-error "static data member|template" }
Index: gcc/testsuite/g++.dg/cpp1y/pr84662.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1y/pr84662.C b/gcc/testsuite/g++.dg/cpp1y/pr84662.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1y/pr84662.C	(revision 262353)
@@ -0,0 +1,6 @@
+// PR c++/84662
+// { dg-do compile { target c++14 } }
+// { dg-options "" }
+
+double b;
+a (__attribute__((c (0 && int() - ([] {} && b) || auto))));	// { dg-error "expected constructor, destructor, or type conversion before" }
Index: gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr10.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr10.C b/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr10.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr10.C	(revision 262353)
@@ -0,0 +1,7 @@
+// PR c++/71638
+// { dg-do compile { target c++14 } }
+
+struct {
+  int &&a;
+  int b{a};
+} c[] { { 2 } };
Index: gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr11.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr11.C b/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr11.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr11.C	(revision 262353)
@@ -0,0 +1,12 @@
+// PR c++/85148
+// { dg-do compile { target c++14 } }
+
+template<typename T> struct A
+{
+  T x[1]{(__PTRDIFF_TYPE__)this};
+};
+
+void foo()
+{
+  A<A<__PTRDIFF_TYPE__>> a{};
+}
Index: gcc/testsuite/g++.dg/cpp1y/pr84558.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1y/pr84558.C b/gcc/testsuite/g++.dg/cpp1y/pr84558.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1y/pr84558.C	(revision 262353)
@@ -0,0 +1,6 @@
+// PR c++/84558
+// { dg-do compile { target c++14 } }
+
+struct A { static int i; constexpr A () { i = 0; } };
+struct B { A a[2][3][4]; };
+B b;
Index: gcc/testsuite/g++.dg/cpp1y/var-templ58a.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1y/var-templ58a.C b/gcc/testsuite/g++.dg/cpp1y/var-templ58a.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1y/var-templ58a.C	(revision 262353)
@@ -0,0 +1,14 @@
+// PR c++/71569
+// { dg-do compile { target c++14 } }
+
+template <class T>
+struct A {
+  template <class U>
+  static const U u;
+};
+
+template <class T>
+template <class U>
+const U* A<T>::u<U*> = 0;
+
+const int *p = A<char>::u<int*>;
Index: gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr9.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr9.C b/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr9.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1y/nsdmi-aggr9.C	(revision 262353)
@@ -0,0 +1,14 @@
+// PR c++/84927 - ICE with NSDMI and reference
+// { dg-do compile { target c++14 } }
+
+struct A
+{
+  int& r;
+  int i = r;
+};
+
+void foo()
+{
+  int j;
+  A a = A{j};
+}
Index: gcc/testsuite/g++.dg/cpp1y/pr85076.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1y/pr85076.C b/gcc/testsuite/g++.dg/cpp1y/pr85076.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1y/pr85076.C	(revision 262353)
@@ -0,0 +1,6 @@
+// PR c++/85076
+// { dg-do compile { target c++14 } }
+
+template<typename> struct A*;	// { dg-error "expected unqualified-id before" }
+
+auto a = [](A<auto>) {};	// { dg-error "is not a template|has incomplete type" }
Index: gcc/testsuite/g++.dg/cpp1y/pr84496.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1y/pr84496.C b/gcc/testsuite/g++.dg/cpp1y/pr84496.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1y/pr84496.C	(revision 262353)
@@ -0,0 +1,44 @@
+// PR c++/84496
+// { dg-do compile { target c++14 } }
+
+template <typename T, T n> struct C { static constexpr T D = n; };
+struct E : C<bool, false> {};
+template <typename> struct F : C<bool, false> {};
+template <typename T> T foo ();
+template <typename> struct H { typedef int G; };
+template <typename> class I;
+struct L;
+template <typename, typename> struct J;
+template <bool, bool, typename...> struct K;
+struct R {
+  template <typename M, typename... N>
+  static J<decltype (foo<M> () (foo<N>...)), L> o;
+};
+template <typename P, typename... Q> struct K<false, false, P, Q...> : R {
+  typedef decltype (o<P, Q...>) G;
+};
+template <typename P, typename... Q>
+struct D : K<E::D, F<typename H<P>::G>::D, P, Q...> {};
+template <typename P, typename... Q> struct I<P (Q...)> : D<P, Q...> {};
+template <typename> class function;
+template <typename S, typename... Q> struct function<S (Q...)> {
+  template <typename T, typename = typename I<T (Q...)>::G> struct C;
+  template <typename, typename> using U = int;
+  template <typename P, typename = U<int, void>, typename = U<C<P>, void>>
+  function (P);
+};
+template <typename S, typename... Q>
+template <typename P, typename, typename>
+function<S (Q...)>::function (P)
+{
+}
+void bar (function<void (int)>);
+
+void
+baz ()
+{
+  auto a = [] {
+    static int counter;
+    bar ([] (auto) { counter++; });
+  };
+}
Index: gcc/testsuite/g++.dg/cpp1y/lambda-mangle-1.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1y/lambda-mangle-1.C b/gcc/testsuite/g++.dg/cpp1y/lambda-mangle-1.C
--- a/gcc/testsuite/g++.dg/cpp1y/lambda-mangle-1.C	(revision 262353)
+++ b/gcc/testsuite/g++.dg/cpp1y/lambda-mangle-1.C	(revision 262353)
@@ -85,4 +85,4 @@
 // { dg-final { scan-assembler "_Z3eatIZ3FoovEUlPT_PT0_E4_Z3FoovEUlS1_S3_E5_EvRS0_RS2_:" } }
 // { dg-final { scan-assembler "_Z3eatIPiZ3BarIsEvvEUlPsPfS3_E_EvRT_RT0_:" } }
 // { dg-final { scan-assembler "_Z3eatIPiZ3BarIsEvvEUlPsPT_PT0_E0_EvRS3_RS5_:" } }
-// { dg-final { scan-assembler "_Z3eatIPiZ3BarIsEvvEUlPsPT_zE1_EvRS3_RT0_:" } }
+// { dg-final { scan-assembler "_Z3eatIPiZ3BarIsEvvEUlPsDpPT_E1_EvRT_RT0_:" } }
Index: gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic16.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic16.C b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic16.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic16.C	(revision 262353)
@@ -0,0 +1,8 @@
+// PR c++/64095
+// { dg-do compile { target c++14 } }
+
+void f()
+{
+  [](auto...){}();
+  [](auto&&...){}();
+}
Index: gcc/testsuite/g++.dg/cpp1y/lambda-generic-nsdmi1.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1y/lambda-generic-nsdmi1.C b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-nsdmi1.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-nsdmi1.C	(revision 262353)
@@ -0,0 +1,8 @@
+// PR c++/84520
+// { dg-do compile { target c++14 } }
+
+struct A
+{
+  static void foo(int);
+  void (*f)(int) = [](auto i) { foo(i); };
+};
Index: gcc/testsuite/g++.dg/cpp1y/var-templ58.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1y/var-templ58.C b/gcc/testsuite/g++.dg/cpp1y/var-templ58.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1y/var-templ58.C	(revision 262353)
@@ -0,0 +1,12 @@
+// PR c++/71569
+// { dg-do compile { target c++14 } }
+
+template <class T>
+struct A {
+  template <class U>
+  static const U u;
+};
+
+template <class T>
+template <class U>
+const U A<T>::u<U> = 0;	// { dg-error "does not specialize" }
Index: gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic17.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic17.C b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic17.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1y/lambda-generic-variadic17.C	(revision 262353)
@@ -0,0 +1,125 @@
+// PR c++/85118
+// { dg-do compile { target c++14 } }
+
+namespace std
+{
+  template<typename _Tp>
+    struct remove_const
+    { typedef _Tp type; };
+
+  template<typename _Tp>
+    struct remove_const<_Tp const>
+    { typedef _Tp type; };
+
+
+  template<typename _Tp>
+    struct remove_volatile
+    { typedef _Tp type; };
+
+  template<typename _Tp>
+    struct remove_volatile<_Tp volatile>
+    { typedef _Tp type; };
+
+
+  template<typename _Tp>
+    struct remove_cv
+    {
+      typedef typename
+      remove_const<typename remove_volatile<_Tp>::type>::type type;
+    };
+
+  template<typename _Tp>
+    struct remove_reference
+    { typedef _Tp type; };
+
+  template<typename _Tp>
+    struct remove_reference<_Tp&>
+    { typedef _Tp type; };
+
+  template<typename _Tp>
+    struct remove_reference<_Tp&&>
+    { typedef _Tp type; };
+
+  template<typename _Tp>
+    struct decay
+    {
+      using type = typename remove_reference<typename remove_const<_Tp>::type>::type;
+    };
+
+  template<typename _Tp>
+    _Tp&&
+    declval() noexcept;
+
+  template<typename _Tp>
+    constexpr _Tp&&
+    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
+    { return static_cast<_Tp&&>(__t); }
+
+
+  template<typename _Arg>
+    struct _Mu
+    {
+      template<typename _CVArg, typename _Tuple>
+         _CVArg&&
+         operator()(_CVArg&& __arg, _Tuple&) const volatile
+         { return std::forward<_CVArg>(__arg); }
+    };
+
+   template<typename _Functor, typename _Bound_args>
+    struct _Bind
+    {
+      _Functor _M_f;
+      _Bound_args _M_bound_args;
+
+      template<typename _Args, typename _Result
+         = decltype( std::declval<_Functor&>()(
+               _Mu<_Bound_args>()( std::declval<_Bound_args&>(),
+              std::declval<_Args&>() ) ) )>
+         _Result
+      operator()(_Args&& __args) { return {}; }
+
+      template<typename _Args, typename _Result
+         = decltype( std::declval<volatile _Functor&>()(
+               _Mu<_Bound_args>()( std::declval<volatile _Bound_args&>(),
+              std::declval<_Args&>() ) ) )>
+         _Result
+         operator()(_Args&& __args) volatile;
+
+    };
+
+  template<typename _Func, typename _BoundArgs>
+    _Bind<typename decay<_Func>::type, typename decay<_BoundArgs>::type>
+    bind(_Func&& __f, _BoundArgs&& __args)
+    {
+      return {
+        std::forward<_Func>(__f),
+          std::forward<_BoundArgs>(__args)
+      };
+    }
+
+} // namespace std
+
+
+template <typename T>
+bool isOneOf(const T& )
+{
+    return false;
+}
+
+template <typename T, typename FirstType, typename... Tail>
+bool isOneOf(const T& t, const FirstType& firstValue, const Tail&... tail)
+{
+    return t == firstValue || isOneOf(t, tail...);
+}
+
+int main()
+{
+    const auto isOneOfHelper = [](auto&&... params)
+    {
+      return isOneOf(std::forward<decltype(params)>(params)...);
+    };
+
+    auto isO = std::bind(isOneOfHelper, 'o');
+
+    isO('o');
+}
Index: gcc/testsuite/g++.dg/cpp1y/pr83817.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1y/pr83817.C b/gcc/testsuite/g++.dg/cpp1y/pr83817.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1y/pr83817.C	(revision 262353)
@@ -0,0 +1,17 @@
+// PR c++/83817
+// { dg-do compile { target c++14 } }
+
+struct A;
+struct B { template <typename> using C = A; };
+struct D : B { struct F { typedef C<char> E; }; };
+struct G {
+  struct I { I (D, A &); } h;
+  D::F::E &k ();
+  D j;
+  G (G &&) : h (j, k ()) {}
+};
+struct N { G l; };
+typedef N (*M)(N &);
+struct H { const char *o; M s; };
+N foo (N &);
+H r { "", [](auto &x) { return foo (x); }};
Index: gcc/testsuite/g++.dg/cpp1y/constexpr-84192.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1y/constexpr-84192.C b/gcc/testsuite/g++.dg/cpp1y/constexpr-84192.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1y/constexpr-84192.C	(revision 262353)
@@ -0,0 +1,41 @@
+// PR c++/84192
+// { dg-do compile { target c++14 } }
+// { dg-options "" }
+
+bool
+f1 ()
+{ 
+  return ({ return true; }) && false;	// { dg-error "could not convert" }
+}
+
+void
+f2 ()
+{ 
+  for (;;)
+    constexpr bool b = ({ break; false; }) && false;	// { dg-error "statement is not a constant expression" }
+}
+
+constexpr bool
+f3 (int n)
+{
+  bool b = false;
+  for (int i = 0; i < n; i++)
+    b = ({ break; });	// { dg-error "void value not ignored as it ought to be" }
+  return b;
+}
+
+constexpr bool b = f3 (4);
+
+bool
+f4 ()
+{
+  constexpr bool b = ({ return true; }) && false;	// { dg-error "could not convert" }
+  return false;
+}
+
+constexpr bool
+f5 (int x)
+{
+  constexpr bool b = ({ switch (x) case 0: true; }) && false;	// { dg-error "could not convert" }
+  return false;
+}
Index: gcc/testsuite/g++.dg/cpp1y/var-templ59.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1y/var-templ59.C b/gcc/testsuite/g++.dg/cpp1y/var-templ59.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1y/var-templ59.C	(revision 262353)
@@ -0,0 +1,14 @@
+// PR c++/71569
+// { dg-do compile { target c++14 } }
+
+template <class T>
+struct A {
+  template <class U>
+  static U u;
+};
+
+int main()
+{
+  decltype(A<int>::u) a;	// { dg-error "missing template arguments" }
+  return a;
+}
Index: gcc/testsuite/g++.dg/cpp1y/pr60393.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1y/pr60393.C b/gcc/testsuite/g++.dg/cpp1y/pr60393.C
--- a/gcc/testsuite/g++.dg/cpp1y/pr60393.C	(revision 262353)
+++ b/gcc/testsuite/g++.dg/cpp1y/pr60393.C	(revision 262353)
@@ -1,8 +1,7 @@
 // PR c++/60393
 // { dg-do compile { target c++14 } }
-// { dg-options "" }
 
-void (*f)(auto) + 0; // { dg-error "expected" }
+void (*f)(auto) + 0; // { dg-error "auto|expected" }
 
 struct A
 {
Index: gcc/testsuite/g++.dg/cpp1z/decomp-lambda1.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/decomp-lambda1.C b/gcc/testsuite/g++.dg/cpp1z/decomp-lambda1.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/decomp-lambda1.C	(revision 262353)
@@ -0,0 +1,10 @@
+// PR c++/84420
+// { dg-additional-options -std=c++17 }
+
+int main(){
+    int a[1]{};
+    [&a]{
+        auto [v] = a;
+        (void)v;
+    }();
+}
Index: gcc/testsuite/g++.dg/cpp1z/noexcept-type19.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/noexcept-type19.C b/gcc/testsuite/g++.dg/cpp1z/noexcept-type19.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/noexcept-type19.C	(revision 262353)
@@ -0,0 +1,12 @@
+// { dg-do compile { target c++11 } }
+
+#include "noexcept-type19.h"
+
+extern "C" void *malloc (size_t);
+
+template<class T> void f(T*);
+
+int main()
+{
+  f<decltype(malloc)>(operator new);
+}
Index: gcc/testsuite/g++.dg/cpp1z/class-deduction51.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/class-deduction51.C b/gcc/testsuite/g++.dg/cpp1z/class-deduction51.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/class-deduction51.C	(revision 262353)
@@ -0,0 +1,11 @@
+// PR c++/84937
+// { dg-additional-options -std=c++17 }
+
+template<int, int> struct A {};
+
+template<int I> struct B
+{
+  template<auto J> B(A<I,J>);
+};
+
+B b(A<0,0>{});
Index: gcc/testsuite/g++.dg/cpp1z/launder7.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/launder7.C b/gcc/testsuite/g++.dg/cpp1z/launder7.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/launder7.C	(revision 262353)
@@ -0,0 +1,10 @@
+// PR c++/84445
+// { dg-do compile }
+
+struct A { virtual void foo (); };
+
+void
+bar (A *p)
+{
+  __builtin_launder (p)->foo ();
+}
Index: gcc/testsuite/g++.dg/cpp1z/noexcept-type19.h
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/noexcept-type19.h b/gcc/testsuite/g++.dg/cpp1z/noexcept-type19.h
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/noexcept-type19.h	(revision 262353)
@@ -0,0 +1,4 @@
+#pragma GCC system_header
+
+typedef decltype(sizeof(0)) size_t;
+extern "C" void *malloc (size_t) throw();
Index: gcc/testsuite/g++.dg/cpp1z/decomp41.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/decomp41.C b/gcc/testsuite/g++.dg/cpp1z/decomp41.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/decomp41.C	(revision 262353)
@@ -0,0 +1,9 @@
+// PR c++/85208
+// { dg-do compile { target c++11 } }
+// { dg-require-weak "" }
+// { dg-options "" }
+
+#pragma weak _ZDC1d1e1fE
+struct A { int i, j, k; };
+auto [a, b, c] = A ();	// { dg-warning "decomposition declaration only available with" "" { target c++14_down } }
+auto [d, e, f] = A ();	// { dg-warning "decomposition declaration only available with" "" { target c++14_down } }
Index: gcc/testsuite/g++.dg/cpp1z/decomp4.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/decomp4.C b/gcc/testsuite/g++.dg/cpp1z/decomp4.C
--- a/gcc/testsuite/g++.dg/cpp1z/decomp4.C	(revision 262353)
+++ b/gcc/testsuite/g++.dg/cpp1z/decomp4.C	(revision 262353)
@@ -18,10 +18,10 @@
 					// { dg-warning "decomposition declaration only available with -std=c..1z or -std=gnu..1z" "" { target c++14_down } .-1 }
   auto [ k ] { b };			// { dg-error "cannot decompose class type 'B' because it has an anonymous union member" }
 					// { dg-warning "decomposition declaration only available with -std=c..1z or -std=gnu..1z" "" { target c++14_down } .-1 }
-  auto [ l, l2 ] = c;			// { dg-error "cannot decompose non-public member 'C::b' of 'C'" }
+  auto [ l, l2 ] = c;			// { dg-error "cannot decompose inaccessible member 'C::b' of 'C'" }
 					// { dg-warning "decomposition declaration only available with -std=c..1z or -std=gnu..1z" "" { target c++14_down } .-1 }
   auto [ m ] = d;			// { dg-warning "decomposition declaration only available with -std=c..1z or -std=gnu..1z" "" { target c++14_down } }
-  auto [ n ] { e };			// { dg-error "cannot decompose non-public member 'E::a' of 'E'" }
+  auto [ n ] { e };			// { dg-error "cannot decompose inaccessible member 'E::a' of 'E'" }
 					// { dg-warning "decomposition declaration only available with -std=c..1z or -std=gnu..1z" "" { target c++14_down } .-1 }
   auto [ o ] { f };			// { dg-warning "decomposition declaration only available with -std=c..1z or -std=gnu..1z" "" { target c++14_down } }
   auto & [ p ] { g };			// { dg-error "cannot decompose class type 'G': both it and its base class 'F' have non-static data members" }
Index: gcc/testsuite/g++.dg/cpp1z/desig7.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/desig7.C b/gcc/testsuite/g++.dg/cpp1z/desig7.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/desig7.C	(revision 262353)
@@ -0,0 +1,18 @@
+// PR c++/84874
+// { dg-do compile { target c++11 } }
+// { dg-options "" }
+
+struct A { int a, b; };
+struct B { A d; };
+
+void
+foo (B *x)
+{
+  *x = { .d = { .b = 5 } };	// { dg-message "non-trivial designated initializers not supported" }
+}
+
+void
+bar (A *x)
+{
+  *x = { .b = 6 };		// { dg-message "non-trivial designated initializers not supported" }
+}
Index: gcc/testsuite/g++.dg/cpp1z/launder8.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/launder8.C b/gcc/testsuite/g++.dg/cpp1z/launder8.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/launder8.C	(revision 262353)
@@ -0,0 +1,11 @@
+// PR c++/84444
+// { dg-do compile }
+// { dg-options "-O2" }
+
+struct A {};
+
+__UINTPTR_TYPE__
+foo (A *p)
+{
+  return (__UINTPTR_TYPE__) __builtin_launder (p);
+}
Index: gcc/testsuite/g++.dg/cpp1z/decomp42.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/decomp42.C b/gcc/testsuite/g++.dg/cpp1z/decomp42.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/decomp42.C	(revision 262353)
@@ -0,0 +1,18 @@
+// PR c++/85210
+// { dg-do compile { target c++11 } }
+// { dg-options "" }
+
+struct A { int i; };
+
+template <int>
+void
+foo (int j)
+{
+  auto [j] = A{j};	// { dg-error "shadows a parameter" }
+}			// { dg-warning "decomposition declaration only available with" "" { target c++14_down } .-1 }
+
+void
+bar ()
+{
+  foo<0> (0);
+}
Index: gcc/testsuite/g++.dg/cpp1z/constexpr-84684.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/constexpr-84684.C b/gcc/testsuite/g++.dg/cpp1z/constexpr-84684.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/constexpr-84684.C	(revision 262353)
@@ -0,0 +1,163 @@
+// PR c++/84684
+// { dg-options -std=c++17 }
+
+typedef decltype (sizeof (0)) size_t;
+
+namespace std {
+  template<class _E>
+  struct initializer_list
+  {
+    typedef _E value_type;
+    typedef const _E& reference;
+    typedef const _E& const_reference;
+    typedef size_t size_type;
+    typedef const _E* iterator;
+    typedef const _E* const_iterator;
+    iterator _M_array;
+    size_type _M_len;
+    constexpr initializer_list(const_iterator __a, size_type __l) : _M_array(__a), _M_len(__l) { }
+    constexpr initializer_list() noexcept : _M_array(0), _M_len(0) { }
+    constexpr size_type size() const noexcept { return _M_len; }
+    constexpr const_iterator begin() const noexcept { return _M_array; }
+    constexpr const_iterator end() const noexcept { return begin() + size(); }
+  };
+}
+
+template <typename E, size_t N>
+struct array
+{
+  constexpr E &operator[](size_t n) noexcept { return elems[n]; }
+  constexpr const E &operator[](size_t n) const noexcept { return elems[n]; }
+  constexpr size_t size() const { return N; }
+  E elems[N];
+};
+
+template<typename T>
+constexpr
+inline T
+max (std::initializer_list<T> i)
+{
+  const T *b = i.begin ();
+  const T *e = i.end ();
+  if (b == e) return *b;
+  const T *r = b;
+  while (++b != e)
+  if (*r < *b)
+    r = b;
+  return *r;
+}
+
+template <typename alphabet_type>
+constexpr char to_char(alphabet_type const alph)
+{
+  return alph.to_char();
+}
+
+template <typename ...alphabet_types>
+struct union_composition
+{
+  static constexpr size_t value_size = (alphabet_types::value_size + ... );
+  unsigned char _value;
+  template <size_t fixed_size, typename alphabet_t>
+  static constexpr auto value_to_char_helper(alphabet_t alphabet)
+  {
+    array<char, fixed_size> value_to_char{};
+    for (size_t i = 0u; i < alphabet_t::value_size; ++i)
+      value_to_char[i] = to_char(alphabet.assign_rank(i));
+    return value_to_char;
+  }
+
+  static constexpr auto make_value_to_char()
+  {
+    constexpr auto N = sizeof...(alphabet_types);
+    constexpr array<size_t, N> alphabet_sizes { alphabet_types::value_size... };
+    constexpr size_t fixed_size = max({alphabet_types::value_size...});
+    array value_to_char_tables = array<array<char, fixed_size>, N> {
+      value_to_char_helper<fixed_size>(alphabet_types{})...
+    };
+    array<char, value_size> value_to_char{};
+    for (size_t i = 0u, value = 0u; i < N; ++i)
+      for (size_t k = 0u; k < alphabet_sizes[i]; ++k, ++value)
+        value_to_char[value] = value_to_char_tables[i][k];
+    return value_to_char;
+  }
+};
+
+struct gap
+{
+  constexpr char to_char() const noexcept { return '-'; }
+  constexpr gap & assign_rank([[maybe_unused]] bool const i) noexcept { return *this; }
+  static constexpr size_t value_size{1};
+};
+
+struct dna4
+{
+  constexpr char to_char() const noexcept { return value_to_char[_value]; }
+  constexpr dna4 & assign_rank(unsigned char const c) { _value = c; return *this; }
+  static constexpr size_t value_size{4};
+  static constexpr char value_to_char[value_size] { 'A', 'C', 'G', 'T' };
+  unsigned char _value;
+};
+
+struct dna5
+{
+  constexpr char to_char() const noexcept { return value_to_char[_value]; }
+  constexpr dna5 & assign_rank(unsigned char const c) { _value = c; return *this; }
+  static constexpr size_t value_size{5};
+  static constexpr char value_to_char[value_size] { 'A', 'C', 'G', 'T', 'N' };
+  unsigned char _value;
+};
+
+constexpr array value_to_char1 = union_composition<dna4>::make_value_to_char();
+static_assert(value_to_char1.size() == 4u);
+static_assert(value_to_char1[0] == 'A');
+static_assert(value_to_char1[1] == 'C');
+static_assert(value_to_char1[2] == 'G');
+static_assert(value_to_char1[3] == 'T');
+
+constexpr array value_to_char2 = union_composition<dna4, gap>::make_value_to_char();
+static_assert(value_to_char2.size() == 5u);
+static_assert(value_to_char2[0] == 'A');
+static_assert(value_to_char2[1] == 'C');
+static_assert(value_to_char2[2] == 'G');
+static_assert(value_to_char2[3] == 'T');
+static_assert(value_to_char2[4] == '-');
+
+constexpr array value_to_char3 = union_composition<dna4, gap, dna5>::make_value_to_char();
+static_assert(value_to_char3.size() == 10u);
+static_assert(value_to_char3[0] == 'A');
+static_assert(value_to_char3[1] == 'C');
+static_assert(value_to_char3[2] == 'G');
+static_assert(value_to_char3[3] == 'T');
+static_assert(value_to_char3[4] == '-');
+static_assert(value_to_char3[5] == 'A');
+static_assert(value_to_char3[6] == 'C');
+static_assert(value_to_char3[7] == 'G');
+static_assert(value_to_char3[8] == 'T');
+static_assert(value_to_char3[9] == 'N');
+
+constexpr array value_to_char4 = union_composition<dna5, gap, dna4>::make_value_to_char();
+static_assert(value_to_char4.size() == 10u);
+static_assert(value_to_char4[0] == 'A');
+static_assert(value_to_char4[1] == 'C');
+static_assert(value_to_char4[2] == 'G');
+static_assert(value_to_char4[3] == 'T');
+static_assert(value_to_char4[4] == 'N');
+static_assert(value_to_char4[5] == '-');
+static_assert(value_to_char4[6] == 'A');
+static_assert(value_to_char4[7] == 'C');
+static_assert(value_to_char4[8] == 'G');
+static_assert(value_to_char4[9] == 'T');
+
+constexpr array value_to_char5 = union_composition<gap, dna4, dna5>::make_value_to_char();
+static_assert(value_to_char5.size() == 10u);
+static_assert(value_to_char5[0] == '-');
+static_assert(value_to_char5[1] == 'A');
+static_assert(value_to_char5[2] == 'C');
+static_assert(value_to_char5[3] == 'G');
+static_assert(value_to_char5[4] == 'T');
+static_assert(value_to_char5[5] == 'A');
+static_assert(value_to_char5[6] == 'C');
+static_assert(value_to_char5[7] == 'G');
+static_assert(value_to_char5[8] == 'T');
+static_assert(value_to_char5[9] == 'N');
Index: gcc/testsuite/g++.dg/cpp1z/constexpr-if13.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/constexpr-if13.C b/gcc/testsuite/g++.dg/cpp1z/constexpr-if13.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/constexpr-if13.C	(revision 262353)
@@ -0,0 +1,11 @@
+// PR c++/84854
+// { dg-options -std=c++17 }
+
+constexpr int foo () { return 1; }
+constexpr int foo (int) { return 2; }
+
+template <typename>
+void a()
+{
+  if constexpr(foo) { };
+}
Index: gcc/testsuite/g++.dg/cpp1z/desig8.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/desig8.C b/gcc/testsuite/g++.dg/cpp1z/desig8.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/desig8.C	(revision 262353)
@@ -0,0 +1,18 @@
+// PR c++/84874
+// { dg-do compile { target c++1z } }
+// { dg-options "" }
+
+struct A { int a; struct { int b; }; };
+struct B { A d; };
+
+void
+foo (B *x)
+{
+  *x = { .d = { .b = 5 } };	// { dg-message "non-trivial designated initializers not supported" }
+}
+
+void
+bar (A *x)
+{
+  *x = { .b = 6 };		// { dg-message "non-trivial designated initializers not supported" }
+}
Index: gcc/testsuite/g++.dg/cpp1z/inh-ctor38.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/inh-ctor38.C b/gcc/testsuite/g++.dg/cpp1z/inh-ctor38.C
--- a/gcc/testsuite/g++.dg/cpp1z/inh-ctor38.C	(revision 262353)
+++ b/gcc/testsuite/g++.dg/cpp1z/inh-ctor38.C	(revision 262353)
@@ -1,17 +1,19 @@
 // { dg-do run { target c++11 } }
 // PR78495 failed to propagate pass-by-value struct to base ctor.
 
+static int moves = 0;
+
 struct Ptr {
   void *ptr = 0;
 
   Ptr() {}
   Ptr(Ptr const&) = delete;
-  Ptr(Ptr&& other) : ptr (other.ptr) {}
+  Ptr(Ptr&& other) : ptr (other.ptr) {moves++;}
 };
 
 struct Base {
   Ptr val;
-  Base(Ptr val_) : val(static_cast<Ptr&&>(val_)) {}
+  Base(Ptr val_);
 };
 
 struct Derived: Base {
@@ -27,5 +29,13 @@
 }
 
 int main () {
-  return Foo () != 0;
+  if (Foo ())
+    return 1;
+
+  if (moves != 2)
+    return 2;
+
+  return 0;
 }
+
+Base::Base(Ptr val_) : val(static_cast<Ptr&&>(val_)) {}
Index: gcc/testsuite/g++.dg/cpp1z/class-deduction54.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/class-deduction54.C b/gcc/testsuite/g++.dg/cpp1z/class-deduction54.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/class-deduction54.C	(revision 262353)
@@ -0,0 +1,15 @@
+// PR c++/82152
+// { dg-additional-options -std=c++17 }
+
+struct Base {};
+
+template<typename T>
+struct Derived : public Base {
+  using Base::Base;
+};
+
+Derived() -> Derived< void >;
+
+int main() {
+  Derived x;
+}
Index: gcc/testsuite/g++.dg/cpp1z/decomp10.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/decomp10.C b/gcc/testsuite/g++.dg/cpp1z/decomp10.C
--- a/gcc/testsuite/g++.dg/cpp1z/decomp10.C	(revision 262353)
+++ b/gcc/testsuite/g++.dg/cpp1z/decomp10.C	(revision 262353)
@@ -20,7 +20,7 @@
 
 struct A3a { int i,j; int get(); } a3a;
 template<> struct std::tuple_size<A3a> { enum { value = 1 }; };
-void f3a() { auto [ x ] = a3a; }	// { dg-error "get<0>" }
+void f3a() { auto [ x ] = a3a; }	// { dg-error "get" }
 
 struct A3b { int i,j; } a3b;
 int get(A3b&&);
Index: gcc/testsuite/g++.dg/cpp1z/decomp35.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/decomp35.C b/gcc/testsuite/g++.dg/cpp1z/decomp35.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/decomp35.C	(revision 262353)
@@ -0,0 +1,35 @@
+// PR c++/83958
+// { dg-do compile { target c++11 } }
+// { dg-options "" }
+
+template <typename = void> struct A;
+class B;
+template <typename, typename, typename = A<>> class C;
+template <typename, typename> struct D;
+template <typename T, typename U, typename V, typename, typename, typename W>
+struct E {
+  using X = W;
+  X operator* ();
+  T operator++ ();
+  template <typename P, typename R, typename S, typename Q>
+  bool operator!= (E<P, U, V, R, S, Q>);
+};
+template <typename T, typename U, typename>
+struct F {
+  class G;
+  using H = D<T, U>;
+  using I = E<G, T, U, G, H, H &>;
+  class G : public I {};
+  G begin ();
+  G end ();
+};
+template <typename T, typename U, typename V> struct C : F<T, U, V> {
+  using J = F<T, U, V>;
+  using J::begin;
+  using J::end;
+};
+using K = class L;
+struct M {
+  void foo () { for (auto & [ a ] : m) {} }	// { dg-error "incomplete type" }
+  C<K, B> m;					// { dg-warning "only available with" "" { target c++14_down } .-1 }
+};
Index: gcc/testsuite/g++.dg/cpp1z/decomp36.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/decomp36.C b/gcc/testsuite/g++.dg/cpp1z/decomp36.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/decomp36.C	(revision 262353)
@@ -0,0 +1,19 @@
+// PR c++/84031
+// { dg-do compile { target c++11 } }
+// { dg-options "" }
+
+struct A { unsigned char : 1, a1 : 1, a2 : 2, : 1, a3 : 3; };
+struct B { unsigned char : 1, : 7; };
+struct C : B { constexpr C () : c1 (1), c2 (2), c3 (3) {} unsigned char : 1, c1 : 1, c2 : 2, : 1, c3 : 3; };
+struct D : C { constexpr D () {} unsigned char : 1, : 7; };
+
+int
+main ()
+{
+  static constexpr A a { 1, 2, 3 };
+  const auto &[a1, a2, a3] = a;		// { dg-warning "only available with" "" { target c++14_down } }
+  static_assert (a1 == 1 && a2 == 2 && a3 == 3, "");
+  static constexpr D d;
+  const auto &[d1, d2, d3] = d;		// { dg-warning "only available with" "" { target c++14_down } }
+  static_assert (d1 == 1 && d2 == 2 && d3 == 3, "");
+}
Index: gcc/testsuite/g++.dg/cpp1z/decomp37.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/decomp37.C b/gcc/testsuite/g++.dg/cpp1z/decomp37.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/decomp37.C	(revision 262353)
@@ -0,0 +1,62 @@
+// { dg-additional-options -std=c++17 }
+// { dg-do compile }
+
+#include <memory>
+#include <tuple>
+#include <string>
+
+struct X : private std::shared_ptr<int>
+{
+  std::string fun_payload;
+};
+
+template<int N> std::string& get(X& x)
+{
+  if constexpr(N==0) return x.fun_payload;
+}
+
+namespace std {
+  template<> class tuple_size<X> : public std::integral_constant<int, 1> {};
+  template<> class tuple_element<0, X> {public: using type = std::string;};
+}
+
+struct X2 : private std::shared_ptr<int>
+{
+  int fun_payload;
+  template <class T> void get();
+};
+
+template<int N> int& get(X2& x)
+{
+  if constexpr(N==0) return x.fun_payload;
+}
+
+namespace std {
+  template<> class tuple_size<X2> : public std::integral_constant<int, 1> {};
+  template<> class tuple_element<0, X2> {public: using type = int;};
+}
+
+class X3
+{
+  double fun_payload;
+public:
+  template <int N> double& get()
+  {
+    if constexpr(N==0) return fun_payload;
+  }
+};
+
+namespace std {
+  template<> class tuple_size<X3> : public std::integral_constant<int, 1> {};
+  template<> class tuple_element<0, X3> {public: using type = double;};
+}
+
+int main()
+{
+  X x;
+  auto& [b1] = x;
+  X2 x2;
+  auto& [b2] = x2;
+  X3 x3;
+  auto& [b3] = x3;
+}
Index: gcc/testsuite/g++.dg/cpp1z/decomp38.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/decomp38.C b/gcc/testsuite/g++.dg/cpp1z/decomp38.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/decomp38.C	(revision 262353)
@@ -0,0 +1,48 @@
+// { dg-additional-options -std=c++17 }
+// { dg-do compile }
+
+class X
+{
+   int a, b;
+   void f()
+   {
+     auto[x,y] = *this;
+   }
+};
+
+class X2
+{
+   int a, b;
+   void f(X2& other)
+   {
+     auto[x,y] = other;
+   }
+};
+
+struct X3
+{
+  friend void foo();
+private:
+  int a;
+};
+
+void foo()
+{
+  X3 x;
+  auto [a] = x;
+}
+
+struct X4
+{
+  int a;
+};
+
+struct X5 : private X4
+{
+  friend void foo2();
+};
+
+void foo2() {
+  X5 x;
+  auto [a] = x;
+}
Index: gcc/testsuite/g++.dg/cpp1z/class-deduction49.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/class-deduction49.C b/gcc/testsuite/g++.dg/cpp1z/class-deduction49.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/class-deduction49.C	(revision 262353)
@@ -0,0 +1,15 @@
+// PR c++/84015
+// { dg-additional-options -std=c++17 }
+
+template <int I>
+struct A { };
+
+template <int I>
+struct B
+{
+  template<template<auto>class T>
+  B(T<I>);
+};
+
+A<42> a;
+B b (a);
Index: gcc/testsuite/g++.dg/cpp1z/class-deduction50.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/cpp1z/class-deduction50.C b/gcc/testsuite/g++.dg/cpp1z/class-deduction50.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/cpp1z/class-deduction50.C	(revision 262353)
@@ -0,0 +1,22 @@
+// PR c++/84355
+// { dg-additional-options -std=c++17 }
+
+template <class, class> struct same;
+template <class T> struct same<T,T> {};
+
+template<typename T> struct A
+{
+  template<class U> struct B
+  {
+    B(U);
+  };
+
+  A() {
+    B b(0);
+    same<decltype(b),B<int>>{};
+  }
+};
+
+struct C {};
+
+A<C> a;
Index: gcc/testsuite/g++.dg/ext/is_trivially_constructible6.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/ext/is_trivially_constructible6.C b/gcc/testsuite/g++.dg/ext/is_trivially_constructible6.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/ext/is_trivially_constructible6.C	(revision 262353)
@@ -0,0 +1,10 @@
+// PR c++/81589
+
+template <typename k>
+struct z {
+  z() {
+    k::error;
+  }
+};
+
+int x = __is_trivially_constructible(z<int>);
Index: gcc/testsuite/g++.dg/ext/offsetof2.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/ext/offsetof2.C b/gcc/testsuite/g++.dg/ext/offsetof2.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/ext/offsetof2.C	(revision 262353)
@@ -0,0 +1,6 @@
+// PR c++/85662
+// { dg-do compile { target c++11 } }
+
+struct S { unsigned long x[31]; };
+struct T { bool b; S f; };
+static_assert (__builtin_offsetof (T, f.x[31 - 1]) == __builtin_offsetof (T, f.x[30]), "");
Index: gcc/testsuite/g++.dg/ext/visibility/lambda1.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/ext/visibility/lambda1.C b/gcc/testsuite/g++.dg/ext/visibility/lambda1.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/ext/visibility/lambda1.C	(revision 262353)
@@ -0,0 +1,14 @@
+// PR c++/85646
+// { dg-do compile { target c++11 } }
+// { dg-additional-options -fvisibility=hidden }
+
+template<typename T>
+void foo() {
+    struct inner {
+        inner() {
+            (void)([this] { });
+        }
+    };
+}
+
+int main() { foo<int>(); }
Index: gcc/testsuite/g++.dg/ext/stmtexpr22.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/ext/stmtexpr22.C b/gcc/testsuite/g++.dg/ext/stmtexpr22.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/ext/stmtexpr22.C	(revision 262353)
@@ -0,0 +1,13 @@
+// PR c++/81853
+// { dg-do compile { target c++11 } }
+// { dg-options "" }
+
+namespace N {
+  enum { i };
+}
+
+int g ()
+{
+  constexpr int j = ({ using namespace N; i; });
+  return j;
+}
Index: gcc/testsuite/g++.dg/ext/offsetof3.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/ext/offsetof3.C b/gcc/testsuite/g++.dg/ext/offsetof3.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/ext/offsetof3.C	(revision 262353)
@@ -0,0 +1,5 @@
+// PR c++/85662
+// { dg-do compile { target c++11 } }
+// { dg-options "-O2" }
+
+#include "offsetof2.C"
Index: gcc/testsuite/g++.dg/ext/vla18.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/ext/vla18.C b/gcc/testsuite/g++.dg/ext/vla18.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/ext/vla18.C	(revision 262353)
@@ -0,0 +1,19 @@
+// PR c++/84767
+// { dg-do compile }
+// { dg-options "" }
+
+int v[1][10];
+
+struct A
+{
+  A (int);
+};
+
+A::A (int i)
+{
+  typedef int T[1][i];
+  T *x = (T *) v;
+  (*x)[0][0] = 0;
+}
+
+A a = 10;
Index: gcc/testsuite/g++.dg/ext/builtin12.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/ext/builtin12.C b/gcc/testsuite/g++.dg/ext/builtin12.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/ext/builtin12.C	(revision 262353)
@@ -0,0 +1,10 @@
+// PR c++/85113
+// { dg-do compile { target c++14 } }
+
+template<bool> struct A {};
+
+constexpr int foo()
+{
+  A<__builtin_constant_p(0)> a{};
+  return 0;
+}
Index: gcc/testsuite/g++.dg/ext/builtin13.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/ext/builtin13.C b/gcc/testsuite/g++.dg/ext/builtin13.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/ext/builtin13.C	(revision 262353)
@@ -0,0 +1,9 @@
+// PR inline-asm/85172
+// { dg-do compile }
+// { dg-options "" }
+
+int
+foo ()
+{
+  return !__builtin_constant_p (({ __asm (""); 0; }));
+}
Index: gcc/testsuite/g++.dg/ext/atomic-4.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/ext/atomic-4.C b/gcc/testsuite/g++.dg/ext/atomic-4.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/ext/atomic-4.C	(revision 262353)
@@ -0,0 +1,9 @@
+// PR inline-asm/85172
+// { dg-do compile }
+// { dg-options "" }
+
+int
+foo (int *p)
+{
+  return !__atomic_always_lock_free (4, ({ __asm (""); p; }));
+}
Index: gcc/testsuite/g++.dg/ext/asm14.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/ext/asm14.C b/gcc/testsuite/g++.dg/ext/asm14.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/ext/asm14.C	(revision 262353)
@@ -0,0 +1,10 @@
+// PR c++/85659
+// { dg-do compile }
+
+struct S { S (); ~S (); int s; };
+
+void
+foo (S &s)
+{
+  __asm volatile ("" : "+m,r" (s) : : "memory");
+}
Index: gcc/testsuite/g++.dg/ext/asm15.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/ext/asm15.C b/gcc/testsuite/g++.dg/ext/asm15.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/ext/asm15.C	(revision 262353)
@@ -0,0 +1,10 @@
+// PR c++/85659
+// { dg-do compile }
+
+struct S { S (); ~S (); int s; };
+
+void
+foo (S &s)
+{
+  __asm volatile ("" : "+r" (s) : : "memory");	// { dg-error "" }
+}
Index: gcc/testsuite/g++.dg/ext/asm16.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/ext/asm16.C b/gcc/testsuite/g++.dg/ext/asm16.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/ext/asm16.C	(revision 262353)
@@ -0,0 +1,10 @@
+// PR c++/85659
+// { dg-do compile }
+
+struct S { S (); ~S (); int s[64]; } s;
+
+void
+foo ()
+{
+  __asm volatile ("" : "=r" (s) : : "memory");	// { dg-error "" }
+}
Index: gcc/testsuite/g++.dg/ext/attr-noinline-4.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/ext/attr-noinline-4.C b/gcc/testsuite/g++.dg/ext/attr-noinline-4.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/ext/attr-noinline-4.C	(revision 262353)
@@ -0,0 +1,10 @@
+// PR c++/84665
+
+struct S {} a[1];
+
+template <int N>
+void
+foo ()
+{
+  __attribute__ ((noinline (a[0]))) int c = 0; // { dg-error "wrong number of arguments" }
+}
Index: gcc/testsuite/g++.dg/vect/pr84556.cc
===================================================================
diff --git a/gcc/testsuite/g++.dg/vect/pr84556.cc b/gcc/testsuite/g++.dg/vect/pr84556.cc
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/vect/pr84556.cc	(revision 262353)
@@ -0,0 +1,21 @@
+// PR c++/84556
+// { dg-do run { target c++11 } }
+// { dg-options "-O2 -fopenmp-simd" }
+// { dg-additional-options "-mavx" { target avx_runtime } }
+
+int
+main ()
+{
+  int y[8] = { 1, 2, 3, 4, 5, 6, 7, 8 };
+  auto x = [&y] ()
+  {
+    #pragma omp simd
+    for (int i = 0; i < 8; ++i)
+      y[i]++;
+  };
+  x ();
+  x ();
+  for (int i = 0; i < 8; ++i)
+    if (y[i] != i + 3)
+      __builtin_abort ();
+}
Index: gcc/testsuite/g++.dg/gomp/pr84556.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/gomp/pr84556.C b/gcc/testsuite/g++.dg/gomp/pr84556.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/gomp/pr84556.C	(revision 262353)
@@ -0,0 +1,14 @@
+// PR c++/84556
+// { dg-do compile }
+// { dg-options "-std=c++17 -fopenmp-simd" }
+
+void
+foo ()
+{
+  auto x = [] ()
+  {
+    #pragma omp simd
+    for (int i = 0; i < 8; ++i)
+      ;
+  };
+}
Index: gcc/testsuite/g++.dg/gomp/pr84430.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/gomp/pr84430.C b/gcc/testsuite/g++.dg/gomp/pr84430.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/gomp/pr84430.C	(revision 262353)
@@ -0,0 +1,12 @@
+// PR c++/84430
+// { dg-do compile { target c++11 } }
+
+void
+foo ()
+{
+  auto a = [] {
+    #pragma omp simd
+    for (int i = 0; i < 10; ++i)
+      ;
+  };
+}
Index: gcc/testsuite/g++.dg/gomp/pr84791.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/gomp/pr84791.C b/gcc/testsuite/g++.dg/gomp/pr84791.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/gomp/pr84791.C	(revision 262353)
@@ -0,0 +1,15 @@
+// PR c++/84791
+// { dg-do compile }
+
+typedef int I;
+
+template <int>
+void
+foo ()
+{
+  I i;
+  #pragma omp parallel reduction (I::I: i)	// { dg-error "'I' is not a class, namespace, or enumeration" "" { target c++11 } }
+    ;						// { dg-error "'I' is not a class or namespace" "" { target c++98_only } .-1 }
+}
+
+template void foo<0> ();
Index: gcc/testsuite/g++.dg/gomp/pr84557.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/gomp/pr84557.C b/gcc/testsuite/g++.dg/gomp/pr84557.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/gomp/pr84557.C	(revision 262353)
@@ -0,0 +1,14 @@
+// PR c++/84557
+// { dg-do compile }
+
+template<int> struct A {};
+template<int> struct B {};
+
+void
+foo ()
+{
+  #pragma omp parallel firstprivate (A)		// { dg-error "is not a variable in clause" }
+  ;
+  #pragma omp parallel firstprivate (B<0>)	// { dg-error "is not a variable in clause" }
+  ;
+}
Index: gcc/testsuite/g++.dg/gomp/pr84448.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/gomp/pr84448.C b/gcc/testsuite/g++.dg/gomp/pr84448.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/gomp/pr84448.C	(revision 262353)
@@ -0,0 +1,17 @@
+// PR c++/84448
+// { dg-do compile }
+
+struct A
+{
+  operator int () const;
+  A& operator += (int);
+  A& operator ++ ();
+};
+
+void
+foo (A a, A b)
+{
+  #pragma omp for
+  for (A i = a; i <=; ++i)	// { dg-error "expected primary-expression before" }
+    ;				// { dg-error "invalid controlling predicate" "" { target *-*-* } .-1 }
+}
Index: gcc/testsuite/g++.dg/init/pr83993-2.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/init/pr83993-2.C b/gcc/testsuite/g++.dg/init/pr83993-2.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/init/pr83993-2.C	(revision 262353)
@@ -0,0 +1,14 @@
+// PR c++/83993
+// { dg-do compile }
+// { dg-options "-w" }
+
+int a[5];
+extern int b[];
+int *const c = &a[6];
+int *const d = &b[1];
+
+int
+foo ()
+{
+  return c[-4] + d[-1];
+}
Index: gcc/testsuite/g++.dg/init/new44.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/init/new44.C b/gcc/testsuite/g++.dg/init/new44.C
--- a/gcc/testsuite/g++.dg/init/new44.C	(revision 262353)
+++ b/gcc/testsuite/g++.dg/init/new44.C	(revision 262353)
@@ -87,10 +87,10 @@
 static void __attribute__ ((used))
 test_two_dim_char_array ()
 {
-    p = new char [1][MAX];              // { dg-error "size of unnamed array" }
-    p = new char [1][MAX - 1];          // { dg-error "size of unnamed array" }
-    p = new char [1][MAX - 2];          // { dg-error "size of unnamed array" }
-    p = new char [1][MAX - 99];         // { dg-error "size of unnamed array" }
+    p = new char [1][MAX];              // { dg-error "size of (unnamed )?array" }
+    p = new char [1][MAX - 1];          // { dg-error "size of (unnamed )?array" }
+    p = new char [1][MAX - 2];          // { dg-error "size of (unnamed )?array" }
+    p = new char [1][MAX - 99];         // { dg-error "size of (unnamed )?array" }
     p = new char [1][MAX / 2];          // { dg-error "size of array" }
     p = new char [1][MAX / 2 - 1];      // { dg-error "size of array" }
     p = new char [1][MAX / 2 - 2];      // { dg-error "size of array" }
@@ -104,9 +104,9 @@
     p = new char [1][MAX / 2 - 7];      // okay
     p = new char [1][MAX / 2 - 8];      // okay
 
-    p = new char [2][MAX];              // { dg-error "size of unnamed array" }
-    p = new char [2][MAX - 1];          // { dg-error "size of unnamed array" }
-    p = new char [2][MAX - 2];          // { dg-error "size of unnamed array" }
+    p = new char [2][MAX];              // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX - 1];          // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX - 2];          // { dg-error "size of (unnamed )?array" }
     p = new char [2][MAX / 2];          // { dg-error "size of array" }
     p = new char [2][MAX / 2 - 1];      // { dg-error "size of array" }
     p = new char [2][MAX / 2 - 2];      // { dg-error "size of array" }
@@ -113,9 +113,9 @@
     p = new char [2][MAX / 2 - 7];      // { dg-error "size of array" }
     p = new char [2][MAX / 2 - 8];      // { dg-error "size of array" }
 
-    p = new char [MAX][MAX];            // { dg-error "size of unnamed array" }
-    p = new char [MAX][MAX - 1];        // { dg-error "size of unnamed array" }
-    p = new char [MAX][MAX - 2];        // { dg-error "size of unnamed array" }
+    p = new char [MAX][MAX];            // { dg-error "size of (unnamed )?array" }
+    p = new char [MAX][MAX - 1];        // { dg-error "size of (unnamed )?array" }
+    p = new char [MAX][MAX - 2];        // { dg-error "size of (unnamed )?array" }
     p = new char [MAX][MAX / 2];        // { dg-error "size of array" }
     p = new char [MAX][MAX / 2 - 1];    // { dg-error "size of array" }
     p = new char [MAX][MAX / 2 - 2];    // { dg-error "size of array" }
@@ -142,10 +142,10 @@
 static __attribute__ ((used)) void
 test_three_dim_char_array ()
 {
-    p = new char [1][1][MAX];           // { dg-error "size of unnamed array" }
-    p = new char [1][1][MAX - 1];       // { dg-error "size of unnamed array" }
-    p = new char [1][1][MAX - 2];       // { dg-error "size of unnamed array" }
-    p = new char [1][1][MAX - 99];      // { dg-error "size of unnamed array" }
+    p = new char [1][1][MAX];           // { dg-error "size of (unnamed )?array" }
+    p = new char [1][1][MAX - 1];       // { dg-error "size of (unnamed )?array" }
+    p = new char [1][1][MAX - 2];       // { dg-error "size of (unnamed )?array" }
+    p = new char [1][1][MAX - 99];      // { dg-error "size of (unnamed )?array" }
     p = new char [1][1][MAX / 2];       // { dg-error "size of array" }
     p = new char [1][1][MAX / 2 - 1];   // { dg-error "size of array" }
     p = new char [1][1][MAX / 2 - 2];   // { dg-error "size of array" }
@@ -159,19 +159,19 @@
     p = new char [1][1][MAX / 2 - 7];   // okay
     p = new char [1][1][MAX / 2 - 8];   // okay
 
-    p = new char [1][2][MAX];           // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX - 1];       // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX - 2];       // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX - 99];      // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX / 2];       // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX / 2 - 1];   // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX / 2 - 2];   // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX / 2 - 3];   // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX / 2 - 4];   // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX / 2 - 5];   // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX / 2 - 6];   // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX / 2 - 7];   // { dg-error "size of unnamed array" }
-    p = new char [1][2][MAX / 2 - 8];   // { dg-error "size of unnamed array" }
+    p = new char [1][2][MAX];           // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX - 1];       // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX - 2];       // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX - 99];      // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX / 2];       // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX / 2 - 1];   // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX / 2 - 2];   // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX / 2 - 3];   // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX / 2 - 4];   // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX / 2 - 5];   // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX / 2 - 6];   // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX / 2 - 7];   // { dg-error "size of (unnamed )?array" }
+    p = new char [1][2][MAX / 2 - 8];   // { dg-error "size of (unnamed )?array" }
     p = new char [1][2][MAX / 4];       // { dg-error "size of array" }
 
     // Avoid exercising data model-dependent expressions.
@@ -181,10 +181,10 @@
     p = new char [1][2][MAX / 4 - 3];   // okay
     p = new char [1][2][MAX / 4 - 4];   // okay
 
-    p = new char [2][1][MAX];           // { dg-error "size of unnamed array" }
-    p = new char [2][1][MAX - 1];       // { dg-error "size of unnamed array" }
-    p = new char [2][1][MAX - 2];       // { dg-error "size of unnamed array" }
-    p = new char [2][1][MAX - 99];      // { dg-error "size of unnamed array" }
+    p = new char [2][1][MAX];           // { dg-error "size of (unnamed )?array" }
+    p = new char [2][1][MAX - 1];       // { dg-error "size of (unnamed )?array" }
+    p = new char [2][1][MAX - 2];       // { dg-error "size of (unnamed )?array" }
+    p = new char [2][1][MAX - 99];      // { dg-error "size of (unnamed )?array" }
     p = new char [2][1][MAX / 2];       // { dg-error "size of array" }
     p = new char [2][1][MAX / 2 - 1];   // { dg-error "size of array" }
     p = new char [2][1][MAX / 2 - 2];   // { dg-error "size of array" }
@@ -203,19 +203,19 @@
     p = new char [2][1][MAX / 4 - 3];   // okay
     p = new char [2][1][MAX / 4 - 4];   // okay
 
-    p = new char [2][2][MAX];           // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX - 1];       // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX - 2];       // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX - 99];      // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX / 2];       // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX / 2 - 1];   // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX / 2 - 2];   // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX / 2 - 3];   // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX / 2 - 4];   // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX / 2 - 5];   // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX / 2 - 6];   // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX / 2 - 7];   // { dg-error "size of unnamed array" }
-    p = new char [2][2][MAX / 2 - 8];   // { dg-error "size of unnamed array" }
+    p = new char [2][2][MAX];           // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX - 1];       // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX - 2];       // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX - 99];      // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX / 2];       // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX / 2 - 1];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX / 2 - 2];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX / 2 - 3];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX / 2 - 4];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX / 2 - 5];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX / 2 - 6];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX / 2 - 7];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][2][MAX / 2 - 8];   // { dg-error "size of (unnamed )?array" }
     p = new char [2][2][MAX / 4];       // { dg-error "size of array" }
     p = new char [2][2][MAX / 4 - 1];   // { dg-error "size of array" }
     p = new char [2][2][MAX / 4 - 2];   // { dg-error "size of array" }
@@ -227,19 +227,19 @@
     p = new char [2][2][MAX / 8 - 2];
     p = new char [2][2][MAX / 8 - 3];
 
-    p = new char [2][MAX][2];           // { dg-error "size of unnamed array" }
-    p = new char [2][MAX - 1][2];       // { dg-error "size of unnamed array" }
-    p = new char [2][MAX - 2][2];       // { dg-error "size of unnamed array" }
-    p = new char [2][MAX - 99][2];      // { dg-error "size of unnamed array" }
-    p = new char [2][MAX / 2][2];       // { dg-error "size of unnamed array" }
-    p = new char [2][MAX / 2 - 1][2];   // { dg-error "size of unnamed array" }
-    p = new char [2][MAX / 2 - 2][2];   // { dg-error "size of unnamed array" }
-    p = new char [2][MAX / 2 - 3][2];   // { dg-error "size of unnamed array" }
-    p = new char [2][MAX / 2 - 4][2];   // { dg-error "size of unnamed array" }
-    p = new char [2][MAX / 2 - 5][2];   // { dg-error "size of unnamed array" }
-    p = new char [2][MAX / 2 - 6][2];   // { dg-error "size of unnamed array" }
-    p = new char [2][MAX / 2 - 7][2];   // { dg-error "size of unnamed array" }
-    p = new char [2][MAX / 2 - 8][2];   // { dg-error "size of unnamed array" }
+    p = new char [2][MAX][2];           // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX - 1][2];       // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX - 2][2];       // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX - 99][2];      // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX / 2][2];       // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX / 2 - 1][2];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX / 2 - 2][2];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX / 2 - 3][2];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX / 2 - 4][2];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX / 2 - 5][2];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX / 2 - 6][2];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX / 2 - 7][2];   // { dg-error "size of (unnamed )?array" }
+    p = new char [2][MAX / 2 - 8][2];   // { dg-error "size of (unnamed )?array" }
     p = new char [2][MAX / 4][2];       // { dg-error "size of array" }
     p = new char [2][MAX / 4 - 1][2];   // { dg-error "size of array" }
     p = new char [2][MAX / 4 - 2][2];   // { dg-error "size of array" }
@@ -275,11 +275,11 @@
     p = new char [MAX / 8 - 2][2][2];
     p = new char [MAX / 8 - 3][2][2];
 
-    p = new char [MAX][MAX][MAX];         // { dg-error "size of unnamed array" }
-    p = new char [MAX][MAX][MAX / 2];     // { dg-error "size of unnamed array" }
-    p = new char [MAX][MAX / 2][MAX];     // { dg-error "size of unnamed array" }
-    p = new char [MAX][MAX / 2][MAX / 2]; // { dg-error "size of unnamed array" }
-    p = new char [MAX / 2][MAX / 2][MAX / 2]; // { dg-error "size of unnamed array" }
+    p = new char [MAX][MAX][MAX];         // { dg-error "size of (unnamed )?array" }
+    p = new char [MAX][MAX][MAX / 2];     // { dg-error "size of (unnamed )?array" }
+    p = new char [MAX][MAX / 2][MAX];     // { dg-error "size of (unnamed )?array" }
+    p = new char [MAX][MAX / 2][MAX / 2]; // { dg-error "size of (unnamed )?array" }
+    p = new char [MAX / 2][MAX / 2][MAX / 2]; // { dg-error "size of (unnamed )?array" }
 }
 
 // Exercise new expression with N-dimensional arrays where N is
@@ -342,10 +342,10 @@
 static void __attribute__ ((used))
 test_placement_two_dim_byte_struct_array (void *p)
 {
-    p = new (p) B [1][MAX];             // { dg-error "size of unnamed array" }
-    p = new (p) B [1][MAX - 1];         // { dg-error "size of unnamed array" }
-    p = new (p) B [1][MAX - 2];         // { dg-error "size of unnamed array" }
-    p = new (p) B [1][MAX - 99];        // { dg-error "size of unnamed array" }
+    p = new (p) B [1][MAX];             // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][MAX - 1];         // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][MAX - 2];         // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][MAX - 99];        // { dg-error "size of (unnamed )?array" }
     p = new (p) B [1][MAX / 2];         // { dg-error "size of array" }
     p = new (p) B [1][MAX / 2 - 1];     // { dg-error "size of array" }
     p = new (p) B [1][MAX / 2 - 2];     // { dg-error "size of array" }
@@ -359,9 +359,9 @@
     p = new (p) B [1][MAX / 2 - 7];      // okay
     p = new (p) B [1][MAX / 2 - 8];      // okay
 
-    p = new (p) B [2][MAX];             // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX - 1];         // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX - 2];         // { dg-error "size of unnamed array" }
+    p = new (p) B [2][MAX];             // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX - 1];         // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX - 2];         // { dg-error "size of (unnamed )?array" }
     p = new (p) B [2][MAX / 2];         // { dg-error "size of array" }
     p = new (p) B [2][MAX / 2 - 1];     // { dg-error "size of array" }
     p = new (p) B [2][MAX / 2 - 2];     // { dg-error "size of array" }
@@ -368,9 +368,9 @@
     p = new (p) B [2][MAX / 2 - 7];     // { dg-error "size of array" }
     p = new (p) B [2][MAX / 2 - 8];     // { dg-error "size of array" }
 
-    p = new (p) B [MAX][MAX];           // { dg-error "size of unnamed array" }
-    p = new (p) B [MAX][MAX - 1];       // { dg-error "size of unnamed array" }
-    p = new (p) B [MAX][MAX - 2];       // { dg-error "size of unnamed array" }
+    p = new (p) B [MAX][MAX];           // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [MAX][MAX - 1];       // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [MAX][MAX - 2];       // { dg-error "size of (unnamed )?array" }
     p = new (p) B [MAX][MAX / 2];       // { dg-error "size of array" }
     p = new (p) B [MAX][MAX / 2 - 1];   // { dg-error "size of array" }
     p = new (p) B [MAX][MAX / 2 - 2];   // { dg-error "size of array" }
@@ -397,10 +397,10 @@
 static __attribute__ ((used)) void
 test_placement_three_dim_byte_struct_array (void *p)
 {
-    p = new (p) B [1][1][MAX];          // { dg-error "size of unnamed array" }
-    p = new (p) B [1][1][MAX - 1];      // { dg-error "size of unnamed array" }
-    p = new (p) B [1][1][MAX - 2];      // { dg-error "size of unnamed array" }
-    p = new (p) B [1][1][MAX - 99];     // { dg-error "size of unnamed array" }
+    p = new (p) B [1][1][MAX];          // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][1][MAX - 1];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][1][MAX - 2];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][1][MAX - 99];     // { dg-error "size of (unnamed )?array" }
     p = new (p) B [1][1][MAX / 2];      // { dg-error "size of array" }
     p = new (p) B [1][1][MAX / 2 - 1];  // { dg-error "size of array" }
     p = new (p) B [1][1][MAX / 2 - 2];  // { dg-error "size of array" }
@@ -414,19 +414,19 @@
     p = new (p) B [1][1][MAX / 2 - 7];   // okay
     p = new (p) B [1][1][MAX / 2 - 8];   // okay
 
-    p = new (p) B [1][2][MAX];          // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX - 1];      // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX - 2];      // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX - 99];     // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX / 2];      // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX / 2 - 1];  // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX / 2 - 2];  // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX / 2 - 3];  // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX / 2 - 4];  // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX / 2 - 5];  // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX / 2 - 6];  // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX / 2 - 7];  // { dg-error "size of unnamed array" }
-    p = new (p) B [1][2][MAX / 2 - 8];  // { dg-error "size of unnamed array" }
+    p = new (p) B [1][2][MAX];          // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX - 1];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX - 2];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX - 99];     // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX / 2];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX / 2 - 1];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX / 2 - 2];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX / 2 - 3];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX / 2 - 4];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX / 2 - 5];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX / 2 - 6];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX / 2 - 7];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [1][2][MAX / 2 - 8];  // { dg-error "size of (unnamed )?array" }
     p = new (p) B [1][2][MAX / 4];      // { dg-error "size of array" }
 
     // Avoid exercising data model-dependent expressions.
@@ -436,10 +436,10 @@
     p = new (p) B [1][2][MAX / 4 - 3];   // okay
     p = new (p) B [1][2][MAX / 4 - 4];   // okay
 
-    p = new (p) B [2][1][MAX];          // { dg-error "size of unnamed array" }
-    p = new (p) B [2][1][MAX - 1];      // { dg-error "size of unnamed array" }
-    p = new (p) B [2][1][MAX - 2];      // { dg-error "size of unnamed array" }
-    p = new (p) B [2][1][MAX - 99];     // { dg-error "size of unnamed array" }
+    p = new (p) B [2][1][MAX];          // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][1][MAX - 1];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][1][MAX - 2];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][1][MAX - 99];     // { dg-error "size of (unnamed )?array" }
     p = new (p) B [2][1][MAX / 2];      // { dg-error "size of array" }
     p = new (p) B [2][1][MAX / 2 - 1];  // { dg-error "size of array" }
     p = new (p) B [2][1][MAX / 2 - 2];  // { dg-error "size of array" }
@@ -458,19 +458,19 @@
     p = new (p) B [2][1][MAX / 4 - 3];   // okay
     p = new (p) B [2][1][MAX / 4 - 4];   // okay
 
-    p = new (p) B [2][2][MAX];          // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX - 1];      // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX - 2];      // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX - 99];     // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX / 2];      // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX / 2 - 1];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX / 2 - 2];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX / 2 - 3];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX / 2 - 4];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX / 2 - 5];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX / 2 - 6];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX / 2 - 7];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][2][MAX / 2 - 8];  // { dg-error "size of unnamed array" }
+    p = new (p) B [2][2][MAX];          // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX - 1];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX - 2];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX - 99];     // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX / 2];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX / 2 - 1];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX / 2 - 2];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX / 2 - 3];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX / 2 - 4];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX / 2 - 5];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX / 2 - 6];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX / 2 - 7];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][2][MAX / 2 - 8];  // { dg-error "size of (unnamed )?array" }
     p = new (p) B [2][2][MAX / 4];      // { dg-error "size of array" }
     p = new (p) B [2][2][MAX / 4 - 1];  // { dg-error "size of array" }
     p = new (p) B [2][2][MAX / 4 - 2];  // { dg-error "size of array" }
@@ -482,19 +482,19 @@
     p = new (p) B [2][2][MAX / 8 - 2];
     p = new (p) B [2][2][MAX / 8 - 3];
 
-    p = new (p) B [2][MAX][2];          // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX - 1][2];      // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX - 2][2];      // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX - 99][2];     // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX / 2][2];      // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX / 2 - 1][2];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX / 2 - 2][2];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX / 2 - 3][2];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX / 2 - 4][2];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX / 2 - 5][2];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX / 2 - 6][2];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX / 2 - 7][2];  // { dg-error "size of unnamed array" }
-    p = new (p) B [2][MAX / 2 - 8][2];  // { dg-error "size of unnamed array" }
+    p = new (p) B [2][MAX][2];          // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX - 1][2];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX - 2][2];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX - 99][2];     // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX / 2][2];      // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX / 2 - 1][2];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX / 2 - 2][2];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX / 2 - 3][2];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX / 2 - 4][2];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX / 2 - 5][2];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX / 2 - 6][2];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX / 2 - 7][2];  // { dg-error "size of (unnamed )?array" }
+    p = new (p) B [2][MAX / 2 - 8][2];  // { dg-error "size of (unnamed )?array" }
     p = new (p) B [2][MAX / 4][2];      // { dg-error "size of array" }
     p = new (p) B [2][MAX / 4 - 1][2];  // { dg-error "size of array" }
     p = new (p) B [2][MAX / 4 - 2][2];  // { dg-error "size of array" }
Index: gcc/testsuite/g++.dg/init/struct2.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/init/struct2.C b/gcc/testsuite/g++.dg/init/struct2.C
--- a/gcc/testsuite/g++.dg/init/struct2.C	(revision 262353)
+++ b/gcc/testsuite/g++.dg/init/struct2.C	(revision 262353)
@@ -15,7 +15,7 @@
     };    
 
     SaveLoadEntry trackEntries = {
-	((long) (__SIZE_TYPE__) (&((Track *) 42)->soundName[0])) - 42,
+	((int) (__SIZE_TYPE__) (&((Track *) 42)->soundName[0])) - 42,
         0, 1
     };
     saveLoadEntries(&trackEntries);
Index: gcc/testsuite/g++.dg/other/anon5.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/other/anon5.C b/gcc/testsuite/g++.dg/other/anon5.C
--- a/gcc/testsuite/g++.dg/other/anon5.C	(revision 262353)
+++ b/gcc/testsuite/g++.dg/other/anon5.C	(revision 262353)
@@ -4,7 +4,7 @@
 // Ignore additional message on powerpc-ibm-aix
 // { dg-prune-output "obtain more information" } */
 // Ignore additional messages on Linux/x86 with PIE
-// { dg-prune-output "Bad value" } */
+// { dg-prune-output "\[Bb\]ad value" } */
 
 namespace {
   struct c
Index: gcc/testsuite/g++.dg/tree-ssa/volatile2.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/tree-ssa/volatile2.C b/gcc/testsuite/g++.dg/tree-ssa/volatile2.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/tree-ssa/volatile2.C	(revision 262353)
@@ -0,0 +1,20 @@
+// PR c++/84686
+// { dg-additional-options -fdump-tree-gimple }
+// { dg-final { scan-tree-dump-times "= i" 10 "gimple" } }
+
+volatile int i;
+
+int main()
+{
+  i; //evaluated (a load is performed)
+  (i); //unevaluated => the load shall be performed
+
+  (void)i; //evaluated (a load is performed)
+  (void)(i); //unevaluated => the load shall be performed
+
+  (void)i; //evaluated (a load is performed)
+  (void)(i); //unevaluated => the load shall be performed
+
+  (i,i); // the two subexpression are evaluated
+  ((i),(i)); // no evaluation, => two loads shall happen
+}
Index: gcc/testsuite/g++.dg/tree-ssa/volatile1.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/tree-ssa/volatile1.C b/gcc/testsuite/g++.dg/tree-ssa/volatile1.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/tree-ssa/volatile1.C	(revision 262353)
@@ -0,0 +1,28 @@
+// PR c++/84151
+// { dg-additional-options "-fdump-tree-gimple" }
+// { dg-final { scan-tree-dump-not {\*this} "gimple" } }
+
+struct A {
+  static int& bar(int& a) {
+    return a;
+  }
+  static int i;
+
+  int foo() volatile {
+    int v = c;
+    return i + bar(v);
+  }
+
+  int c;
+};
+
+int A::i = 0;
+
+A a;
+
+int main() {
+  a.c = 2;
+  a.foo();
+
+  return 0;
+}
Index: gcc/testsuite/g++.dg/warn/Wunused-function4.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/warn/Wunused-function4.C b/gcc/testsuite/g++.dg/warn/Wunused-function4.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/warn/Wunused-function4.C	(revision 262353)
@@ -0,0 +1,21 @@
+// PR c++/80598
+// { dg-do compile }
+// { dg-options "-Wunused-function" }
+
+static void
+foo ()		// { dg-bogus "defined but not used" }
+{
+}
+
+static void
+bar ()		// { dg-warning "defined but not used" }
+{
+}
+
+template <class T>
+int
+baz (T x)
+{
+  foo ();
+  return 0;
+}
Index: gcc/testsuite/g++.dg/warn/Wnonnull4.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/warn/Wnonnull4.C b/gcc/testsuite/g++.dg/warn/Wnonnull4.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/warn/Wnonnull4.C	(revision 262353)
@@ -0,0 +1,21 @@
+// PR c++/86210
+// { dg-do compile }
+// { dg-options "-Wnonnull" }
+
+void *declared_not_defined (void *p) __attribute__((nonnull));
+
+inline void *declared_and_defined (void *p) __attribute__((nonnull));
+
+int
+main ()
+{
+  int *const p = 0;
+  declared_not_defined (p);	// { dg-warning "null argument where non-null required" }
+  declared_and_defined (p);	// { dg-warning "null argument where non-null required" }
+}
+
+void *
+declared_and_defined (void *p)
+{
+  return p;
+}
Index: gcc/testsuite/g++.dg/warn/Wunused-var-33.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/warn/Wunused-var-33.C b/gcc/testsuite/g++.dg/warn/Wunused-var-33.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/warn/Wunused-var-33.C	(revision 262353)
@@ -0,0 +1,37 @@
+// PR c++/85952
+// { dg-do compile { target c++11 } }
+// { dg-options "-Wunused-but-set-variable" }
+
+int
+foo ()
+{
+  int a[2] = {1, 2};	// { dg-bogus "set but not used" } */
+  auto [x, y] = a;	// { dg-warning "decomposition declaration only available with" "" { target c++14_down } }
+  return x + y;
+}
+
+struct S { int d, e; };
+
+int
+bar ()
+{
+  S a = {1, 2};
+  auto [x, y] = a;	// { dg-warning "decomposition declaration only available with" "" { target c++14_down } }
+  return x + y;
+}
+
+int
+baz ()
+{
+  S a = {1, 2};
+  auto & [x, y] = a;	// { dg-warning "decomposition declaration only available with" "" { target c++14_down } }
+  return x + y;
+}
+
+int
+qux ()
+{
+  int a[2] = {1, 2};
+  auto & [x, y] = a;	// { dg-warning "decomposition declaration only available with" "" { target c++14_down } }
+  return x + y;
+}
Index: gcc/testsuite/g++.dg/warn/deprecated-6.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/warn/deprecated-6.C b/gcc/testsuite/g++.dg/warn/deprecated-6.C
--- a/gcc/testsuite/g++.dg/warn/deprecated-6.C	(revision 262353)
+++ b/gcc/testsuite/g++.dg/warn/deprecated-6.C	(revision 262353)
@@ -98,7 +98,7 @@
 
 inline void T::member1(int) {}
 
-int T::member3(T *p)		// { dg-warning "'T' is deprecated: Please avoid T" }
+int T::member3(T *p)		// { dg-bogus "'T' is deprecated: Please avoid T" }
 {
   p->member1(1);			/* { dg-warning "'void T::member1\\(int\\)' is deprecated: Please avoid member1" "" } */
   (*p).member1(2);			/* { dg-warning "'void T::member1\\(int\\)' is deprecated: Please avoid member1" "" } */
Index: gcc/testsuite/g++.dg/warn/Wformat-2.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/warn/Wformat-2.C b/gcc/testsuite/g++.dg/warn/Wformat-2.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/warn/Wformat-2.C	(revision 262353)
@@ -0,0 +1,17 @@
+// PR c++/84076
+// { dg-do compile }
+// { dg-options "-Wformat" }
+
+struct S { ~S (); };
+struct T { T (); T (const T &); };
+
+void
+foo ()
+{
+  S s;
+  T t;
+  __builtin_printf ("%s\n", s);	// { dg-warning "format '%s' expects argument of type 'char\\*', but argument 2 has type 'S'" }
+  __builtin_printf ("%s\n", t);	// { dg-warning "format '%s' expects argument of type 'char\\*', but argument 2 has type 'T'" }
+  __builtin_printf ("%s\n", &s);// { dg-warning "format '%s' expects argument of type 'char\\*', but argument 2 has type 'S\\*'" }
+  __builtin_printf ("%s\n", &t);// { dg-warning "format '%s' expects argument of type 'char\\*', but argument 2 has type 'T\\*'" }
+}
Index: gcc/testsuite/g++.dg/warn/deprecated.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/warn/deprecated.C b/gcc/testsuite/g++.dg/warn/deprecated.C
--- a/gcc/testsuite/g++.dg/warn/deprecated.C	(revision 262353)
+++ b/gcc/testsuite/g++.dg/warn/deprecated.C	(revision 262353)
@@ -102,7 +102,7 @@
 
 inline void T::member1(int) {}
 
-int T::member3(T *p)		// { dg-warning "'T' is deprecated" }
+int T::member3(T *p)		// { dg-bogus "'T' is deprecated" }
 {
   p->member1(1);			/* { dg-warning "'void T::member1\\(int\\)' is deprecated" "" } */
   (*p).member1(2);			/* { dg-warning "'void T::member1\\(int\\)' is deprecated" "" } */
@@ -113,5 +113,3 @@
   return f1(); 				/* { dg-warning "'INT1 f1\\(\\)' is deprecated" "" } */
 }
 #endif
-
-
Index: gcc/testsuite/g++.dg/warn/deprecated-13.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/warn/deprecated-13.C b/gcc/testsuite/g++.dg/warn/deprecated-13.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/warn/deprecated-13.C	(revision 262353)
@@ -0,0 +1,44 @@
+// PR c++/84222
+// { dg-do compile }
+
+struct __attribute__((deprecated)) C {		// { dg-message "declared here" }
+  C () {}
+  C (const C &);				// { dg-bogus "'C' is deprecated" }
+  C (const C &x, const C &y) { C z = x; }	// { dg-bogus "'C' is deprecated" }
+  void foo (const C &x, const C &y);		// { dg-bogus "'C' is deprecated" }
+};
+
+void
+C::foo (const C &x, const C &y)			// { dg-bogus "'C' is deprecated" }
+{
+  C z = x;					// { dg-bogus "'C' is deprecated" }
+}
+
+void
+bar (const C &x, const C &y)			// { dg-warning "'C' is deprecated" }
+{
+  C z = x;					// { dg-warning "'C' is deprecated" }
+}
+
+template <int N>
+struct __attribute__((deprecated)) D {		// { dg-message "declared here" }
+  D () {}
+  D (const D &);				// { dg-bogus "is deprecated" }
+  D (const D &x, const D &y) { D z = x; }	// { dg-bogus "is deprecated" }
+  void foo (const D &x, const D &y);		// { dg-bogus "is deprecated" }
+};
+
+template <int N>
+void
+D<N>::foo					// { dg-bogus "is deprecated" "" { xfail *-*-* } }
+(const D &x, const D &y)			// { dg-bogus "is deprecated" }
+{
+  D z = x;					// { dg-bogus "is deprecated" }
+}
+
+template <int N>
+void
+bar (const D<N> &x, const D<N> &y)		// { dg-warning "is deprecated" }
+{
+  D<N> z = x;					// { dg-warning "is deprecated" }
+}
Index: gcc/testsuite/g++.dg/concepts/auto4.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/concepts/auto4.C b/gcc/testsuite/g++.dg/concepts/auto4.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/concepts/auto4.C	(revision 262353)
@@ -0,0 +1,11 @@
+// PR c++/85006
+// { dg-additional-options "-std=c++17 -fconcepts" }
+
+template<typename... Ts> struct A {};
+
+template<typename... Us> A<auto...> foo() { return A{}; }
+
+void bar()
+{
+  foo();
+}
Index: gcc/testsuite/g++.dg/asan/pr85081.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/asan/pr85081.C b/gcc/testsuite/g++.dg/asan/pr85081.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/asan/pr85081.C	(revision 262353)
@@ -0,0 +1,20 @@
+/* PR sanitizer/85081 */
+/* { dg-do run } */
+/* { dg-options "-fopenmp-simd" } */
+/* { dg-require-effective-target fopenmp } */
+
+inline const int& max(const int& a, const int& b)
+{
+  return a < b ? b : a;
+}
+
+int main()
+{
+  #pragma omp simd
+  for ( int i = 0; i < 20; ++i )
+  {
+    const int j = max(i, 1);
+  }
+
+  return 0;
+}
Index: gcc/testsuite/g++.dg/asan/pr78651.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/asan/pr78651.C b/gcc/testsuite/g++.dg/asan/pr78651.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/asan/pr78651.C	(revision 262353)
@@ -0,0 +1,26 @@
+// PR sanitizer/78651
+// { dg-do run }
+// { dg-additional-options "-fpic" { target fpic } }
+
+struct A { };
+
+namespace {
+
+void thisThrows () {
+  throw A();
+}
+
+struct SomeRandomType {};
+}
+
+int main() {
+  try {
+    thisThrows();
+  }
+  catch (SomeRandomType) {
+    throw;
+  }
+  catch (A) {
+  }
+  return 0;
+}
Index: gcc/testsuite/g++.dg/inherit/covariant22.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/inherit/covariant22.C b/gcc/testsuite/g++.dg/inherit/covariant22.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/inherit/covariant22.C	(revision 262353)
@@ -0,0 +1,19 @@
+// PR c++/85068
+// { dg-do compile }
+
+struct A;
+
+struct B
+{
+  virtual A *foo ();	// { dg-error "overriding" }
+};
+
+struct C : virtual B
+{
+  virtual C *foo ();	// { dg-error "invalid covariant return type for" }
+};
+
+struct D : C
+{
+  virtual C *foo ();
+};
Index: gcc/testsuite/g++.dg/template/nontype-fn1.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/template/nontype-fn1.C b/gcc/testsuite/g++.dg/template/nontype-fn1.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/template/nontype-fn1.C	(revision 262353)
@@ -0,0 +1,11 @@
+// PR c++/82664
+
+template < typename > struct target_disambiguator;
+template < typename R, typename A1 > struct target_disambiguator< R(A1) > {
+  typedef A1 type;
+  template < R (&)() > struct layout;
+};
+
+int main() {
+  typedef target_disambiguator< void (int) > ::type target_type ;
+}
Index: gcc/testsuite/g++.dg/template/dependent-base3.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/template/dependent-base3.C b/gcc/testsuite/g++.dg/template/dependent-base3.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/template/dependent-base3.C	(revision 262353)
@@ -0,0 +1,26 @@
+// PR c++/85060
+// { dg-do compile { target c++14 } }
+
+struct CA {
+  constexpr int foo() const { return 42; }
+};
+
+template <class T>
+struct CB : CA { };
+
+template <class T>
+struct CC : CB<T> {
+  constexpr int bar() const {
+    const int m = CA::foo();
+    return m;
+  }
+
+  constexpr int baz() const {
+    const T m = CA::foo();
+    return m;
+  }
+};
+
+constexpr CC<double> c;
+
+static_assert( c.bar() == 42, "" );
Index: gcc/testsuite/g++.dg/template/incomplete11.C
===================================================================
diff --git a/gcc/testsuite/g++.dg/template/incomplete11.C b/gcc/testsuite/g++.dg/template/incomplete11.C
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/g++.dg/template/incomplete11.C	(revision 262353)
@@ -0,0 +1,10 @@
+// PR c++/84082
+// { dg-do compile }
+// { dg-options "" }
+
+struct A;
+
+template<typename> void foo()
+{
+  static int a[A().operator=(A())];	// { dg-error "invalid use of incomplete type 'struct A'" }
+}
Index: gcc/testsuite/c-c++-common/tsan/race_on_mutex.c
===================================================================
diff --git a/gcc/testsuite/c-c++-common/tsan/race_on_mutex.c b/gcc/testsuite/c-c++-common/tsan/race_on_mutex.c
--- a/gcc/testsuite/c-c++-common/tsan/race_on_mutex.c	(revision 262353)
+++ b/gcc/testsuite/c-c++-common/tsan/race_on_mutex.c	(revision 262353)
@@ -37,9 +37,10 @@
 }
 
 /* { dg-output "WARNING: ThreadSanitizer: data race.*(\n|\r\n|\r)" } */
-/* { dg-output "  Atomic read of size 1 at .* by thread T2:(\n|\r\n|\r)" } */
+/* { dg-output "  Atomic read of size \[0-9]\+ at .* by thread T2:(\n|\r\n|\r)" } */
 /* { dg-output "    #0 pthread_mutex_lock.*" } */
 /* { dg-output "    #1 Thread2.* .*(race_on_mutex.c:22|\\?{2}:0) (.*)" } */
-/* { dg-output "  Previous write of size 1 at .* by thread T1:(\n|\r\n|\r)" } */
-/* { dg-output "    #0 pthread_mutex_init .* (.)*" } */
-/* { dg-output "    #1 Thread1.* .*(race_on_mutex.c:12|\\?{2}:0) .*" } */
+/* { dg-output "  Previous write of size \[0-9]\+ at .* by thread T1:(\n|\r\n|\r)" } */
+/* { dg-output "(    #0 \[^\n\r\]*(\n|\r\n|\r))?" } */
+/* { dg-output "    #\[01\] ((__GI_)?__)?pthread_mutex_init \[^\n\r\]* (.)*" } */
+/* { dg-output "    #\[12\] Thread1.* .*(race_on_mutex.c:12|\\?{2}:0) .*" } */
Index: gcc/testsuite/c-c++-common/pr84999.c
===================================================================
diff --git a/gcc/testsuite/c-c++-common/pr84999.c b/gcc/testsuite/c-c++-common/pr84999.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/c-c++-common/pr84999.c	(revision 262353)
@@ -0,0 +1,12 @@
+/* PR c/84999 */
+/* { dg-do compile { target { i?86-*-* x86_64-*-* } } } */
+/* { dg-options "" } */
+
+typedef __float128 V __attribute__ ((__vector_size__ (2 * sizeof (__float128))));
+V a;
+typeof (a != 0) b;	/* { dg-error "could not find an integer type of the same size as" "" { target ia32 } } */
+typeof (a == 0) c;	/* { dg-error "could not find an integer type of the same size as" "" { target ia32 } } */
+typeof (a < 0) d;	/* { dg-error "could not find an integer type of the same size as" "" { target ia32 } } */
+typeof (a <= 0) e;	/* { dg-error "could not find an integer type of the same size as" "" { target ia32 } } */
+typeof (a > 0) f;	/* { dg-error "could not find an integer type of the same size as" "" { target ia32 } } */
+typeof (a >= 0) g;	/* { dg-error "could not find an integer type of the same size as" "" { target ia32 } } */
Index: gcc/testsuite/c-c++-common/pr43690.c
===================================================================
diff --git a/gcc/testsuite/c-c++-common/pr43690.c b/gcc/testsuite/c-c++-common/pr43690.c
--- a/gcc/testsuite/c-c++-common/pr43690.c	(revision 262353)
+++ b/gcc/testsuite/c-c++-common/pr43690.c	(revision 262353)
@@ -6,8 +6,8 @@
 foo (char *x)
 {
   asm ("" : : "m" (x++));	/* { dg-error "is not directly addressable" } */
-  asm ("" : : "m" (++x));	/* { dg-error "is not directly addressable" } */
+  asm ("" : : "m" (++x));	/* { dg-error "is not directly addressable" "" { target c } } */
   asm ("" : : "m" (x--));	/* { dg-error "is not directly addressable" } */
-  asm ("" : : "m" (--x));	/* { dg-error "is not directly addressable" } */
+  asm ("" : : "m" (--x));	/* { dg-error "is not directly addressable" "" { target c } } */
   asm ("" : : "m" (x + 1));	/* { dg-error "is not directly addressable" } */
 }
Index: gcc/testsuite/c-c++-common/torture/pr85022.c
===================================================================
diff --git a/gcc/testsuite/c-c++-common/torture/pr85022.c b/gcc/testsuite/c-c++-common/torture/pr85022.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/c-c++-common/torture/pr85022.c	(revision 262353)
@@ -0,0 +1,9 @@
+/* PR inline-asm/85022 */
+
+extern struct B b;
+
+void
+foo ()
+{
+  __asm ("" : "+m" (b));
+}
Index: gcc/testsuite/c-c++-common/gomp/pr83977-2.c
===================================================================
diff --git a/gcc/testsuite/c-c++-common/gomp/pr83977-2.c b/gcc/testsuite/c-c++-common/gomp/pr83977-2.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/c-c++-common/gomp/pr83977-2.c	(revision 262353)
@@ -0,0 +1,18 @@
+/* PR middle-end/83977 */
+/* { dg-do compile } */
+
+void bar (void);
+
+#pragma omp declare simd uniform (b) linear(a:b)
+int
+foo (int a, int b)
+{
+  a = a + 1;
+/* This function can't be called from simd loops,
+   because it violates declare simd restrictions.
+   We shouldn't ICE on it though, nor attempt to generate
+   simd clones for the *omp_fn* functions.  */
+  #pragma omp parallel
+  bar ();  
+  return a;
+}
Index: gcc/testsuite/c-c++-common/gomp/pr85696.c
===================================================================
diff --git a/gcc/testsuite/c-c++-common/gomp/pr85696.c b/gcc/testsuite/c-c++-common/gomp/pr85696.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/c-c++-common/gomp/pr85696.c	(revision 262353)
@@ -0,0 +1,20 @@
+/* PR c/85696 */
+
+#ifndef __cplusplus
+void
+foo (int n, int a[][n])
+{
+  #pragma omp parallel shared(a) default(none)
+  #pragma omp master
+    a[23][0] = 42;
+}
+#endif
+
+void
+bar (int n, void *p)
+{
+  int (*a)[n] = (int (*)[n]) p;
+  #pragma omp parallel shared(a) default(none)
+  #pragma omp master
+    a[23][0] = 42;
+}
Index: gcc/testsuite/c-c++-common/gomp/pr84341.c
===================================================================
diff --git a/gcc/testsuite/c-c++-common/gomp/pr84341.c b/gcc/testsuite/c-c++-common/gomp/pr84341.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/c-c++-common/gomp/pr84341.c	(revision 262353)
@@ -0,0 +1,10 @@
+/* PR c++/84341 */
+/* { dg-do compile } */
+/* { dg-options "-fopenmp" } */
+
+void
+foo (int i)
+{
+  #pragma omp atomic
+    i = &i + 1;		/* { dg-error "invalid form of" } */
+}
Index: gcc/testsuite/c-c++-common/gomp/pr86025.c
===================================================================
diff --git a/gcc/testsuite/c-c++-common/gomp/pr86025.c b/gcc/testsuite/c-c++-common/gomp/pr86025.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/c-c++-common/gomp/pr86025.c	(revision 262353)
@@ -0,0 +1,20 @@
+/* PR c++/86025 */
+/* { dg-do compile } */
+/* { dg-additional-options "-Wduplicated-branches" } */
+
+int i;
+
+void
+foo (int x)
+{
+  if (x)
+    {
+      #pragma omp critical (foo)
+      i++;
+    }
+  else
+    {
+      #pragma omp critical
+      i++;
+    }
+}
Index: gcc/testsuite/c-c++-common/gomp/pr83977-1.c
===================================================================
diff --git a/gcc/testsuite/c-c++-common/gomp/pr83977-1.c b/gcc/testsuite/c-c++-common/gomp/pr83977-1.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/c-c++-common/gomp/pr83977-1.c	(revision 262353)
@@ -0,0 +1,19 @@
+/* PR middle-end/83977 */
+/* { dg-do compile } */
+/* { dg-additional-options "-O2" } */
+
+struct S { int a, b, c; };
+
+#pragma omp declare simd uniform(z) linear(v:1)
+__attribute__((noinline)) static int
+foo (int x, int y, struct S z, int u, int v)
+{
+  return x + y + z.a;
+}
+
+int
+bar (int x, int y, int z)
+{
+  struct S s = { z, 1, 1 };
+  return foo (x, y, s, 0, 0);
+}
Index: gcc/testsuite/c-c++-common/gomp/pr83977-3.c
===================================================================
diff --git a/gcc/testsuite/c-c++-common/gomp/pr83977-3.c b/gcc/testsuite/c-c++-common/gomp/pr83977-3.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/c-c++-common/gomp/pr83977-3.c	(revision 262353)
@@ -0,0 +1,21 @@
+/* PR middle-end/83977 */
+/* { dg-do compile } */
+
+void bar (void);
+int foo (int, int) __attribute__((used));
+
+#pragma omp declare simd uniform (b) linear(a:b)
+int
+foo (int a, int b)
+{
+  a = a + 1;
+/* This function can't be called from simd loops,
+   because it violates declare simd restrictions.
+   We shouldn't ICE on it though, nor attempt to generate
+   simd clones for the *omp_fn* functions.  */
+  #pragma omp parallel
+  bar ();  
+  return a;
+}
+
+int foo (int, int)  __attribute__((unused));
Index: gcc/testsuite/c-c++-common/pr84873.c
===================================================================
diff --git a/gcc/testsuite/c-c++-common/pr84873.c b/gcc/testsuite/c-c++-common/pr84873.c
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/testsuite/c-c++-common/pr84873.c	(revision 262353)
@@ -0,0 +1,8 @@
+/* { dg-do compile } */
+/* { dg-additional-options "-frounding-math" } */
+
+int
+i1 (int w3, int n9)
+{
+  return w3 >> ((long int)(1 + 0.1) + -!n9);
+}
Index: gcc/cp/typeck.c
===================================================================
diff --git a/gcc/cp/typeck.c b/gcc/cp/typeck.c
--- a/gcc/cp/typeck.c	(revision 262353)
+++ b/gcc/cp/typeck.c	(revision 262353)
@@ -905,14 +905,14 @@
       return t1;
 
     default:;
+      if (attribute_list_equal (TYPE_ATTRIBUTES (t1), attributes))
+	return t1;
+      else if (attribute_list_equal (TYPE_ATTRIBUTES (t2), attributes))
+	return t2;
+      break;
     }
 
-  if (attribute_list_equal (TYPE_ATTRIBUTES (t1), attributes))
-    return t1;
-  else if (attribute_list_equal (TYPE_ATTRIBUTES (t2), attributes))
-    return t2;
-  else
-    return cp_build_type_attribute_variant (t1, attributes);
+  return cp_build_type_attribute_variant (t1, attributes);
 }
 
 /* Return the ARRAY_TYPE type without its domain.  */
@@ -5713,19 +5713,6 @@
       return arg;
     }
 
-  /* ??? Cope with user tricks that amount to offsetof.  */
-  if (TREE_CODE (argtype) != FUNCTION_TYPE
-      && TREE_CODE (argtype) != METHOD_TYPE
-      && argtype != unknown_type_node
-      && (val = get_base_address (arg))
-      && COMPLETE_TYPE_P (TREE_TYPE (val))
-      && INDIRECT_REF_P (val)
-      && TREE_CONSTANT (TREE_OPERAND (val, 0)))
-    {
-      tree type = build_pointer_type (argtype);
-      return fold_convert (type, fold_offsetof_1 (arg));
-    }
-
   /* Handle complex lvalues (when permitted)
      by reduction to simpler cases.  */
   val = unary_complex_lvalue (ADDR_EXPR, arg);
@@ -6177,6 +6164,25 @@
   return cp_build_unary_op (code, xarg, noconvert, tf_warning_or_error);
 }
 
+/* Adjust LVALUE, an MODIFY_EXPR, PREINCREMENT_EXPR or PREDECREMENT_EXPR,
+   so that it is a valid lvalue even for GENERIC by replacing
+   (lhs = rhs) with ((lhs = rhs), lhs)
+   (--lhs) with ((--lhs), lhs)
+   (++lhs) with ((++lhs), lhs)
+   and if lhs has side-effects, calling cp_stabilize_reference on it, so
+   that it can be evaluated multiple times.  */
+
+tree
+genericize_compound_lvalue (tree lvalue)
+{
+  if (TREE_SIDE_EFFECTS (TREE_OPERAND (lvalue, 0)))
+    lvalue = build2 (TREE_CODE (lvalue), TREE_TYPE (lvalue),
+		     cp_stabilize_reference (TREE_OPERAND (lvalue, 0)),
+		     TREE_OPERAND (lvalue, 1));
+  return build2 (COMPOUND_EXPR, TREE_TYPE (TREE_OPERAND (lvalue, 0)),
+		 lvalue, TREE_OPERAND (lvalue, 0));
+}
+
 /* Apply unary lvalue-demanding operator CODE to the expression ARG
    for certain kinds of expressions which are not really lvalues
    but which we can accept as lvalues.
@@ -6211,17 +6217,7 @@
   if (TREE_CODE (arg) == MODIFY_EXPR
       || TREE_CODE (arg) == PREINCREMENT_EXPR
       || TREE_CODE (arg) == PREDECREMENT_EXPR)
-    {
-      tree lvalue = TREE_OPERAND (arg, 0);
-      if (TREE_SIDE_EFFECTS (lvalue))
-	{
-	  lvalue = cp_stabilize_reference (lvalue);
-	  arg = build2 (TREE_CODE (arg), TREE_TYPE (arg),
-			lvalue, TREE_OPERAND (arg, 1));
-	}
-      return unary_complex_lvalue
-	(code, build2 (COMPOUND_EXPR, TREE_TYPE (lvalue), arg, lvalue));
-    }
+    return unary_complex_lvalue (code, genericize_compound_lvalue (arg));
 
   if (code != ADDR_EXPR)
     return NULL_TREE;
@@ -7617,11 +7613,7 @@
     case PREINCREMENT_EXPR:
       if (compound_side_effects_p)
 	newrhs = rhs = stabilize_expr (rhs, &preeval);
-      if (TREE_SIDE_EFFECTS (TREE_OPERAND (lhs, 0)))
-	lhs = build2 (TREE_CODE (lhs), TREE_TYPE (lhs),
-		      cp_stabilize_reference (TREE_OPERAND (lhs, 0)),
-		      TREE_OPERAND (lhs, 1));
-      lhs = build2 (COMPOUND_EXPR, lhstype, lhs, TREE_OPERAND (lhs, 0));
+      lhs = genericize_compound_lvalue (lhs);
     maybe_add_compound:
       /* If we had (bar, --foo) = 5; or (bar, (baz, --foo)) = 5;
 	 and looked through the COMPOUND_EXPRs, readd them now around
@@ -7644,11 +7636,7 @@
     case MODIFY_EXPR:
       if (compound_side_effects_p)
 	newrhs = rhs = stabilize_expr (rhs, &preeval);
-      if (TREE_SIDE_EFFECTS (TREE_OPERAND (lhs, 0)))
-	lhs = build2 (TREE_CODE (lhs), TREE_TYPE (lhs),
-		      cp_stabilize_reference (TREE_OPERAND (lhs, 0)),
-		      TREE_OPERAND (lhs, 1));
-      lhs = build2 (COMPOUND_EXPR, lhstype, lhs, TREE_OPERAND (lhs, 0));
+      lhs = genericize_compound_lvalue (lhs);
       goto maybe_add_compound;
 
     case MIN_EXPR:
Index: gcc/cp/init.c
===================================================================
diff --git a/gcc/cp/init.c b/gcc/cp/init.c
--- a/gcc/cp/init.c	(revision 262353)
+++ b/gcc/cp/init.c	(revision 262353)
@@ -1632,6 +1632,7 @@
       if (VAR_P (exp) && DECL_DECOMPOSITION_P (exp))
 	{
 	  from_array = 1;
+	  init = mark_rvalue_use (init);
 	  if (init && DECL_P (init)
 	      && !(flags & LOOKUP_ONLYCONVERTING))
 	    {
Index: gcc/cp/class.c
===================================================================
diff --git a/gcc/cp/class.c b/gcc/cp/class.c
--- a/gcc/cp/class.c	(revision 262353)
+++ b/gcc/cp/class.c	(revision 262353)
@@ -2732,19 +2732,20 @@
 	     order.  Of course it is lame that we have to repeat the
 	     search here anyway -- we should really be caching pieces
 	     of the vtable and avoiding this repeated work.  */
-	  tree thunk_binfo, base_binfo;
+	  tree thunk_binfo = NULL_TREE;
+	  tree base_binfo = TYPE_BINFO (base_return);
 
 	  /* Find the base binfo within the overriding function's
 	     return type.  We will always find a thunk_binfo, except
 	     when the covariancy is invalid (which we will have
 	     already diagnosed).  */
-	  for (base_binfo = TYPE_BINFO (base_return),
-	       thunk_binfo = TYPE_BINFO (over_return);
-	       thunk_binfo;
-	       thunk_binfo = TREE_CHAIN (thunk_binfo))
-	    if (SAME_BINFO_TYPE_P (BINFO_TYPE (thunk_binfo),
-				   BINFO_TYPE (base_binfo)))
-	      break;
+	  if (base_binfo)
+	    for (thunk_binfo = TYPE_BINFO (over_return); thunk_binfo;
+		 thunk_binfo = TREE_CHAIN (thunk_binfo))
+	      if (SAME_BINFO_TYPE_P (BINFO_TYPE (thunk_binfo),
+				     BINFO_TYPE (base_binfo)))
+		break;
+	  gcc_assert (thunk_binfo || errorcount);
 
 	  /* See if virtual inheritance is involved.  */
 	  for (virtual_offset = thunk_binfo;
@@ -4532,8 +4533,14 @@
   DECL_ARTIFICIAL (decl) = 1;
   DECL_IGNORED_P (decl) = 1;
   DECL_FIELD_CONTEXT (decl) = t;
-  DECL_SIZE (decl) = CLASSTYPE_SIZE (basetype);
-  DECL_SIZE_UNIT (decl) = CLASSTYPE_SIZE_UNIT (basetype);
+  if (is_empty_class (basetype))
+    /* CLASSTYPE_SIZE is one byte, but the field needs to have size zero.  */
+    DECL_SIZE (decl) = DECL_SIZE_UNIT (decl) = size_zero_node;
+  else
+    {
+      DECL_SIZE (decl) = CLASSTYPE_SIZE (basetype);
+      DECL_SIZE_UNIT (decl) = CLASSTYPE_SIZE_UNIT (basetype);
+    }
   SET_DECL_ALIGN (decl, CLASSTYPE_ALIGN (basetype));
   DECL_USER_ALIGN (decl) = CLASSTYPE_USER_ALIGN (basetype);
   SET_DECL_MODE (decl, TYPE_MODE (basetype));
@@ -7592,7 +7599,8 @@
 
     case CALL_EXPR:
       /* This is a call to a constructor, hence it's never zero.  */
-      if (TREE_HAS_CONSTRUCTOR (instance))
+      if (CALL_EXPR_FN (instance)
+	  && TREE_HAS_CONSTRUCTOR (instance))
 	{
 	  if (nonnull)
 	    *nonnull = 1;
Index: gcc/cp/decl.c
===================================================================
diff --git a/gcc/cp/decl.c b/gcc/cp/decl.c
--- a/gcc/cp/decl.c	(revision 262353)
+++ b/gcc/cp/decl.c	(revision 262353)
@@ -5022,7 +5022,7 @@
     }
 
   /* If #pragma weak was used, mark the decl weak now.  */
-  if (!processing_template_decl)
+  if (!processing_template_decl && !DECL_DECOMPOSITION_P (decl))
     maybe_apply_pragma_weak (decl);
 
   if (TREE_CODE (decl) == FUNCTION_DECL
@@ -5042,19 +5042,17 @@
 	  if (field == NULL_TREE
 	      || !(VAR_P (field) || variable_template_p (field)))
 	    error ("%q+#D is not a static data member of %q#T", decl, context);
+	  else if (variable_template_p (field)
+		   && (DECL_LANG_SPECIFIC (decl)
+		       && DECL_TEMPLATE_SPECIALIZATION (decl)))
+	    /* OK, specialization was already checked.  */;
 	  else if (variable_template_p (field) && !this_tmpl)
 	    {
-	      if (DECL_LANG_SPECIFIC (decl)
-		  && DECL_TEMPLATE_SPECIALIZATION (decl))
-		/* OK, specialization was already checked.  */;
-	      else
-		{
-		  error_at (DECL_SOURCE_LOCATION (decl),
-			    "non-member-template declaration of %qD", decl);
-		  inform (DECL_SOURCE_LOCATION (field), "does not match "
-			  "member template declaration here");
-		  return error_mark_node;
-		}
+	      error_at (DECL_SOURCE_LOCATION (decl),
+			"non-member-template declaration of %qD", decl);
+	      inform (DECL_SOURCE_LOCATION (field), "does not match "
+		      "member template declaration here");
+	      return error_mark_node;
 	    }
 	  else
 	    {
@@ -5798,8 +5796,18 @@
 	    return error_mark_node;
 
 	  if (TREE_CODE (d->cur->index) == FIELD_DECL)
-	    /* We already reshaped this.  */
-	    gcc_assert (d->cur->index == field);
+	    {
+	      /* We already reshaped this.  */
+	      if (field != d->cur->index)
+		{
+		  tree id = DECL_NAME (d->cur->index);
+		  gcc_assert (id);
+		  gcc_checking_assert (lookup_field_1 (type, id,
+						       /*want_type=*/false)
+				       == d->cur->index);
+		  field = d->cur->index;
+		}
+	    }
 	  else if (TREE_CODE (d->cur->index) == IDENTIFIER_NODE)
 	    field = lookup_field_1 (type, d->cur->index, /*want_type=*/false);
 	  else
@@ -6402,7 +6410,9 @@
     }
 
   if (init_code
-      && (DECL_IN_AGGR_P (decl) && !DECL_VAR_DECLARED_INLINE_P (decl)))
+      && (DECL_IN_AGGR_P (decl)
+	  && DECL_INITIALIZED_IN_CLASS_P (decl)
+	  && !DECL_VAR_DECLARED_INLINE_P (decl)))
     {
       static int explained = 0;
 
@@ -7213,7 +7223,9 @@
 {
   bool member_seen = false;
   for (tree field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))
-    if (TREE_CODE (field) != FIELD_DECL || DECL_ARTIFICIAL (field))
+    if (TREE_CODE (field) != FIELD_DECL
+	|| DECL_ARTIFICIAL (field)
+	|| (DECL_C_BIT_FIELD (field) && !DECL_NAME (field)))
       continue;
     else if (ret)
       return type;
@@ -7228,9 +7240,9 @@
 	inform (DECL_SOURCE_LOCATION (field), "declared here");
 	return error_mark_node;
       }
-    else if (TREE_PRIVATE (field) || TREE_PROTECTED (field))
+    else if (!accessible_p (type, field, true))
       {
-	error_at (loc, "cannot decompose non-public member %qD of %qT",
+	error_at (loc, "cannot decompose inaccessible member %qD of %qT",
 		  field, type);
 	inform (DECL_SOURCE_LOCATION (field),
 		TREE_PRIVATE (field)
@@ -7252,7 +7264,7 @@
       tree t = find_decomp_class_base (loc, TREE_TYPE (base_binfo), ret);
       if (t == error_mark_node)
 	return error_mark_node;
-      if (t != NULL_TREE)
+      if (t != NULL_TREE && t != ret)
 	{
 	  if (ret == type)
 	    {
@@ -7263,9 +7275,6 @@
 	    }
 	  else if (orig_ret != NULL_TREE)
 	    return t;
-	  else if (ret == t)
-	    /* OK, found the same base along another path.  We'll complain
-	       in convert_to_base if it's ambiguous.  */;
 	  else if (ret != NULL_TREE)
 	    {
 	      error_at (loc, "cannot decompose class type %qT: its base "
@@ -7341,8 +7350,30 @@
 
   tree fns = lookup_qualified_name (TREE_TYPE (e), get_id,
 				    /*type*/false, /*complain*/false);
-  if (fns != error_mark_node)
+  bool use_member_get = false;
+
+  /* To use a member get, member lookup must find at least one
+     declaration that is a function template
+     whose first template parameter is a non-type parameter.  */
+  for (tree iter = BASELINK_P (fns) ? BASELINK_FUNCTIONS (fns) : fns;
+       iter;
+       iter = OVL_NEXT (iter))
     {
+      tree fn = OVL_CURRENT (iter);
+      if (TREE_CODE (fn) == TEMPLATE_DECL)
+	{
+	  tree tparms = DECL_TEMPLATE_PARMS (fn);
+	  tree parm = TREE_VEC_ELT (INNERMOST_TEMPLATE_PARMS (tparms), 0);
+	  if (TREE_CODE (TREE_VALUE (parm)) == PARM_DECL)
+	    {
+	      use_member_get = true;
+	      break;
+	    }
+	}
+    }
+
+  if (use_member_get)
+    {
       fns = lookup_template_function (fns, targs);
       return build_new_method_call (e, fns, /*args*/NULL,
 				    /*path*/NULL_TREE, LOOKUP_NORMAL,
@@ -7391,6 +7422,7 @@
       for (unsigned int i = 0; i < count; i++, d = DECL_CHAIN (d))
 	v[count - i - 1] = d;
       SET_DECL_ASSEMBLER_NAME (decl, mangle_decomp (decl, v));
+      maybe_apply_pragma_weak (decl);
     }
 }
 
@@ -7466,6 +7498,12 @@
       type = complete_type (TREE_TYPE (type));
       if (type == error_mark_node)
 	goto error_out;
+      if (!COMPLETE_TYPE_P (type))
+	{
+	  error_at (loc, "structured binding refers to incomplete type %qT",
+		    type);
+	  goto error_out;
+	}
     }
 
   tree eltype = NULL_TREE;
@@ -7640,7 +7678,9 @@
 	  goto error_out;
 	}
       for (tree field = TYPE_FIELDS (btype); field; field = TREE_CHAIN (field))
-	if (TREE_CODE (field) != FIELD_DECL || DECL_ARTIFICIAL (field))
+	if (TREE_CODE (field) != FIELD_DECL
+	    || DECL_ARTIFICIAL (field)
+	    || (DECL_C_BIT_FIELD (field) && !DECL_NAME (field)))
 	  continue;
 	else
 	  eltscnt++;
@@ -7655,7 +7695,9 @@
 	}
       unsigned int i = 0;
       for (tree field = TYPE_FIELDS (btype); field; field = TREE_CHAIN (field))
-	if (TREE_CODE (field) != FIELD_DECL || DECL_ARTIFICIAL (field))
+	if (TREE_CODE (field) != FIELD_DECL
+	    || DECL_ARTIFICIAL (field)
+	    || (DECL_C_BIT_FIELD (field) && !DECL_NAME (field)))
 	  continue;
 	else
 	  {
@@ -9517,7 +9559,8 @@
       constant_expression_error (size);
 
       /* An array must have a positive number of elements.  */
-      if (tree_int_cst_lt (size, integer_zero_node))
+      tree signed_size = fold_convert (ssizetype, size);
+      if (tree_int_cst_lt (signed_size, integer_zero_node))
 	{
 	  if (!(complain & tf_error))
 	    return error_mark_node;
@@ -10097,6 +10140,8 @@
 						      declspecs->locations);
   if (typespec_loc == UNKNOWN_LOCATION)
     typespec_loc = declspecs->locations[ds_type_spec];
+  if (typespec_loc == UNKNOWN_LOCATION)
+    typespec_loc = input_location;
 
   /* Look inside a declarator for the name being declared
      and get it as a string, for an error message.  */
@@ -10366,7 +10411,7 @@
      suppress reports of deprecated items.  */
   if (type && TREE_DEPRECATED (type)
       && deprecated_state != DEPRECATED_SUPPRESS)
-    warn_deprecated_use (type, NULL_TREE);
+    cp_warn_deprecated_use (type);
   if (type && TREE_CODE (type) == TYPE_DECL)
     {
       typedef_decl = type;
@@ -10374,7 +10419,7 @@
       if (TREE_DEPRECATED (type)
 	  && DECL_ARTIFICIAL (typedef_decl)
 	  && deprecated_state != DEPRECATED_SUPPRESS)
-	warn_deprecated_use (type, NULL_TREE);
+	cp_warn_deprecated_use (type);
     }
   /* No type at all: default to `int', and set DEFAULTED_INT
      because it was not a user-defined typedef.  */
@@ -11169,9 +11214,19 @@
 		  explicitp = 2;
 	      }
 
-	    arg_types = grokparms (declarator->u.function.parameters,
-				   &parms);
+	    tree pushed_scope = NULL_TREE;
+	    if (funcdecl_p
+		&& decl_context != FIELD
+		&& inner_declarator->u.id.qualifying_scope
+		&& CLASS_TYPE_P (inner_declarator->u.id.qualifying_scope))
+	      pushed_scope
+		= push_scope (inner_declarator->u.id.qualifying_scope);
 
+	    arg_types = grokparms (declarator->u.function.parameters, &parms);
+
+	    if (pushed_scope)
+	      pop_scope (pushed_scope);
+
 	    if (inner_declarator
 		&& inner_declarator->kind == cdk_id
 		&& inner_declarator->u.id.sfk == sfk_destructor
@@ -12556,7 +12611,9 @@
      A default argument expression is implicitly converted to the
      parameter type.  */
   ++cp_unevaluated_operand;
-  perform_implicit_conversion_flags (decl_type, arg, complain,
+  /* Avoid digest_init clobbering the initializer.  */
+  tree carg = BRACE_ENCLOSED_INITIALIZER_P (arg) ? unshare_expr (arg): arg;
+  perform_implicit_conversion_flags (decl_type, carg, complain,
 				     LOOKUP_IMPLICIT);
   --cp_unevaluated_operand;
 
@@ -12685,7 +12742,7 @@
 	    {
 	      tree deptype = type_is_deprecated (type);
 	      if (deptype)
-		warn_deprecated_use (deptype, NULL_TREE);
+		cp_warn_deprecated_use (deptype);
 	    }
 
 	  /* Top-level qualifiers on the parameters are
Index: gcc/cp/method.c
===================================================================
diff --git a/gcc/cp/method.c b/gcc/cp/method.c
--- a/gcc/cp/method.c	(revision 262353)
+++ b/gcc/cp/method.c	(revision 262353)
@@ -1165,6 +1165,7 @@
     {
       tree ctype = to;
       vec<tree, va_gc> *args = NULL;
+      cp_unevaluated cp_uneval_guard;
       if (TREE_CODE (to) != REFERENCE_TYPE)
 	to = cp_build_reference_type (to, /*rval*/false);
       tree ob = build_stub_object (to);
@@ -1430,7 +1431,7 @@
 synthesized_method_base_walk (tree binfo, tree base_binfo, 
 			      int quals, bool copy_arg_p,
 			      bool move_p, bool ctor_p,
-			      tree inheriting_ctor, tree inherited_parms,
+			      tree *inheriting_ctor, tree inherited_parms,
 			      tree fnname, int flags, bool diag,
 			      tree *spec_p, bool *trivial_p,
 			      bool *deleted_p, bool *constexpr_p)
@@ -1441,8 +1442,9 @@
 
   if (copy_arg_p)
     argtype = build_stub_type (BINFO_TYPE (base_binfo), quals, move_p);
-  else if ((inherited_binfo
-	    = binfo_inherited_from (binfo, base_binfo, inheriting_ctor)))
+  else if (inheriting_ctor
+	   && (inherited_binfo
+	       = binfo_inherited_from (binfo, base_binfo, *inheriting_ctor)))
     {
       argtype = inherited_parms;
       /* Don't check access on the inherited constructor.  */
@@ -1464,6 +1466,12 @@
   if (defer != dk_no_deferred)
     pop_deferring_access_checks ();
 
+  /* Replace an inherited template with the appropriate specialization.  */
+  if (inherited_binfo && rval
+      && DECL_P (*inheriting_ctor) && DECL_P (rval)
+      && DECL_CONTEXT (*inheriting_ctor) == DECL_CONTEXT (rval))
+    *inheriting_ctor = DECL_CLONED_FUNCTION (rval);
+
   process_subob_fn (rval, spec_p, trivial_p, deleted_p,
 		    constexpr_p, diag, BINFO_TYPE (base_binfo));
   if (ctor_p &&
@@ -1498,7 +1506,7 @@
 synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,
 			 tree *spec_p, bool *trivial_p, bool *deleted_p,
 			 bool *constexpr_p, bool diag,
-			 tree inheriting_ctor, tree inherited_parms)
+			 tree *inheriting_ctor, tree inherited_parms)
 {
   tree binfo, base_binfo, fnname;
   int i;
@@ -1553,7 +1561,7 @@
     }
 
   gcc_assert ((sfk == sfk_inheriting_constructor)
-	      == (inheriting_ctor != NULL_TREE));
+	      == (inheriting_ctor && *inheriting_ctor != NULL_TREE));
 
   /* If that user-written default constructor would satisfy the
      requirements of a constexpr constructor (7.1.5), the
@@ -1628,7 +1636,7 @@
   tree scope = push_scope (ctype);
 
   int flags = LOOKUP_NORMAL | LOOKUP_SPECULATIVE;
-  if (!inheriting_ctor)
+  if (sfk != sfk_inheriting_constructor)
     flags |= LOOKUP_DEFAULTED;
 
   tsubst_flags_t complain = diag ? tf_warning_or_error : tf_none;
@@ -1731,9 +1739,9 @@
   tree parm_type = TREE_VALUE (parms);
   bool const_p = CP_TYPE_CONST_P (non_reference (parm_type));
   tree spec = empty_except_spec;
+  tree inh = DECL_INHERITED_CTOR (decl);
   synthesized_method_walk (ctype, sfk, const_p, &spec, NULL, NULL,
-			   NULL, false, DECL_INHERITED_CTOR (decl),
-			   parms);
+			   NULL, false, &inh, parms);
   return spec;
 }
 
@@ -1810,10 +1818,11 @@
 	  tree raises = NULL_TREE;
 	  bool deleted_p = false;
 	  tree scope = push_scope (ctype);
+	  tree inh = DECL_INHERITED_CTOR (decl);
 
 	  synthesized_method_walk (ctype, sfk, const_p,
 				   &raises, NULL, &deleted_p, NULL, false,
-				   DECL_INHERITED_CTOR (decl), parms);
+				   &inh, parms);
 	  if (deleted_p)
 	    {
 	      inform (DECL_SOURCE_LOCATION (decl),
@@ -1821,7 +1830,7 @@
 		      "definition would be ill-formed:", decl);
 	      synthesized_method_walk (ctype, sfk, const_p,
 				       NULL, NULL, NULL, NULL, true,
-				       DECL_INHERITED_CTOR (decl), parms);
+				       &inh, parms);
 	    }
 	  else if (!comp_except_specs
 		   (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (decl)),
@@ -1850,11 +1859,12 @@
 {
   tree parm_type = TREE_VALUE (FUNCTION_FIRST_USER_PARMTYPE (decl));
   bool const_p = CP_TYPE_CONST_P (non_reference (parm_type));
+  tree inh = DECL_INHERITED_CTOR (decl);
   bool dummy;
   synthesized_method_walk (DECL_CLASS_CONTEXT (decl),
 			   special_function_p (decl), const_p,
 			   NULL, NULL, NULL, &dummy, true,
-			   DECL_INHERITED_CTOR (decl),
+			   &inh,
 			   FUNCTION_FIRST_USER_PARMTYPE (decl));
 }
 
@@ -1869,10 +1879,11 @@
   gcc_assert (DECL_INHERITED_CTOR (decl));
   tree spec;
   bool trivial, constexpr_, deleted;
+  tree inh = DECL_INHERITED_CTOR (decl);
   synthesized_method_walk (DECL_CONTEXT (decl), sfk_inheriting_constructor,
 			   false, &spec, &trivial, &deleted, &constexpr_,
 			   /*diag*/false,
-			   DECL_INHERITED_CTOR (decl),
+			   &inh,
 			   FUNCTION_FIRST_USER_PARMTYPE (decl));
   if (TREE_CODE (inherited_ctor_binfo (decl)) != TREE_BINFO)
     /* Inherited the same constructor from different base subobjects.  */
@@ -1879,6 +1890,7 @@
     deleted = true;
   DECL_DELETED_FN (decl) = deleted;
   TREE_TYPE (decl) = build_exception_variant (TREE_TYPE (decl), spec);
+  SET_DECL_INHERITED_CTOR (decl, inh);
 
   tree clone;
   FOR_EACH_CLONE (clone, decl)
@@ -1885,6 +1897,7 @@
     {
       DECL_DELETED_FN (clone) = deleted;
       TREE_TYPE (clone) = build_exception_variant (TREE_TYPE (clone), spec);
+      SET_DECL_INHERITED_CTOR (clone, inh);
     }
 }
 
@@ -1999,12 +2012,12 @@
       raises = unevaluated_noexcept_spec ();
       synthesized_method_walk (type, kind, const_p, NULL, &trivial_p,
 			       &deleted_p, &constexpr_p, false,
-			       inherited_ctor, inherited_parms);
+			       &inherited_ctor, inherited_parms);
     }
   else
     synthesized_method_walk (type, kind, const_p, &raises, &trivial_p,
 			     &deleted_p, &constexpr_p, false,
-			     inherited_ctor, inherited_parms);
+			     &inherited_ctor, inherited_parms);
   /* Don't bother marking a deleted constructor as constexpr.  */
   if (deleted_p)
     constexpr_p = false;
@@ -2120,7 +2133,7 @@
       input_location = DECL_SOURCE_LOCATION (fn);
       synthesized_method_walk (type, kind, const_p,
 			       NULL, NULL, NULL, NULL, true,
-			       NULL_TREE, NULL_TREE);
+			       NULL, NULL_TREE);
       input_location = loc;
     }
 
Index: gcc/cp/constexpr.c
===================================================================
diff --git a/gcc/cp/constexpr.c b/gcc/cp/constexpr.c
--- a/gcc/cp/constexpr.c	(revision 262353)
+++ b/gcc/cp/constexpr.c	(revision 262353)
@@ -1140,7 +1140,10 @@
   /* Don't fold __builtin_constant_p within a constexpr function.  */
   bool bi_const_p = (DECL_FUNCTION_CODE (fun) == BUILT_IN_CONSTANT_P);
 
+  /* If we aren't requiring a constant expression, defer __builtin_constant_p
+     in a constexpr function until we have values for the parameters.  */
   if (bi_const_p
+      && ctx->quiet
       && current_function_decl
       && DECL_DECLARED_CONSTEXPR_P (current_function_decl))
     {
@@ -1155,8 +1158,14 @@
   bool dummy1 = false, dummy2 = false;
   for (i = 0; i < nargs; ++i)
     {
-      args[i] = cxx_eval_constant_expression (&new_ctx, CALL_EXPR_ARG (t, i),
-					      false, &dummy1, &dummy2);
+      args[i] = CALL_EXPR_ARG (t, i);
+      /* If builtin_valid_in_constant_expr_p is true,
+	 potential_constant_expression_1 has not recursed into the arguments
+	 of the builtin, verify it here.  */
+      if (!builtin_valid_in_constant_expr_p (fun)
+	  || potential_constant_expression (args[i]))
+	args[i] = cxx_eval_constant_expression (&new_ctx, args[i], false,
+						&dummy1, &dummy2);
       if (bi_const_p)
 	/* For __built_in_constant_p, fold all expressions with constant values
 	   even if they aren't C++ constant-expressions.  */
@@ -1274,6 +1283,8 @@
 
       if (!*non_constant_p)
 	{
+	  /* Don't share a CONSTRUCTOR that might be changed.  */
+	  arg = unshare_constructor (arg);
 	  /* Make sure the binding has the same type as the parm.  But
 	     only for constant args.  */
 	  if (TREE_CODE (type) != REFERENCE_TYPE)
@@ -2783,14 +2794,20 @@
 	  gcc_assert (is_empty_class (TREE_TYPE (TREE_TYPE (index))));
 	  changed = true;
 	}
-      else if (new_ctx.ctor != ctx->ctor)
+      else
 	{
-	  /* We appended this element above; update the value.  */
-	  gcc_assert ((*p)->last().index == index);
-	  (*p)->last().value = elt;
+	  if (new_ctx.ctor != ctx->ctor)
+	    {
+	      /* We appended this element above; update the value.  */
+	      gcc_assert ((*p)->last().index == index);
+	      (*p)->last().value = elt;
+	    }
+	  else
+	    CONSTRUCTOR_APPEND_ELT (*p, index, elt);
+	  /* Adding or replacing an element might change the ctor's flags.  */
+	  TREE_CONSTANT (ctx->ctor) = constant_p;
+	  TREE_SIDE_EFFECTS (ctx->ctor) = side_effects_p;
 	}
-      else
-	CONSTRUCTOR_APPEND_ELT (*p, index, elt);
     }
   if (*non_constant_p || !changed)
     return t;
@@ -2895,9 +2912,8 @@
 	  if (!lvalue_p (init))
 	    eltinit = move (eltinit);
 	  eltinit = force_rvalue (eltinit, tf_warning_or_error);
-	  eltinit = (cxx_eval_constant_expression
-		     (&new_ctx, eltinit, lval,
-		      non_constant_p, overflow_p));
+	  eltinit = cxx_eval_constant_expression (&new_ctx, eltinit, lval,
+						  non_constant_p, overflow_p);
 	}
       if (*non_constant_p && !ctx->quiet)
 	break;
@@ -2910,12 +2926,13 @@
       else
 	CONSTRUCTOR_APPEND_ELT (*p, idx, eltinit);
       /* Reuse the result of cxx_eval_constant_expression call
-	  from the first iteration to all others if it is a constant
-	  initializer that doesn't require relocations.  */
+	 from the first iteration to all others if it is a constant
+	 initializer that doesn't require relocations.  */
       if (reuse
 	  && max > 1
-	  && (initializer_constant_valid_p (eltinit, TREE_TYPE (eltinit))
-	      == null_pointer_node))
+	  && (eltinit == NULL_TREE
+	      || (initializer_constant_valid_p (eltinit, TREE_TYPE (eltinit))
+		  == null_pointer_node)))
 	{
 	  if (new_ctx.ctor != ctx->ctor)
 	    eltinit = new_ctx.ctor;
@@ -2966,9 +2983,9 @@
 static tree
 cxx_fold_indirect_ref (location_t loc, tree type, tree op0, bool *empty_base)
 {
-  tree sub, subtype;
+  tree sub = op0;
+  tree subtype;
 
-  sub = op0;
   STRIP_NOPS (sub);
   subtype = TREE_TYPE (sub);
   if (!POINTER_TYPE_P (subtype))
@@ -3023,7 +3040,8 @@
 	{
 	  tree part_width = TYPE_SIZE (type);
 	  tree index = bitsize_int (0);
-	  return fold_build3_loc (loc, BIT_FIELD_REF, type, op, part_width, index);
+	  return fold_build3_loc (loc, BIT_FIELD_REF, type, op, part_width,
+				  index);
 	}
       /* Also handle conversion to an empty base class, which
 	 is represented with a NOP_EXPR.  */
@@ -3063,19 +3081,31 @@
 	  /* ((foo*)&vectorfoo)[1] => BIT_FIELD_REF<vectorfoo,...> */
 	  if (VECTOR_TYPE_P (op00type)
 	      && (same_type_ignoring_top_level_qualifiers_p
-		  (type, TREE_TYPE (op00type))))
+						(type, TREE_TYPE (op00type)))
+	      /* POINTER_PLUS_EXPR second operand is sizetype, unsigned,
+		 but we want to treat offsets with MSB set as negative.
+		 For the code below negative offsets are invalid and
+		 TYPE_SIZE of the element is something unsigned, so
+		 check whether op01 fits into HOST_WIDE_INT, which
+		 implies it is from 0 to INTTYPE_MAXIMUM (HOST_WIDE_INT), and
+		 then just use unsigned HOST_WIDE_INT because we want to treat
+		 the value as unsigned.  */
+	      && tree_fits_shwi_p (op01))
 	    {
-	      HOST_WIDE_INT offset = tree_to_shwi (op01);
 	      tree part_width = TYPE_SIZE (type);
-	      unsigned HOST_WIDE_INT part_widthi = tree_to_shwi (part_width)/BITS_PER_UNIT;
-	      unsigned HOST_WIDE_INT indexi = offset * BITS_PER_UNIT;
-	      tree index = bitsize_int (indexi);
-
-	      if (offset / part_widthi < TYPE_VECTOR_SUBPARTS (op00type))
-		return fold_build3_loc (loc,
-					BIT_FIELD_REF, type, op00,
-					part_width, index);
-
+	      unsigned HOST_WIDE_INT max_offset
+		= (tree_to_uhwi (part_width) / BITS_PER_UNIT
+		   * TYPE_VECTOR_SUBPARTS (op00type));
+	      if (tree_int_cst_sign_bit (op01) == 0
+		  && compare_tree_int (op01, max_offset) == -1)
+		{
+		  unsigned HOST_WIDE_INT offset = tree_to_uhwi (op01);
+		  unsigned HOST_WIDE_INT indexi = offset * BITS_PER_UNIT;
+		  tree index = bitsize_int (indexi);
+		  return fold_build3_loc (loc,
+					  BIT_FIELD_REF, type, op00,
+					  part_width, index);
+		}
 	    }
 	  /* ((foo*)&complexfoo)[1] => __imag__ complexfoo */
 	  else if (TREE_CODE (op00type) == COMPLEX_TYPE
@@ -3132,7 +3162,8 @@
     {
       tree type_domain;
       tree min_val = size_zero_node;
-      tree newsub = cxx_fold_indirect_ref (loc, TREE_TYPE (subtype), sub, NULL);
+      tree newsub
+	= cxx_fold_indirect_ref (loc, TREE_TYPE (subtype), sub, NULL);
       if (newsub)
 	sub = newsub;
       else
@@ -4170,7 +4201,16 @@
 	r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),
 					  lval,
 					  non_constant_p, overflow_p);
-      *jump_target = t;
+      if (jump_target)
+	*jump_target = t;
+      else
+	{
+	  /* Can happen with ({ return true; }) && false; passed to
+	     maybe_constant_value.  There is nothing to jump over in this
+	     case, and the bug will be diagnosed later.  */
+	  gcc_assert (ctx->quiet);
+	  *non_constant_p = true;
+	}
       break;
 
     case SAVE_EXPR:
@@ -4414,11 +4454,7 @@
 	{
 	  /* Don't re-process a constant CONSTRUCTOR, but do fold it to
 	     VECTOR_CST if applicable.  */
-	  /* FIXME after GCC 6 branches, make the verify unconditional.  */
-	  if (CHECKING_P)
-	    verify_constructor_flags (t);
-	  else
-	    recompute_constructor_flags (t);
+	  verify_constructor_flags (t);
 	  if (TREE_CONSTANT (t))
 	    return fold (t);
 	}
@@ -4640,6 +4676,10 @@
 					jump_target);
       break;
 
+    case USING_STMT:
+      r = void_node;
+      break;
+
     default:
       if (STATEMENT_CODE_P (TREE_CODE (t)))
 	{
@@ -4763,8 +4803,12 @@
     return error_mark_node;
   else if (non_constant_p && TREE_CONSTANT (r))
     {
-      /* This isn't actually constant, so unset TREE_CONSTANT.  */
-      if (EXPR_P (r))
+      /* This isn't actually constant, so unset TREE_CONSTANT.
+	 Don't clear TREE_CONSTANT on ADDR_EXPR, as the middle-end requires
+	 it to be set if it is invariant address, even when it is not
+	 a valid C++ constant expression.  Wrap it with a NOP_EXPR
+	 instead.  */
+      if (EXPR_P (r) && TREE_CODE (r) != ADDR_EXPR)
 	r = copy_node (r);
       else if (TREE_CODE (r) == CONSTRUCTOR)
 	r = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (r), r);
@@ -5453,6 +5497,7 @@
     case OMP_PARALLEL:
     case OMP_TASK:
     case OMP_FOR:
+    case OMP_SIMD:
     case OMP_DISTRIBUTE:
     case OMP_TASKLOOP:
     case OMP_TEAMS:
@@ -5627,7 +5672,8 @@
       return RECUR (TREE_OPERAND (t, 1), want_rval);
 
     case TARGET_EXPR:
-      if (!literal_type_p (TREE_TYPE (t)))
+      if (!TARGET_EXPR_DIRECT_INIT_P (t)
+	  && !literal_type_p (TREE_TYPE (t)))
 	{
 	  if (flags & tf_error)
 	    {
Index: gcc/cp/except.c
===================================================================
diff --git a/gcc/cp/except.c b/gcc/cp/except.c
--- a/gcc/cp/except.c	(revision 262353)
+++ b/gcc/cp/except.c	(revision 262353)
@@ -1218,6 +1218,10 @@
     {
       gcc_assert (processing_template_decl
 		  || TREE_CODE (expr) == DEFERRED_NOEXCEPT);
+      if (TREE_CODE (expr) != DEFERRED_NOEXCEPT)
+	/* Avoid problems with a function type built with a dependent typedef
+	   being reused in another scope (c++/84045).  */
+	expr = strip_typedefs_expr (expr);
       return build_tree_list (expr, NULL_TREE);
     }
 }
Index: gcc/cp/error.c
===================================================================
diff --git a/gcc/cp/error.c b/gcc/cp/error.c
--- a/gcc/cp/error.c	(revision 262353)
+++ b/gcc/cp/error.c	(revision 262353)
@@ -2695,6 +2695,7 @@
     case INTEGER_TYPE:
     case COMPLEX_TYPE:
     case VECTOR_TYPE:
+    case DECLTYPE_TYPE:
       pp_type_specifier_seq (pp, t);
       break;
 
Index: gcc/cp/tree.c
===================================================================
diff --git a/gcc/cp/tree.c b/gcc/cp/tree.c
--- a/gcc/cp/tree.c	(revision 262353)
+++ b/gcc/cp/tree.c	(revision 262353)
@@ -1050,6 +1050,9 @@
 {
   tree lvalue_ref, t;
 
+  if (to_type == error_mark_node)
+    return error_mark_node;
+
   if (TREE_CODE (to_type) == REFERENCE_TYPE)
     {
       rval = rval && TYPE_REF_IS_RVALUE (to_type);
@@ -1667,9 +1670,9 @@
 	tree it;
 	for (it = t; it; it = TREE_CHAIN (it))
 	  {
-	    tree val = strip_typedefs_expr (TREE_VALUE (t), remove_attributes);
+	    tree val = strip_typedefs_expr (TREE_VALUE (it), remove_attributes);
 	    vec_safe_push (vec, val);
-	    if (val != TREE_VALUE (t))
+	    if (val != TREE_VALUE (it))
 	      changed = true;
 	    gcc_assert (TREE_PURPOSE (it) == NULL_TREE);
 	  }
@@ -2589,6 +2592,8 @@
 	{
 	  u = build_cplus_new (TREE_TYPE (t), TREE_OPERAND (t, 1),
 			       tf_warning_or_error);
+	  if (u == error_mark_node)
+	    return u;
 	  if (AGGR_INIT_ZERO_FIRST (TREE_OPERAND (t, 1)))
 	    AGGR_INIT_ZERO_FIRST (TREE_OPERAND (u, 1)) = true;
 	}
@@ -2606,6 +2611,8 @@
 			 (splay_tree_value) TREE_OPERAND (u, 0));
 
       TREE_OPERAND (u, 1) = break_out_target_exprs (TREE_OPERAND (u, 1));
+      if (TREE_OPERAND (u, 1) == error_mark_node)
+	return error_mark_node;
 
       /* Replace the old expression with the new version.  */
       *tp = u;
@@ -2718,7 +2725,8 @@
     target_remap = splay_tree_new (splay_tree_compare_pointers,
 				   /*splay_tree_delete_key_fn=*/NULL,
 				   /*splay_tree_delete_value_fn=*/NULL);
-  cp_walk_tree (&t, bot_manip, target_remap, NULL);
+  if (cp_walk_tree (&t, bot_manip, target_remap, NULL) == error_mark_node)
+    t = error_mark_node;
   cp_walk_tree (&t, bot_replace, target_remap, NULL);
 
   if (!--target_remap_count)
@@ -2793,7 +2801,7 @@
 	for (; !same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (*t),
 							   TREE_TYPE (x));
 	     x = TREE_OPERAND (x, 0))
-	  gcc_assert (TREE_CODE (x) == COMPONENT_REF);
+	  gcc_assert (handled_component_p (x));
 	*t = x;
 	*walk_subtrees = false;
 	d->seen = true;
@@ -4895,6 +4903,19 @@
     }
 }
 
+/* Wrapper around warn_deprecated_use that doesn't warn for
+   current_class_type.  */
+
+void
+cp_warn_deprecated_use (tree node)
+{
+  if (TYPE_P (node)
+      && current_class_type
+      && TYPE_MAIN_VARIANT (node) == current_class_type)
+    return;
+  warn_deprecated_use (node, NULL_TREE);
+}
+
 /* Implement -Wzero_as_null_pointer_constant.  Return true if the
    conditions for the warning hold, false otherwise.  */
 bool
Index: gcc/cp/ChangeLog
===================================================================
diff --git a/gcc/cp/ChangeLog b/gcc/cp/ChangeLog
--- a/gcc/cp/ChangeLog	(revision 262353)
+++ b/gcc/cp/ChangeLog	(revision 262353)
@@ -1,3 +1,557 @@
+2018-07-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/86378 - functional cast in noexcept-specifier.
+	* tree.c (strip_typedefs_expr) [TREE_LIST]: Fix iteration.
+
+2018-06-26  Jason Merrill  <jason@redhat.com>
+
+	PR c++/80290 - memory-hog with std::pair.
+	* pt.c (type_unification_real): Skip non-dependent conversion
+	check for a nested list argument.
+	(braced_init_depth): New.
+
+2018-06-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/86291
+	* parser.c (cp_parser_omp_for_loop_init): Change for_block argument
+	type from vec<tree, va_gc> * to vec<tree, va_gc> *&.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-05-29  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85952
+	* init.c (build_aggr_init): For structured binding initialized from
+	array call mark_rvalue_use on the initializer.
+
+	2018-05-11  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c/85696
+	* cp-tree.h (cxx_omp_predetermined_sharing_1): New prototype.
+	* cp-gimplify.c (cxx_omp_predetermined_sharing): New wrapper around
+	cxx_omp_predetermined_sharing_1.  Rename old function to ...
+	(cxx_omp_predetermined_sharing_1): ... this.
+	* semantics.c (finish_omp_clauses): Use cxx_omp_predetermined_sharing_1
+	instead of cxx_omp_predetermined_sharing.
+
+	2018-05-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85662
+	* cp-gimplify.c (cp_fold): Use fold_offsetof rather than
+	fold_offsetof_1, pass TREE_TYPE (x) as TYPE to it and drop the
+	fold_convert.
+
+	2018-04-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84463
+	* typeck.c (cp_build_addr_expr_1): Move handling of offsetof-like
+	tricks from here to ...
+	* cp-gimplify.c (cp_fold) <case ADDR_EXPR>: ... here.  Only use it
+	if INDIRECT_REF's operand is INTEGER_CST cast to pointer type.
+
+	2018-04-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85210
+	* pt.c (tsubst_decomp_names): Return error_mark_node and assert
+	errorcount is set if tsubst doesn't return a VAR_DECL.
+
+	2018-04-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85208
+	* decl.c (start_decl): For DECL_DECOMPOSITION_P decls, don't call
+	maybe_apply_pragma_weak here...
+	(cp_maybe_mangle_decomp): ... but call it here instead.
+
+	2018-04-04  Jakub Jelinek  <jakub@redhat.com>
+
+	PR inline-asm/85172
+	* constexpr.c (cxx_eval_builtin_function_call): For calls to
+	builtin_valid_in_constant_expr_p functions, don't call
+	cxx_eval_constant_expression if argument is not
+	potential_constant_expression.
+
+	2018-04-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85147
+	* pt.c (fixed_parameter_pack_p_1): Punt if parm is error_mark_node.
+
+	PR c++/85140
+	* name-lookup.c (handle_namespace_attrs): Return early if attributes
+	is error_mark_node.
+
+	2018-03-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84791
+	* semantics.c (finish_omp_reduction_clause): If
+	OMP_CLAUSE_REDUCTION_PLACEHOLDER is error_mark_node, return true
+	even if processing_template_decl.
+
+	2018-03-27  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/85076
+	* tree.c (cp_build_reference_type): If to_type is error_mark_node,
+	return it right away.
+
+	PR c++/85068
+	* class.c (update_vtable_entry_for_fn): Don't ICE if base_binfo
+	is NULL.  Assert if thunk_binfo is NULL then errorcount is non-zero.
+
+	2018-03-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84961
+	* cp-tree.h (genericize_compound_lvalue): Declare.
+	* typeck.c (genericize_compound_lvalue): New function.
+	(unary_complex_lvalue, cp_build_modify_expr): Use it.
+	* semantics.c (finish_asm_stmt): Replace MODIFY_EXPR, PREINCREMENT_EXPR
+	and PREDECREMENT_EXPR in output and "m" constrained input operands with
+	COMPOUND_EXPR.  Call cxx_mark_addressable on the rightmost
+	COMPOUND_EXPR operand.
+
+	2018-03-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84874
+	* decl.c (reshape_init_class): Don't assert d->cur->index == field
+	if d->cur->index is a FIELD_DECL, instead set field to d->cur->index.
+
+	2018-03-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84222
+	* cp-tree.h (cp_warn_deprecated_use): Declare.
+	* tree.c (cp_warn_deprecated_use): New function.
+	* typeck2.c (build_functional_cast): Use it.
+	* decl.c (grokparms): Likewise.
+	(grokdeclarator): Likewise.  Temporarily push nested class scope
+	around grokparms call for out of class member definitions.
+
+	2018-03-09  Jason Merrill  <jason@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84076
+	* call.c (convert_arg_to_ellipsis): Instead of cp_build_addr_expr
+	build ADDR_EXPR with REFERENCE_TYPE.
+	(build_over_call): For purposes of check_function_arguments, if
+	argarray[j] is ADDR_EXPR with REFERENCE_TYPE created above, use
+	its operand rather than the argument itself.
+
+	2018-03-08  Jason Merrill  <jason@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/80598
+	* call.c (build_over_call): In templates set TREE_USED (first_fn) when
+	not calling mark_used for the benefit of -Wunused-function warning.
+
+	2018-03-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84662
+	* pt.c (tsubst_copy_and_build) <case TEMPLATE_ID_EXPR>: Use
+	RETURN instead of return.
+	<case POINTER_PLUS_EXPR>: Likewise.
+	<case CONVERT_EXPR>: If op0 is error_mark_node, just return
+	it instead of wrapping it into CONVERT_EXPR.
+
+2018-06-12  Jason Merrill  <jason@redhat.com>
+
+	PR c++/85815 - reference to member of enclosing template.
+	* parser.c (cp_parser_postfix_dot_deref_expression): Check
+	currently_open_class.
+
+	PR c++/86060 - ICE on range for with -std=c++98.
+	* parser.c (cp_parser_init_statement): Don't clobber *decl after
+	pedwarn.
+
+2018-05-07  Jason Merrill  <jason@redhat.com>
+
+	PR c++/85646 - lambda visibility.
+	* decl2.c (determine_visibility): Don't mess with template arguments
+	from the containing scope.
+	(vague_linkage_p): Check DECL_ABSTRACT_P before looking at a 'tor
+	thunk.
+
+2018-04-23  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	Backport from mainline
+	2018-04-05  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	Implement P0969
+	* decl.c (find_decomp_class_base): Check accessibility instead
+	of declared access, adjust diagnostic.
+
+2018-04-23  Jakub Jelinek  <jakub@redhat.com>
+	    Jason Merrill  <jason@redhat.com>
+
+	PR c++/85470 - wrong error with static data member.
+	* decl.c (check_initializer): Check DECL_INITIALIZED_IN_CLASS_P.
+	* typeck2.c (store_init_value): Likewise.
+
+2018-04-23  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	Backport from mainline
+	2018-04-05  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	Implement P0961
+	* decl.c (get_tuple_decomp_init): Check the templatedness
+	of a member get.
+
+2018-04-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	PR c++/85464 - missing location for -Wignored-qualifiers diagnostic
+	* decl.c (grokdeclarator): If declspecs->locations[ds_type_spec]
+	is UNKNOWN_LOCATION fall back to input_location.
+
+2018-04-09  Jason Merrill  <jason@redhat.com>
+
+	PR c++/85279 - dump_expr doesn't understand decltype.
+	* error.c (dump_expr): Handle DECLTYPE_TYPE.
+
+2018-04-05  Jason Merrill  <jason@redhat.com>
+
+	PR c++/82152 - ICE with class deduction and inherited ctor.
+	* pt.c (do_class_deduction): Ignore inherited ctors.
+
+	PR c++/84665 - ICE with array of empty class.
+	* decl2.c (cp_check_const_attributes): Use fold_non_dependent_expr.
+
+	PR c++/85006 - -fconcepts ICE with A<auto...> return type
+	* pt.c (tsubst_pack_expansion): Allow unsubstituted auto pack.
+
+2018-04-04  Jason Merrill  <jason@redhat.com>
+
+	PR c++/85118 - wrong error with generic lambda and std::bind.
+	* call.c (add_template_conv_candidate): Disable if there are any
+	call operators.
+
+	PR c++/85148 - ICE with 'this' in array NSDMI.
+	* tree.c (replace_placeholders_r): Use handled_component_p.
+
+2018-04-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/85113 - ICE with constexpr and __builtin_constant_p.
+	* constexpr.c (cxx_eval_builtin_function_call): Only defer
+	__builtin_constant_p if ctx->quiet.
+
+	* typeck.c (merge_types): Limit matching attribute shortcut to
+	the default case.
+
+	PR c++/64095 - auto... parameter pack.
+	* parser.c (cp_parser_parameter_declaration): Handle turning autos
+	into packs here.
+	(cp_parser_parameter_declaration_list): Not here.
+
+	PR c++/85060 - wrong-code with call to base member in template.
+	* search.c (any_dependent_bases_p): Check uses_template_parms
+	rather than processing_template_decl.
+
+2018-03-29  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	Backport from mainline
+	2018-03-23  Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	Implement P0962
+	* parser.c (cp_parser_perform_range_for_lookup): Change
+	the condition for deciding whether to use members.
+
+2018-03-23  Jason Merrill  <jason@redhat.com>
+
+	PR c++/78489 - Substitution in wrong order
+	PR c++/84489
+	* pt.c (type_unification_real): Revert last two changes.
+
+	PR c++/71834 - template-id with too few arguments.
+	* pt.c (coerce_template_parms): Make sure we gave an error.
+
+	PR c++/84937 - ICE with class deduction and auto.
+	* pt.c (rewrite_template_parm): Fix auto handling.
+
+	PR c++/80227 - SFINAE and negative array size.
+	* decl.c (compute_array_index_type): Convert to signed for negative
+	check.
+
+	PR c++/84839 - ICE with decltype of parameter pack.
+	* pt.c (tsubst_pack_expansion): Set cp_unevaluated_operand while
+	instantiating dummy parms.
+
+	PR c++/84798 - ICE with auto in abstract function declarator.
+	* parser.c (cp_parser_parameter_declaration_clause): Check
+	parser->default_arg_ok_p.
+
+	PR c++/84355 - ICE with deduction for member class template.
+	* pt.c (tsubst) [TEMPLATE_TYPE_PARM]: Always substitute into
+	CLASS_PLACEHOLDER_TEMPLATE.
+
+2018-03-23  Paolo Carlini  <paolo.carlini@oracle.com>
+	    Jason Merrill  <jason@redhat.com>
+
+	PR c++/82336 - link error with list-init default argument.
+	* decl.c (check_default_argument): Unshare an initializer list.
+
+2018-03-22  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2018-03-22  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/84854
+	* semantics.c (finish_if_stmt_cond): Check if the type of the condition
+	is boolean.
+
+	2018-03-19  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/84927
+	* constexpr.c (cxx_eval_bare_aggregate): Update constructor's flags
+	as we evaluate the elements.
+	(cxx_eval_constant_expression): Verify constructor's flags
+	unconditionally.
+
+	2018-03-21  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/71638, ICE with NSDMI and reference.
+	* constexpr.c (cxx_eval_bare_aggregate): Update constructor's flags
+	even when we replace an element.
+
+2018-03-09  Jason Merrill  <jason@redhat.com>
+
+	PR c++/84785 - ICE with alias template and default targs.
+	* pt.c (type_unification_real): Set processing_template_decl if
+	saw_undeduced == 1.
+
+2018-03-07  Marek Polacek  <polacek@redhat.com>
+
+	Backported from mainline
+	2018-03-06  Marek Polacek  <polacek@redhat.com>
+
+	PR c++/84684
+	* constexpr.c (cxx_bind_parameters_in_call): Unshare evaluated
+	arguments.
+
+2018-03-03  Jason Merrill  <jason@redhat.com>
+
+	PR c++/84686 - missing volatile loads.
+	* cvt.c (convert_to_void): Call maybe_undo_parenthesized_ref.
+
+2018-03-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-02-26  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84558
+	* constexpr.c (cxx_eval_vec_init_1): For reuse, treat NULL eltinit like
+	a valid constant initializer.  Formatting fixes.
+
+	PR c++/84557
+	* parser.c (cp_parser_omp_var_list_no_open): Only call
+	cp_parser_lookup_name_simple on names satisfying identifier_p.
+	(cp_parser_oacc_routine): Likewise.
+
+	2018-02-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84445
+	* class.c (fixed_type_or_null) <case CALL_EXPR>: Only test
+	TREE_HAS_CONSTRUCTOR if instance is not an internal function call.
+
+	PR c++/84449
+	* tree.c (bot_manip): If build_cplus_new or break_out_target_exprs
+	returns error_mark_node, return it immediately.
+	(break_out_target_exprs): If cp_walk_tree with bot_manip returns
+	error_mark_node, return error_mark_node.
+
+	2018-02-19  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84448
+	* parser.c (cp_parser_binary_expression): For no_toplevel_fold_p, if
+	either operand is error_mark_node, set current.lhs to that instead of
+	creating a binary op with error_mark_node operands.
+
+	PR c++/84430
+	* constexpr.c (potential_constant_expression_1): Handle OMP_SIMD.
+
+	2018-02-16  Marek Polacek  <polacek@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84192
+	* constexpr.c (cxx_eval_constant_expression) <case RETURN_EXPR>: Don't
+	set *jump_target to anything if jump_target is NULL.
+
+	2018-02-12  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84341
+	* parser.c (cp_parser_binary_expression): Use build_min instead of
+	build2_loc to build the no_toplevel_fold_p toplevel binary expression.
+
+	2018-02-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/83987
+	* tree.c (cp_free_lang_data): Revert 2018-01-23 change.
+
+	2018-02-09  Marek Polacek  <polacek@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/83659
+	* constexpr.c (cxx_fold_indirect_ref): Sync some changes from
+	fold_indirect_ref_1.  Verify first that tree_fits_shwi_p (op01).
+	Formatting fixes.
+
+	2018-02-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84082
+	* parser.c (cp_parser_dot_deref_incomplete): New function.
+	(cp_parser_postfix_dot_deref_expression): Use it.
+
+	2018-01-31  Jason Merrill  <jason@redhat.com>
+		    Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/83993
+	* constexpr.c (cxx_eval_outermost_constant_expr): Build NOP_EXPR
+	around non-constant ADDR_EXPRs rather than clearing TREE_CONSTANT
+	on ADDR_EXPR.
+
+	2018-01-25  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/84031
+	* decl.c (find_decomp_class_base): Ignore unnamed bitfields.  Ignore
+	recursive calls that return ret.
+	(cp_finish_decomp): Ignore unnamed bitfields.
+
+	2018-01-23  Jakub Jelinek  <jakub@redhat.com>
+
+	PR sanitizer/83987
+	* tree.c (cp_free_lang_data): Change DECL_VALUE_EXPR of
+	DECL_OMP_PRIVATIZED_MEMBER vars to error_mark_node.
+
+	PR c++/83958
+	* decl.c (cp_finish_decomp): Diagnose if reference structure binding
+	refers to incomplete type.
+
+	2018-01-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/83824
+	* parser.c (attr_chainon): New function.
+	(cp_parser_label_for_labeled_statement, cp_parser_decl_specifier_seq,
+	cp_parser_namespace_definition, cp_parser_init_declarator,
+	cp_parser_type_specifier_seq, cp_parser_parameter_declaration,
+	cp_parser_gnu_attributes_opt): Use it.
+	(cp_parser_member_declaration, cp_parser_objc_class_ivars,
+	cp_parser_objc_struct_declaration): Likewise.  Don't reset
+	prefix_attributes if attributes is error_mark_node.
+
+	2018-01-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/83817
+	* pt.c (tsubst_copy_and_build) <case CALL_EXPR>: If function
+	is AGGR_INIT_EXPR rather than CALL_EXPR, set AGGR_INIT_FROM_THUNK_P
+	instead of CALL_FROM_THUNK_P.
+
+2018-03-02  Jason Merrill  <jason@redhat.com>
+
+	Fix MIPS16 ICE.
+	* pt.c (type_dependent_expression_p): Check DECL_LANG_SPECIFIC.
+
+2018-02-27  Jason Merrill  <jason@redhat.com>
+
+	PR c++/84489 - dependent default template argument
+	* pt.c (type_unification_real): Handle early substitution failure.
+
+2018-03-01  Jason Merrill  <jason@redhat.com>
+
+	PR c++/71569 - decltype of template.
+	* parser.c (cp_parser_decltype_expr): Handle missing template args.
+
+2018-03-01  Jason Merrill  <jason@redhat.com>
+	    Alexandre Oliva <aoliva@redhat.com>
+
+	PR c++/71569 - ICE with redundant args on member variable template.
+	* decl.c (start_decl): Handle partial specialization of member
+	variable template.
+	* pt.c (determine_specialization): Allow partial specialization
+	of member variable template without specializing enclosing class.
+	(process_partial_specialization): Improve error message.
+
+2018-02-28  Jason Merrill  <jason@redhat.com>
+
+	PR c++/71784 - ICE with ref-qualifier and explicit specialization.
+	* pt.c (determine_specialization): Check ref-qualifier.
+
+2018-02-27  Jason Merrill  <jason@redhat.com>
+
+	PR c++/84496 - ICE with generic lambda in lambda.
+	* pt.c (type_dependent_expression_p): Fix dependency checking of
+	functions without DECL_TEMPLATE_INFO.
+
+2018-02-26  Jason Merrill  <jason@redhat.com>
+
+	PR c++/84441 - ICE with base initialized from ?:
+	* call.c (unsafe_copy_elision_p): Handle COND_EXPR.
+
+	PR c++/84520 - ICE with generic lambda in NSDMI.
+	* lambda.c (lambda_expr_this_capture): Don't look for fake NSDMI
+	'this' in a generic lambda instantiation.
+
+2018-02-26  Jason Merrill  <jason@redhat.com>
+	    Ville Voutilainen  <ville.voutilainen@gmail.com>
+
+	PR c++/81589 - error with is_trivially_constructible.
+	* method.c (constructible_expr): Set cp_unevaluated.
+
+2018-02-25  Jason Merrill  <jason@redhat.com>
+
+	PR c++/84015 - ICE with class deduction and auto template parm.
+	* pt.c (rewrite_template_parm): Use tf_partial in first tsubst.
+
+2018-02-19  Jonathan Wakely  <jwakely@redhat.com>
+
+	Backport from mainline
+	2017-08-29  Jason Merrill  <jason@redhat.com>
+
+	Fix lambdas in template default argument of inherited ctor.
+	* method.c (synthesized_method_base_walk): Replace an inherited
+	template with its specialization.
+	(synthesized_method_walk): Make inheriting_ctor a pointer.
+	(maybe_explain_implicit_delete, explain_implicit_non_constexpr)
+	(deduce_inheriting_ctor, implicitly_declare_fn): Adjust.
+
+2018-02-16  Jason Merrill  <jason@redhat.com>
+
+	PR c++/84151 - unnecessary volatile load with static member.
+	* call.c (build_new_method_call_1): Avoid loading from a volatile
+	lvalue used as the object argument for a static member function.
+
+	PR c++/81853 - using-directive and constexpr.
+	* constexpr.c (cxx_eval_constant_expression): Handle USING_STMT.
+
+	PR c++/84420 - ICE with structured binding in lambda.
+	* lambda.c (is_capture_proxy): Check DECL_DECOMPOSITION_P.
+
+	PR c++/83835 - C++17 error with constructor ctors.
+	* call.c (build_special_member_call): Set TARGET_EXPR_DIRECT_INIT_P.
+
+	PR c++/82664 - ICE with reference to function template parm.
+	* pt.c (convert_nontype_argument_function): Avoid obfuscationg
+	NOP_EXPRs.
+
+	PR c++/82764 - C++17 ICE with empty base
+	* class.c (build_base_field_1): Set DECL_SIZE to zero for empty base.
+
+	PR c++/83227 - C++17 ICE with init-list derived-to-base conversion.
+	* call.c (convert_like_real): Don't use the copy-list-initialization
+	shortcut for ck_base.
+
+	PR c++/84045 - ICE with typedef and noexcept.
+	* except.c (build_noexcept_spec): Use strip_typedefs_expr.
+
+2018-01-29  Jason Merrill  <jason@redhat.com>
+
+	PR c++/82461 - constexpr list-initialized member
+	* constexpr.c (potential_constant_expression_1): Check
+	TARGET_EXPR_DIRECT_INIT_P.
+
+2018-01-26  Nathan Sidwell  <nathan@acm.org>
+
+	PR c++/82878
+	PR c++/78495
+	* call.c (build_call_a): Don't set CALL_FROM_THUNK_P for inherited
+	ctor.
+	* cp-gimplify.c	(cp_genericize_r): Restore THUNK dereference
+	inhibibition check removed in previous c++/78495 change.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
Index: gcc/cp/cp-gimplify.c
===================================================================
diff --git a/gcc/cp/cp-gimplify.c b/gcc/cp/cp-gimplify.c
--- a/gcc/cp/cp-gimplify.c	(revision 262353)
+++ b/gcc/cp/cp-gimplify.c	(revision 262353)
@@ -1107,6 +1107,14 @@
       && omp_var_to_track (stmt))
     omp_cxx_notice_variable (wtd->omp_ctx, stmt);
 
+  /* Don't dereference parms in a thunk, pass the references through. */
+  if ((TREE_CODE (stmt) == CALL_EXPR && CALL_FROM_THUNK_P (stmt))
+      || (TREE_CODE (stmt) == AGGR_INIT_EXPR && AGGR_INIT_FROM_THUNK_P (stmt)))
+    {
+      *walk_subtrees = 0;
+      return NULL;
+    }
+
   /* Dereference invisible reference parms.  */
   if (wtd->handle_invisiref_parm_p && is_invisiref_parm (stmt))
     {
@@ -1910,7 +1918,7 @@
 /* True if OpenMP sharing attribute of DECL is predetermined.  */
 
 enum omp_clause_default_kind
-cxx_omp_predetermined_sharing (tree decl)
+cxx_omp_predetermined_sharing_1 (tree decl)
 {
   /* Static data members are predetermined shared.  */
   if (TREE_STATIC (decl))
@@ -1928,6 +1936,32 @@
   return OMP_CLAUSE_DEFAULT_UNSPECIFIED;
 }
 
+/* Likewise, but also include the artificial vars.  We don't want to
+   disallow the artificial vars being mentioned in explicit clauses,
+   as we use artificial vars e.g. for loop constructs with random
+   access iterators other than pointers, but during gimplification
+   we want to treat them as predetermined.  */
+
+enum omp_clause_default_kind
+cxx_omp_predetermined_sharing (tree decl)
+{
+  enum omp_clause_default_kind ret = cxx_omp_predetermined_sharing_1 (decl);
+  if (ret != OMP_CLAUSE_DEFAULT_UNSPECIFIED)
+    return ret;
+
+  /* Predetermine artificial variables holding integral values, those
+     are usually result of gimplify_one_sizepos or SAVE_EXPR
+     gimplification.  */
+  if (VAR_P (decl)
+      && DECL_ARTIFICIAL (decl)
+      && INTEGRAL_TYPE_P (TREE_TYPE (decl))
+      && !(DECL_LANG_SPECIFIC (decl)
+	   && DECL_OMP_PRIVATIZED_MEMBER (decl)))
+    return OMP_CLAUSE_DEFAULT_SHARED;
+
+  return OMP_CLAUSE_DEFAULT_UNSPECIFIED;
+}
+
 /* Finalize an implicitly determined clause.  */
 
 void
@@ -2148,6 +2182,28 @@
       goto unary;
 
     case ADDR_EXPR:
+      loc = EXPR_LOCATION (x);
+      op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), false);
+
+      /* Cope with user tricks that amount to offsetof.  */
+      if (op0 != error_mark_node
+	  && TREE_CODE (TREE_TYPE (op0)) != FUNCTION_TYPE
+	  && TREE_CODE (TREE_TYPE (op0)) != METHOD_TYPE)
+	{
+	  tree val = get_base_address (op0);
+	  if (val
+	      && INDIRECT_REF_P (val)
+	      && COMPLETE_TYPE_P (TREE_TYPE (val))
+	      && TREE_CONSTANT (TREE_OPERAND (val, 0)))
+	    {
+	      val = TREE_OPERAND (val, 0);
+	      STRIP_NOPS (val);
+	      if (TREE_CODE (val) == INTEGER_CST)
+		return fold_offsetof (op0, TREE_TYPE (x));
+	    }
+	}
+      goto finish_unary;
+
     case REALPART_EXPR:
     case IMAGPART_EXPR:
       rval_ops = false;
@@ -2165,6 +2221,7 @@
       loc = EXPR_LOCATION (x);
       op0 = cp_fold_maybe_rvalue (TREE_OPERAND (x, 0), rval_ops);
 
+    finish_unary:
       if (op0 != TREE_OPERAND (x, 0))
 	{
 	  if (op0 == error_mark_node)
Index: gcc/cp/typeck2.c
===================================================================
diff --git a/gcc/cp/typeck2.c b/gcc/cp/typeck2.c
--- a/gcc/cp/typeck2.c	(revision 262353)
+++ b/gcc/cp/typeck2.c	(revision 262353)
@@ -817,9 +817,12 @@
       bool const_init;
       value = instantiate_non_dependent_expr (value);
       if (DECL_DECLARED_CONSTEXPR_P (decl)
-	  || (DECL_IN_AGGR_P (decl) && !DECL_VAR_DECLARED_INLINE_P (decl)))
+	  || (DECL_IN_AGGR_P (decl)
+	      && DECL_INITIALIZED_IN_CLASS_P (decl)
+	      && !DECL_VAR_DECLARED_INLINE_P (decl)))
 	{
-	  /* Diagnose a non-constant initializer for constexpr.  */
+	  /* Diagnose a non-constant initializer for constexpr variable or
+	     non-inline in-class-initialized static data member.  */
 	  if (processing_template_decl
 	      && !require_potential_constant_expression (value))
 	    value = error_mark_node;
@@ -1954,7 +1957,7 @@
       if (complain & tf_warning
 	  && TREE_DEPRECATED (type)
 	  && DECL_ARTIFICIAL (exp))
-	warn_deprecated_use (type, NULL_TREE);
+	cp_warn_deprecated_use (type);
     }
   else
     type = exp;
Index: gcc/cp/pt.c
===================================================================
diff --git a/gcc/cp/pt.c b/gcc/cp/pt.c
--- a/gcc/cp/pt.c	(revision 262353)
+++ b/gcc/cp/pt.c	(revision 262353)
@@ -2072,7 +2072,8 @@
   /* We shouldn't be specializing a member template of an
      unspecialized class template; we already gave an error in
      check_specialization_scope, now avoid crashing.  */
-  if (template_count && DECL_CLASS_SCOPE_P (decl)
+  if (!VAR_P (decl)
+      && template_count && DECL_CLASS_SCOPE_P (decl)
       && template_class_depth (DECL_CONTEXT (decl)) > 0)
     {
       gcc_assert (errorcount);
@@ -2175,11 +2176,18 @@
 	     that the const qualification is the same.  Since
 	     get_bindings does not try to merge the "this" parameter,
 	     we must do the comparison explicitly.  */
-	  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fn)
-	      && !same_type_p (TREE_VALUE (fn_arg_types),
-			       TREE_VALUE (decl_arg_types)))
-	    continue;
+	  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fn))
+	    {
+	      if (!same_type_p (TREE_VALUE (fn_arg_types),
+				TREE_VALUE (decl_arg_types)))
+		continue;
 
+	      /* And the ref-qualification.  */
+	      if (type_memfn_rqual (TREE_TYPE (decl))
+		  != type_memfn_rqual (TREE_TYPE (fn)))
+		continue;
+	    }
+
 	  /* Skip the "this" parameter and, for constructors of
 	     classes with virtual bases, the VTT parameter.  A
 	     full specialization of a constructor will have a VTT
@@ -2284,6 +2292,11 @@
 			 decl_arg_types))
             continue;
 
+	  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fn)
+	      && (type_memfn_rqual (TREE_TYPE (decl))
+		  != type_memfn_rqual (TREE_TYPE (fn))))
+	    continue;
+
           // If the deduced arguments do not satisfy the constraints,
           // this is not a candidate.
           if (flag_concepts && !constraints_satisfied_p (fn))
@@ -4601,10 +4614,13 @@
     {
       if (!flag_concepts)
         error ("partial specialization %q+D does not specialize "
-	       "any template arguments", decl);
+	       "any template arguments; to define the primary template, "
+	       "remove the template argument list", decl);
       else
         error ("partial specialization %q+D does not specialize any "
-	       "template arguments and is not more constrained than", decl);
+	       "template arguments and is not more constrained than "
+	       "the primary template; to define the primary template, "
+	       "remove the template argument list", decl);
       inform (DECL_SOURCE_LOCATION (maintmpl), "primary template here");
     }
 
@@ -4848,7 +4864,7 @@
 fixed_parameter_pack_p_1 (tree parm, struct find_parameter_pack_data *ppd)
 {
   /* A type parm can't refer to another parm.  */
-  if (TREE_CODE (parm) == TYPE_DECL)
+  if (TREE_CODE (parm) == TYPE_DECL || parm == error_mark_node)
     return;
   else if (TREE_CODE (parm) == PARM_DECL)
     {
@@ -6032,7 +6048,12 @@
 
  accept:
   if (TREE_CODE (type) == REFERENCE_TYPE)
-    fn = build_address (fn);
+    {
+      if (REFERENCE_REF_P (fn))
+	fn = TREE_OPERAND (fn, 0);
+      else
+	fn = build_address (fn);
+    }
   if (!same_type_ignoring_top_level_qualifiers_p (type, TREE_TYPE (fn)))
     fn = build_nop (type, fn);
 
@@ -8244,7 +8265,11 @@
     }
 
   if (lost)
-    return error_mark_node;
+    {
+      if ((complain & tf_error) && !seen_error())
+	error ("wrong number of template arguments");
+      return error_mark_node;
+    }
 
   if (CHECKING_P && !NON_DEFAULT_TEMPLATE_ARGS_COUNT (new_inner_args))
     SET_NON_DEFAULT_TEMPLATE_ARGS_COUNT (new_inner_args,
@@ -11454,7 +11479,9 @@
 	    {
 	      /* This parameter pack was used in an unevaluated context.  Just
 		 make a dummy decl, since it's only used for its type.  */
+	      ++cp_unevaluated_operand;
 	      arg_pack = tsubst_decl (parm_pack, args, complain);
+	      --cp_unevaluated_operand;
 	      if (arg_pack && DECL_PACK_P (arg_pack))
 		/* Partial instantiation of the parm_pack, we can't build
 		   up an argument pack yet.  */
@@ -11524,7 +11551,7 @@
 	  /* We can't substitute for this parameter pack.  We use a flag as
 	     well as the missing_level counter because function parameter
 	     packs don't have a level.  */
-	  gcc_assert (processing_template_decl);
+	  gcc_assert (processing_template_decl || is_auto (parm_pack));
 	  unsubstituted_packs = true;
 	}
     }
@@ -13755,8 +13782,7 @@
 			= tsubst_constraint (constr, args, complain, in_decl);
 		    else if (tree pl = CLASS_PLACEHOLDER_TEMPLATE (t))
 		      {
-			if (DECL_TEMPLATE_TEMPLATE_PARM_P (pl))
-			  pl = tsubst (pl, args, complain, in_decl);
+			pl = tsubst_copy (pl, args, complain, in_decl);
 			CLASS_PLACEHOLDER_TEMPLATE (r) = pl;
 		      }
 		  }
@@ -15778,6 +15804,12 @@
       DECL_HAS_VALUE_EXPR_P (decl2) = 1;
       if (VAR_P (decl3))
 	DECL_TEMPLATE_INSTANTIATED (decl3) = 1;
+      else
+	{
+	  gcc_assert (errorcount);
+	  decl = error_mark_node;
+	  continue;
+	}
       maybe_push_decl (decl3);
       if (error_operand_p (decl3))
 	decl = error_mark_node;
@@ -16766,7 +16798,7 @@
 	if (targs)
 	  targs = tsubst_template_args (targs, args, complain, in_decl);
 	if (targs == error_mark_node)
-	  return error_mark_node;
+	  RETURN (error_mark_node);
 
 	if (TREE_CODE (templ) == SCOPE_REF)
 	  {
@@ -16773,7 +16805,7 @@
 	    tree name = TREE_OPERAND (templ, 1);
 	    tree tid = lookup_template_function (name, targs);
 	    TREE_OPERAND (templ, 1) = tid;
-	    return templ;
+	    RETURN (templ);
 	  }
 
 	if (variable_template_p (templ))
@@ -16838,6 +16870,8 @@
       {
 	tree type = tsubst (TREE_TYPE (t), args, complain, in_decl);
 	tree op0 = RECUR (TREE_OPERAND (t, 0));
+	if (op0 == error_mark_node)
+	  RETURN (error_mark_node);
 	RETURN (build1 (CONVERT_EXPR, type, op0));
       }
 
@@ -16985,7 +17019,7 @@
       {
 	tree op0 = RECUR (TREE_OPERAND (t, 0));
 	tree op1 = RECUR (TREE_OPERAND (t, 1));
-	return fold_build_pointer_plus (op0, op1);
+	RETURN (fold_build_pointer_plus (op0, op1));
       }
 
     case SCOPE_REF:
@@ -17492,7 +17526,10 @@
 		CALL_EXPR_REVERSE_ARGS (function) = rev;
 		if (thk)
 		  {
-		    CALL_FROM_THUNK_P (function) = true;
+		    if (TREE_CODE (function) == CALL_EXPR)
+		      CALL_FROM_THUNK_P (function) = true;
+		    else
+		      AGGR_INIT_FROM_THUNK_P (function) = true;
 		    /* The thunk location is not interesting.  */
 		    SET_EXPR_LOCATION (function, UNKNOWN_LOCATION);
 		  }
@@ -19205,6 +19242,24 @@
 			  /*nondeduced*/false, array_deduction_r);
 }
 
+/* Returns how many levels of { } INIT contains.  */
+
+static int
+braced_init_depth (tree init)
+{
+  if (!init || !BRACE_ENCLOSED_INITIALIZER_P (init))
+    return 0;
+  unsigned i; tree val;
+  unsigned max = 0;
+  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (init), i, val)
+    {
+      unsigned elt_d = braced_init_depth (val);
+      if (elt_d > max)
+	max = elt_d;
+    }
+  return max + 1;
+}
+
 /* Most parms like fn_type_unification.
 
    If SUBR is 1, we're being called recursively (to unify the
@@ -19441,6 +19496,10 @@
 
 	    if (uses_template_parms (parm))
 	      continue;
+	    /* Workaround for c++/80290: avoid combinatorial explosion on
+	       deeply nested braced init-lists.  */
+	    if (braced_init_depth (arg) > 2)
+	      continue;
 	    if (check_non_deducible_conversion (parm, arg, strict, flags,
 						explain_p))
 	      return 1;
@@ -24065,20 +24124,21 @@
 	  && (any_dependent_template_arguments_p
 	      (INNERMOST_TEMPLATE_ARGS (DECL_TI_ARGS (expression)))))
 	return true;
+    }
 
-      /* Otherwise, if the decl isn't from a dependent scope, it can't be
-	 type-dependent.  Checking this is important for functions with auto
-	 return type, which looks like a dependent type.  */
-      if (TREE_CODE (expression) == FUNCTION_DECL
-	  && undeduced_auto_decl (expression)
-	  && (!DECL_CLASS_SCOPE_P (expression)
-	      || !dependent_type_p (DECL_CONTEXT (expression)))
-	  && (!DECL_FRIEND_CONTEXT (expression)
-	      || !dependent_type_p (DECL_FRIEND_CONTEXT (expression)))
-	  && !DECL_LOCAL_FUNCTION_P (expression))
-	{
-	  return false;
-	}
+  /* Otherwise, if the decl isn't from a dependent scope, it can't be
+     type-dependent.  Checking this is important for functions with auto
+     return type, which looks like a dependent type.  */
+  if (TREE_CODE (expression) == FUNCTION_DECL
+      && undeduced_auto_decl (expression)
+      && (!DECL_CLASS_SCOPE_P (expression)
+	  || !dependent_type_p (DECL_CONTEXT (expression)))
+      && (!DECL_LANG_SPECIFIC (expression)
+	  || !DECL_FRIEND_CONTEXT (expression)
+	  || !dependent_type_p (DECL_FRIEND_CONTEXT (expression)))
+      && !DECL_LOCAL_FUNCTION_P (expression))
+    {
+      return false;
     }
 
   /* Always dependent, on the number of arguments if nothing else.  */
@@ -25105,8 +25165,21 @@
 	  = TEMPLATE_TYPE_PARM_FOR_CLASS (oldtype);
     }
   else
-    newtype = tsubst (TREE_TYPE (olddecl), tsubst_args,
-		      complain, NULL_TREE);
+    {
+      newtype = TREE_TYPE (olddecl);
+      if (type_uses_auto (newtype))
+	{
+	  // Substitute once to fix references to other template parameters.
+	  newtype = tsubst (newtype, tsubst_args,
+			    complain|tf_partial, NULL_TREE);
+	  // Now substitute again to reduce the level of the auto.
+	  newtype = tsubst (newtype, current_template_args (),
+			    complain, NULL_TREE);
+	}
+      else
+	newtype = tsubst (newtype, tsubst_args,
+			  complain, NULL_TREE);
+    }
 
   tree newdecl
     = build_decl (DECL_SOURCE_LOCATION (olddecl), TREE_CODE (olddecl),
@@ -25145,7 +25218,7 @@
 	  // Substitute ttargs into ttparms to fix references to
 	  // other template parameters.
 	  ttparms = tsubst_template_parms_level (ttparms, ttargs,
-						 complain);
+						 complain|tf_partial);
 	  // Now substitute again with args based on tparms, to reduce
 	  // the level of the ttparms.
 	  ttargs = current_template_args ();
@@ -25386,6 +25459,9 @@
     // FIXME cache artificial deduction guides
     for (tree fns = CLASSTYPE_CONSTRUCTORS (type); fns; fns = OVL_NEXT (fns))
       {
+	if (TREE_CODE (fns) == OVERLOAD && OVL_USED (fns))
+	  continue;
+
 	tree fn = OVL_CURRENT (fns);
 	tree guide = build_deduction_guide (fn, outer_args, complain);
 	cands = ovl_cons (guide, cands);
Index: gcc/cp/semantics.c
===================================================================
diff --git a/gcc/cp/semantics.c b/gcc/cp/semantics.c
--- a/gcc/cp/semantics.c	(revision 262353)
+++ b/gcc/cp/semantics.c	(revision 262353)
@@ -730,7 +730,10 @@
   cond = maybe_convert_cond (cond);
   if (IF_STMT_CONSTEXPR_P (if_stmt)
       && require_potential_rvalue_constant_expression (cond)
-      && !value_dependent_expression_p (cond))
+      && !value_dependent_expression_p (cond)
+      /* Wait until instantiation time, since only then COND has been
+	 converted to bool.  */
+      && TREE_TYPE (cond) == boolean_type_node)
     {
       cond = instantiate_non_dependent_expr (cond);
       cond = cxx_constant_value (cond, NULL_TREE);
@@ -1480,6 +1483,21 @@
 		      && C_TYPE_FIELDS_READONLY (TREE_TYPE (operand)))))
 	    cxx_readonly_error (operand, lv_asm);
 
+	  tree *op = &operand;
+	  while (TREE_CODE (*op) == COMPOUND_EXPR)
+	    op = &TREE_OPERAND (*op, 1);
+	  switch (TREE_CODE (*op))
+	    {
+	    case PREINCREMENT_EXPR:
+	    case PREDECREMENT_EXPR:
+	    case MODIFY_EXPR:
+	      *op = genericize_compound_lvalue (*op);
+	      op = &TREE_OPERAND (*op, 1);
+	      break;
+	    default:
+	      break;
+	    }
+
 	  constraint = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (t)));
 	  oconstraints[i] = constraint;
 
@@ -1488,7 +1506,7 @@
 	    {
 	      /* If the operand is going to end up in memory,
 		 mark it addressable.  */
-	      if (!allows_reg && !cxx_mark_addressable (operand))
+	      if (!allows_reg && !cxx_mark_addressable (*op))
 		operand = error_mark_node;
 	    }
 	  else
@@ -1530,7 +1548,23 @@
 		  /* Strip the nops as we allow this case.  FIXME, this really
 		     should be rejected or made deprecated.  */
 		  STRIP_NOPS (operand);
-		  if (!cxx_mark_addressable (operand))
+
+		  tree *op = &operand;
+		  while (TREE_CODE (*op) == COMPOUND_EXPR)
+		    op = &TREE_OPERAND (*op, 1);
+		  switch (TREE_CODE (*op))
+		    {
+		    case PREINCREMENT_EXPR:
+		    case PREDECREMENT_EXPR:
+		    case MODIFY_EXPR:
+		      *op = genericize_compound_lvalue (*op);
+		      op = &TREE_OPERAND (*op, 1);
+		      break;
+		    default:
+		      break;
+		    }
+
+		  if (!cxx_mark_addressable (*op))
 		    operand = error_mark_node;
 		}
 	      else if (!allows_reg && !allows_mem)
@@ -5604,7 +5638,11 @@
       return false;
     }
   else if (processing_template_decl)
-    return false;
+    {
+      if (OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) == error_mark_node)
+	return true;
+      return false;
+    }
 
   tree id = OMP_CLAUSE_REDUCTION_PLACEHOLDER (c);
 
@@ -7333,7 +7371,7 @@
 
 	  if (VAR_P (t) && CP_DECL_THREAD_LOCAL_P (t))
 	    share_name = "threadprivate";
-	  else switch (cxx_omp_predetermined_sharing (t))
+	  else switch (cxx_omp_predetermined_sharing_1 (t))
 	    {
 	    case OMP_CLAUSE_DEFAULT_UNSPECIFIED:
 	      break;
Index: gcc/cp/decl2.c
===================================================================
diff --git a/gcc/cp/decl2.c b/gcc/cp/decl2.c
--- a/gcc/cp/decl2.c	(revision 262353)
+++ b/gcc/cp/decl2.c	(revision 262353)
@@ -1360,7 +1360,7 @@
 	{
 	  tree expr = TREE_VALUE (arg);
 	  if (EXPR_P (expr))
-	    TREE_VALUE (arg) = maybe_constant_value (expr);
+	    TREE_VALUE (arg) = fold_non_dependent_expr (expr);
 	}
     }
 }
@@ -1829,10 +1829,13 @@
 {
   if (!TREE_PUBLIC (decl))
     {
-      /* maybe_thunk_body clears TREE_PUBLIC on the maybe-in-charge 'tor
-	 variants, check one of the "clones" for the real linkage.  */
+      /* maybe_thunk_body clears TREE_PUBLIC and DECL_ABSTRACT_P on the
+	 maybe-in-charge 'tor variants; in that case we need to check one of
+	 the "clones" for the real linkage.  But only in that case; before
+	 maybe_clone_body we haven't yet copied the linkage to the clones.  */
       if ((DECL_MAYBE_IN_CHARGE_DESTRUCTOR_P (decl)
 	   || DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (decl))
+	  && !DECL_ABSTRACT_P (decl)
 	  && DECL_CHAIN (decl)
 	  && DECL_CLONED_FUNCTION (DECL_CHAIN (decl)))
 	return vague_linkage_p (DECL_CHAIN (decl));
@@ -2310,11 +2313,8 @@
 	    }
 
 	  /* Local classes in templates have CLASSTYPE_USE_TEMPLATE set,
-	     but have no TEMPLATE_INFO.  Their containing template
-	     function does, and the local class could be constrained
-	     by that.  */
-	  if (template_decl)
-	    template_decl = fn;
+	     but have no TEMPLATE_INFO, so don't try to check it.  */
+	  template_decl = NULL_TREE;
 	}
       else if (VAR_P (decl) && DECL_TINFO_P (decl)
 	       && flag_visibility_ms_compat)
Index: gcc/cp/parser.c
===================================================================
diff --git a/gcc/cp/parser.c b/gcc/cp/parser.c
--- a/gcc/cp/parser.c	(revision 262353)
+++ b/gcc/cp/parser.c	(revision 262353)
@@ -7252,6 +7252,60 @@
   return postfix_expression;
 }
 
+/* A subroutine of cp_parser_postfix_dot_deref_expression.  Handle dot
+   dereference of incomplete type, returns true if error_mark_node should
+   be returned from caller, otherwise adjusts *SCOPE, *POSTFIX_EXPRESSION
+   and *DEPENDENT_P.  */
+
+bool
+cp_parser_dot_deref_incomplete (tree *scope, cp_expr *postfix_expression,
+				bool *dependent_p)
+{
+  /* In a template, be permissive by treating an object expression
+     of incomplete type as dependent (after a pedwarn).  */
+  diagnostic_t kind = (processing_template_decl
+		       && MAYBE_CLASS_TYPE_P (*scope) ? DK_PEDWARN : DK_ERROR);
+
+  switch (TREE_CODE (*postfix_expression))
+    {
+    case CAST_EXPR:
+    case REINTERPRET_CAST_EXPR:
+    case CONST_CAST_EXPR:
+    case STATIC_CAST_EXPR:
+    case DYNAMIC_CAST_EXPR:
+    case IMPLICIT_CONV_EXPR:
+    case VIEW_CONVERT_EXPR:
+    case NON_LVALUE_EXPR:
+      kind = DK_ERROR;
+      break;
+    case OVERLOAD:
+      /* Don't emit any diagnostic for OVERLOADs.  */
+      kind = DK_IGNORED;
+      break;
+    default:
+      /* Avoid clobbering e.g. DECLs.  */
+      if (!EXPR_P (*postfix_expression))
+	kind = DK_ERROR;
+      break;
+    }
+
+  if (kind == DK_IGNORED)
+    return false;
+
+  location_t exploc = location_of (*postfix_expression);
+  cxx_incomplete_type_diagnostic (exploc, *postfix_expression, *scope, kind);
+  if (!MAYBE_CLASS_TYPE_P (*scope))
+    return true;
+  if (kind == DK_ERROR)
+    *scope = *postfix_expression = error_mark_node;
+  else if (processing_template_decl)
+    {
+      *dependent_p = true;
+      *scope = TREE_TYPE (*postfix_expression) = NULL_TREE;
+    }
+  return false;
+}
+
 /* A subroutine of cp_parser_postfix_expression that also gets hijacked
    by cp_parser_builtin_offsetof.  We're looking for
 
@@ -7310,29 +7364,13 @@
       if (postfix_expression != current_class_ref
 	  && scope != error_mark_node
 	  && !(processing_template_decl
-	       && current_class_type
-	       && (same_type_ignoring_top_level_qualifiers_p
-		   (scope, current_class_type))))
+	       && currently_open_class (scope)))
 	{
 	  scope = complete_type (scope);
 	  if (!COMPLETE_TYPE_P (scope)
-	      /* Avoid clobbering e.g. OVERLOADs or DECLs.  */
-	      && EXPR_P (postfix_expression))
-	    {
-	      /* In a template, be permissive by treating an object expression
-		 of incomplete type as dependent (after a pedwarn).  */
-	      diagnostic_t kind = (processing_template_decl
-				   ? DK_PEDWARN
-				   : DK_ERROR);
-	      cxx_incomplete_type_diagnostic
-		(location_of (postfix_expression),
-		 postfix_expression, scope, kind);
-	      if (processing_template_decl)
-		{
-		  dependent_p = true;
-		  scope = TREE_TYPE (postfix_expression) = NULL_TREE;
-		}
-	    }
+	      && cp_parser_dot_deref_incomplete (&scope, &postfix_expression,
+						 &dependent_p))
+	    return error_mark_node;
 	}
 
       if (!dependent_p)
@@ -9030,12 +9068,20 @@
       if (no_toplevel_fold_p
 	  && lookahead_prec <= current.prec
 	  && sp == stack)
-	current.lhs = build2_loc (combined_loc,
-				  current.tree_type,
-				  TREE_CODE_CLASS (current.tree_type)
-				  == tcc_comparison
-				  ? boolean_type_node : TREE_TYPE (current.lhs),
-				  current.lhs, rhs);
+	{
+	  if (current.lhs == error_mark_node || rhs == error_mark_node)
+	    current.lhs = error_mark_node;
+	  else
+	    {
+	      current.lhs
+		= build_min (current.tree_type,
+			     TREE_CODE_CLASS (current.tree_type)
+			     == tcc_comparison
+			     ? boolean_type_node : TREE_TYPE (current.lhs),
+			     current.lhs.get_value (), rhs.get_value ());
+	      SET_EXPR_LOCATION (current.lhs, combined_loc);
+	    }
+	}
       else
         {
           current.lhs = build_x_binary_op (combined_loc, current.tree_type,
@@ -10743,6 +10789,18 @@
 		"attributes at the beginning of statement are ignored");
 }
 
+/* Append ATTR to attribute list ATTRS.  */
+
+static tree
+attr_chainon (tree attrs, tree attr)
+{
+  if (attrs == error_mark_node)
+    return error_mark_node;
+  if (attr == error_mark_node)
+    return error_mark_node;
+  return chainon (attrs, attr);
+}
+
 /* Parse the label for a labeled-statement, i.e.
 
    identifier :
@@ -10862,7 +10920,7 @@
       else if (!cp_parser_parse_definitely (parser))
 	;
       else
-	attributes = chainon (attributes, attrs);
+	attributes = attr_chainon (attributes, attrs);
     }
 
   if (attributes != NULL_TREE)
@@ -11798,7 +11856,7 @@
 				  /*protect=*/2, /*want_type=*/false,
 				  tf_warning_or_error);
 
-      if (member_begin != NULL_TREE || member_end != NULL_TREE)
+      if (member_begin != NULL_TREE && member_end != NULL_TREE)
 	{
 	  /* Use the member functions.  */
 	  if (member_begin != NULL_TREE)
@@ -12043,12 +12101,9 @@
 	  cp_lexer_consume_token (parser->lexer);
 	  is_range_for = true;
 	  if (cxx_dialect < cxx11)
-	    {
-	      pedwarn (cp_lexer_peek_token (parser->lexer)->location, 0,
-		       "range-based %<for%> loops only available with "
-		       "-std=c++11 or -std=gnu++11");
-	      *decl = error_mark_node;
-	    }
+	    pedwarn (cp_lexer_peek_token (parser->lexer)->location, 0,
+		     "range-based %<for%> loops only available with "
+		     "-std=c++11 or -std=gnu++11");
 	}
       else
 	  /* The ';' is not consumed yet because we told
@@ -13194,8 +13249,7 @@
 		  else
 		    {
 		      decl_specs->std_attributes
-			= chainon (decl_specs->std_attributes,
-				   attrs);
+			= attr_chainon (decl_specs->std_attributes, attrs);
 		      if (decl_specs->locations[ds_std_attribute] == 0)
 			decl_specs->locations[ds_std_attribute] = token->location;
 		    }
@@ -13203,9 +13257,8 @@
 		}
 	    }
 
-	    decl_specs->attributes
-	      = chainon (decl_specs->attributes,
-			 attrs);
+	  decl_specs->attributes
+	    = attr_chainon (decl_specs->attributes, attrs);
 	  if (decl_specs->locations[ds_attribute] == 0)
 	    decl_specs->locations[ds_attribute] = token->location;
 	  continue;
@@ -13688,6 +13741,10 @@
 	expr = cp_parser_lookup_name_simple (parser, expr,
 					     id_expr_start_token->location);
 
+      if (expr && TREE_CODE (expr) == TEMPLATE_DECL)
+	/* A template without args is not a complete id-expression.  */
+	expr = error_mark_node;
+
       if (expr
           && expr != error_mark_node
           && TREE_CODE (expr) != TYPE_DECL
@@ -13753,6 +13810,9 @@
          expression.  */
       cp_parser_abort_tentative_parse (parser);
 
+      /* Commit to the tentative_firewall so we get syntax errors.  */
+      cp_parser_commit_to_tentative_parse (parser);
+
       /* Parse a full expression.  */
       expr = cp_parser_expression (parser, /*pidk=*/NULL, /*cast_p=*/false,
 				   /*decltype_p=*/true);
@@ -18220,7 +18280,7 @@
   if (post_ident_attribs)
     {
       if (attribs)
-        attribs = chainon (attribs, post_ident_attribs);
+        attribs = attr_chainon (attribs, post_ident_attribs);
       else
         attribs = post_ident_attribs;
     }
@@ -19394,7 +19454,7 @@
       decl = grokfield (declarator, decl_specifiers,
 			initializer, !is_non_constant_init,
 			/*asmspec=*/NULL_TREE,
-			chainon (attributes, prefix_attributes));
+			attr_chainon (attributes, prefix_attributes));
       if (decl && TREE_CODE (decl) == FUNCTION_DECL)
 	cp_parser_save_default_args (parser, decl);
       cp_finalize_omp_declare_simd (parser, decl);
@@ -20789,9 +20849,9 @@
       /* Check for attributes first.  */
       if (cp_next_tokens_can_be_attribute_p (parser))
 	{
-	  type_specifier_seq->attributes =
-	    chainon (type_specifier_seq->attributes,
-		     cp_parser_attributes_opt (parser));
+	  type_specifier_seq->attributes
+	    = attr_chainon (type_specifier_seq->attributes,
+			    cp_parser_attributes_opt (parser));
 	  continue;
 	}
 
@@ -20904,7 +20964,10 @@
 
   if (!processing_specialization
       && !processing_template_parmlist
-      && !processing_explicit_instantiation)
+      && !processing_explicit_instantiation
+      /* default_arg_ok_p tracks whether this is a parameter-clause for an
+         actual function or a random abstract declarator.  */
+      && parser->default_arg_ok_p)
     if (!current_function_decl
 	|| (current_class_type && LAMBDA_TYPE_P (current_class_type)))
       parser->auto_is_implicit_function_template_parm_p = true;
@@ -21013,9 +21076,6 @@
       cp_parameter_declarator *parameter;
       tree decl = error_mark_node;
       bool parenthesized_p = false;
-      int template_parm_idx = (function_being_declared_is_template_p (parser)?
-			       TREE_VEC_LENGTH (INNERMOST_TEMPLATE_PARMS
-						(current_template_parms)) : 0);
 
       /* Parse the parameter.  */
       parameter
@@ -21029,22 +21089,6 @@
 
       if (parameter)
 	{
-	  /* If a function parameter pack was specified and an implicit template
-	     parameter was introduced during cp_parser_parameter_declaration,
-	     change any implicit parameters introduced into packs.  */
-	  if (parser->implicit_template_parms
-	      && parameter->declarator
-	      && parameter->declarator->parameter_pack_p)
-	    {
-	      int latest_template_parm_idx = TREE_VEC_LENGTH
-		(INNERMOST_TEMPLATE_PARMS (current_template_parms));
-
-	      if (latest_template_parm_idx != template_parm_idx)
-		parameter->decl_specifiers.type = convert_generic_types_to_packs
-		  (parameter->decl_specifiers.type,
-		   template_parm_idx, latest_template_parm_idx);
-	    }
-
 	  decl = grokdeclarator (parameter->declarator,
 				 &parameter->decl_specifiers,
 				 PARM,
@@ -21202,6 +21246,10 @@
   parser->type_definition_forbidden_message
     = G_("types may not be defined in parameter types");
 
+  int template_parm_idx = (function_being_declared_is_template_p (parser) ?
+			   TREE_VEC_LENGTH (INNERMOST_TEMPLATE_PARMS
+					    (current_template_parms)) : 0);
+
   /* Parse the declaration-specifiers.  */
   cp_parser_decl_specifier_seq (parser,
 				CP_PARSER_FLAGS_NONE,
@@ -21270,8 +21318,8 @@
       parser->default_arg_ok_p = saved_default_arg_ok_p;
       /* After the declarator, allow more attributes.  */
       decl_specifiers.attributes
-	= chainon (decl_specifiers.attributes,
-		   cp_parser_attributes_opt (parser));
+	= attr_chainon (decl_specifiers.attributes,
+			cp_parser_attributes_opt (parser));
 
       /* If the declarator is a template parameter pack, remember that and
 	 clear the flag in the declarator itself so we don't get errors
@@ -21290,6 +21338,23 @@
      parameter pack expansion expression. Otherwise, leave the ellipsis
      for a C-style variadic function. */
   token = cp_lexer_peek_token (parser->lexer);
+
+  /* If a function parameter pack was specified and an implicit template
+     parameter was introduced during cp_parser_parameter_declaration,
+     change any implicit parameters introduced into packs.  */
+  if (parser->implicit_template_parms
+      && (token->type == CPP_ELLIPSIS
+	  || (declarator && declarator->parameter_pack_p)))
+    {
+      int latest_template_parm_idx = TREE_VEC_LENGTH
+	(INNERMOST_TEMPLATE_PARMS (current_template_parms));
+
+      if (latest_template_parm_idx != template_parm_idx)
+	decl_specifiers.type = convert_generic_types_to_packs
+	  (decl_specifiers.type,
+	   template_parm_idx, latest_template_parm_idx);
+    }
+
   if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))
     {
       tree type = decl_specifiers.type;
@@ -23261,7 +23326,7 @@
 		 which are not.  */
 	      first_attribute = attributes;
 	      /* Combine the attributes.  */
-	      attributes = chainon (prefix_attributes, attributes);
+	      attributes = attr_chainon (prefix_attributes, attributes);
 
 	      /* Create the bitfield declaration.  */
 	      decl = grokbitfield (identifier
@@ -23318,7 +23383,7 @@
 		 which are not.  */
 	      first_attribute = attributes;
 	      /* Combine the attributes.  */
-	      attributes = chainon (prefix_attributes, attributes);
+	      attributes = attr_chainon (prefix_attributes, attributes);
 
 	      /* If it's an `=', then we have a constant-initializer or a
 		 pure-specifier.  It is not correct to parse the
@@ -23432,10 +23497,13 @@
 	  cp_finalize_oacc_routine (parser, decl, false);
 
 	  /* Reset PREFIX_ATTRIBUTES.  */
-	  while (attributes && TREE_CHAIN (attributes) != first_attribute)
-	    attributes = TREE_CHAIN (attributes);
-	  if (attributes)
-	    TREE_CHAIN (attributes) = NULL_TREE;
+	  if (attributes != error_mark_node)
+	    {
+	      while (attributes && TREE_CHAIN (attributes) != first_attribute)
+		attributes = TREE_CHAIN (attributes);
+	      if (attributes)
+		TREE_CHAIN (attributes) = NULL_TREE;
+	    }
 
 	  /* If there is any qualification still in effect, clear it
 	     now; we will be starting fresh with the next declarator.  */
@@ -24547,7 +24615,7 @@
 	cp_parser_skip_to_end_of_statement (parser);
 
       /* Add these new attributes to the list.  */
-      attributes = chainon (attributes, attribute_list);
+      attributes = attr_chainon (attributes, attribute_list);
     }
 
   return attributes;
@@ -29725,7 +29793,7 @@
 	     which are not.  */
 	  first_attribute = attributes;
 	  /* Combine the attributes.  */
-	  attributes = chainon (prefix_attributes, attributes);
+	  attributes = attr_chainon (prefix_attributes, attributes);
 
 	  if (width)
 	      /* Create the bitfield declaration.  */
@@ -29742,10 +29810,13 @@
 	    objc_add_instance_variable (decl);
 
 	  /* Reset PREFIX_ATTRIBUTES.  */
-	  while (attributes && TREE_CHAIN (attributes) != first_attribute)
-	    attributes = TREE_CHAIN (attributes);
-	  if (attributes)
-	    TREE_CHAIN (attributes) = NULL_TREE;
+	  if (attributes != error_mark_node)
+	    {
+	      while (attributes && TREE_CHAIN (attributes) != first_attribute)
+		attributes = TREE_CHAIN (attributes);
+	      if (attributes)
+		TREE_CHAIN (attributes) = NULL_TREE;
+	    }
 
 	  token = cp_lexer_peek_token (parser->lexer);
 
@@ -30275,8 +30346,8 @@
 	 which are not.  */
       first_attribute = attributes;
       /* Combine the attributes.  */
-      attributes = chainon (prefix_attributes, attributes);
-      
+      attributes = attr_chainon (prefix_attributes, attributes);
+
       decl = grokfield (declarator, &declspecs,
 			NULL_TREE, /*init_const_expr_p=*/false,
 			NULL_TREE, attributes);
@@ -30285,10 +30356,13 @@
 	return error_mark_node;
       
       /* Reset PREFIX_ATTRIBUTES.  */
-      while (attributes && TREE_CHAIN (attributes) != first_attribute)
-	attributes = TREE_CHAIN (attributes);
-      if (attributes)
-	TREE_CHAIN (attributes) = NULL_TREE;
+      if (attributes != error_mark_node)
+	{
+	  while (attributes && TREE_CHAIN (attributes) != first_attribute)
+	    attributes = TREE_CHAIN (attributes);
+	  if (attributes)
+	    TREE_CHAIN (attributes) = NULL_TREE;
+	}
 
       DECL_CHAIN (decl) = decls;
       decls = decl;
@@ -30888,7 +30962,10 @@
 	  if (name == error_mark_node)
 	    goto skip_comma;
 
-	  decl = cp_parser_lookup_name_simple (parser, name, token->location);
+	  if (identifier_p (name))
+	    decl = cp_parser_lookup_name_simple (parser, name, token->location);
+	  else
+	    decl = name;
 	  if (decl == error_mark_node)
 	    cp_parser_name_lookup_error (parser, name, decl, NLE_NULL,
 					 token->location);
@@ -34209,7 +34286,7 @@
 cp_parser_omp_for_loop_init (cp_parser *parser,
 			     enum tree_code code,
 			     tree &this_pre_body,
-			     vec<tree, va_gc> *for_block,
+			     vec<tree, va_gc> *&for_block,
 			     tree &init,
 			     tree &orig_init,
 			     tree &decl,
@@ -37448,7 +37525,9 @@
 					   /*template_p=*/NULL,
 					   /*declarator_p=*/false,
 					   /*optional_p=*/false);
-      tree decl = cp_parser_lookup_name_simple (parser, name, name_loc);
+      tree decl = (identifier_p (name)
+		   ? cp_parser_lookup_name_simple (parser, name, name_loc)
+		   : name);
       if (name != error_mark_node && decl == error_mark_node)
 	cp_parser_name_lookup_error (parser, name, decl, NLE_NULL, name_loc);
 
Index: gcc/cp/call.c
===================================================================
diff --git a/gcc/cp/call.c b/gcc/cp/call.c
--- a/gcc/cp/call.c	(revision 262353)
+++ b/gcc/cp/call.c	(revision 262353)
@@ -375,18 +375,10 @@
 
   TREE_HAS_CONSTRUCTOR (function) = (decl && DECL_CONSTRUCTOR_P (decl));
 
-  if (current_function_decl && decl
-      && flag_new_inheriting_ctors
-      && DECL_INHERITED_CTOR (current_function_decl)
-      && (DECL_INHERITED_CTOR (current_function_decl)
-	  == DECL_CLONED_FUNCTION (decl)))
-    /* Pass arguments directly to the inherited constructor.  */
-    CALL_FROM_THUNK_P (function) = true;
-
   /* Don't pass empty class objects by value.  This is useful
      for tags in STL, which are used to control overload resolution.
      We don't need to handle other cases of copying empty classes.  */
-  else if (! decl || ! DECL_BUILT_IN (decl))
+  if (! decl || ! DECL_BUILT_IN (decl))
     for (i = 0; i < n; i++)
       {
 	tree arg = CALL_EXPR_ARG (function, i);
@@ -3267,10 +3259,10 @@
 			     tree return_type, tree access_path,
 			     tree conversion_path, tsubst_flags_t complain)
 {
-  /* Making this work broke PR 71117, so until the committee resolves core
-     issue 2189, let's disable this candidate if there are any viable call
+  /* Making this work broke PR 71117 and 85118, so until the committee resolves
+     core issue 2189, let's disable this candidate if there are any call
      operators.  */
-  if (any_strictly_viable (*candidates))
+  if (*candidates)
     return NULL;
 
   return
@@ -6886,6 +6878,11 @@
 	  && DECL_INHERITED_CTOR (current_function_decl))
 	return expr;
 
+      if (TREE_CODE (expr) == TARGET_EXPR
+	  && TARGET_EXPR_LIST_INIT_P (expr))
+	/* Copy-list-initialization doesn't actually involve a copy.  */
+	return expr;
+
       /* Fall through.  */
     case ck_base:
       if (convs->kind == ck_base && !convs->need_temporary_p)
@@ -6911,10 +6908,6 @@
 	flags |= LOOKUP_ONLYCONVERTING;
       if (convs->rvaluedness_matches_p)
 	flags |= LOOKUP_PREFER_RVALUE;
-      if (TREE_CODE (expr) == TARGET_EXPR
-	  && TARGET_EXPR_LIST_INIT_P (expr))
-	/* Copy-list-initialization doesn't actually involve a copy.  */
-	return expr;
       expr = build_temp (expr, totype, flags, &diag_kind, complain);
       if (diag_kind && complain)
 	{
@@ -7151,7 +7144,7 @@
 		     "passing objects of non-trivially-copyable "
 		     "type %q#T through %<...%> is conditionally supported",
 		     arg_type);
-	  return cp_build_addr_expr (arg, complain);
+	  return build1 (ADDR_EXPR, build_reference_type (arg_type), arg);
 	}
       /* Build up a real lvalue-to-rvalue conversion in case the
 	 copy constructor is trivial but not callable.  */
@@ -7525,6 +7518,15 @@
   /* build_compound_expr pushes COMPOUND_EXPR inside TARGET_EXPR.  */
   while (TREE_CODE (init) == COMPOUND_EXPR)
     init = TREE_OPERAND (init, 1);
+  if (TREE_CODE (init) == COND_EXPR)
+    {
+      /* We'll end up copying from each of the arms of the COND_EXPR directly
+	 into the target, so look at them. */
+      if (tree op = TREE_OPERAND (init, 1))
+	if (unsafe_copy_elision_p (target, op))
+	  return true;
+      return unsafe_copy_elision_p (target, TREE_OPERAND (init, 2));
+    }
   return (TREE_CODE (init) == AGGR_INIT_EXPR
 	  && !AGGR_INIT_VIA_CTOR_P (init));
 }
@@ -7566,6 +7568,10 @@
 
       if (undeduced_auto_decl (fn))
 	mark_used (fn, complain);
+      else
+	/* Otherwise set TREE_USED for the benefit of -Wunused-function.
+	   See PR80598.  */
+	TREE_USED (fn) = 1;
 
       return_type = TREE_TYPE (TREE_TYPE (fn));
       nargs = vec_safe_length (args);
@@ -7929,7 +7935,15 @@
       tree *fargs = (!nargs ? argarray
 			    : (tree *) alloca (nargs * sizeof (tree)));
       for (j = 0; j < nargs; j++)
-	fargs[j] = maybe_constant_value (argarray[j]);
+	{
+	  /* For -Wformat undo the implicit passing by hidden reference
+	     done by convert_arg_to_ellipsis.  */
+	  if (TREE_CODE (argarray[j]) == ADDR_EXPR
+	      && TREE_CODE (TREE_TYPE (argarray[j])) == REFERENCE_TYPE)
+	    fargs[j] = TREE_OPERAND (argarray[j], 0);
+	  else
+	    fargs[j] = maybe_constant_value (argarray[j]);
+	}
 
       warned_p = check_function_arguments (input_location, fn, TREE_TYPE (fn),
 					   nargs, fargs);
@@ -8399,6 +8413,9 @@
 	{
 	  if (is_dummy_object (instance))
 	    return arg;
+	  else if (TREE_CODE (arg) == TARGET_EXPR)
+	    TARGET_EXPR_DIRECT_INIT_P (arg) = true;
+
 	  if ((complain & tf_error)
 	      && (flags & LOOKUP_DELEGATING_CONS))
 	    check_self_delegation (arg);
@@ -8851,8 +8868,14 @@
 	      if (TREE_CODE (TREE_TYPE (fn)) != METHOD_TYPE
 		  && !is_dummy_object (instance)
 		  && TREE_SIDE_EFFECTS (instance))
-		call = build2 (COMPOUND_EXPR, TREE_TYPE (call),
-			       instance, call);
+		{
+		  /* But avoid the implicit lvalue-rvalue conversion when 'a'
+		     is volatile.  */
+		  tree a = instance;
+		  if (TREE_THIS_VOLATILE (a))
+		    a = build_this (a);
+		  call = build2 (COMPOUND_EXPR, TREE_TYPE (call), a, call);
+		}
 	      else if (call != error_mark_node
 		       && DECL_DESTRUCTOR_P (cand->fn)
 		       && !VOID_TYPE_P (TREE_TYPE (call)))
Index: gcc/cp/lambda.c
===================================================================
diff --git a/gcc/cp/lambda.c b/gcc/cp/lambda.c
--- a/gcc/cp/lambda.c	(revision 262353)
+++ b/gcc/cp/lambda.c	(revision 262353)
@@ -262,6 +262,7 @@
   return (VAR_P (decl)
 	  && DECL_HAS_VALUE_EXPR_P (decl)
 	  && !DECL_ANON_UNION_VAR_P (decl)
+	  && !DECL_DECOMPOSITION_P (decl)
 	  && LAMBDA_FUNCTION_P (DECL_CONTEXT (decl)));
 }
 
@@ -712,11 +713,14 @@
                                     lambda_stack);
 
 	  if (LAMBDA_EXPR_EXTRA_SCOPE (tlambda)
+	      && !COMPLETE_TYPE_P (LAMBDA_EXPR_CLOSURE (tlambda))
 	      && TREE_CODE (LAMBDA_EXPR_EXTRA_SCOPE (tlambda)) == FIELD_DECL)
 	    {
 	      /* In an NSDMI, we don't have a function to look up the decl in,
 		 but the fake 'this' pointer that we're using for parsing is
-		 in scope_chain.  */
+		 in scope_chain.  But if the closure is already complete, we're
+	         in an instantiation of a generic lambda, and the fake 'this'
+	         is gone.  */
 	      init = scope_chain->x_current_class_ptr;
 	      gcc_checking_assert
 		(init && (TREE_TYPE (TREE_TYPE (init))
@@ -1072,7 +1076,6 @@
       }
   }
 
-
   if (generic_lambda_p)
     {
       if (decltype_call)
Index: gcc/cp/cvt.c
===================================================================
diff --git a/gcc/cp/cvt.c b/gcc/cp/cvt.c
--- a/gcc/cp/cvt.c	(revision 262353)
+++ b/gcc/cp/cvt.c	(revision 262353)
@@ -1053,6 +1053,8 @@
       || TREE_TYPE (expr) == error_mark_node)
     return error_mark_node;
 
+  expr = maybe_undo_parenthesized_ref (expr);
+
   if (implicit == ICV_CAST)
     mark_exp_read (expr);
   else
Index: gcc/cp/cp-tree.h
===================================================================
diff --git a/gcc/cp/cp-tree.h b/gcc/cp/cp-tree.h
--- a/gcc/cp/cp-tree.h	(revision 262353)
+++ b/gcc/cp/cp-tree.h	(revision 262353)
@@ -6708,6 +6708,7 @@
 
 extern void cxx_print_statistics		(void);
 extern bool maybe_warn_zero_as_null_pointer_constant (tree, location_t);
+extern void cp_warn_deprecated_use		(tree);
 
 /* in ptree.c */
 extern void cxx_print_xnode			(FILE *, tree, int);
@@ -6777,6 +6778,7 @@
 extern tree cp_build_addr_expr			(tree, tsubst_flags_t);
 extern tree cp_build_unary_op                   (enum tree_code, tree, bool,
                                                  tsubst_flags_t);
+extern tree genericize_compound_lvalue		(tree);
 extern tree unary_complex_lvalue		(enum tree_code, tree);
 extern tree build_x_conditional_expr		(location_t, tree, tree, tree, 
                                                  tsubst_flags_t);
@@ -6941,6 +6943,7 @@
 						 gimple_seq *);
 extern void cp_genericize			(tree);
 extern bool cxx_omp_const_qual_no_mutable	(tree);
+extern enum omp_clause_default_kind cxx_omp_predetermined_sharing_1 (tree);
 extern enum omp_clause_default_kind cxx_omp_predetermined_sharing (tree);
 extern tree cxx_omp_clause_default_ctor		(tree, tree, tree);
 extern tree cxx_omp_clause_copy_ctor		(tree, tree, tree);
Index: gcc/cp/search.c
===================================================================
diff --git a/gcc/cp/search.c b/gcc/cp/search.c
--- a/gcc/cp/search.c	(revision 262353)
+++ b/gcc/cp/search.c	(revision 262353)
@@ -2879,7 +2879,7 @@
 bool
 any_dependent_bases_p (tree type)
 {
-  if (!type || !CLASS_TYPE_P (type) || !processing_template_decl)
+  if (!type || !CLASS_TYPE_P (type) || !uses_template_parms (type))
     return false;
 
   unsigned i;
Index: gcc/cp/name-lookup.c
===================================================================
diff --git a/gcc/cp/name-lookup.c b/gcc/cp/name-lookup.c
--- a/gcc/cp/name-lookup.c	(revision 262353)
+++ b/gcc/cp/name-lookup.c	(revision 262353)
@@ -3684,6 +3684,9 @@
   tree d;
   bool saw_vis = false;
 
+  if (attributes == error_mark_node)
+    return false;
+
   for (d = attributes; d; d = TREE_CHAIN (d))
     {
       tree name = get_attribute_name (d);
Index: gcc/omp-expand.c
===================================================================
diff --git a/gcc/omp-expand.c b/gcc/omp-expand.c
--- a/gcc/omp-expand.c	(revision 262353)
+++ b/gcc/omp-expand.c	(revision 262353)
@@ -5628,6 +5628,14 @@
 
 	  split->flags ^= EDGE_FALLTHRU | EDGE_TRUE_VALUE;
 
+	  /* Add a dummy exit for the tiled block when cont_bb is missing.  */
+	  if (cont_bb == NULL)
+	    {
+	      edge e = make_edge (body_bb, exit_bb, EDGE_FALSE_VALUE);
+	      e->probability = PROB_EVEN;
+	      split->probability = PROB_EVEN;
+	    }
+
 	  /* Initialize the user's loop vars.  */
 	  gsi = gsi_start_bb (elem_body_bb);
 	  expand_oacc_collapse_vars (fd, true, &gsi, counts, e_offset);
Index: gcc/lto-streamer-out.c
===================================================================
diff --git a/gcc/lto-streamer-out.c b/gcc/lto-streamer-out.c
--- a/gcc/lto-streamer-out.c	(revision 262353)
+++ b/gcc/lto-streamer-out.c	(revision 262353)
@@ -2524,13 +2524,10 @@
   const char *comdat;
   unsigned char c;
 
-  /* None of the following kinds of symbols are needed in the
-     symbol table.  */
-  if (!TREE_PUBLIC (t)
-      || is_builtin_fn (t)
-      || DECL_ABSTRACT_P (t)
-      || (VAR_P (t) && DECL_HARD_REGISTER (t)))
-    return;
+  gcc_checking_assert (TREE_PUBLIC (t)
+		       && !is_builtin_fn (t)
+		       && !DECL_ABSTRACT_P (t)
+		       && (!VAR_P (t) || !DECL_HARD_REGISTER (t)));
 
   gcc_assert (VAR_OR_FUNCTION_DECL_P (t));
 
@@ -2618,45 +2615,6 @@
   lto_write_data (&slot_num, 4);
 }
 
-/* Return true if NODE should appear in the plugin symbol table.  */
-
-bool
-output_symbol_p (symtab_node *node)
-{
-  struct cgraph_node *cnode;
-  if (!node->real_symbol_p ())
-    return false;
-  /* We keep external functions in symtab for sake of inlining
-     and devirtualization.  We do not want to see them in symbol table as
-     references unless they are really used.  */
-  cnode = dyn_cast <cgraph_node *> (node);
-  if (cnode && (!node->definition || DECL_EXTERNAL (cnode->decl))
-      && cnode->callers)
-    return true;
-
- /* Ignore all references from external vars initializers - they are not really
-    part of the compilation unit until they are used by folding.  Some symbols,
-    like references to external construction vtables can not be referred to at all.
-    We decide this at can_refer_decl_in_current_unit_p.  */
- if (!node->definition || DECL_EXTERNAL (node->decl))
-    {
-      int i;
-      struct ipa_ref *ref;
-      for (i = 0; node->iterate_referring (i, ref); i++)
-	{
-	  if (ref->use == IPA_REF_ALIAS)
-	    continue;
-          if (is_a <cgraph_node *> (ref->referring))
-	    return true;
-	  if (!DECL_EXTERNAL (ref->referring->decl))
-	    return true;
-	}
-      return false;
-    }
-  return true;
-}
-
-
 /* Write an IL symbol table to OB.
    SET and VSET are cgraph/varpool node sets we are outputting.  */
 
@@ -2681,7 +2639,7 @@
     {
       symtab_node *node = lsei_node (lsei);
 
-      if (!output_symbol_p (node) || DECL_EXTERNAL (node->decl))
+      if (DECL_EXTERNAL (node->decl) || !node->output_to_lto_symbol_table_p ())
 	continue;
       write_symbol (cache, node->decl, &seen, false);
     }
@@ -2690,7 +2648,7 @@
     {
       symtab_node *node = lsei_node (lsei);
 
-      if (!output_symbol_p (node) || !DECL_EXTERNAL (node->decl))
+      if (!DECL_EXTERNAL (node->decl) || !node->output_to_lto_symbol_table_p ())
 	continue;
       write_symbol (cache, node->decl, &seen, false);
     }
Index: gcc/ipa-utils.c
===================================================================
diff --git a/gcc/ipa-utils.c b/gcc/ipa-utils.c
--- a/gcc/ipa-utils.c	(revision 262353)
+++ b/gcc/ipa-utils.c	(revision 262353)
@@ -404,6 +404,8 @@
 
   if (!dst->count)
     return;
+  if (!src->count || src->alias)
+    return;
   if (symtab->dump_file)
     {
       fprintf (symtab->dump_file, "Merging profiles of %s/%i to %s/%i\n",
Index: gcc/ipa-inline.c
===================================================================
diff --git a/gcc/ipa-inline.c b/gcc/ipa-inline.c
--- a/gcc/ipa-inline.c	(revision 262353)
+++ b/gcc/ipa-inline.c	(revision 262353)
@@ -1773,7 +1773,7 @@
 		struct cgraph_node *n2;
 		int id = dfs->scc_no + 1;
 		for (n2 = node; n2;
-		     n2 = ((struct ipa_dfs_info *) node->aux)->next_cycle)
+		     n2 = ((struct ipa_dfs_info *) n2->aux)->next_cycle)
 		  {
 		    struct inline_summary *info2 = inline_summaries->get (n2);
 		    if (info2->scc_no)
Index: gcc/machmode.def
===================================================================
diff --git a/gcc/machmode.def b/gcc/machmode.def
--- a/gcc/machmode.def	(revision 262353)
+++ b/gcc/machmode.def	(revision 262353)
@@ -243,6 +243,7 @@
 
 /* Complex modes.  */
 COMPLEX_MODES (INT);
+COMPLEX_MODES (PARTIAL_INT);
 COMPLEX_MODES (FLOAT);
 
 /* Decimal floating point modes.  */
Index: gcc/dwarf2out.c
===================================================================
diff --git a/gcc/dwarf2out.c b/gcc/dwarf2out.c
--- a/gcc/dwarf2out.c	(revision 262353)
+++ b/gcc/dwarf2out.c	(revision 262353)
@@ -18749,6 +18749,8 @@
 
       if (GET_MODE_CLASS (mode) == MODE_INT && GET_MODE_SIZE (mode) == 1
 	  && domain
+	  && TYPE_MAX_VALUE (domain)
+	  && TREE_CODE (TYPE_MAX_VALUE (domain)) == INTEGER_CST
 	  && integer_zerop (TYPE_MIN_VALUE (domain))
 	  && compare_tree_int (TYPE_MAX_VALUE (domain),
 			       TREE_STRING_LENGTH (init) - 1) == 0
Index: gcc/match.pd
===================================================================
diff --git a/gcc/match.pd b/gcc/match.pd
--- a/gcc/match.pd	(revision 262353)
+++ b/gcc/match.pd	(revision 262353)
@@ -2789,15 +2789,17 @@
 (simplify
  (cond
   (ne (bit_and @0 integer_pow2p@1) integer_zerop)
-  integer_pow2p@2 integer_zerop)
- (with {
-    int shift = wi::exact_log2 (@2) - wi::exact_log2 (@1);
-  }
-  (if (shift > 0)
-   (bit_and
-    (lshift (convert @0) { build_int_cst (integer_type_node, shift); }) @2)
-   (bit_and
-    (convert (rshift @0 { build_int_cst (integer_type_node, -shift); })) @2))))
+  INTEGER_CST@2 integer_zerop)
+ (if (integer_pow2p (@2))
+  (with {
+     int shift = wi::exact_log2 (@2) - wi::exact_log2 (@1);
+   }
+   (if (shift > 0)
+    (bit_and
+     (lshift (convert @0) { build_int_cst (integer_type_node, shift); }) @2)
+    (bit_and
+     (convert (rshift @0 { build_int_cst (integer_type_node, -shift); }))
+     @2)))))
 
 /* If we have (A & C) != 0 where C is the sign bit of A, convert
    this into A < 0.  Similarly for (A & C) == 0 into A >= 0.  */
@@ -2818,8 +2820,9 @@
 (simplify
  (cond
   (lt @0 integer_zerop)
-  integer_pow2p@1 integer_zerop)
- (if (!TYPE_UNSIGNED (TREE_TYPE (@0)))
+  INTEGER_CST@1 integer_zerop)
+ (if (integer_pow2p (@1)
+      && !TYPE_UNSIGNED (TREE_TYPE (@0)))
   (with {
     int shift = element_precision (@0) - wi::exact_log2 (@1) - 1;
    }
@@ -2926,10 +2929,13 @@
 (for cmp (ne eq)
  (simplify
   (cmp (convert @0) INTEGER_CST@1)
-  (if ((POINTER_TYPE_P (TREE_TYPE (@0)) && !FUNC_OR_METHOD_TYPE_P (TREE_TYPE (TREE_TYPE (@0)))
-	&& INTEGRAL_TYPE_P (TREE_TYPE (@1)))
-      || (INTEGRAL_TYPE_P (TREE_TYPE (@0)) && POINTER_TYPE_P (TREE_TYPE (@1))
-	  && !FUNC_OR_METHOD_TYPE_P (TREE_TYPE (TREE_TYPE (@1)))))
+  (if (((POINTER_TYPE_P (TREE_TYPE (@0))
+	 && !FUNC_OR_METHOD_TYPE_P (TREE_TYPE (TREE_TYPE (@0)))
+	 && INTEGRAL_TYPE_P (TREE_TYPE (@1)))
+	|| (INTEGRAL_TYPE_P (TREE_TYPE (@0))
+	    && POINTER_TYPE_P (TREE_TYPE (@1))
+	    && !FUNC_OR_METHOD_TYPE_P (TREE_TYPE (TREE_TYPE (@1)))))
+       && TYPE_PRECISION (TREE_TYPE (@0)) == TYPE_PRECISION (TREE_TYPE (@1)))
    (cmp @0 (convert @1)))))
 
 /* Non-equality compare simplifications from fold_binary  */
Index: gcc/expr.c
===================================================================
diff --git a/gcc/expr.c b/gcc/expr.c
--- a/gcc/expr.c	(revision 262353)
+++ b/gcc/expr.c	(revision 262353)
@@ -5109,7 +5109,10 @@
 	      && bitpos == 0
 	      && bitsize == mode_bitsize)
 	    result = store_expr (from, to_rtx, false, nontemporal, reversep);
-	  else if (bitsize == mode_bitsize / 2
+	  else if (COMPLEX_MODE_P (GET_MODE (to_rtx))
+		   && (TYPE_MODE (TREE_TYPE (from))
+		       == GET_MODE_INNER (GET_MODE (to_rtx)))
+		   && bitsize == mode_bitsize / 2
 		   && (bitpos == 0 || bitpos == mode_bitsize / 2))
 	    result = store_expr (from, XEXP (to_rtx, bitpos != 0), false,
 				 nontemporal, reversep);
@@ -6893,8 +6896,9 @@
       if (GET_CODE (temp) == PARALLEL)
 	{
 	  HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (exp));
-	  machine_mode temp_mode
-	    = smallest_mode_for_size (size * BITS_PER_UNIT, MODE_INT);
+	  machine_mode temp_mode = GET_MODE (temp);
+	  if (temp_mode == BLKmode || temp_mode == VOIDmode)
+	    temp_mode = smallest_mode_for_size (size * BITS_PER_UNIT, MODE_INT);
 	  rtx temp_target = gen_reg_rtx (temp_mode);
 	  emit_group_store (temp_target, temp, TREE_TYPE (exp), size);
 	  temp = temp_target;
@@ -10862,18 +10866,30 @@
 	tree fndecl = get_callee_fndecl (exp), attr;
 
 	if (fndecl
+	    /* Don't diagnose the error attribute in thunks, those are
+	       artificially created.  */
+	    && !CALL_FROM_THUNK_P (exp)
 	    && (attr = lookup_attribute ("error",
 					 DECL_ATTRIBUTES (fndecl))) != NULL)
-	  error ("%Kcall to %qs declared with attribute error: %s",
-		 exp, identifier_to_locale (lang_hooks.decl_printable_name (fndecl, 1)),
-		 TREE_STRING_POINTER (TREE_VALUE (TREE_VALUE (attr))));
+	  {
+	    const char *ident = lang_hooks.decl_printable_name (fndecl, 1);
+	    error ("%Kcall to %qs declared with attribute error: %s", exp,
+		   identifier_to_locale (ident),
+		   TREE_STRING_POINTER (TREE_VALUE (TREE_VALUE (attr))));
+	  }
 	if (fndecl
+	    /* Don't diagnose the warning attribute in thunks, those are
+	       artificially created.  */
+	    && !CALL_FROM_THUNK_P (exp)
 	    && (attr = lookup_attribute ("warning",
 					 DECL_ATTRIBUTES (fndecl))) != NULL)
-	  warning_at (tree_nonartificial_location (exp),
-		      0, "%Kcall to %qs declared with attribute warning: %s",
-		      exp, identifier_to_locale (lang_hooks.decl_printable_name (fndecl, 1)),
-		      TREE_STRING_POINTER (TREE_VALUE (TREE_VALUE (attr))));
+	  {
+	    const char *ident = lang_hooks.decl_printable_name (fndecl, 1);
+	    warning_at (tree_nonartificial_location (exp), 0,
+			"%Kcall to %qs declared with attribute warning: %s",
+			exp, identifier_to_locale (ident),
+			TREE_STRING_POINTER (TREE_VALUE (TREE_VALUE (attr))));
+	  }
 
 	/* Check for a built-in function.  */
 	if (fndecl && DECL_BUILT_IN (fndecl))
Index: gcc/opts.c
===================================================================
diff --git a/gcc/opts.c b/gcc/opts.c
--- a/gcc/opts.c	(revision 262353)
+++ b/gcc/opts.c	(revision 262353)
@@ -1014,6 +1014,26 @@
   if ((opts->x_flag_sanitize & SANITIZE_KERNEL_ADDRESS) && opts->x_flag_tm)
     sorry ("transactional memory is not supported with "
 	   "%<-fsanitize=kernel-address%>");
+
+  /* Comes from final.c -- no real reason to change it.  */
+#define MAX_CODE_ALIGN 16
+#define MAX_CODE_ALIGN_VALUE (1 << MAX_CODE_ALIGN)
+
+  if (opts->x_align_loops > MAX_CODE_ALIGN_VALUE)
+    error_at (loc, "-falign-loops=%d is not between 0 and %d",
+	      opts->x_align_loops, MAX_CODE_ALIGN_VALUE);
+
+  if (opts->x_align_jumps > MAX_CODE_ALIGN_VALUE)
+    error_at (loc, "-falign-jumps=%d is not between 0 and %d",
+	      opts->x_align_jumps, MAX_CODE_ALIGN_VALUE);
+
+  if (opts->x_align_functions > MAX_CODE_ALIGN_VALUE)
+    error_at (loc, "-falign-functions=%d is not between 0 and %d",
+	      opts->x_align_functions, MAX_CODE_ALIGN_VALUE);
+
+  if (opts->x_align_labels > MAX_CODE_ALIGN_VALUE)
+    error_at (loc, "-falign-labels=%d is not between 0 and %d",
+	      opts->x_align_labels, MAX_CODE_ALIGN_VALUE);
 }
 
 #define LEFT_COLUMN	27
Index: gcc/lra-lives.c
===================================================================
diff --git a/gcc/lra-lives.c b/gcc/lra-lives.c
--- a/gcc/lra-lives.c	(revision 262353)
+++ b/gcc/lra-lives.c	(revision 262353)
@@ -593,7 +593,9 @@
 reg_early_clobber_p (const struct lra_insn_reg *reg, int n_alt)
 {
   return (reg->early_clobber
-	  && (n_alt < 0 || TEST_BIT (reg->early_clobber_alts, n_alt)));
+	  && (n_alt == LRA_UNKNOWN_ALT
+	      || (n_alt != LRA_NON_CLOBBERED_ALT
+		  && TEST_BIT (reg->early_clobber_alts, n_alt))));
 }
 
 /* Process insns of the basic block BB to update pseudo live ranges,
Index: gcc/ada/ChangeLog
===================================================================
diff --git a/gcc/ada/ChangeLog b/gcc/ada/ChangeLog
--- a/gcc/ada/ChangeLog	(revision 262353)
+++ b/gcc/ada/ChangeLog	(revision 262353)
@@ -1,3 +1,86 @@
+2018-06-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/ada-tree.h (TYPE_RETURN_BY_DIRECT_REF_P): Change from
+	using TYPE_LANG_FLAG_4 to using TYPE_LANG_FLAG_0.
+	(TYPE_ALIGN_OK): Move around.
+	(TYPE_PADDING_FOR_COMPONENT): Remove superfluous parentheses.
+	* gcc-interface/decl.c (change_qualified_type): Move to...
+	(gnat_to_gnu_entity): Adjust comment.
+	* gcc-interface/gigi.h (change_qualified_type): ...here; make inline.
+	(ceil_pow2): Use ceil_log2.
+	* gcc-interface/utils.c (finish_subprog_decl): Add couple of comments
+	and do not set TREE_SIDE_EFFECTS.
+	(handle_noreturn_attribute): Use change_qualified_type.
+
+2018-06-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Constant>: Do not get
+	the expression of a dispatch table that is not being defined.
+	<E_Record_Subtype>: Remove obsolete kludge.
+
+2018-06-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backpor from mainline
+	2018-06-02  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Constant>: If this is
+	not a definition, retrieve the expression only if it's a compile-time
+	known value if we are just annotating types.
+
+	* gcc-interface/utils.c (convert): Do not try to upcast properly for a
+	conversion between tagged types in type_annotate_only mode.
+
+2018-06-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2018-06-11  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Type>: Reuse the
+	existing fields of a dummy fat pointer type, if any.  Clear the
+	TYPE_DECL_SUPPRESS_DEBUG on the fat pointer type after completing it.
+
+2018-06-02  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/ada-tree.h (TYPE_PADDING_FOR_COMPONENT): New macro.
+	* gcc-interface/decl.c (gnat_to_gnu_component_type): Cache the padding
+	type built for an aliased component with variable size.
+
+2018-06-02  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2018-05-31  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (Call_to_gnu): If this is a function call and
+	there is no target, also create a temporary for the return value for
+	an allocator if the type is an unconstrained record type with default
+	discriminant.
+
+2018-04-12  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	Backport from mainline
+	2018-03-07  Sebastian Huber  <sebastian.huber@embedded-brains.de>
+
+	* gcc-interface/Makefile.in (OSCONS_CPP): Remove redundant
+	$(GNATLIBCFLAGS).
+	(OSCONS_EXTRACT): Add $(GNATLIBCFLAGS_FOR_C).
+
+2018-03-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR ada/82813
+	* gcc-interface/misc.c (gnat_post_options): Disable string overflow
+	warnings.
+
+2018-03-10  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (node_has_volatile_full_access) <N_Identifier>:
+	Consider only entities for objects.
+
+2018-03-06  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc-interface/trans.c (convert_with_check): Fix typo in the condition
+	guarding the overflow check emitted for the upper bound of a floating-
+	point conversion.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
Index: gcc/ada/gcc-interface/utils.c
===================================================================
diff --git a/gcc/ada/gcc-interface/utils.c b/gcc/ada/gcc-interface/utils.c
--- a/gcc/ada/gcc-interface/utils.c	(revision 262353)
+++ b/gcc/ada/gcc-interface/utils.c	(revision 262353)
@@ -3255,9 +3255,12 @@
   DECL_BY_REFERENCE (result_decl) = TREE_ADDRESSABLE (type);
   DECL_RESULT (decl) = result_decl;
 
+  /* Propagate the "const" property.  */
   TREE_READONLY (decl) = TYPE_READONLY (type);
-  TREE_SIDE_EFFECTS (decl) = TREE_THIS_VOLATILE (decl) = TYPE_VOLATILE (type);
 
+  /* Propagate the "noreturn" property.  */
+  TREE_THIS_VOLATILE (decl) = TYPE_VOLATILE (type);
+
   if (asm_name)
     {
       /* Let the target mangle the name if this isn't a verbatim asm.  */
@@ -4543,9 +4546,12 @@
 					   etype)))
     return build1 (VIEW_CONVERT_EXPR, type, expr);
 
-  /* If we are converting between tagged types, try to upcast properly.  */
+  /* If we are converting between tagged types, try to upcast properly.
+     But don't do it if we are just annotating types since tagged types
+     aren't fully laid out in this mode.  */
   else if (ecode == RECORD_TYPE && code == RECORD_TYPE
-	   && TYPE_ALIGN_OK (etype) && TYPE_ALIGN_OK (type))
+	   && TYPE_ALIGN_OK (etype) && TYPE_ALIGN_OK (type)
+	   && !type_annotate_only)
     {
       tree child_etype = etype;
       do {
@@ -6113,8 +6119,7 @@
 	   && TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE)
     TREE_TYPE (*node)
       = build_pointer_type
-	(build_type_variant (TREE_TYPE (type),
-			     TYPE_READONLY (TREE_TYPE (type)), 1));
+	(change_qualified_type (TREE_TYPE (type), TYPE_QUAL_VOLATILE));
   else
     {
       warning (OPT_Wattributes, "%qs attribute ignored",
Index: gcc/ada/gcc-interface/Makefile.in
===================================================================
diff --git a/gcc/ada/gcc-interface/Makefile.in b/gcc/ada/gcc-interface/Makefile.in
--- a/gcc/ada/gcc-interface/Makefile.in	(revision 262353)
+++ b/gcc/ada/gcc-interface/Makefile.in	(revision 262353)
@@ -2756,9 +2756,9 @@
 # ada/types.h does not conflict with a same-named system header (VxWorks
 # has a <types.h> header).
 
-OSCONS_CPP=$(OSCONS_CC) $(GNATLIBCFLAGS) $(GNATLIBCFLAGS_FOR_C) -E -C \
+OSCONS_CPP=$(OSCONS_CC) $(GNATLIBCFLAGS_FOR_C) -E -C \
   -DTARGET=\"$(target)\" -iquote $(fsrcpfx)ada $(fsrcpfx)ada/s-oscons-tmplt.c > s-oscons-tmplt.i
-OSCONS_EXTRACT=$(OSCONS_CC) -S s-oscons-tmplt.i
+OSCONS_EXTRACT=$(OSCONS_CC) $(GNATLIBCFLAGS_FOR_C) -S s-oscons-tmplt.i
 
 # Note: if you need to build with a non-GNU compiler, you could adapt the
 # following definitions (written for VMS DEC-C)
Index: gcc/ada/gcc-interface/decl.c
===================================================================
diff --git a/gcc/ada/gcc-interface/decl.c b/gcc/ada/gcc-interface/decl.c
--- a/gcc/ada/gcc-interface/decl.c	(revision 262353)
+++ b/gcc/ada/gcc-interface/decl.c	(revision 262353)
@@ -206,7 +206,6 @@
 static tree gnat_to_gnu_subprog_type (Entity_Id, bool, bool, tree *);
 static tree gnat_to_gnu_field (Entity_Id, tree, int, bool, bool);
 static tree gnu_ext_name_for_subprog (Entity_Id, tree);
-static tree change_qualified_type (tree, int);
 static void set_nonaliased_component_on_array_type (tree);
 static void set_reverse_storage_order_on_array_type (tree);
 static bool same_discriminant_p (Entity_Id, Entity_Id);
@@ -592,17 +591,22 @@
       /* If we have a constant that we are not defining, get the expression it
 	 was defined to represent.  This is necessary to avoid generating dumb
 	 elaboration code in simple cases, but we may throw it away later if it
-	 is not a constant.  But do not retrieve it if it is an allocator since
-	 the designated type might still be dummy at this point.  */
+	 is not a constant.  But do not do it for dispatch tables because they
+	 are only referenced indirectly and we need to have a consistent view
+	 of the exported and of the imported declarations of the tables from
+	 external units for them to be properly merged in LTO mode.  Moreover
+	 simply do not retrieve the expression it if it is an allocator since
+	 the designated type might still be dummy at this point.  Note that we
+	 invoke gnat_to_gnu_external and not gnat_to_gnu because the expression
+	 may contain N_Expression_With_Actions nodes and thus declarations of
+	 objects from other units that we need to discard.  */
       if (!definition
 	  && !No_Initialization (Declaration_Node (gnat_entity))
-	  && Present (Expression (Declaration_Node (gnat_entity)))
-	  && Nkind (Expression (Declaration_Node (gnat_entity)))
-	     != N_Allocator)
-	  /* The expression may contain N_Expression_With_Actions nodes and
-	     thus object declarations from other units.  Discard them.  */
-	gnu_expr
-	  = gnat_to_gnu_external (Expression (Declaration_Node (gnat_entity)));
+	  && !Is_Dispatch_Table_Entity (gnat_entity)
+	  && Present (gnat_temp = Expression (Declaration_Node (gnat_entity)))
+	  && Nkind (gnat_temp) != N_Allocator
+	  && (!type_annotate_only || Compile_Time_Known_Value (gnat_temp)))
+	gnu_expr = gnat_to_gnu_external (gnat_temp);
 
       /* ... fall through ... */
 
@@ -2063,11 +2067,16 @@
 	  {
 	    gnu_fat_type = TYPE_MAIN_VARIANT (TYPE_POINTER_TO (gnu_type));
 	    TYPE_NAME (gnu_fat_type) = NULL_TREE;
+	    gnu_ptr_template =
+	      TREE_TYPE (DECL_CHAIN (TYPE_FIELDS (gnu_fat_type)));
+	    gnu_template_type = TREE_TYPE (gnu_ptr_template);
+
 	    /* Save the contents of the dummy type for update_pointer_to.  */
 	    TYPE_POINTER_TO (gnu_type) = copy_type (gnu_fat_type);
-	    gnu_ptr_template =
-	      TREE_TYPE (TREE_CHAIN (TYPE_FIELDS (gnu_fat_type)));
-	    gnu_template_type = TREE_TYPE (gnu_ptr_template);
+	    TYPE_FIELDS (TYPE_POINTER_TO (gnu_type))
+	      = copy_node (TYPE_FIELDS (gnu_fat_type));
+	    DECL_CHAIN (TYPE_FIELDS (TYPE_POINTER_TO (gnu_type)))
+	      = copy_node (DECL_CHAIN (TYPE_FIELDS (gnu_fat_type)));
 	  }
 	else
 	  {
@@ -2088,29 +2097,39 @@
 
 	/* Build the fat pointer type.  Use a "void *" object instead of
 	   a pointer to the array type since we don't have the array type
-	   yet (it will reference the fat pointer via the bounds).  */
-	tem
-	  = create_field_decl (get_identifier ("P_ARRAY"), ptr_type_node,
-			       gnu_fat_type, NULL_TREE, NULL_TREE, 0, 0);
-	DECL_CHAIN (tem)
-	  = create_field_decl (get_identifier ("P_BOUNDS"), gnu_ptr_template,
-			       gnu_fat_type, NULL_TREE, NULL_TREE, 0, 0);
+	   yet (it will reference the fat pointer via the bounds).  Note
+	   that we reuse the existing fields of a dummy type because for:
 
+	     type Arr is array (Positive range <>) of Element_Type;
+	     type Array_Ref is access Arr;
+	     Var : Array_Ref := Null;
+
+	   in a declarative part, Arr will be frozen only after Var, which
+	   means that the fields used in the CONSTRUCTOR built for Null are
+	   those of the dummy type, which in turn means that COMPONENT_REFs
+	   of Var may be built with these fields.  Now if COMPONENT_REFs of
+	   Var are also built later with the fields of the final type, the
+	   aliasing machinery may consider that the accesses are distinct
+	   if the FIELD_DECLs are distinct as objects.  */
 	if (COMPLETE_TYPE_P (gnu_fat_type))
 	  {
-	    /* We are going to lay it out again so reset the alias set.  */
-	    alias_set_type alias_set = TYPE_ALIAS_SET (gnu_fat_type);
-	    TYPE_ALIAS_SET (gnu_fat_type) = -1;
-	    finish_fat_pointer_type (gnu_fat_type, tem);
-	    TYPE_ALIAS_SET (gnu_fat_type) = alias_set;
+	    tem = TYPE_FIELDS (gnu_fat_type);
+	    TREE_TYPE (tem) = ptr_type_node;
+	    TREE_TYPE (DECL_CHAIN (tem)) = gnu_ptr_template;
+	    TYPE_DECL_SUPPRESS_DEBUG (TYPE_STUB_DECL (gnu_fat_type)) = 0;
 	    for (t = gnu_fat_type; t; t = TYPE_NEXT_VARIANT (t))
-	      {
-		TYPE_FIELDS (t) = tem;
-		SET_TYPE_UNCONSTRAINED_ARRAY (t, gnu_type);
-	      }
+	      SET_TYPE_UNCONSTRAINED_ARRAY (t, gnu_type);
 	  }
 	else
 	  {
+	    tem
+	      = create_field_decl (get_identifier ("P_ARRAY"),
+				   ptr_type_node, gnu_fat_type,
+				   NULL_TREE, NULL_TREE, 0, 0);
+	    DECL_CHAIN (tem)
+	      = create_field_decl (get_identifier ("P_BOUNDS"),
+				   gnu_ptr_template, gnu_fat_type,
+				   NULL_TREE, NULL_TREE, 0, 0);
 	    finish_fat_pointer_type (gnu_fat_type, tem);
 	    SET_TYPE_UNCONSTRAINED_ARRAY (gnu_fat_type, gnu_type);
 	  }
@@ -3389,20 +3408,6 @@
 	      break;
 	    }
 
-	  /* If this is a record subtype associated with a dispatch table,
-	     strip the suffix.  This is necessary to make sure 2 different
-	     subtypes associated with the imported and exported views of a
-	     dispatch table are properly merged in LTO mode.  */
-	  if (Is_Dispatch_Table_Entity (gnat_entity))
-	    {
-	      char *p;
-	      Get_Encoded_Name (gnat_entity);
-	      p = strchr (Name_Buffer, '_');
-	      gcc_assert (p);
-	      strcpy (p+2, "dtS");
-	      gnu_entity_name = get_identifier (Name_Buffer);
-	    }
-
 	  /* When the subtype has discriminants and these discriminants affect
 	     the initial shape it has inherited, factor them in.  But for an
 	     Unchecked_Union (it must be an Itype), just return the type.
@@ -4681,7 +4686,7 @@
       /* If this is not an unconstrained array type, set some flags.  */
       if (TREE_CODE (gnu_type) != UNCONSTRAINED_ARRAY_TYPE)
 	{
-	  /* Tell the middle-end that objects of tagged types are guaranteed to
+	  /* Record the property that objects of tagged types are guaranteed to
 	     be properly aligned.  This is necessary because conversions to the
 	     class-wide type are translated into conversions to the root type,
 	     which can be less aligned than some of its derived types.  */
@@ -5272,17 +5277,6 @@
 		     Is_Bit_Packed_Array (gnat_array) ? TYPE_DECL : VAR_DECL,
 		     true, Has_Component_Size_Clause (gnat_array));
 
-  /* If the array has aliased components and the component size can be zero,
-     force at least unit size to ensure that the components have distinct
-     addresses.  */
-  if (!gnu_comp_size
-      && Has_Aliased_Components (gnat_array)
-      && (integer_zerop (TYPE_SIZE (gnu_type))
-	  || (TREE_CODE (gnu_type) == ARRAY_TYPE
-	      && !TREE_CONSTANT (TYPE_SIZE (gnu_type)))))
-    gnu_comp_size
-      = size_binop (MAX_EXPR, TYPE_SIZE (gnu_type), bitsize_unit_node);
-
   /* If the component type is a RECORD_TYPE that has a self-referential size,
      then use the maximum size for the component size.  */
   if (!gnu_comp_size
@@ -5290,6 +5284,13 @@
       && CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_type)))
     gnu_comp_size = max_size (TYPE_SIZE (gnu_type), true);
 
+  /* If the array has aliased components and the component size is zero, force
+     the unit size to ensure that the components have distinct addresses.  */
+  if (!gnu_comp_size
+      && Has_Aliased_Components (gnat_array)
+      && integer_zerop (TYPE_SIZE (gnu_type)))
+    gnu_comp_size = bitsize_unit_node;
+
   /* Honor the component size.  This is not needed for bit-packed arrays.  */
   if (gnu_comp_size && !Is_Bit_Packed_Array (gnat_array))
     {
@@ -5312,6 +5313,30 @@
 			  gnat_array);
     }
 
+  /* This is a very special case where the array has aliased components and the
+     component size might be zero at run time.  As explained above, we force at
+     least the unit size but we don't want to build a distinct padding type for
+     each invocation (they are not canonicalized if they have variable size) so
+     we cache this special padding type as TYPE_PADDING_FOR_COMPONENT.  */
+  else if (Has_Aliased_Components (gnat_array)
+	   && TREE_CODE (gnu_type) == ARRAY_TYPE
+	   && !TREE_CONSTANT (TYPE_SIZE (gnu_type)))
+    {
+      if (TYPE_PADDING_FOR_COMPONENT (gnu_type))
+	gnu_type = TYPE_PADDING_FOR_COMPONENT (gnu_type);
+      else
+	{
+	  gnu_comp_size
+	    = size_binop (MAX_EXPR, TYPE_SIZE (gnu_type), bitsize_unit_node);
+	  TYPE_PADDING_FOR_COMPONENT (gnu_type)
+	    = maybe_pad_type (gnu_type, gnu_comp_size, 0, gnat_array,
+			      true, false, definition, true);
+	  gnu_type = TYPE_PADDING_FOR_COMPONENT (gnu_type);
+	  create_type_decl (TYPE_NAME (gnu_type), gnu_type, true, debug_info_p,
+			    gnat_array);
+	}
+    }
+
   /* If the component type is a padded type made for a non-bit-packed array
      of scalars with reverse storage order, we need to propagate the reverse
      storage order to the padding type since it is the innermost enclosing
@@ -6276,19 +6301,6 @@
   return gnu_ext_name;
 }
 
-/* Like build_qualified_type, but TYPE_QUALS is added to the existing
-   qualifiers on TYPE.  */
-
-static tree
-change_qualified_type (tree type, int type_quals)
-{
-  /* Qualifiers must be put on the associated array type.  */
-  if (TREE_CODE (type) == UNCONSTRAINED_ARRAY_TYPE)
-    return type;
-
-  return build_qualified_type (type, TYPE_QUALS (type) | type_quals);
-}
-
 /* Set TYPE_NONALIASED_COMPONENT on an array type built by means of
    build_nonshared_array_type.  */
 
Index: gcc/ada/gcc-interface/gigi.h
===================================================================
diff --git a/gcc/ada/gcc-interface/gigi.h b/gcc/ada/gcc-interface/gigi.h
--- a/gcc/ada/gcc-interface/gigi.h	(revision 262353)
+++ b/gcc/ada/gcc-interface/gigi.h	(revision 262353)
@@ -1074,7 +1074,7 @@
 static inline unsigned HOST_WIDE_INT
 ceil_pow2 (unsigned HOST_WIDE_INT x)
 {
-  return (unsigned HOST_WIDE_INT) 1 << (floor_log2 (x - 1) + 1);
+  return (unsigned HOST_WIDE_INT) 1 << ceil_log2 (x);
 }
 
 /* Return true if EXP, a CALL_EXPR, is an atomic load.  */
@@ -1171,3 +1171,16 @@
 
   return type;
 }
+
+/* Like build_qualified_type, but TYPE_QUALS is added to the existing
+   qualifiers on TYPE.  */
+
+static inline tree
+change_qualified_type (tree type, int type_quals)
+{
+  /* Qualifiers must be put on the associated array type.  */
+  if (TREE_CODE (type) == UNCONSTRAINED_ARRAY_TYPE)
+    return type;
+
+  return build_qualified_type (type, TYPE_QUALS (type) | type_quals);
+}
Index: gcc/ada/gcc-interface/ada-tree.h
===================================================================
diff --git a/gcc/ada/gcc-interface/ada-tree.h b/gcc/ada/gcc-interface/ada-tree.h
--- a/gcc/ada/gcc-interface/ada-tree.h	(revision 262353)
+++ b/gcc/ada/gcc-interface/ada-tree.h	(revision 262353)
@@ -6,7 +6,7 @@
  *                                                                          *
  *                              C Header File                               *
  *                                                                          *
- *          Copyright (C) 1992-2016, Free Software Foundation, Inc.         *
+ *          Copyright (C) 1992-2018, Free Software Foundation, Inc.         *
  *                                                                          *
  * GNAT is free software;  you can  redistribute it  and/or modify it under *
  * terms of the  GNU General Public License as published  by the Free Soft- *
@@ -83,6 +83,12 @@
   ((TREE_CODE (NODE) == INTEGER_TYPE || TREE_CODE (NODE) == ARRAY_TYPE) \
    && TYPE_PACKED_ARRAY_TYPE_P (NODE))
 
+/* For FUNCTION_TYPEs, nonzero if the function returns by direct reference,
+   i.e. the callee returns a pointer to a memory location it has allocated
+   and the caller only needs to dereference the pointer.  */
+#define TYPE_RETURN_BY_DIRECT_REF_P(NODE) \
+  TYPE_LANG_FLAG_0 (FUNCTION_TYPE_CHECK (NODE))
+
 /* For INTEGER_TYPE, nonzero if this is a modular type with a modulus that
    is not equal to two to the power of its mode's size.  */
 #define TYPE_MODULAR_P(NODE) TYPE_LANG_FLAG_1 (INTEGER_TYPE_CHECK (NODE))
@@ -152,12 +158,6 @@
 #define TYPE_CONVENTION_FORTRAN_P(NODE) \
   TYPE_LANG_FLAG_4 (ARRAY_TYPE_CHECK (NODE))
 
-/* For FUNCTION_TYPEs, nonzero if the function returns by direct reference,
-   i.e. the callee returns a pointer to a memory location it has allocated
-   and the caller only needs to dereference the pointer.  */
-#define TYPE_RETURN_BY_DIRECT_REF_P(NODE) \
-  TYPE_LANG_FLAG_4 (FUNCTION_TYPE_CHECK (NODE))
-
 /* For RECORD_TYPE, UNION_TYPE and ENUMERAL_TYPE, nonzero if this is a dummy
    type, made to correspond to a private or incomplete type.  */
 #define TYPE_DUMMY_P(NODE) \
@@ -186,6 +186,9 @@
 /* True for a dummy type if TYPE appears in a profile.  */
 #define TYPE_DUMMY_IN_PROFILE_P(NODE) TYPE_LANG_FLAG_6 (NODE)
 
+/* True if objects of this type are guaranteed to be properly aligned.  */
+#define TYPE_ALIGN_OK(NODE) TYPE_LANG_FLAG_7 (NODE)
+
 /* True for types that implement a packed array and for original packed array
    types.  */
 #define TYPE_IMPL_PACKED_ARRAY_P(NODE) \
@@ -199,9 +202,6 @@
    alignment value the type ought to have.  */
 #define TYPE_MAX_ALIGN(NODE) (TYPE_PRECISION (RECORD_OR_UNION_CHECK (NODE)))
 
-/* True if objects of tagged types are guaranteed to be properly aligned.  */
-#define TYPE_ALIGN_OK(NODE) TYPE_LANG_FLAG_7 (NODE)
-
 /* For an UNCONSTRAINED_ARRAY_TYPE, this is the record containing both the
    template and the object.
 
@@ -232,6 +232,11 @@
    refer to the routine gnat_to_gnu_entity.  */
 #define TYPE_CI_CO_LIST(NODE) TYPE_LANG_SLOT_1 (FUNCTION_TYPE_CHECK (NODE))
 
+/* For an ARRAY_TYPE with variable size, this is the padding type built for
+   the array type when it is itself the component type of another array.  */
+#define TYPE_PADDING_FOR_COMPONENT(NODE) \
+  TYPE_LANG_SLOT_1 (ARRAY_TYPE_CHECK (NODE))
+
 /* For a VECTOR_TYPE, this is the representative array type.  */
 #define TYPE_REPRESENTATIVE_ARRAY(NODE) \
   TYPE_LANG_SLOT_1 (VECTOR_TYPE_CHECK (NODE))
Index: gcc/ada/gcc-interface/trans.c
===================================================================
diff --git a/gcc/ada/gcc-interface/trans.c b/gcc/ada/gcc-interface/trans.c
--- a/gcc/ada/gcc-interface/trans.c	(revision 262353)
+++ b/gcc/ada/gcc-interface/trans.c	(revision 262353)
@@ -4059,6 +4059,8 @@
     case N_Identifier:
     case N_Expanded_Name:
       gnat_entity = Entity (gnat_node);
+      if (!Is_Object (gnat_entity))
+	break;
       return Is_Volatile_Full_Access (gnat_entity)
 	     || Is_Volatile_Full_Access (Etype (gnat_entity));
 
@@ -4324,12 +4326,15 @@
 	  because we need to preserve the return value before copying back the
 	  parameters.
 
-       2. There is no target and the call is made for neither an object nor a
+       2. There is no target and the call is made for neither an object, nor a
 	  renaming declaration, nor a return statement, nor an allocator, and
 	  the return type has variable size because in this case the gimplifier
-	  cannot create the temporary, or more generally is simply an aggregate
-	  type, because the gimplifier would then create the temporary in the
-	  outermost scope instead of locally.
+	  cannot create the temporary, or more generally is an aggregate type,
+	  because the gimplifier would create the temporary in the outermost
+	  scope instead of locally.  But there is an exception for an allocator
+	  of an unconstrained record type with default discriminant because we
+	  allocate the actual size in this case, unlike the other 3 cases, so
+	  we need a temporary to fetch the discriminant and we create it here.
 
        3. There is a target and it is a slice or an array with fixed size,
 	  and the return type has variable size, because the gimplifier
@@ -4348,8 +4353,9 @@
 	      && Nkind (Parent (gnat_node)) != N_Object_Declaration
 	      && Nkind (Parent (gnat_node)) != N_Object_Renaming_Declaration
 	      && Nkind (Parent (gnat_node)) != N_Simple_Return_Statement
-	      && !(Nkind (Parent (gnat_node)) == N_Qualified_Expression
-		   && Nkind (Parent (Parent (gnat_node))) == N_Allocator)
+	      && (!(Nkind (Parent (gnat_node)) == N_Qualified_Expression
+		    && Nkind (Parent (Parent (gnat_node))) == N_Allocator)
+		  || type_is_padding_self_referential (gnu_result_type))
 	      && AGGREGATE_TYPE_P (gnu_result_type)
 	      && !TYPE_IS_FAT_POINTER_P (gnu_result_type))
 	  || (gnu_target
@@ -9272,7 +9278,7 @@
 	  ? tree_int_cst_lt (gnu_out_ub, gnu_in_ub)
 	  : (FLOAT_TYPE_P (gnu_base_type)
 	     ? real_less (&TREE_REAL_CST (gnu_out_ub),
-			  &TREE_REAL_CST (gnu_in_lb))
+			  &TREE_REAL_CST (gnu_in_ub))
 	     : 1))
 	gnu_cond
 	  = build_binary_op (TRUTH_ORIF_EXPR, boolean_type_node, gnu_cond,
Index: gcc/ada/gcc-interface/misc.c
===================================================================
diff --git a/gcc/ada/gcc-interface/misc.c b/gcc/ada/gcc-interface/misc.c
--- a/gcc/ada/gcc-interface/misc.c	(revision 262353)
+++ b/gcc/ada/gcc-interface/misc.c	(revision 262353)
@@ -262,6 +262,9 @@
   /* No psABI change warnings for Ada.  */
   warn_psabi = 0;
 
+  /* No string overflow warnings for Ada.  */
+  warn_stringop_overflow = 0;
+
   /* No caret by default for Ada.  */
   if (!global_options_set.x_flag_diagnostics_show_caret)
     global_dc->show_caret = false;
Index: gcc/dse.c
===================================================================
diff --git a/gcc/dse.c b/gcc/dse.c
--- a/gcc/dse.c	(revision 262353)
+++ b/gcc/dse.c	(revision 262353)
@@ -1342,6 +1342,9 @@
   else
     width = GET_MODE_SIZE (GET_MODE (mem));
 
+  if (width == 0)
+    return 0;
+
   if (group_id >= 0)
     {
       /* In the restrictive case where the base is a constant or the
Index: gcc/gimple-ssa-strength-reduction.c
===================================================================
diff --git a/gcc/gimple-ssa-strength-reduction.c b/gcc/gimple-ssa-strength-reduction.c
--- a/gcc/gimple-ssa-strength-reduction.c	(revision 262353)
+++ b/gcc/gimple-ssa-strength-reduction.c	(revision 262353)
@@ -55,6 +55,7 @@
 #include "params.h"
 #include "tree-ssa-address.h"
 #include "tree-affine.h"
+#include "tree-eh.h"
 #include "builtins.h"
 
 /* Information about a strength reduction candidate.  Each statement
@@ -265,6 +266,10 @@
      of a statement.  */
   cand_idx next_interp;
 
+  /* Index of the first candidate record in a chain for the same
+     statement.  */
+  cand_idx first_interp;
+
   /* Index of the basis statement S0, if any, in the candidate vector.  */
   cand_idx basis;
 
@@ -642,6 +647,7 @@
   c->kind = kind;
   c->cand_num = cand_vec.length () + 1;
   c->next_interp = 0;
+  c->first_interp = c->cand_num;
   c->dependent = 0;
   c->sibling = 0;
   c->def_phi = kind == CAND_MULT ? find_phi_def (base) : 0;
@@ -1212,6 +1218,7 @@
 	 is the stride and RHS2 is the base expression.  */
       c2 = create_mul_ssa_cand (gs, rhs2, rhs1, speed);
       c->next_interp = c2->cand_num;
+      c2->first_interp = c->cand_num;
     }
   else
     {
@@ -1449,7 +1456,10 @@
 	{
 	  c2 = create_add_ssa_cand (gs, rhs2, rhs1, false, speed);
 	  if (c)
-	    c->next_interp = c2->cand_num;
+	    {
+	      c->next_interp = c2->cand_num;
+	      c2->first_interp = c->cand_num;
+	    }
 	  else
 	    add_cand_for_stmt (gs, c2);
 	}
@@ -1572,6 +1582,8 @@
 
   if (base_cand && base_cand->kind != CAND_PHI)
     {
+      slsr_cand_t first_cand = NULL;
+
       while (base_cand)
 	{
 	  /* Propagate all data from the base candidate except the type,
@@ -1586,6 +1598,12 @@
 					 base_cand->index, base_cand->stride,
 					 ctype, base_cand->stride_type,
 					 savings);
+	  if (!first_cand)
+	    first_cand = c;
+
+	  if (first_cand != c)
+	    c->first_interp = first_cand->cand_num;
+
 	  if (base_cand->next_interp)
 	    base_cand = lookup_cand (base_cand->next_interp);
 	  else
@@ -1608,6 +1626,7 @@
       c2 = alloc_cand_and_find_basis (CAND_MULT, gs, rhs1, 0,
 				      integer_one_node, ctype, sizetype, 0);
       c->next_interp = c2->cand_num;
+      c2->first_interp = c->cand_num;
     }
 
   /* Add the first (or only) interpretation to the statement-candidate
@@ -1632,6 +1651,8 @@
 
   if (base_cand && base_cand->kind != CAND_PHI)
     {
+      slsr_cand_t first_cand = NULL;
+
       while (base_cand)
 	{
 	  /* Propagate all data from the base candidate.  */
@@ -1644,6 +1665,12 @@
 					 base_cand->index, base_cand->stride,
 					 base_cand->cand_type,
 					 base_cand->stride_type, savings);
+	  if (!first_cand)
+	    first_cand = c;
+
+	  if (first_cand != c)
+	    c->first_interp = first_cand->cand_num;
+
 	  if (base_cand->next_interp)
 	    base_cand = lookup_cand (base_cand->next_interp);
 	  else
@@ -1668,6 +1695,7 @@
 				      integer_one_node, TREE_TYPE (rhs1),
 				      sizetype, 0);
       c->next_interp = c2->cand_num;
+      c2->first_interp = c->cand_num;
     }
 
   /* Add the first (or only) interpretation to the statement-candidate
@@ -1699,6 +1727,9 @@
     {
       gimple *gs = gsi_stmt (gsi);
 
+      if (stmt_could_throw_p (gs))
+	continue;
+
       if (gimple_vuse (gs) && gimple_assign_single_p (gs))
 	slsr_process_ref (gs);
 
@@ -1835,8 +1866,9 @@
   print_generic_expr (dump_file, c->cand_type, 0);
   fprintf (dump_file, "\n     basis: %d  dependent: %d  sibling: %d\n",
 	   c->basis, c->dependent, c->sibling);
-  fprintf (dump_file, "     next-interp: %d  dead-savings: %d\n",
-	   c->next_interp, c->dead_savings);
+  fprintf (dump_file,
+	   "     next-interp: %d  first-interp: %d  dead-savings: %d\n",
+	   c->next_interp, c->first_interp, c->dead_savings);
   if (c->def_phi)
     fprintf (dump_file, "     phi:  %d\n", c->def_phi);
   fputs ("\n", dump_file);
@@ -2094,14 +2126,13 @@
       tree lhs = gimple_assign_lhs (c->cand_stmt);
       gassign *copy_stmt = gimple_build_assign (lhs, basis_name);
       gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);
-      slsr_cand_t cc = c;
+      slsr_cand_t cc = lookup_cand (c->first_interp);
       gimple_set_location (copy_stmt, gimple_location (c->cand_stmt));
       gsi_replace (&gsi, copy_stmt, false);
-      c->cand_stmt = copy_stmt;
-      while (cc->next_interp)
+      while (cc)
 	{
-	  cc = lookup_cand (cc->next_interp);
 	  cc->cand_stmt = copy_stmt;
+	  cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;
 	}
       if (dump_file && (dump_flags & TDF_DETAILS))
 	stmt_to_print = copy_stmt;
@@ -2128,15 +2159,14 @@
       else
 	{
 	  gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);
-	  slsr_cand_t cc = c;
+	  slsr_cand_t cc = lookup_cand (c->first_interp);
 	  gimple_assign_set_rhs_with_ops (&gsi, code,
 					  basis_name, bump_tree);
 	  update_stmt (gsi_stmt (gsi));
-	  c->cand_stmt = gsi_stmt (gsi);
-	  while (cc->next_interp)
+	  while (cc)
 	    {
-	      cc = lookup_cand (cc->next_interp);
 	      cc->cand_stmt = gsi_stmt (gsi);
+	      cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;
 	    }
 	  if (dump_file && (dump_flags & TDF_DETAILS))
 	    stmt_to_print = gsi_stmt (gsi);
@@ -3422,14 +3452,13 @@
 	      || !operand_equal_p (new_rhs2, old_rhs1, 0))))
     {
       gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);
-      slsr_cand_t cc = c;
+      slsr_cand_t cc = lookup_cand (c->first_interp);
       gimple_assign_set_rhs_with_ops (&gsi, new_code, new_rhs1, new_rhs2);
       update_stmt (gsi_stmt (gsi));
-      c->cand_stmt = gsi_stmt (gsi);
-      while (cc->next_interp)
+      while (cc)
 	{
-	  cc = lookup_cand (cc->next_interp);
 	  cc->cand_stmt = gsi_stmt (gsi);
+	  cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;
 	}
 
       if (dump_file && (dump_flags & TDF_DETAILS))
@@ -3462,6 +3491,11 @@
   orig_rhs2 = gimple_assign_rhs2 (c->cand_stmt);
   cand_incr = cand_increment (c);
 
+  /* If orig_rhs2 is NULL, we have already replaced this in situ with
+     a copy statement under another interpretation.  */
+  if (!orig_rhs2)
+    return;
+
   if (dump_file && (dump_flags & TDF_DETAILS))
     {
       fputs ("Replacing: ", dump_file);
@@ -3534,14 +3568,13 @@
 	  || !operand_equal_p (rhs2, orig_rhs2, 0))
 	{
 	  gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);
-	  slsr_cand_t cc = c;
+	  slsr_cand_t cc = lookup_cand (c->first_interp);
 	  gimple_assign_set_rhs_with_ops (&gsi, MINUS_EXPR, basis_name, rhs2);
 	  update_stmt (gsi_stmt (gsi));
-          c->cand_stmt = gsi_stmt (gsi);
-	  while (cc->next_interp)
+	  while (cc)
 	    {
-	      cc = lookup_cand (cc->next_interp);
 	      cc->cand_stmt = gsi_stmt (gsi);
+	      cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;
 	    }
 
 	  if (dump_file && (dump_flags & TDF_DETAILS))
@@ -3561,14 +3594,13 @@
 	{
 	  gassign *copy_stmt = gimple_build_assign (lhs, basis_name);
 	  gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);
-	  slsr_cand_t cc = c;
+	  slsr_cand_t cc = lookup_cand (c->first_interp);
 	  gimple_set_location (copy_stmt, gimple_location (c->cand_stmt));
 	  gsi_replace (&gsi, copy_stmt, false);
-	  c->cand_stmt = copy_stmt;
-	  while (cc->next_interp)
+	  while (cc)
 	    {
-	      cc = lookup_cand (cc->next_interp);
 	      cc->cand_stmt = copy_stmt;
+	      cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;
 	    }
 
 	  if (dump_file && (dump_flags & TDF_DETAILS))
@@ -3578,14 +3610,13 @@
 	{
 	  gimple_stmt_iterator gsi = gsi_for_stmt (c->cand_stmt);
 	  gassign *cast_stmt = gimple_build_assign (lhs, NOP_EXPR, basis_name);
-	  slsr_cand_t cc = c;
+	  slsr_cand_t cc = lookup_cand (c->first_interp);
 	  gimple_set_location (cast_stmt, gimple_location (c->cand_stmt));
 	  gsi_replace (&gsi, cast_stmt, false);
-	  c->cand_stmt = cast_stmt;
-	  while (cc->next_interp)
+	  while (cc)
 	    {
-	      cc = lookup_cand (cc->next_interp);
 	      cc->cand_stmt = cast_stmt;
+	      cc = cc->next_interp ? lookup_cand (cc->next_interp) : NULL;
 	    }
 
 	  if (dump_file && (dump_flags & TDF_DETAILS))
Index: gcc/tree-eh.c
===================================================================
diff --git a/gcc/tree-eh.c b/gcc/tree-eh.c
--- a/gcc/tree-eh.c	(revision 262353)
+++ b/gcc/tree-eh.c	(revision 262353)
@@ -44,6 +44,7 @@
 #include "cfgloop.h"
 #include "gimple-low.h"
 #include "asan.h"
+#include "gimplify.h"
 
 /* In some instances a tree and a gimple need to be stored in a same table,
    i.e. in hash tables. This is a structure to do this. */
@@ -2438,7 +2439,7 @@
     case ROUND_MOD_EXPR:
     case TRUNC_MOD_EXPR:
     case RDIV_EXPR:
-      if (honor_snans || honor_trapv)
+      if (honor_snans)
 	return true;
       if (fp_operation)
 	return flag_trapping_math;
@@ -2722,7 +2723,92 @@
     }
 }
 
+/* Return non-NULL if there is an integer operation with trapping overflow
+   we can rewrite into non-trapping.  Called via walk_tree from
+   rewrite_to_non_trapping_overflow.  */
 
+static tree
+find_trapping_overflow (tree *tp, int *walk_subtrees, void *data)
+{
+  if (EXPR_P (*tp)
+      && !operation_no_trapping_overflow (TREE_TYPE (*tp), TREE_CODE (*tp)))
+    return *tp;
+  if (IS_TYPE_OR_DECL_P (*tp)
+      || (TREE_CODE (*tp) == SAVE_EXPR && data == NULL))
+    *walk_subtrees = 0;
+  return NULL_TREE;
+}
+
+/* Rewrite selected operations into unsigned arithmetics, so that they
+   don't trap on overflow.  */
+
+static tree
+replace_trapping_overflow (tree *tp, int *walk_subtrees, void *data)
+{
+  if (find_trapping_overflow (tp, walk_subtrees, data))
+    {
+      tree type = TREE_TYPE (*tp);
+      tree utype = unsigned_type_for (type);
+      *walk_subtrees = 0;
+      int len = TREE_OPERAND_LENGTH (*tp);
+      for (int i = 0; i < len; ++i)
+	walk_tree (&TREE_OPERAND (*tp, i), replace_trapping_overflow,
+		   data, (hash_set<tree> *) data);
+
+      if (TREE_CODE (*tp) == ABS_EXPR)
+	{
+	  tree op = TREE_OPERAND (*tp, 0);
+	  op = save_expr (op);
+	  /* save_expr skips simple arithmetics, which is undesirable
+	     here, if it might trap due to flag_trapv.  We need to
+	     force a SAVE_EXPR in the COND_EXPR condition, to evaluate
+	     it before the comparison.  */
+	  if (EXPR_P (op)
+	      && TREE_CODE (op) != SAVE_EXPR
+	      && walk_tree (&op, find_trapping_overflow, NULL, NULL))
+	    {
+	      op = build1_loc (EXPR_LOCATION (op), SAVE_EXPR, type, op);
+	      TREE_SIDE_EFFECTS (op) = 1;
+	    }
+	  /* Change abs (op) to op < 0 ? -op : op and handle the NEGATE_EXPR
+	     like other signed integer trapping operations.  */
+	  tree cond = fold_build2 (LT_EXPR, boolean_type_node,
+				   op, build_int_cst (type, 0));
+	  tree neg = fold_build1 (NEGATE_EXPR, utype,
+				  fold_convert (utype, op));
+	  *tp = fold_build3 (COND_EXPR, type, cond,
+			     fold_convert (type, neg), op);
+	}
+      else
+	{
+	  TREE_TYPE (*tp) = utype;
+	  len = TREE_OPERAND_LENGTH (*tp);
+	  for (int i = 0; i < len; ++i)
+	    TREE_OPERAND (*tp, i)
+	      = fold_convert (utype, TREE_OPERAND (*tp, i));
+	  *tp = fold_convert (type, *tp);
+	}
+    }
+  return NULL_TREE;
+}
+
+/* If any subexpression of EXPR can trap due to -ftrapv, rewrite it
+   using unsigned arithmetics to avoid traps in it.  */
+
+tree
+rewrite_to_non_trapping_overflow (tree expr)
+{
+  if (!flag_trapv)
+    return expr;
+  hash_set<tree> pset;
+  if (!walk_tree (&expr, find_trapping_overflow, &pset, &pset))
+    return expr;
+  expr = unshare_expr (expr);
+  hash_set<tree> pset2;
+  walk_tree (&expr, replace_trapping_overflow, &pset2, &pset2);
+  return expr;
+}
+
 /* Helper for stmt_could_throw_p.  Return true if STMT (assumed to be a
    an assignment or a conditional) may throw.  */
 
Index: gcc/fortran/openmp.c
===================================================================
diff --git a/gcc/fortran/openmp.c b/gcc/fortran/openmp.c
--- a/gcc/fortran/openmp.c	(revision 262353)
+++ b/gcc/fortran/openmp.c	(revision 262353)
@@ -1312,23 +1312,21 @@
 	      else if (gfc_match_omp_variable_list (" val (",
 						    &c->lists[OMP_LIST_LINEAR],
 						    false, NULL, &head)
-		  == MATCH_YES)
+		       == MATCH_YES)
 		linear_op = OMP_LINEAR_VAL;
 	      else if (gfc_match_omp_variable_list (" uval (",
 						    &c->lists[OMP_LIST_LINEAR],
 						    false, NULL, &head)
-		  == MATCH_YES)
+		       == MATCH_YES)
 		linear_op = OMP_LINEAR_UVAL;
 	      else if (gfc_match_omp_variable_list ("",
 						    &c->lists[OMP_LIST_LINEAR],
 						    false, &end_colon, &head)
-		  == MATCH_YES)
+		       == MATCH_YES)
 		linear_op = OMP_LINEAR_DEFAULT;
 	      else
 		{
-		  gfc_free_omp_namelist (*head);
 		  gfc_current_locus = old_loc;
-		  *head = NULL;
 		  break;
 		}
 	      if (linear_op != OMP_LINEAR_DEFAULT)
@@ -5577,8 +5575,6 @@
 			     "iteration space at %L", name, &do_code->loc);
 		  break;
 		}
-	      if (j < i)
-		break;
 	      do_code2 = do_code2->block->next;
 	    }
 	}
@@ -5742,12 +5738,10 @@
 		  || gfc_find_sym_in_expr (ivar, do_code->ext.iterator->end)
 		  || gfc_find_sym_in_expr (ivar, do_code->ext.iterator->step))
 		{
-		  gfc_error ("!$ACC LOOP %s loops don't form rectangular iteration space at %L",
-			     clause, &do_code->loc);
+		  gfc_error ("!$ACC LOOP %s loops don't form rectangular "
+			     "iteration space at %L", clause, &do_code->loc);
 		  break;
 		}
-	      if (j < i)
-		break;
 	      do_code2 = do_code2->block->next;
 	    }
 	}
Index: gcc/fortran/interface.c
===================================================================
diff --git a/gcc/fortran/interface.c b/gcc/fortran/interface.c
--- a/gcc/fortran/interface.c	(revision 262353)
+++ b/gcc/fortran/interface.c	(revision 262353)
@@ -1263,7 +1263,7 @@
 {
   gfc_array_spec *as = NULL;
 
-  if (sym->ts.type == BT_CLASS && CLASS_DATA (sym) && CLASS_DATA (sym)->as)
+  if (sym->ts.type == BT_CLASS && CLASS_DATA (sym))
     as = CLASS_DATA (sym)->as;
   else
     as = sym->as;
@@ -2791,7 +2791,8 @@
 
 static bool
 compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,
-	 	       int ranks_must_agree, int is_elemental, locus *where)
+	 	       int ranks_must_agree, int is_elemental,
+		       bool in_statement_function, locus *where)
 {
   gfc_actual_arglist **new_arg, *a, *actual;
   gfc_formal_arglist *f;
@@ -2820,6 +2821,13 @@
 
   for (a = actual; a; a = a->next, f = f->next)
     {
+      if (a->name != NULL && in_statement_function)
+	{
+	  gfc_error ("Keyword argument %qs at %L is invalid in "
+		     "a statement function", a->name, &a->expr->where);
+	  return false;
+	}
+
       /* Look for keywords but ignore g77 extensions like %VAL.  */
       if (a->name != NULL && a->name[0] != '%')
 	{
@@ -3143,8 +3151,9 @@
 	}
 
       /* Check intent = OUT/INOUT for definable actual argument.  */
-      if ((f->sym->attr.intent == INTENT_OUT
-	  || f->sym->attr.intent == INTENT_INOUT))
+      if (!in_statement_function
+	  && (f->sym->attr.intent == INTENT_OUT
+	      || f->sym->attr.intent == INTENT_INOUT))
 	{
 	  const char* context = (where
 				 ? _("actual argument to INTENT = OUT/INOUT")
@@ -3249,7 +3258,8 @@
 		       "at %L", where);
 	  return false;
 	}
-      if (!f->sym->attr.optional)
+      if (!f->sym->attr.optional
+	  || (in_statement_function && f->sym->attr.optional))
 	{
 	  if (where)
 	    gfc_error ("Missing actual argument for argument %qs at %L",
@@ -3535,6 +3545,7 @@
 bool
 gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)
 {
+  gfc_actual_arglist *a;
   gfc_formal_arglist *dummy_args;
 
   /* Warn about calls with an implicit interface.  Special case
@@ -3561,8 +3572,6 @@
 
   if (sym->attr.if_source == IFSRC_UNKNOWN)
     {
-      gfc_actual_arglist *a;
-
       if (sym->attr.pointer)
 	{
 	  gfc_error ("The pointer object %qs at %L must have an explicit "
@@ -3654,9 +3663,12 @@
 
   dummy_args = gfc_sym_get_dummy_args (sym);
 
-  if (!compare_actual_formal (ap, dummy_args, 0, sym->attr.elemental, where))
+  /* For a statement function, check that types and type parameters of actual
+     arguments and dummy arguments match.  */
+  if (!compare_actual_formal (ap, dummy_args, 0, sym->attr.elemental,
+			      sym->attr.proc == PROC_ST_FUNCTION, where))
     return false;
-
+ 
   if (!check_intents (dummy_args, *ap))
     return false;
 
@@ -3703,7 +3715,7 @@
     }
 
   if (!compare_actual_formal (ap, comp->ts.interface->formal, 0,
-			      comp->attr.elemental, where))
+			      comp->attr.elemental, false, where))
     return;
 
   check_intents (comp->ts.interface->formal, *ap);
@@ -3728,7 +3740,7 @@
   dummy_args = gfc_sym_get_dummy_args (sym);
 
   r = !sym->attr.elemental;
-  if (compare_actual_formal (args, dummy_args, r, !r, NULL))
+  if (compare_actual_formal (args, dummy_args, r, !r, false, NULL))
     {
       check_intents (dummy_args, *args);
       if (warn_aliasing)
Index: gcc/fortran/trans-expr.c
===================================================================
diff --git a/gcc/fortran/trans-expr.c b/gcc/fortran/trans-expr.c
--- a/gcc/fortran/trans-expr.c	(revision 262353)
+++ b/gcc/fortran/trans-expr.c	(revision 262353)
@@ -960,6 +960,7 @@
     }
 
   if ((ref == NULL || class_ref == ref)
+      && !(gfc_is_class_array_function (e) && parmse->class_vptr != NULL_TREE)
       && (!class_ts.u.derived->components->as
 	  || class_ts.u.derived->components->as->rank != -1))
     return;
@@ -1030,8 +1031,11 @@
      First we have to find the corresponding class reference.  */
 
   tmp = NULL_TREE;
-  if (class_ref == NULL
-	&& e->symtree && e->symtree->n.sym->ts.type == BT_CLASS)
+  if (gfc_is_class_array_function (e)
+      && parmse->class_vptr != NULL_TREE)
+    tmp = parmse->class_vptr;
+  else if (class_ref == NULL
+	   && e->symtree && e->symtree->n.sym->ts.type == BT_CLASS)
     {
       tmp = e->symtree->n.sym->backend_decl;
 
@@ -1063,7 +1067,11 @@
   if (TREE_CODE (TREE_TYPE (tmp)) == REFERENCE_TYPE)
     tmp = build_fold_indirect_ref_loc (input_location, tmp);
 
-  vptr = gfc_class_vptr_get (tmp);
+  if (!(gfc_is_class_array_function (e) && parmse->class_vptr))
+    vptr = gfc_class_vptr_get (tmp);
+  else
+    vptr = tmp;
+
   gfc_add_modify (&block, ctree,
 		  fold_convert (TREE_TYPE (ctree), vptr));
 
@@ -1148,15 +1156,32 @@
    of the referenced element.  */
 
 tree
-gfc_get_class_array_ref (tree index, tree class_decl, tree data_comp)
+gfc_get_class_array_ref (tree index, tree class_decl, tree data_comp,
+			 bool unlimited)
 {
-  tree data = data_comp != NULL_TREE ? data_comp :
-				       gfc_class_data_get (class_decl);
-  tree size = gfc_class_vtab_size_get (class_decl);
-  tree offset = fold_build2_loc (input_location, MULT_EXPR,
-				 gfc_array_index_type,
-				 index, size);
-  tree ptr;
+  tree data, size, tmp, ctmp, offset, ptr;
+
+  data = data_comp != NULL_TREE ? data_comp :
+				  gfc_class_data_get (class_decl);
+  size = gfc_class_vtab_size_get (class_decl);
+
+  if (unlimited)
+    {
+      tmp = fold_convert (gfc_array_index_type,
+			  gfc_class_len_get (class_decl));
+      ctmp = fold_build2_loc (input_location, MULT_EXPR,
+			      gfc_array_index_type, size, tmp);
+      tmp = fold_build2_loc (input_location, GT_EXPR,
+			     logical_type_node, tmp,
+			     build_zero_cst (TREE_TYPE (tmp)));
+      size = fold_build3_loc (input_location, COND_EXPR,
+			      gfc_array_index_type, tmp, ctmp, size);
+    }
+
+  offset = fold_build2_loc (input_location, MULT_EXPR,
+			    gfc_array_index_type,
+			    index, size);
+
   data = gfc_conv_descriptor_data_get (data);
   ptr = fold_convert (pvoid_type_node, data);
   ptr = fold_build_pointer_plus_loc (input_location, ptr, offset);
@@ -1258,7 +1283,8 @@
 
       if (is_from_desc)
 	{
-	  from_ref = gfc_get_class_array_ref (index, from, from_data);
+	  from_ref = gfc_get_class_array_ref (index, from, from_data,
+					      unlimited);
 	  vec_safe_push (args, from_ref);
 	}
       else
@@ -1265,7 +1291,7 @@
         vec_safe_push (args, from_data);
 
       if (is_to_class)
-	to_ref = gfc_get_class_array_ref (index, to, to_data);
+	to_ref = gfc_get_class_array_ref (index, to, to_data, unlimited);
       else
 	{
 	  tmp = gfc_conv_array_data (to);
@@ -4307,6 +4333,8 @@
 
       if (expr->value.function.esym == NULL
 	    && expr->value.function.isym != NULL
+	    && expr->value.function.actual
+	    && expr->value.function.actual->expr
 	    && expr->value.function.actual->expr->symtree
 	    && gfc_map_intrinsic_function (expr, mapping))
 	break;
@@ -4435,7 +4463,7 @@
   /* Reset the offset for the function call since the loop
      is zero based on the data pointer.  Note that the temp
      comes first in the loop chain since it is added second.  */
-  if (gfc_is_alloc_class_array_function (expr))
+  if (gfc_is_class_array_function (expr))
     {
       tmp = loop.ss->loop_chain->info->data.array.descriptor;
       gfc_conv_descriptor_offset_set (&loop.pre, tmp,
@@ -4484,7 +4512,7 @@
   dimen = rse.ss->dimen;
 
   /* Skip the write-out loop for this case.  */
-  if (gfc_is_alloc_class_array_function (expr))
+  if (gfc_is_class_array_function (expr))
     goto class_array_fcn;
 
   /* Calculate the bounds of the scalarization.  */
@@ -4778,7 +4806,7 @@
 	      gcc_assert ((!comp && gfc_return_by_reference (sym)
 			   && sym->result->attr.dimension)
 			  || (comp && comp->attr.dimension)
-			  || gfc_is_alloc_class_array_function (expr));
+			  || gfc_is_class_array_function (expr));
 	      gcc_assert (se->loop != NULL);
 	      /* Access the previously obtained result.  */
 	      gfc_conv_tmp_array_ref (se);
@@ -5461,7 +5489,7 @@
 				fsym ? fsym->attr.intent : INTENT_INOUT,
 				fsym && fsym->attr.pointer);
 
-	      else if (gfc_is_alloc_class_array_function (e)
+	      else if (gfc_is_class_array_function (e)
 			 && fsym && fsym->ts.type == BT_DERIVED)
 		/* See previous comment.  For function actual argument,
 		   the write out is not needed so the intent is set as
@@ -6302,7 +6330,7 @@
 	 call the finalization function of the temporary. Note that the
 	 nullification of allocatable components needed by the result
 	 is done in gfc_trans_assignment_1.  */
-      if (expr && ((gfc_is_alloc_class_array_function (expr)
+      if (expr && ((gfc_is_class_array_function (expr)
 		    && se->ss && se->ss->loop)
 		   || gfc_is_alloc_class_scalar_function (expr))
 	  && se->expr && GFC_CLASS_TYPE_P (TREE_TYPE (se->expr))
@@ -6313,6 +6341,7 @@
 	  int n;
 	  if (se->ss && se->ss->loop)
 	    {
+	      gfc_add_block_to_block (&se->ss->loop->pre, &se->pre);
 	      se->expr = gfc_evaluate_now (se->expr, &se->ss->loop->pre);
 	      tmp = gfc_class_data_get (se->expr);
 	      info->descriptor = tmp;
@@ -6335,6 +6364,11 @@
 			CLASS_DATA (expr->value.function.esym->result)->attr);
 	    }
 
+	  if ((gfc_is_class_array_function (expr)
+	       || gfc_is_alloc_class_scalar_function (expr))
+	      && CLASS_DATA (expr->value.function.esym->result)->attr.pointer)
+	    goto no_finalization;
+
 	  final_fndecl = gfc_class_vtab_final_get (se->expr);
 	  is_final = fold_build2_loc (input_location, NE_EXPR,
 				      logical_type_node,
@@ -6365,6 +6399,8 @@
 	      tmp = gfc_call_free (tmp);
 	      gfc_add_expr_to_block (&se->post, tmp);
 	    }
+
+no_finalization:
 	  expr->must_finalize = 0;
 	}
 
@@ -8835,7 +8871,7 @@
 	  gfc_add_expr_to_block (&block, tmp);
 	}
     }
-  else if (gfc_bt_struct (ts.type) || ts.type == BT_CLASS)
+  else if (gfc_bt_struct (ts.type) || ts.type == BT_CLASS || ts.type == BT_COMPLEX)
     {
       gfc_add_block_to_block (&block, &lse->pre);
       gfc_add_block_to_block (&block, &rse->pre);
@@ -8871,7 +8907,7 @@
   gfc_symbol *sym = expr1->symtree->n.sym;
 
   /* Play it safe with class functions assigned to a derived type.  */
-  if (gfc_is_alloc_class_array_function (expr2)
+  if (gfc_is_class_array_function (expr2)
       && expr1->ts.type == BT_DERIVED)
     return true;
 
@@ -9878,7 +9914,7 @@
   rss = NULL;
 
   if ((expr1->ts.type == BT_DERIVED)
-      && (gfc_is_alloc_class_array_function (expr2)
+      && (gfc_is_class_array_function (expr2)
 	  || gfc_is_alloc_class_scalar_function (expr2)))
     expr2->must_finalize = 1;
 
@@ -10085,7 +10121,7 @@
      a scalar to array assignment, this is done in gfc_trans_scalar_assign
      as part of the deep copy.  */
   if (!scalar_to_array && expr1->ts.type == BT_DERIVED
-		       && (gfc_is_alloc_class_array_function (expr2)
+		       && (gfc_is_class_array_function (expr2)
 			   || gfc_is_alloc_class_scalar_function (expr2)))
     {
       tmp = rse.expr;
@@ -10294,6 +10330,10 @@
 	return tmp;
     }
 
+  if (UNLIMITED_POLY (expr1) && expr1->rank
+      && expr2->ts.type != BT_CLASS)
+    use_vptr_copy = true;
+
   /* Fallback to the scalarizer to generate explicit loops.  */
   return gfc_trans_assignment_1 (expr1, expr2, init_flag, dealloc,
 				 use_vptr_copy, may_alias);
Index: gcc/fortran/trans-array.c
===================================================================
diff --git a/gcc/fortran/trans-array.c b/gcc/fortran/trans-array.c
--- a/gcc/fortran/trans-array.c	(revision 262353)
+++ b/gcc/fortran/trans-array.c	(revision 262353)
@@ -2652,6 +2652,8 @@
 	  gfc_init_se (&se, NULL);
 	  se.loop = loop;
 	  se.ss = ss;
+	  if (gfc_is_class_array_function (expr))
+	    expr->must_finalize = 1;
 	  gfc_conv_expr (&se, expr);
 	  gfc_add_block_to_block (&outer_loop->pre, &se.pre);
 	  gfc_add_block_to_block (&outer_loop->post, &se.post);
@@ -3071,7 +3073,7 @@
     }
 
   /* Multiply by the stride.  */
-  if (!integer_onep (stride))
+  if (stride != NULL && !integer_onep (stride))
     index = fold_build2_loc (input_location, MULT_EXPR, gfc_array_index_type,
 			     index, stride);
 
@@ -3102,7 +3104,7 @@
     {
       if (expr == NULL
 	  || (expr->ts.type != BT_CLASS
-	      && !gfc_is_alloc_class_array_function (expr)
+	      && !gfc_is_class_array_function (expr)
 	      && !gfc_is_class_array_ref (expr, NULL)))
 	return false;
 
@@ -3132,12 +3134,12 @@
     }
 
   if (class_ref == NULL && expr && expr->symtree->n.sym->attr.function
-      && expr->symtree->n.sym == expr->symtree->n.sym->result)
+      && expr->symtree->n.sym == expr->symtree->n.sym->result
+      && expr->symtree->n.sym->backend_decl == current_function_decl)
     {
-      gcc_assert (expr->symtree->n.sym->backend_decl == current_function_decl);
       decl = gfc_get_fake_result_decl (expr->symtree->n.sym, 0);
     }
-  else if (expr && gfc_is_alloc_class_array_function (expr))
+  else if (expr && gfc_is_class_array_function (expr))
     {
       size = NULL_TREE;
       decl = NULL_TREE;
@@ -3160,6 +3162,8 @@
 
       if (decl == NULL_TREE)
 	return false;
+
+      se->class_vptr = gfc_evaluate_now (gfc_class_vptr_get (decl), &se->pre);
     }
   else if (class_ref == NULL)
     {
@@ -3334,7 +3338,10 @@
     {
       type = gfc_get_element_type (type);
       tmp = TREE_OPERAND (cdecl, 0);
-      tmp = gfc_get_class_array_ref (offset, tmp, NULL_TREE);
+      /* Note that the fourth argument in this call has been set false.
+	 should any character dynamic types come this way, the 'len'
+	 field of the unlimited object will not be used.  */
+      tmp = gfc_get_class_array_ref (offset, tmp, NULL_TREE, false);
       tmp = fold_convert (build_pointer_type (type), tmp);
       tmp = build_fold_indirect_ref_loc (input_location, tmp);
       return tmp;
@@ -7125,7 +7132,11 @@
       else
 	{
 	  /* Otherwise make a new one.  */
-	  parmtype = gfc_get_element_type (TREE_TYPE (desc));
+	  if (expr->ts.type == BT_CHARACTER && expr->ts.deferred)
+	    parmtype = gfc_typenode_for_spec (&expr->ts);
+	  else
+	    parmtype = gfc_get_element_type (TREE_TYPE (desc));
+
 	  parmtype = gfc_get_array_type_bounds (parmtype, loop.dimen, codim,
 						loop.from, loop.to, 0,
 						GFC_ARRAY_UNKNOWN, false);
@@ -8598,7 +8609,7 @@
 	  break;
 
 	case COPY_ALLOC_COMP:
-	  if (c->attr.pointer)
+	  if (c->attr.pointer || c->attr.proc_pointer)
 	    continue;
 
 	  /* We need source and destination components.  */
@@ -8642,6 +8653,31 @@
 
 	      gfc_init_block (&tmpblock);
 
+	      gfc_add_modify (&tmpblock, gfc_class_vptr_get (dcmp),
+			      gfc_class_vptr_get (comp));
+
+	      /* Copy the unlimited '_len' field. If it is greater than zero
+		 (ie. a character(_len)), multiply it by size and use this
+		 for the malloc call.  */
+	      if (UNLIMITED_POLY (c))
+		{
+		  tree ctmp;
+		  gfc_add_modify (&tmpblock, gfc_class_len_get (dcmp),
+				  gfc_class_len_get (comp));
+
+		  size = gfc_evaluate_now (size, &tmpblock);
+		  tmp = gfc_class_len_get (comp);
+		  ctmp = fold_build2_loc (input_location, MULT_EXPR,
+					  size_type_node, size,
+					  fold_convert (size_type_node, tmp));
+		  tmp = fold_build2_loc (input_location, GT_EXPR,
+					 logical_type_node, tmp,
+					 build_zero_cst (TREE_TYPE (tmp)));
+		  size = fold_build3_loc (input_location, COND_EXPR,
+					  size_type_node, tmp, ctmp, size);
+		  size = gfc_evaluate_now (size, &tmpblock);
+		}
+
 	      /* Coarray component have to have the same allocation status and
 		 shape/type-parameter/effective-type on the LHS and RHS of an
 		 intrinsic assignment. Hence, we did not deallocated them - and
@@ -9096,6 +9132,12 @@
   if (expr2 && rss == gfc_ss_terminator)
     return NULL_TREE;
 
+  /* Ensure that the string length from the current scope is used.  */
+  if (expr2->ts.type == BT_CHARACTER
+      && expr2->expr_type == EXPR_FUNCTION
+      && !expr2->value.function.isym)
+    expr2->ts.u.cl->backend_decl = rss->info->string_length;
+
   gfc_start_block (&fblock);
 
   /* Since the lhs is allocatable, this must be a descriptor type.
@@ -9340,6 +9382,8 @@
 			     gfc_array_index_type, tmp,
 			     expr1->ts.u.cl->backend_decl);
     }
+  else if (UNLIMITED_POLY (expr1) && expr2->ts.type != BT_CLASS)
+    tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&expr2->ts));
   else
     tmp = TYPE_SIZE_UNIT (gfc_typenode_for_spec (&expr1->ts));
   tmp = fold_convert (gfc_array_index_type, tmp);
@@ -9366,6 +9410,28 @@
       gfc_add_modify (&fblock, tmp,
 		      gfc_get_dtype_rank_type (expr1->rank,type));
     }
+  else if (UNLIMITED_POLY (expr1) && expr2->ts.type != BT_CLASS)
+    {
+      tree type;
+      tmp = gfc_conv_descriptor_dtype (desc);
+      type = gfc_typenode_for_spec (&expr2->ts);
+      gfc_add_modify (&fblock, tmp,
+		      gfc_get_dtype_rank_type (expr2->rank,type));
+      /* Set the _len field as well...  */
+      tmp = gfc_class_len_get (TREE_OPERAND (desc, 0));
+      if (expr2->ts.type == BT_CHARACTER)
+	gfc_add_modify (&fblock, tmp,
+			fold_convert (TREE_TYPE (tmp),
+				      TYPE_SIZE_UNIT (type)));
+      else
+	gfc_add_modify (&fblock, tmp,
+			build_int_cst (TREE_TYPE (tmp), 0));
+      /* ...and the vptr.  */
+      tmp = gfc_class_vptr_get (TREE_OPERAND (desc, 0));
+      tmp2 = gfc_get_symbol_decl (gfc_find_vtab (&expr2->ts));
+      tmp2 = gfc_build_addr_expr (TREE_TYPE (tmp), tmp2);
+      gfc_add_modify (&fblock, tmp, tmp2);
+    }
   else if (coarray && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc)))
     {
       gfc_add_modify (&fblock, gfc_conv_descriptor_dtype (desc),
@@ -9471,10 +9537,11 @@
 
 
   /* We already set the dtype in the case of deferred character
-     length arrays.  */
+     length arrays and unlimited polymorphic arrays.  */
   if (!(GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc))
 	&& ((expr1->ts.type == BT_CHARACTER && expr1->ts.deferred)
-	    || coarray)))
+	    || coarray))
+      && !UNLIMITED_POLY (expr1))
     {
       tmp = gfc_conv_descriptor_dtype (desc);
       gfc_add_modify (&alloc_block, tmp, gfc_get_dtype (TREE_TYPE (desc)));
@@ -10007,7 +10074,7 @@
   if (!sym)
     sym = expr->symtree->n.sym;
 
-  if (gfc_is_alloc_class_array_function (expr))
+  if (gfc_is_class_array_function (expr))
     return gfc_get_array_ss (ss, expr,
 			     CLASS_DATA (expr->value.function.esym->result)->as->rank,
 			     GFC_SS_FUNCTION);
Index: gcc/fortran/symbol.c
===================================================================
diff --git a/gcc/fortran/symbol.c b/gcc/fortran/symbol.c
--- a/gcc/fortran/symbol.c	(revision 262353)
+++ b/gcc/fortran/symbol.c	(revision 262353)
@@ -1259,6 +1259,20 @@
 			 where))
       return false;
 
+  /* F2008:  C1282 A designator of a variable with the VOLATILE attribute
+     shall not appear in a pure subprogram.
+
+     F2018: C1588 A local variable of a pure subprogram, or of a BLOCK
+     construct within a pure subprogram, shall not have the SAVE or
+     VOLATILE attribute.  */
+  if (gfc_pure (NULL))
+    {
+      gfc_error ("VOLATILE attribute at %L cannot be specified in a "
+		 "PURE procedure", where);
+      return false;
+    }
+
+
   attr->volatile_ = 1;
   attr->volatile_ns = gfc_current_ns;
   return check_conflict (attr, name, where);
Index: gcc/fortran/decl.c
===================================================================
diff --git a/gcc/fortran/decl.c b/gcc/fortran/decl.c
--- a/gcc/fortran/decl.c	(revision 262353)
+++ b/gcc/fortran/decl.c	(revision 262353)
@@ -573,6 +573,20 @@
       if (m != MATCH_YES)
 	goto cleanup;
 
+      if (new_data->var->iter.var
+	  && new_data->var->iter.var->ts.type == BT_INTEGER
+	  && new_data->var->iter.var->symtree->n.sym->attr.implied_index == 1
+	  && new_data->var->list
+	  && new_data->var->list->expr
+	  && new_data->var->list->expr->ts.type == BT_CHARACTER
+	  && new_data->var->list->expr->ref
+	  && new_data->var->list->expr->ref->type == REF_SUBSTRING)
+	{
+	  gfc_error ("Invalid substring in data-implied-do at %L in DATA "
+		     "statement", &new_data->var->list->expr->where);
+	  goto cleanup;
+	}
+
       m = top_val_list (new_data);
       if (m != MATCH_YES)
 	goto cleanup;
@@ -1115,14 +1129,12 @@
   if (sym->attr.proc == PROC_ST_FUNCTION)
     return rc;
 
-  if (sym->attr.module_procedure
-      && sym->attr.if_source == IFSRC_IFBODY)
+  if (sym->attr.module_procedure && sym->attr.if_source == IFSRC_IFBODY)
     {
       /* Create a partially populated interface symbol to carry the
 	 characteristics of the procedure and the result.  */
       sym->tlink = gfc_new_symbol (name, sym->ns);
-      gfc_add_type (sym->tlink, &(sym->ts),
-		    &gfc_current_locus);
+      gfc_add_type (sym->tlink, &(sym->ts), &gfc_current_locus);
       gfc_copy_attr (&sym->tlink->attr, &sym->attr, NULL);
       if (sym->attr.dimension)
 	sym->tlink->as = gfc_copy_array_spec (sym->as);
@@ -1152,11 +1164,22 @@
 	 accessible names.  */
       if (sym->attr.flavor != 0
 	  && sym->attr.proc != 0
-	  && (sym->attr.subroutine || sym->attr.function)
+	  && (sym->attr.subroutine || sym->attr.function || sym->attr.entry)
 	  && sym->attr.if_source != IFSRC_UNKNOWN)
 	gfc_error_now ("Procedure %qs at %C is already defined at %L",
 		       name, &sym->declared_at);
 
+      if (sym->attr.flavor != 0
+	  && sym->attr.entry && sym->attr.if_source != IFSRC_UNKNOWN)
+	gfc_error_now ("Procedure %qs at %C is already defined at %L",
+		       name, &sym->declared_at);
+
+      if (sym->attr.external && sym->attr.procedure
+	  && gfc_current_state () == COMP_CONTAINS)
+	gfc_error_now ("Contained procedure %qs at %C clashes with "
+			"procedure defined at %L",
+		       name, &sym->declared_at);
+
       /* Trap a procedure with a name the same as interface in the
 	 encompassing scope.  */
       if (sym->attr.generic != 0
@@ -1176,7 +1199,16 @@
 	  && sym->attr.access == 0
 	  && !module_fcn_entry)
 	gfc_error_now ("Procedure %qs at %C has an explicit interface "
-		       "and must not have attributes declared at %L",
+		       "from a previous declaration",  name);
+    }
+
+    if (sym && !sym->gfc_new
+	&& sym->attr.flavor != FL_UNKNOWN
+	&& sym->attr.referenced == 0 && sym->attr.subroutine == 1
+	&& gfc_state_stack->state == COMP_CONTAINS
+	&& gfc_state_stack->previous->state == COMP_SUBROUTINE)
+    {
+	gfc_error_now ("Procedure %qs at %C is already defined at %L",
 		       name, &sym->declared_at);
     }
 
@@ -1201,10 +1233,10 @@
   /* See if the procedure should be a module procedure.  */
 
   if (((sym->ns->proc_name != NULL
-		&& sym->ns->proc_name->attr.flavor == FL_MODULE
-		&& sym->attr.proc != PROC_MODULE)
-	    || (module_fcn_entry && sym->attr.proc != PROC_MODULE))
-	&& !gfc_add_procedure (&sym->attr, PROC_MODULE, sym->name, NULL))
+	&& sym->ns->proc_name->attr.flavor == FL_MODULE
+	&& sym->attr.proc != PROC_MODULE)
+       || (module_fcn_entry && sym->attr.proc != PROC_MODULE))
+      && !gfc_add_procedure (&sym->attr, PROC_MODULE, sym->name, NULL))
     rc = 2;
 
   return rc;
@@ -2183,7 +2215,10 @@
   /* At this point, we know for sure if the symbol is PARAMETER and can thus
      determine (and check) whether it can be implied-shape.  If it
      was parsed as assumed-size, change it because PARAMETERs can not
-     be assumed-size.  */
+     be assumed-size.
+
+     An explicit-shape-array cannot appear under several conditions.
+     That check is done here as well.  */
   if (as)
     {
       if (as->type == AS_IMPLIED_SHAPE && current_attr.flavor != FL_PARAMETER)
@@ -2205,6 +2240,50 @@
 	  m = MATCH_ERROR;
 	  goto cleanup;
 	}
+
+      /* F2018:C830 (R816) An explicit-shape-spec whose bounds are not
+	 constant expressions shall appear only in a subprogram, derived
+	 type definition, BLOCK construct, or interface body.  */
+      if (as->type == AS_EXPLICIT
+	  && gfc_current_state () != COMP_BLOCK
+	  && gfc_current_state () != COMP_DERIVED
+	  && gfc_current_state () != COMP_FUNCTION
+	  && gfc_current_state () != COMP_INTERFACE
+	  && gfc_current_state () != COMP_SUBROUTINE)
+	{
+	  gfc_expr *e;
+	  bool not_constant = false;
+
+	  for (int i = 0; i < as->rank; i++)
+	    {
+	      e = gfc_copy_expr (as->lower[i]);
+	      gfc_resolve_expr (e);
+	      gfc_simplify_expr (e, 0);
+	      if (e && (e->expr_type != EXPR_CONSTANT))
+		{
+		  not_constant = true;
+		  break;
+		}
+	      gfc_free_expr (e);
+
+	      e = gfc_copy_expr (as->upper[i]);
+	      gfc_resolve_expr (e);
+	      gfc_simplify_expr (e, 0);
+	      if (e && (e->expr_type != EXPR_CONSTANT))
+		{
+		  not_constant = true;
+		  break;
+		}
+	      gfc_free_expr (e);
+	    }
+
+	  if (not_constant)
+	    { 
+	      gfc_error ("Explicit shaped array with nonconstant bounds at %C");
+	      m = MATCH_ERROR;
+	      goto cleanup;
+	    }
+	}
     }
 
   char_len = NULL;
@@ -2918,8 +2997,39 @@
   if (seen_length == 0)
     cl->length = gfc_get_int_expr (gfc_default_integer_kind, NULL, 1);
   else
-    cl->length = len;
+    {
+      /* If gfortran ends up here, then len may be reducible to a constant.
+	 Try to do that here.  If it does not reduce, simply assign len to
+	 charlen.  A complication occurs with user-defined generic functions,
+	 which are not resolved.  Use a private namespace to deal with
+	 generic functions.  */
 
+      if (len && len->expr_type != EXPR_CONSTANT)
+	{
+	  gfc_namespace *old_ns;
+	  gfc_expr *e;
+
+	  old_ns = gfc_current_ns;
+	  gfc_current_ns = gfc_get_namespace (NULL, 0);
+
+	  e = gfc_copy_expr (len);
+	  gfc_reduce_init_expr (e);
+	  if (e->expr_type == EXPR_CONSTANT)
+	    {
+	      gfc_replace_expr (len, e);
+	      if (mpz_cmp_si (len->value.integer, 0) < 0)
+		mpz_set_ui (len->value.integer, 0);
+	    }
+	  else
+	    gfc_free_expr (e);
+
+	  gfc_free_namespace (gfc_current_ns);
+	  gfc_current_ns = old_ns;
+	}
+
+      cl->length = len;
+    }
+
   ts->u.cl = cl;
   ts->kind = kind == 0 ? gfc_default_character_kind : kind;
   ts->deferred = deferred;
@@ -8935,8 +9045,12 @@
 
   if (!gensym->attr.generic && gensym->ts.type != BT_UNKNOWN)
     {
-      gfc_error ("Derived type name %qs at %C already has a basic type "
-		 "of %s", gensym->name, gfc_typename (&gensym->ts));
+      if (gensym->ts.u.derived)
+	gfc_error ("Derived type name %qs at %C already has a basic type "
+		   "of %s", gensym->name, gfc_typename (&gensym->ts));
+      else
+	gfc_error ("Derived type name %qs at %C already has a basic type",
+		   gensym->name);
       return MATCH_ERROR;
     }
 
Index: gcc/fortran/array.c
===================================================================
diff --git a/gcc/fortran/array.c b/gcc/fortran/array.c
--- a/gcc/fortran/array.c	(revision 262353)
+++ b/gcc/fortran/array.c	(revision 262353)
@@ -1079,6 +1079,15 @@
   if (m != MATCH_YES)
     return m;
 
+  if (expr->expr_type == EXPR_FUNCTION
+      && expr->ts.type == BT_UNKNOWN
+      && strcmp(expr->symtree->name, "null") == 0)
+   {
+      gfc_error ("NULL() at %C cannot appear in an array constructor");
+      gfc_free_expr (expr);
+      return MATCH_ERROR;
+   }
+
   gfc_constructor_append_expr (result, expr, &gfc_current_locus);
   return MATCH_YES;
 }
@@ -1998,7 +2007,9 @@
 	  gfc_ref *ref;
 	  for (ref = p->expr->ref; ref; ref = ref->next)
 	    if (ref->type == REF_SUBSTRING
+		&& ref->u.ss.start
 		&& ref->u.ss.start->expr_type == EXPR_CONSTANT
+		&& ref->u.ss.end
 		&& ref->u.ss.end->expr_type == EXPR_CONSTANT)
 	      break;
 
@@ -2021,7 +2032,8 @@
 	  else
 	    return true;
 
-	  gcc_assert (current_length != -1);
+	  if (current_length < 0)
+	    current_length = 0;
 
 	  if (found_length == -1)
 	    found_length = current_length;
Index: gcc/fortran/trans-openmp.c
===================================================================
diff --git a/gcc/fortran/trans-openmp.c b/gcc/fortran/trans-openmp.c
--- a/gcc/fortran/trans-openmp.c	(revision 262353)
+++ b/gcc/fortran/trans-openmp.c	(revision 262353)
@@ -1949,9 +1949,32 @@
 			  }
 			else
 			  {
-			    tree type = gfc_typenode_for_spec (&n->sym->ts);
-			    OMP_CLAUSE_LINEAR_STEP (node)
-			      = fold_convert (type, last_step);
+			    if (kind == OMP_CLAUSE_LINEAR_REF)
+			      {
+				tree type;
+				if (n->sym->attr.flavor == FL_PROCEDURE)
+				  {
+				    type = gfc_get_function_type (n->sym);
+				    type = build_pointer_type (type);
+				  }
+				else
+				  type = gfc_sym_type (n->sym);
+				if (POINTER_TYPE_P (type))
+				  type = TREE_TYPE (type);
+				/* Otherwise to be determined what exactly
+				   should be done.  */
+				tree t = fold_convert (sizetype, last_step);
+				t = size_binop (MULT_EXPR, t,
+						TYPE_SIZE_UNIT (type));
+				OMP_CLAUSE_LINEAR_STEP (node) = t;
+			      }
+			    else
+			      {
+				tree type
+				  = gfc_typenode_for_spec (&n->sym->ts);
+				OMP_CLAUSE_LINEAR_STEP (node)
+				  = fold_convert (type, last_step);
+			      }
 			  }
 			if (n->sym->attr.dimension || n->sym->attr.allocatable)
 			  OMP_CLAUSE_LINEAR_ARRAY (node) = 1;
Index: gcc/fortran/gfortran.h
===================================================================
diff --git a/gcc/fortran/gfortran.h b/gcc/fortran/gfortran.h
--- a/gcc/fortran/gfortran.h	(revision 262353)
+++ b/gcc/fortran/gfortran.h	(revision 262353)
@@ -863,7 +863,7 @@
   unsigned alloc_comp:1, pointer_comp:1, proc_pointer_comp:1,
 	   private_comp:1, zero_comp:1, coarray_comp:1, lock_comp:1,
 	   event_comp:1, defined_assign_comp:1, unlimited_polymorphic:1,
-	   has_dtio_procs:1;
+	   has_dtio_procs:1, caf_token:1;
 
   /* This is a temporary selector for SELECT TYPE or an associate
      variable for SELECT_TYPE or ASSOCIATE.  */
@@ -2856,6 +2856,8 @@
 extern int gfc_numeric_storage_size;
 extern int gfc_character_storage_size;
 
+#define gfc_integer_4_kind 4
+
 /* symbol.c */
 void gfc_clear_new_implicit (void);
 bool gfc_add_new_implicit_range (int, int);
@@ -3145,7 +3147,7 @@
 gfc_component * gfc_get_proc_ptr_comp (gfc_expr *);
 bool gfc_is_proc_ptr_comp (gfc_expr *);
 bool gfc_is_alloc_class_scalar_function (gfc_expr *);
-bool gfc_is_alloc_class_array_function (gfc_expr *);
+bool gfc_is_class_array_function (gfc_expr *);
 
 bool gfc_ref_this_image (gfc_ref *ref);
 bool gfc_is_coindexed (gfc_expr *);
Index: gcc/fortran/ChangeLog
===================================================================
diff --git a/gcc/fortran/ChangeLog b/gcc/fortran/ChangeLog
--- a/gcc/fortran/ChangeLog	(revision 262353)
+++ b/gcc/fortran/ChangeLog	(revision 262353)
@@ -1,3 +1,496 @@
+2018-07-03  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/82969
+	PR fortran/86242
+	* trans-array.c (structure_alloc_comps): Do not explicitly copy
+	procedure pointer components.
+
+2018-06-25  Fritz Reese  <fritzoreese@gmail.com>
+
+	PR fortran/82972
+	PR fortran/83088
+	PR fortran/85851
+	Backport from trunk.
+	* expr.c (component_initializer): Assign init expr to c->initializer.
+	(generate_isocbinding_initializer): New.
+	(gfc_generate_initializer): Call generate_isocbinding_initializer to
+	generate initializers for c_ptr and c_funptr with -finit-derived.
+
+2018-06-25  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/83118
+	Back port from trunk
+	* resolve.c (resolve_ordinary_assign): Force the creation of a
+	vtable for assignment of non-polymorphic expressions to an
+	unlimited polymorphic object.
+	* trans-array.c (gfc_alloc_allocatable_for_assignment): Use the
+	size of the rhs type for such assignments. Set the dtype, _len
+	and vptrs appropriately.
+	* trans-expr.c (gfc_trans_assignment): Force the use of the
+	_copy function for these assignments.
+
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/85313
+	* openmp.c (resolve_omp_do): Remove bogus if (j < i) break;.
+	(resolve_oacc_nested_loops): Likewise.  Formatting fix.
+
+2018-06-13  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/86110
+	* array.c (gfc_resolve_character_array_constructor): Avoid NULL
+	pointer dereference.
+
+2018-06-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/44491
+	* expr.c (gfc_check_assign): Select non-NULL locus.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/38351
+	* resolve.c (resolve_operator): Provide better error message for
+	derived type entity used in an binary intrinsic numeric operator.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/63514
+	* symbol.c (gfc_add_volatile): Enforce F2008:C1282 and F2018:C1588.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/78278
+	* data.c (gfc_assign_data_value): Re-arrange code to allow for
+	an error for double initialization of CHARACTER entities.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/86059
+	* array.c (match_array_cons_element): NULL() cannot be in an
+	array constructor.
+
+2018-06-09  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85138
+	PR fortran/85996
+	PR fortran/86051
+	* decl.c (gfc_match_char_spec): Use private namespace in attempt to
+	reduce a charlen to a constant.
+
+2018-06-07  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/86045
+	Backport from trunk.
+	* simplify.c (gfc_simplify_mod): Re-arrange code to test whether
+	'P' is zero and issue an error if it is.
+
+2018-06-07  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/85641
+	Backport from trunk.
+	* frontend-passes.c (is_fe_temp): Add prototype.
+	(realloc_string_callback): Early return for frontend-generated
+	temporary.
+
+2018-06-04  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85981
+	* resolve.c (resolve_allocate_deallocate): Check errmsg is default
+	character kind.
+
+2018-05-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85543
+	Backport from trunk
+	* resolve.c (update_current_proc_array_outer_dependency): Avoid NULL
+	pointer dereference.
+
+2018-05-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85779
+	Backport from trunk
+	* decl.c (gfc_match_derived_decl): Fix NULL point dereference.
+
+2018-05-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85780
+	Backport from trunk
+	* resolve.c (resolve_fl_procedure): Avoid NULL dereference.
+
+2018-05-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85895
+	Backport from trunk
+	* resolve.c (resolve_sync): Resolve expression before checking for
+	an error.
+
+2018-05-20  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/80657
+	Backport from trunk
+	* resolve.c (flag_fn_result_spec): Use the 'sym' argument to
+	test for self refs to the function result in the character len
+	expression. If a self reference is found, emit an error and
+	return true.
+	(resolve_fntype): Use the function symbol in the calls to the
+	above.
+
+2018-05-20  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/82275
+	Backport from trunk
+	* match.c (gfc_match_type_spec): Go through the array ref and
+	decrement 'rank' for every dimension that is an element.
+
+2018-05-19  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/82923
+	PR fortran/66694
+	PR fortran/82617
+	Backport from trunk
+	* trans-array.c (gfc_alloc_allocatable_for_assignment): Set the
+	charlen backend_decl of the rhs expr to ss->info->string_length
+	so that the value in the current scope is used.
+
+2018-05-16  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/83149
+	Backport from trunk
+	* trans-decl.c (gfc_finish_var_decl): Test sym->ns->proc_name
+	before accessing its components.
+	* trans-types.c (gfc_sym_type): If a character result has null
+	backend_decl, try the procedure symbol..
+
+2018-16-05  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/83898
+	Backport from trunk
+	* trans-stmt.c (trans_associate_var): Do not set cst_array_ctor
+	for characters.
+
+2018-05-16  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/84546
+	Backport from trunk
+	* trans-array.c (structure_alloc_comps): Make sure that the
+	vptr is copied and that the unlimited polymorphic _len is used
+	to compute the size to be allocated.
+	(build_array_ref): Set the 'unlimited' argument false in the
+	call to gfc_get_class_array_ref.
+	* trans-expr.c (gfc_get_class_array_ref): If unlimited, use the
+	unlimited polymorphic _len for the offset to the element.
+	(gfc_copy_class_to_class): Set the new 'unlimited' argument.
+	* trans.h : Add the boolean 'unlimited' to the prototype.
+
+2018-05-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85542
+	Backport from trunk
+	* expr.c (check_inquiry): Avoid NULL pointer dereference.
+
+2018-05-12  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/68846
+	PR fortran/70864
+	Backport from trunk
+	* resolve.c (get_temp_from_expr): The temporary must not have
+	dummy or intent attributes.
+
+2018-05-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/70870
+	Backport from trunk
+	* data.c (gfc_assign_data_value): Check that a data object does
+	not also have default initialization.
+
+2018-05-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85521
+	Backport from trunk
+	* array.c (gfc_resolve_character_array_constructor): Substrings
+	with upper bound smaller than lower bound are zero length strings.
+
+2018-05-11  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85687
+	Backport from trunk
+	* check.c (gfc_check_rank): Check that the argument is a data object.
+
+2018-05-06  Andre Vehreschild  <vehre@gcc.gnu.org>
+
+	PR fortran/85507
+	Backport from trunk.
+	* dependency.c (gfc_dep_resolver): Revert looking at coarray dimension
+	introduced by r259385.
+	* trans-intrinsic.c (conv_caf_send): Always report a dependency for
+	same variables in coarray assignments.
+
+2018-04-28  Andre Vehreschild  <vehre@gcc.gnu.org>
+
+	PR fortran/81773
+	PR fortran/83606
+	Backport from trunk.
+	* dependency.c (gfc_dep_resolver): Coarray indexes are to be ignored
+	during dependency computation.  They define no data dependency.
+	* trans-array.c (conv_array_index_offset): The stride can not be set
+	here, prevent fail.
+	* trans-intrinsic.c (conv_caf_send): Add creation of temporary array
+	for caf_get's result and copying to the array with vectorial
+	indexing.
+
+2018-04-24  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85520
+	* decl.c (gfc_match_char_spec): Check for negative length and set to 0.
+
+2018-03-28  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/85084
+	Backport from trunk.
+	* frontend-passes.c (gfc_run_passes): Do not run front-end
+	optimizations if a previous error occurred.
+
+2018-03-20  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/85001
+	* interface.c (symbol_rank): Remove bogus null pointer check that
+	crept in when translating a ternary operator into an if-else
+	constructor.
+
+2018-03-19  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/84931
+	Backport from trunk
+	* simplify.c (gfc_convert_constant): Correctly handle iterators
+	for type conversion.
+
+2018-03-19  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/77414
+	* decl.c (get_proc_name):  Check for a subroutine re-defined in
+	the contain portion of a subroutine.  Change language of existing
+	error message to better describe the issue. While here fix whitespace
+	issues.
+
+2018-03-19  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/65453
+	* decl.c (get_proc_name): Catch clash between a procedure statement
+	and a contained subprogram
+
+2018-03-15  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/78741
+	* decl.c (get_proc_name):  Check for clash of entry name with
+	subroutine name.
+
+2018-03-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/83939
+	* resolve.c (resolve_fl_procedure): Enforce F2018:C15100.
+
+2018-03-10  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/84734
+	* arith.c (check_result, eval_intrinsic):  If result overflows, pass
+	the expression up the chain instead of a NULL pointer.
+
+2018-03-08  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/64124
+	PR fortran/70409
+	* decl.c (gfc_match_char_spec): Try to reduce a charlen to a constant.
+
+2018-03-06  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/56667
+	* primary.c (match_sym_complex_part): Give the matcher for an implied
+	do-loop a chance to run.
+
+2018-03-04  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/83076
+	* resolve.c (resolve_fl_derived0): Add caf_token fields for
+	allocatable and pointer scalars, when -fcoarray selected.
+	* trans-types.c (gfc_copy_dt_decls_ifequal): Copy the token
+	field as well as the backend_decl.
+	(gfc_get_derived_type): Flag GFC_FCOARRAY_LIB for module
+	derived types that are not vtypes. Components with caf_token
+	attribute are pvoid types. For a component requiring it, find
+	the caf_token field and have the component token field point to
+	its backend_decl.
+
+2018-03-03  Harald Anlauf  <anlauf@gmx.de>
+
+	PR fortran/71085
+	* trans-expr.c (gfc_apply_interface_mapping_to_expr): Do not
+	dereference NULL pointer.
+
+2018-03-03  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/51434
+	* simplify.c (gfc_simplify_transfer): Resolve mold.
+
+2018-03-03  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/80965
+	* resolve.c (build_loc_call): Change symtree name from 'loc' to
+	'_loc'.
+
+2018-03-03  Paul Thomas  <pault@gcc.gnu.org>
+
+	Backported from trunk.
+	PR fortran/78990
+	* expr.c (gfc_is_class_array_function): Renamed from
+	'gfc_is_alloc_class_array_function' and modified to return true
+	for pointers as well as allocatable results.
+	* gfortran.h : Change of name for prototype of above function.
+	* trans-array.c (gfc_add_loop_ss_code): Force finalization of
+	class array results.
+	(build_class_array_ref): Change assertion into a condition.
+	(build_class_array_ref): Set the se class_vptr for class array
+	function results.
+	(gfc_walk_function_expr): Reference gfc_is_class_array_function
+	as above.
+	* trans-decl.c (get_proc_result): Move it up before
+	gfc_trans_deferred_vars.
+	(gfc_trans_deferred_vars): Nullify explicit return class arrays
+	on entry.
+	* trans-expr.c (gfc_conv_class_to_class): Allow conversion of
+	class array functions that have an se class_vptr and use it
+	for the result vptr.
+	(gfc_conv_subref_array_arg): Rename reference to the above
+	function.
+	(gfc_conv_procedure_call): Ditto. Add the se pre block to the
+	loop pre block before the function is evaluated. Do not
+	finalize class pointer results.
+	(arrayfunc_assign_needs_temporary, gfc_trans_assignment_1) More
+	renamed references.
+	* trans-intrinsic.c (gfc_conv_intrinsic_size): Ditto.
+
+2018-03-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-02-16  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/84418
+	* trans-openmp.c (gfc_trans_omp_clauses): For OMP_CLAUSE_LINEAR_REF
+	kind set OMP_CLAUSE_LINEAR_STEP to TYPE_SIZE_UNIT times last_step.
+
+	2018-01-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/84116
+	* openmp.c (gfc_match_omp_clauses): If all the linear
+	gfc_match_omp_variable_list calls failed, don't gfc_free_omp_namelist
+	nor set *head = NULL.  Formatting fixes.
+
+2018-02-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	ChangeLog for r257972
+	PR fortran/83633
+	* decl.c (variable_decl): Check that an explicit-shape-array with
+	nonconstant bounds is allowed.
+
+2018-02-25  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/78238
+	Backport from trunk
+	* gfortran.h (gfc_integer_4_kind): Define.
+	* resolve.c (resolve_select_type): Make sure that the
+	kind of c->high is gfc_integer_4_kind.
+
+2018-02-24  Steven G. Kargl <kargl@gcc.gnu.org>
+
+	PR fortran/30792
+	* decl.c (gfc_match_data): Check for invalid substring in
+	data-implied-do
+
+2018-02-23  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/84511
+	* trans-io.c (transfer_expr): Deal with C_LOC in transfer statement.
+
+2018-02-23  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/84346
+	* interface.c (compare_actual_formal): Issue error if keyword is
+	used in a statement function.
+
+2018-02-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/84506
+	* trans-io.c (set_parameter_value_inquire): Adjust range check of
+	negative unit values for kind=8 units to the kind=4 negative limit.
+
+2018-02-22  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/81116
+	PR fortran/84495
+	* gfortran.dg/realloc_on_assignment_29.f90:  New test.
+
+2018-02-19  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/82007
+	* resolve.c (resolve_transfer): Delete code looking for 'DT'
+	format specifiers in format strings. Set formatted to true if a
+	format string or format label is present.
+	* trans-io.c (get_dtio_proc): Likewise. (transfer_expr): Fix
+	whitespace.
+
+2018-02-17  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	Backport from trunk
+	PR fortran/84270
+	* frontend-passes (scalarized_expr):  If the expression
+	is an assumed size array, leave in the last reference
+	and pass AR_SECTION instead of AR_FULL to gfc_resolve
+	in order to avoid an error.
+
+2018-02-13  Alastair McKinstry  <alastair.mckinstry@sceal.ie>
+	    Janne Blomqvist  <jb@gcc.gnu.org>
+
+	* module.c (dump_module): Use lbasename to ensure that module
+	files are reproducible.
+
+2018-02-12  Thomas Koenig  <tkoenig@gcc.gnu.org>
+
+	PR fortran/68560
+	* trans-intrinsic.c (gfc_conv_intrinsic_shape): New function.
+	(gfc_conv_intrinsic_function): Call it.
+
+2018-02-12  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>
+
+	PR fortran/35299
+	ChangeLog for r257566
+	* resolve.c (resolve_formal_arglist): Update error message.
+
+2018-02-12  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/54223
+	PR fortran/84276
+	* interface.c (compare_actual_formal): Add in_statement_function
+	bool parameter.  Skip check of INTENT attribute for statement
+	functions.  Arguments to a statement function cannot be optional,
+	issue error for missing argument.
+	(gfc_procedure_use, gfc_ppc_use, gfc_arglist_matches_symbol): Use
+	in_statement_function.
+
+2018-02-07  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/82994
+	* match.c (gfc_match_deallocate): Check for NULL pointer.
+
+2018-02-07  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/82049
+	* match.c (gfc_match_type_spec): If the charlen is non-NULL, then
+	try to resolve it.  While here return early if possible.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
Index: gcc/fortran/data.c
===================================================================
diff --git a/gcc/fortran/data.c b/gcc/fortran/data.c
--- a/gcc/fortran/data.c	(revision 262353)
+++ b/gcc/fortran/data.c	(revision 262353)
@@ -481,6 +481,21 @@
   mpz_clear (offset);
   gcc_assert (repeat == NULL);
 
+  /* Overwriting an existing initializer is non-standard but usually only
+     provokes a warning from other compilers.  */
+  if (init != NULL && init->where.lb && rvalue->where.lb)
+    {
+      /* Order in which the expressions arrive here depends on whether
+	 they are from data statements or F95 style declarations.
+	 Therefore, check which is the most recent.  */
+      expr = (LOCATION_LINE (init->where.lb->location)
+	      > LOCATION_LINE (rvalue->where.lb->location))
+	   ? init : rvalue;
+      if (gfc_notify_std (GFC_STD_GNU, "re-initialization of %qs at %L",
+			  symbol->name, &expr->where) == false)
+	return false;
+    }
+
   if (ref || last_ts->type == BT_CHARACTER)
     {
       /* An initializer has to be constant.  */
@@ -492,20 +507,13 @@
     }
   else
     {
-      /* Overwriting an existing initializer is non-standard but usually only
-	 provokes a warning from other compilers.  */
-      if (init != NULL)
+      if (lvalue->ts.type == BT_DERIVED
+	  && gfc_has_default_initializer (lvalue->ts.u.derived))
 	{
-	  /* Order in which the expressions arrive here depends on whether
-	     they are from data statements or F95 style declarations.
-	     Therefore, check which is the most recent.  */
-	  expr = (LOCATION_LINE (init->where.lb->location)
-		  > LOCATION_LINE (rvalue->where.lb->location))
-	       ? init : rvalue;
-	  if (gfc_notify_std (GFC_STD_GNU,
-			      "re-initialization of %qs at %L",
-			      symbol->name, &expr->where) == false)
-	    return false;
+	  gfc_error ("Nonpointer object %qs with default initialization "
+		     "shall not appear in a DATA statement at %L", 
+		     symbol->name, &lvalue->where);
+	  return false;
 	}
 
       expr = gfc_copy_expr (rvalue);
Index: gcc/fortran/trans-stmt.c
===================================================================
diff --git a/gcc/fortran/trans-stmt.c b/gcc/fortran/trans-stmt.c
--- a/gcc/fortran/trans-stmt.c	(revision 262353)
+++ b/gcc/fortran/trans-stmt.c	(revision 262353)
@@ -1566,7 +1566,8 @@
 
       desc = sym->backend_decl;
       cst_array_ctor = e->expr_type == EXPR_ARRAY
-	      && gfc_constant_array_constructor_p (e->value.constructor);
+	      && gfc_constant_array_constructor_p (e->value.constructor)
+	      && e->ts.type != BT_CHARACTER;
 
       /* If association is to an expression, evaluate it and create temporary.
 	 Otherwise, get descriptor of target for pointer assignment.  */
Index: gcc/fortran/expr.c
===================================================================
diff --git a/gcc/fortran/expr.c b/gcc/fortran/expr.c
--- a/gcc/fortran/expr.c	(revision 262353)
+++ b/gcc/fortran/expr.c	(revision 262353)
@@ -2315,7 +2315,7 @@
 
 	/* Assumed character length will not reduce to a constant expression
 	   with LEN, as required by the standard.  */
-	if (i == 5 && not_restricted
+	if (i == 5 && not_restricted && ap->expr->symtree
 	    && ap->expr->symtree->n.sym->ts.type == BT_CHARACTER
 	    && (ap->expr->symtree->n.sym->ts.u.cl->length == NULL
 		|| ap->expr->symtree->n.sym->ts.deferred))
@@ -3288,6 +3288,8 @@
   /* Only DATA Statements come here.  */
   if (!conform)
     {
+      locus *where;
+
       /* Numeric can be converted to any other numeric. And Hollerith can be
 	 converted to any other type.  */
       if ((gfc_numeric_ts (&lvalue->ts) && gfc_numeric_ts (&rvalue->ts))
@@ -3297,8 +3299,9 @@
       if (lvalue->ts.type == BT_LOGICAL && rvalue->ts.type == BT_LOGICAL)
 	return true;
 
+      where = lvalue->where.lb ? &lvalue->where : &rvalue->where;
       gfc_error ("Incompatible types in DATA statement at %L; attempted "
-		 "conversion of %s to %s", &lvalue->where,
+		 "conversion of %s to %s", where,
 		 gfc_typename (&rvalue->ts), gfc_typename (&lvalue->ts));
 
       return false;
@@ -4335,7 +4338,7 @@
       gfc_apply_init (&c->ts, &c->attr, init);
     }
 
-  return init;
+  return (c->initializer = init);
 }
 
 
@@ -4347,7 +4350,33 @@
   return gfc_generate_initializer (ts, false);
 }
 
+/* Generate an initializer expression for an iso_c_binding type
+   such as c_[fun]ptr. The appropriate initializer is c_null_[fun]ptr.  */
 
+static gfc_expr *
+generate_isocbinding_initializer (gfc_symbol *derived)
+{
+  /* The initializers have already been built into the c_null_[fun]ptr symbols
+     from gen_special_c_interop_ptr.  */
+  gfc_symtree *npsym = NULL;
+  if (0 == strcmp (derived->name, "c_ptr"))
+    gfc_find_sym_tree ("c_null_ptr", gfc_current_ns, true, &npsym);
+  else if (0 == strcmp (derived->name, "c_funptr"))
+    gfc_find_sym_tree ("c_null_funptr", gfc_current_ns, true, &npsym);
+  else
+    gfc_internal_error ("generate_isocbinding_initializer(): bad iso_c_binding"
+			" type, expected %<c_ptr%> or %<c_funptr%>");
+  if (npsym)
+    {
+      gfc_expr *init = gfc_copy_expr (npsym->n.sym->value);
+      init->symtree = npsym;
+      init->ts.is_iso_c = true;
+      return init;
+    }
+
+  return NULL;
+}
+
 /* Get or generate an expression for a default initializer of a derived type.
    If -finit-derived is specified, generate default initialization expressions
    for components that lack them when generate is set.  */
@@ -4357,8 +4386,12 @@
 {
   gfc_expr *init, *tmp;
   gfc_component *comp;
+
   generate = flag_init_derived && generate;
 
+  if (ts->u.derived->ts.is_iso_c && generate)
+    return generate_isocbinding_initializer (ts->u.derived);
+
   /* See if we have a default initializer in this, but not in nested
      types (otherwise we could use gfc_has_default_initializer()).
      We don't need to check if we are going to generate them.  */
@@ -4762,7 +4795,7 @@
 /* Determine if an expression is a function with an allocatable class array
    result.  */
 bool
-gfc_is_alloc_class_array_function (gfc_expr *expr)
+gfc_is_class_array_function (gfc_expr *expr)
 {
   if (expr->expr_type == EXPR_FUNCTION
       && expr->value.function.esym
@@ -4769,7 +4802,8 @@
       && expr->value.function.esym->result
       && expr->value.function.esym->result->ts.type == BT_CLASS
       && CLASS_DATA (expr->value.function.esym->result)->attr.dimension
-      && CLASS_DATA (expr->value.function.esym->result)->attr.allocatable)
+      && (CLASS_DATA (expr->value.function.esym->result)->attr.allocatable
+	  || CLASS_DATA (expr->value.function.esym->result)->attr.pointer))
     return true;
 
   return false;
Index: gcc/fortran/module.c
===================================================================
diff --git a/gcc/fortran/module.c b/gcc/fortran/module.c
--- a/gcc/fortran/module.c	(revision 262353)
+++ b/gcc/fortran/module.c	(revision 262353)
@@ -6063,8 +6063,10 @@
     gfc_fatal_error ("Can't open module file %qs for writing at %C: %s",
 		     filename_tmp, xstrerror (errno));
 
+  /* Use lbasename to ensure module files are reproducible regardless
+     of the build path (see the reproducible builds project).  */
   gzprintf (module_fp, "GFORTRAN module version '%s' created from %s\n",
-	    MOD_VERSION, gfc_source_file);
+	    MOD_VERSION, lbasename (gfc_source_file));
 
   /* Write the module itself.  */
   iomode = IO_OUTPUT;
Index: gcc/fortran/trans-types.c
===================================================================
diff --git a/gcc/fortran/trans-types.c b/gcc/fortran/trans-types.c
--- a/gcc/fortran/trans-types.c	(revision 262353)
+++ b/gcc/fortran/trans-types.c	(revision 262353)
@@ -1804,7 +1804,7 @@
       TREE_NO_WARNING (decl) = 1;
     }
 
-  if (flag_coarray == GFC_FCOARRAY_LIB && codimen)
+  if (flag_coarray == GFC_FCOARRAY_LIB)
     {
       decl = gfc_add_field_to_struct_1 (fat_type,
 					get_identifier ("token"),
@@ -2168,6 +2168,14 @@
   if (sym->backend_decl && !sym->attr.function)
     return TREE_TYPE (sym->backend_decl);
 
+  if (sym->attr.result
+      && sym->ts.type == BT_CHARACTER
+      && sym->ts.u.cl->backend_decl == NULL_TREE
+      && sym->ns->proc_name
+      && sym->ns->proc_name->ts.u.cl
+      && sym->ns->proc_name->ts.u.cl->backend_decl != NULL_TREE)
+    sym->ts.u.cl->backend_decl = sym->ns->proc_name->ts.u.cl->backend_decl;
+
   if (sym->ts.type == BT_CHARACTER
       && ((sym->attr.function && sym->attr.is_bind_c)
 	  || (sym->attr.result
@@ -2334,6 +2342,7 @@
   for (; to_cm; to_cm = to_cm->next, from_cm = from_cm->next)
     {
       to_cm->backend_decl = from_cm->backend_decl;
+      to_cm->caf_token = from_cm->caf_token;
       if (from_cm->ts.type == BT_UNION)
         gfc_get_union_type (to_cm->ts.u.derived);
       else if (from_cm->ts.type == BT_DERIVED
@@ -2444,7 +2453,11 @@
   gfc_dt_list *dt;
   gfc_namespace *ns;
   tree tmp;
+  bool coarray_flag;
 
+  coarray_flag = flag_coarray == GFC_FCOARRAY_LIB
+		 && derived->module && !derived->attr.vtype;
+
   if (derived->attr.unlimited_polymorphic
       || (flag_coarray == GFC_FCOARRAY_LIB
 	  && derived->from_intmod == INTMOD_ISO_FORTRAN_ENV
@@ -2636,7 +2649,9 @@
 	  field_type = build_pointer_type (tmp);
 	}
       else if (c->ts.type == BT_DERIVED || c->ts.type == BT_CLASS)
-        field_type = c->ts.u.derived->backend_decl;
+	field_type = c->ts.u.derived->backend_decl;
+      else if (c->attr.caf_token)
+	field_type = pvoid_type_node;
       else
 	{
 	  if (c->ts.type == BT_CHARACTER && !c->ts.deferred)
@@ -2715,19 +2730,6 @@
       gcc_assert (field);
       if (!c->backend_decl)
 	c->backend_decl = field;
-
-      /* Do not add a caf_token field for classes' data components.  */
-      if (codimen && !c->attr.dimension && !c->attr.codimension
-	  && (c->attr.allocatable || c->attr.pointer)
-	  && c->caf_token == NULL_TREE && strcmp ("_data", c->name) != 0)
-	{
-	  char caf_name[GFC_MAX_SYMBOL_LEN];
-	  snprintf (caf_name, GFC_MAX_SYMBOL_LEN, "_caf_%s", c->name);
-	  c->caf_token = gfc_add_field_to_struct (typenode,
-						  get_identifier (caf_name),
-						  pvoid_type_node, &chain);
-	  TREE_NO_WARNING (c->caf_token) = 1;
-	}
     }
 
   /* Now lay out the derived type, including the fields.  */
@@ -2753,6 +2755,24 @@
 
 copy_derived_types:
 
+  for (c = derived->components; c; c = c->next)
+    {
+      /* Do not add a caf_token field for class container components.  */
+      if ((codimen || coarray_flag)
+	  && !c->attr.dimension && !c->attr.codimension
+	  && (c->attr.allocatable || c->attr.pointer)
+	  && !derived->attr.is_class)
+	{
+	  char caf_name[GFC_MAX_SYMBOL_LEN];
+	  gfc_component *token;
+	  snprintf (caf_name, GFC_MAX_SYMBOL_LEN, "_caf_%s", c->name);
+	  token = gfc_find_component (derived, caf_name, true, true, NULL);
+	  gcc_assert (token);
+	  c->caf_token = token->backend_decl;
+	  TREE_NO_WARNING (c->caf_token) = 1;
+	}
+    }
+
   for (dt = gfc_derived_types; dt; dt = dt->next)
     gfc_copy_dt_decls_ifequal (derived, dt->derived, false);
 
Index: gcc/fortran/trans.h
===================================================================
diff --git a/gcc/fortran/trans.h b/gcc/fortran/trans.h
--- a/gcc/fortran/trans.h	(revision 262353)
+++ b/gcc/fortran/trans.h	(revision 262353)
@@ -431,7 +431,7 @@
 void gfc_reset_vptr (stmtblock_t *, gfc_expr *);
 void gfc_reset_len (stmtblock_t *, gfc_expr *);
 tree gfc_get_vptr_from_expr (tree);
-tree gfc_get_class_array_ref (tree, tree, tree);
+tree gfc_get_class_array_ref (tree, tree, tree, bool);
 tree gfc_copy_class_to_class (tree, tree, tree, bool);
 bool gfc_add_finalizer_call (stmtblock_t *, gfc_expr *);
 bool gfc_add_comp_finalizer_call (stmtblock_t *, tree, gfc_component *, bool);
Index: gcc/fortran/frontend-passes.c
===================================================================
diff --git a/gcc/fortran/frontend-passes.c b/gcc/fortran/frontend-passes.c
--- a/gcc/fortran/frontend-passes.c	(revision 262353)
+++ b/gcc/fortran/frontend-passes.c	(revision 262353)
@@ -48,6 +48,8 @@
 				  locus *, gfc_namespace *,
 				  char *vname=NULL);
 
+static bool is_fe_temp (gfc_expr *e);
+
 #ifdef CHECKING_P
 static void check_locus (gfc_namespace *);
 #endif
@@ -135,6 +137,10 @@
   check_locus (ns);
 #endif
 
+  gfc_get_errors (&w, &e);
+  if (e > 0)
+   return;
+
   if (flag_frontend_optimize)
     {
       optimize_namespace (ns);
@@ -145,10 +151,6 @@
       expr_array.release ();
     }
 
-  gfc_get_errors (&w, &e);
-  if (e > 0)
-   return;
-
   if (flag_realloc_lhs)
     realloc_strings (ns);
 }
@@ -231,22 +233,29 @@
       || !expr1->ts.deferred)
     return 0;
 
-  expr2 = gfc_discard_nops (co->expr2);
-  if (expr2->expr_type != EXPR_VARIABLE)
+  if (is_fe_temp (expr1))
     return 0;
 
-  found_substr = false;
-  for (ref = expr2->ref; ref; ref = ref->next)
+  expr2 = gfc_discard_nops (co->expr2);
+
+  if (expr2->expr_type == EXPR_VARIABLE)
     {
-      if (ref->type == REF_SUBSTRING)
+      found_substr = false;
+      for (ref = expr2->ref; ref; ref = ref->next)
 	{
-	  found_substr = true;
-	  break;
+	  if (ref->type == REF_SUBSTRING)
+	    {
+	      found_substr = true;
+	      break;
+	    }
 	}
+      if (!found_substr)
+	return 0;
     }
-  if (!found_substr)
+  else if (expr2->expr_type != EXPR_OP
+	   || expr2->value.op.op != INTRINSIC_CONCAT)
     return 0;
-
+  
   if (!gfc_check_dependency (expr1, expr2, true))
     return 0;
 
@@ -619,7 +628,8 @@
 
   /* Return length of char symbol, if constant.  */
 
-  if (e->symtree->n.sym->ts.u.cl && e->symtree->n.sym->ts.u.cl->length
+  if (e->symtree && e->symtree->n.sym->ts.u.cl
+      && e->symtree->n.sym->ts.u.cl->length
       && e->symtree->n.sym->ts.u.cl->length->expr_type == EXPR_CONSTANT)
     return gfc_copy_expr (e->symtree->n.sym->ts.u.cl->length);
 
@@ -2750,11 +2760,27 @@
 			 is the lbound of a full ref.  */
 		      int j;
 		      gfc_array_ref *ar;
+		      int to;
 
 		      ar = &ref->u.ar;
-		      ar->type = AR_FULL;
-		      for (j = 0; j < ar->dimen; j++)
+
+		      /* For assumed size, we need to keep around the final
+			 reference in order not to get an error on resolution
+			 below, and we cannot use AR_FULL.  */
+			 
+		      if (ar->as->type == AS_ASSUMED_SIZE)
 			{
+			  ar->type = AR_SECTION;
+			  to = ar->dimen - 1;
+			}
+		      else
+			{
+			  to = ar->dimen;
+			  ar->type = AR_FULL;
+			}
+
+		      for (j = 0; j < to; j++)
+			{
 			  gfc_free_expr (ar->start[j]);
 			  ar->start[j] = NULL;
 			  gfc_free_expr (ar->end[j]);
Index: gcc/fortran/resolve.c
===================================================================
diff --git a/gcc/fortran/resolve.c b/gcc/fortran/resolve.c
--- a/gcc/fortran/resolve.c	(revision 262353)
+++ b/gcc/fortran/resolve.c	(revision 262353)
@@ -512,8 +512,11 @@
 	{
 	  if (sym->as != NULL)
 	    {
-	      gfc_error ("Argument %qs of statement function at %L must "
-			 "be scalar", sym->name, &sym->declared_at);
+	      /* F03:C1263 (R1238) The function-name and each dummy-arg-name
+		 shall be specified, explicitly or implicitly, to be scalar.  */
+	      gfc_error ("Argument '%s' of statement function '%s' at %L "
+			 "must be scalar", sym->name, proc->name,
+			 &proc->declared_at);
 	      continue;
 	    }
 
@@ -2903,8 +2906,8 @@
 
   /* If SYM has references to outer arrays, so has the procedure calling
      SYM.  If SYM is a procedure pointer, we can assume the worst.  */
-  if (sym->attr.array_outer_dependency
-      || sym->attr.proc_pointer)
+  if ((sym->attr.array_outer_dependency || sym->attr.proc_pointer)
+      && gfc_current_ns->proc_name)
     gfc_current_ns->proc_name->attr.array_outer_dependency = 1;
 }
 
@@ -3682,7 +3685,13 @@
 	  break;
 	}
 
-      sprintf (msg,
+      if (op1->ts.type == BT_DERIVED || op2->ts.type == BT_DERIVED)
+	sprintf (msg,
+	       _("Unexpected derived-type entities in binary intrinsic "
+		 "numeric operator %%<%s%%> at %%L"),
+	       gfc_op2string (e->value.op.op));
+      else
+      	sprintf (msg,
 	       _("Operands of binary numeric operator %%<%s%%> at %%L are %s/%s"),
 	       gfc_op2string (e->value.op.op), gfc_typename (&op1->ts),
 	       gfc_typename (&op2->ts));
@@ -7551,12 +7560,17 @@
       gfc_check_vardef_context (errmsg, false, false, false,
 				_("ERRMSG variable"));
 
+      /* F18:R928  alloc-opt             is ERRMSG = errmsg-variable
+	 F18:R930  errmsg-variable       is scalar-default-char-variable
+	 F18:R906  default-char-variable is variable
+	 F18:C906  default-char-variable shall be default character.  */
       if ((errmsg->ts.type != BT_CHARACTER
 	   && !(errmsg->ref
 		&& (errmsg->ref->type == REF_ARRAY
 		    || errmsg->ref->type == REF_COMPONENT)))
-	  || errmsg->rank > 0 )
-	gfc_error ("Errmsg-variable at %L must be a scalar CHARACTER "
+	  || errmsg->rank > 0
+	  || errmsg->ts.kind != gfc_default_character_kind)
+	gfc_error ("ERRMSG variable at %L shall be a scalar default CHARACTER "
 		   "variable", &errmsg->where);
 
       for (p = code->ext.alloc.list; p; p = p->next)
@@ -8495,7 +8509,7 @@
   gfc_expr *loc_call;
   loc_call = gfc_get_expr ();
   loc_call->expr_type = EXPR_FUNCTION;
-  gfc_get_sym_tree ("loc", gfc_current_ns, &loc_call->symtree, false);
+  gfc_get_sym_tree ("_loc", gfc_current_ns, &loc_call->symtree, false);
   loc_call->symtree->n.sym->attr.flavor = FL_PROCEDURE;
   loc_call->symtree->n.sym->attr.intrinsic = 1;
   loc_call->symtree->n.sym->result = loc_call->symtree->n.sym;
@@ -8548,6 +8562,9 @@
 	code->expr1->symtree->n.sym->ts = code->expr2->ts;
       selector_type = CLASS_DATA (code->expr2)->ts.u.derived;
 
+      if (code->expr2->rank && CLASS_DATA (code->expr1)->as)
+	CLASS_DATA (code->expr1)->as->rank = code->expr2->rank;
+
       /* F2008: C803 The selector expression must not be coindexed.  */
       if (gfc_is_coindexed (code->expr2))
 	{
@@ -8742,7 +8759,7 @@
 	    {
 	      vtab = gfc_find_derived_vtab (c->ts.u.derived);
 	      gcc_assert (vtab);
-	      c->high = gfc_get_int_expr (gfc_default_integer_kind, NULL,
+	      c->high = gfc_get_int_expr (gfc_integer_4_kind, NULL,
 					  c->ts.u.derived->hash_value);
 	    }
 	  else
@@ -8751,6 +8768,13 @@
 	      gcc_assert (vtab && CLASS_DATA (vtab)->initializer);
 	      e = CLASS_DATA (vtab)->initializer;
 	      c->high = gfc_copy_expr (e);
+	      if (c->high->ts.kind != gfc_integer_4_kind)
+		{
+		  gfc_typespec ts;
+		  ts.kind = gfc_integer_4_kind;
+		  ts.type = BT_INTEGER;
+		  gfc_convert_type_warn (c->high, &ts, 2, 0);
+		}
 	    }
 
 	  e = gfc_lval_expr_from_sym (vtab);
@@ -8996,19 +9020,9 @@
       else
 	derived = ts->u.derived->components->ts.u.derived;
 
-      if (dt->format_expr)
-	{
-	  char *fmt;
-	  fmt = gfc_widechar_to_char (dt->format_expr->value.character.string,
-				      -1);
-	  if (strtok (fmt, "DT") != NULL)
-	    formatted = true;
-	}
-      else if (dt->format_label == &format_asterisk)
-	{
-	  /* List directed io must call the formatted DTIO procedure.  */
-	  formatted = true;
-	}
+      /* Determine when to use the formatted DTIO procedure.  */
+      if (dt && (dt->format_expr || dt->format_label))
+	formatted = true;
 
       write = dt->dt_io_kind->value.iokind == M_WRITE
 	      || dt->dt_io_kind->value.iokind == M_PRINT;
@@ -9296,6 +9310,7 @@
     }
 
   /* Check STAT.  */
+  gfc_resolve_expr (code->expr2);
   if (code->expr2
       && (code->expr2->ts.type != BT_INTEGER || code->expr2->rank != 0
 	  || code->expr2->expr_type != EXPR_VARIABLE))
@@ -9303,6 +9318,7 @@
 	       &code->expr2->where);
 
   /* Check ERRMSG.  */
+  gfc_resolve_expr (code->expr3);
   if (code->expr3
       && (code->expr3->ts.type != BT_CHARACTER || code->expr3->rank != 0
 	  || code->expr3->expr_type != EXPR_VARIABLE))
@@ -10135,6 +10151,11 @@
       && rhs->expr_type != EXPR_ARRAY)
     gfc_add_data_component (rhs);
 
+  /* Make sure there is a vtable and, in particular, a _copy for the
+     rhs type.  */
+  if (UNLIMITED_POLY (lhs) && lhs->rank && rhs->ts.type != BT_CLASS)
+    gfc_find_vtab (&rhs->ts);
+
   bool caf_convert_to_send = flag_coarray == GFC_FCOARRAY_LIB
       && (lhs_coindexed
 	  || (code->expr2->expr_type == EXPR_FUNCTION
@@ -10273,6 +10294,8 @@
   tmp->n.sym->attr.function = 0;
   tmp->n.sym->attr.result = 0;
   tmp->n.sym->attr.flavor = FL_VARIABLE;
+  tmp->n.sym->attr.dummy = 0;
+  tmp->n.sym->attr.intent = INTENT_UNKNOWN;
 
   if (as)
     {
@@ -12225,6 +12248,19 @@
 	}
     }
 
+  /* F2018, C15100: "The result of an elemental function shall be scalar,
+     and shall not have the POINTER or ALLOCATABLE attribute."  The scalar
+     pointer is tested and caught elsewhere.  */
+  if (sym->attr.elemental && sym->result
+      && (sym->result->attr.allocatable || sym->result->attr.pointer))
+    {
+      gfc_error ("Function result variable %qs at %L of elemental "
+		 "function %qs shall not have an ALLOCATABLE or POINTER "
+		 "attribute", sym->result->name,
+		 &sym->result->declared_at, sym->name);
+      return false;
+    }
+
   if (sym->attr.is_bind_c && sym->attr.is_c_interop != 1)
     {
       gfc_formal_arglist *curr_arg;
@@ -12250,7 +12286,7 @@
       while (curr_arg != NULL)
         {
           /* Skip implicitly typed dummy args here.  */
-	  if (curr_arg->sym->attr.implicit_type == 0)
+	  if (curr_arg->sym && curr_arg->sym->attr.implicit_type == 0)
 	    if (!gfc_verify_c_interop_param (curr_arg->sym))
 	      /* If something is found to fail, record the fact so we
 		 can mark the symbol for the procedure as not being
@@ -13799,6 +13835,31 @@
   if (!success)
     return false;
 
+  /* Now add the caf token field, where needed.  */
+  if (flag_coarray != GFC_FCOARRAY_NONE
+      && !sym->attr.is_class && !sym->attr.vtype)
+    {
+      for (c = sym->components; c; c = c->next)
+	if (!c->attr.dimension && !c->attr.codimension
+	    && (c->attr.allocatable || c->attr.pointer))
+	  {
+	    char name[GFC_MAX_SYMBOL_LEN+9];
+	    gfc_component *token;
+	    sprintf (name, "_caf_%s", c->name);
+	    token = gfc_find_component (sym, name, true, true, NULL);
+	    if (token == NULL)
+	      {
+		if (!gfc_add_component (sym, name, &token))
+		  return false;
+		token->ts.type = BT_VOID;
+		token->ts.kind = gfc_default_integer_kind;
+		token->attr.access = ACCESS_PRIVATE;
+		token->attr.artificial = 1;
+		token->attr.caf_token = 1;
+	      }
+	  }
+    }
+
   check_defined_assignments (sym);
 
   if (!sym->attr.defined_assign_comp && super_type)
@@ -15827,7 +15888,7 @@
 
 static bool
 flag_fn_result_spec (gfc_expr *expr,
-                     gfc_symbol *sym ATTRIBUTE_UNUSED,
+                     gfc_symbol *sym,
                      int *f ATTRIBUTE_UNUSED)
 {
   gfc_namespace *ns;
@@ -15840,6 +15901,13 @@
 	if (!ns->parent)
 	  break;
 
+      if (sym == s)
+	{
+	  gfc_error ("Self reference in character length expression "
+		     "for %qs at %L", sym->name, &expr->where);
+	  return true;
+	}
+
       if (!s->fn_result_spec
 	  && s->attr.flavor == FL_PARAMETER)
 	{
@@ -15922,7 +15990,7 @@
       }
 
   if (sym->ts.type == BT_CHARACTER)
-    gfc_traverse_expr (sym->ts.u.cl->length, NULL, flag_fn_result_spec, 0);
+    gfc_traverse_expr (sym->ts.u.cl->length, sym, flag_fn_result_spec, 0);
 }
 
 
Index: gcc/fortran/trans-decl.c
===================================================================
diff --git a/gcc/fortran/trans-decl.c b/gcc/fortran/trans-decl.c
--- a/gcc/fortran/trans-decl.c	(revision 262353)
+++ b/gcc/fortran/trans-decl.c	(revision 262353)
@@ -603,10 +603,12 @@
      function scope.  */
   if (current_function_decl != NULL_TREE)
     {
-      if (sym->ns->proc_name->backend_decl == current_function_decl
-	  || sym->result == sym)
+      if (sym->ns->proc_name
+	  && (sym->ns->proc_name->backend_decl == current_function_decl
+	      || sym->result == sym))
 	gfc_add_decl_to_function (decl);
-      else if (sym->ns->proc_name->attr.flavor == FL_LABEL)
+      else if (sym->ns->proc_name
+	       && sym->ns->proc_name->attr.flavor == FL_LABEL)
 	/* This is a BLOCK construct.  */
 	add_decl_as_local (decl);
       else
@@ -698,7 +700,8 @@
     }
 
   /* Keep variables larger than max-stack-var-size off stack.  */
-  if (!sym->ns->proc_name->attr.recursive && !sym->attr.automatic
+  if (!(sym->ns->proc_name && sym->ns->proc_name->attr.recursive)
+      && !sym->attr.automatic
       && INTEGER_CST_P (DECL_SIZE_UNIT (decl))
       && !gfc_can_put_var_on_stack (DECL_SIZE_UNIT (decl))
 	 /* Put variable length auto array pointers always into stack.  */
@@ -4142,6 +4145,24 @@
   return tmp;
 }
 
+
+/* Get the result expression for a procedure.  */
+
+static tree
+get_proc_result (gfc_symbol* sym)
+{
+  if (sym->attr.subroutine || sym == sym->result)
+    {
+      if (current_fake_result_decl != NULL)
+	return TREE_VALUE (current_fake_result_decl);
+
+      return NULL_TREE;
+    }
+
+  return sym->result->backend_decl;
+}
+
+
 /* Generate function entry and exit code, and add it to the function body.
    This includes:
     Allocation and initialization of array variables.
@@ -4251,7 +4272,22 @@
       else
 	gcc_assert (flag_f2c && proc_sym->ts.type == BT_COMPLEX);
     }
+  else if (proc_sym == proc_sym->result && IS_CLASS_ARRAY (proc_sym))
+    {
+      /* Nullify explicit return class arrays on entry.  */
+      tree type;
+      tmp = get_proc_result (proc_sym);
+	if (tmp && GFC_CLASS_TYPE_P (TREE_TYPE (tmp)))
+	  {
+	    gfc_start_block (&init);
+	    tmp = gfc_class_data_get (tmp);
+	    type = TREE_TYPE (gfc_conv_descriptor_data_get (tmp));
+	    gfc_conv_descriptor_data_set (&init, tmp, build_int_cst (type, 0));
+	    gfc_add_init_cleanup (block, gfc_finish_block (&init), NULL_TREE);
+	  }
+    }
 
+
   /* Initialize the INTENT(OUT) derived type dummy arguments.  This
      should be done here so that the offsets and lbounds of arrays
      are available.  */
@@ -5981,23 +6017,6 @@
 }
 
 
-/* Get the result expression for a procedure.  */
-
-static tree
-get_proc_result (gfc_symbol* sym)
-{
-  if (sym->attr.subroutine || sym == sym->result)
-    {
-      if (current_fake_result_decl != NULL)
-	return TREE_VALUE (current_fake_result_decl);
-
-      return NULL_TREE;
-    }
-
-  return sym->result->backend_decl;
-}
-
-
 /* Generate an appropriate return-statement for a procedure.  */
 
 tree
Index: gcc/fortran/match.c
===================================================================
diff --git a/gcc/fortran/match.c b/gcc/fortran/match.c
--- a/gcc/fortran/match.c	(revision 262353)
+++ b/gcc/fortran/match.c	(revision 262353)
@@ -2001,12 +2001,17 @@
 {
   match m;
   locus old_locus;
-  char name[GFC_MAX_SYMBOL_LEN + 1];
+  char c, name[GFC_MAX_SYMBOL_LEN + 1];
 
   gfc_clear_ts (ts);
   gfc_gobble_whitespace ();
   old_locus = gfc_current_locus;
 
+  /* If c isn't [a-z], then return immediately.  */
+  c = gfc_peek_ascii_char ();
+  if (!ISALPHA(c))
+    return MATCH_NO;
+
   if (match_derived_type_spec (ts) == MATCH_YES)
     {
       /* Enforce F03:C401.  */
@@ -2045,6 +2050,8 @@
       ts->type = BT_CHARACTER;
 
       m = gfc_match_char_spec (ts);
+      if (ts->u.cl && ts->u.cl->length)
+	gfc_resolve_expr (ts->u.cl->length);
 
       if (m == MATCH_NO)
 	m = MATCH_YES;
@@ -2056,7 +2063,7 @@
      or list item in a type-list of an OpenMP reduction clause.  Need to
      differentiate REAL([KIND]=scalar-int-initialization-expr) from
      REAL(A,[KIND]) and REAL(KIND,A).  Logically, when this code was
-     written the use of LOGICAL as a type-spec or intrinsic subprogram 
+     written the use of LOGICAL as a type-spec or intrinsic subprogram
      was overlooked.  */
 
   m = gfc_match (" %n", name);
@@ -4404,8 +4411,8 @@
 	   && (tail->expr->ref->type == REF_COMPONENT
 	       || tail->expr->ref->type == REF_ARRAY));
       if (sym && sym->ts.type == BT_CLASS)
-	b2 = !(CLASS_DATA (sym)->attr.allocatable
-	       || CLASS_DATA (sym)->attr.class_pointer);
+	b2 = !(CLASS_DATA (sym) && (CLASS_DATA (sym)->attr.allocatable
+	       || CLASS_DATA (sym)->attr.class_pointer));
       else
 	b2 = sym && !(sym->attr.allocatable || sym->attr.pointer
 		      || sym->attr.proc_pointer);
@@ -5707,6 +5714,7 @@
 {
   gfc_ref *ref;
   gfc_symbol *assoc_sym;
+  int rank = 0;
 
   assoc_sym = associate->symtree->n.sym;
 
@@ -5743,14 +5751,28 @@
 	selector->rank = ref->u.ar.dimen;
       else
 	selector->rank = 0;
+
+      rank = selector->rank;
     }
 
-  if (selector->rank)
+  if (rank)
     {
-      assoc_sym->attr.dimension = 1;
-      assoc_sym->as = gfc_get_array_spec ();
-      assoc_sym->as->rank = selector->rank;
-      assoc_sym->as->type = AS_DEFERRED;
+      for (int i = 0; i < ref->u.ar.dimen + ref->u.ar.codimen; i++)
+	if (ref->u.ar.dimen_type[i] == DIMEN_ELEMENT
+	    || (ref->u.ar.dimen_type[i] == DIMEN_UNKNOWN
+		&& ref->u.ar.end[i] == NULL
+		&& ref->u.ar.stride[i] == NULL))
+	  rank--;
+
+      if (rank)
+	{
+	  assoc_sym->attr.dimension = 1;
+	  assoc_sym->as = gfc_get_array_spec ();
+	  assoc_sym->as->rank = rank;
+	  assoc_sym->as->type = AS_DEFERRED;
+	}
+      else
+	assoc_sym->as = NULL;
     }
   else
     assoc_sym->as = NULL;
Index: gcc/fortran/trans-io.c
===================================================================
diff --git a/gcc/fortran/trans-io.c b/gcc/fortran/trans-io.c
--- a/gcc/fortran/trans-io.c	(revision 262353)
+++ b/gcc/fortran/trans-io.c	(revision 262353)
@@ -639,12 +639,12 @@
       /* Don't evaluate the UNIT number multiple times.  */
       se.expr = gfc_evaluate_now (se.expr, &se.pre);
 
-      /* UNIT numbers should be greater than zero.  */
+      /* UNIT numbers should be greater than the min.  */
       i = gfc_validate_kind (BT_INTEGER, 4, false);
+      val = gfc_conv_mpz_to_tree (gfc_integer_kinds[i].pedantic_min_int, 4);
       cond1 = build2_loc (input_location, LT_EXPR, logical_type_node,
 			  se.expr,
-			  fold_convert (TREE_TYPE (se.expr),
-			  integer_zero_node));
+			  fold_convert (TREE_TYPE (se.expr), val));
       /* UNIT numbers should be less than the max.  */
       val = gfc_conv_mpz_to_tree (gfc_integer_kinds[i].huge, 4);
       cond2 = build2_loc (input_location, GT_EXPR, logical_type_node,
@@ -2214,26 +2214,10 @@
   bool formatted = false;
   gfc_dt *dt = code->ext.dt;
 
-  if (dt)
-    {
-      char *fmt = NULL;
+  /* Determine when to use the formatted DTIO procedure.  */
+  if (dt && (dt->format_expr || dt->format_label))
+    formatted = true;
 
-      if (dt->format_label == &format_asterisk)
-	{
-	  /* List directed io must call the formatted DTIO procedure.  */
-	  formatted = true;
-	}
-      else if (dt->format_expr)
-	fmt = gfc_widechar_to_char (dt->format_expr->value.character.string,
-				      -1);
-      else if (dt->format_label)
-	fmt = gfc_widechar_to_char (dt->format_label->format->value.character.string,
-				      -1);
-      if (fmt && strtok (fmt, "DT") != NULL)
-	formatted = true;
-
-    }
-
   if (ts->type == BT_CLASS)
     derived = ts->u.derived->components->ts.u.derived;
   else
@@ -2293,6 +2277,16 @@
       ts->kind = gfc_index_integer_kind;
     }
 
+  /* gfortran reaches here for "print *, c_loc(xxx)".  */
+  if (ts->type == BT_VOID
+      && code->expr1 && code->expr1->ts.type == BT_VOID
+      && code->expr1->symtree
+      && strcmp (code->expr1->symtree->name, "c_loc") == 0)
+    {
+      ts->type = BT_INTEGER;
+      ts->kind = gfc_index_integer_kind;
+    }
+
   kind = ts->kind;
   function = NULL;
   arg2 = NULL;
@@ -2442,8 +2436,7 @@
 	    {
 	      /* Recurse into the elements of the derived type.  */
 	      expr = gfc_evaluate_now (addr_expr, &se->pre);
-	      expr = build_fold_indirect_ref_loc (input_location,
-				      expr);
+	      expr = build_fold_indirect_ref_loc (input_location, expr);
 
 	      /* Make sure that the derived type has been built.  An external
 		 function, if only referenced in an io statement, requires this
Index: gcc/fortran/arith.c
===================================================================
diff --git a/gcc/fortran/arith.c b/gcc/fortran/arith.c
--- a/gcc/fortran/arith.c	(revision 262353)
+++ b/gcc/fortran/arith.c	(revision 262353)
@@ -555,10 +555,10 @@
       val = ARITH_OK;
     }
 
-  if (val != ARITH_OK)
+  if (val == ARITH_OK || val == ARITH_OVERFLOW)
+    *rp = r;
+  else
     gfc_free_expr (r);
-  else
-    *rp = r;
 
   return val;
 }
@@ -1603,9 +1603,13 @@
   if (rc != ARITH_OK)
     {
       gfc_error (gfc_arith_error (rc), &op1->where);
+      if (rc == ARITH_OVERFLOW)
+	goto done;
       return NULL;
     }
 
+done:
+
   gfc_free_expr (op1);
   gfc_free_expr (op2);
   return result;
Index: gcc/fortran/check.c
===================================================================
diff --git a/gcc/fortran/check.c b/gcc/fortran/check.c
--- a/gcc/fortran/check.c	(revision 262353)
+++ b/gcc/fortran/check.c	(revision 262353)
@@ -3764,8 +3764,11 @@
 		  ? a->value.function.esym->result->attr.pointer
 		  : a->symtree->n.sym->result->attr.pointer;
 
-  if (a->expr_type == EXPR_OP || a->expr_type == EXPR_NULL
-      || a->expr_type == EXPR_COMPCALL|| a->expr_type == EXPR_PPC
+  if (a->expr_type == EXPR_OP
+      || a->expr_type == EXPR_NULL
+      || a->expr_type == EXPR_COMPCALL
+      || a->expr_type == EXPR_PPC
+      || a->ts.type == BT_PROCEDURE
       || !is_variable)
     {
       gfc_error ("The argument of the RANK intrinsic at %L must be a data "
Index: gcc/fortran/dependency.c
===================================================================
diff --git a/gcc/fortran/dependency.c b/gcc/fortran/dependency.c
Index: gcc/fortran/primary.c
===================================================================
diff --git a/gcc/fortran/primary.c b/gcc/fortran/primary.c
--- a/gcc/fortran/primary.c	(revision 262353)
+++ b/gcc/fortran/primary.c	(revision 262353)
@@ -1247,8 +1247,22 @@
 
   if (sym->attr.flavor != FL_PARAMETER)
     {
-      gfc_error ("Expected PARAMETER symbol in complex constant at %C");
-      return MATCH_ERROR;
+      /* Give the matcher for implied do-loops a chance to run.  This yields
+	 a much saner error message for "write(*,*) (i, i=1, 6" where the 
+	 right parenthesis is missing.  */
+      char c;
+      gfc_gobble_whitespace ();
+      c = gfc_peek_ascii_char ();
+      if (c == '=' || c == ',')
+	{
+	  m = MATCH_NO;
+	}
+      else
+	{
+	  gfc_error ("Expected PARAMETER symbol in complex constant at %C");
+	  m = MATCH_ERROR;
+	}
+      return m;
     }
 
   if (!sym->value)
Index: gcc/fortran/trans-intrinsic.c
===================================================================
diff --git a/gcc/fortran/trans-intrinsic.c b/gcc/fortran/trans-intrinsic.c
--- a/gcc/fortran/trans-intrinsic.c	(revision 262353)
+++ b/gcc/fortran/trans-intrinsic.c	(revision 262353)
@@ -1860,7 +1860,7 @@
 
   lhs_expr = code->ext.actual->expr;
   rhs_expr = code->ext.actual->next->expr;
-  may_require_tmp = gfc_check_dependency (lhs_expr, rhs_expr, false) == 0
+  may_require_tmp = gfc_check_dependency (lhs_expr, rhs_expr, true) == 0
 		    ? boolean_false_node : boolean_true_node;
   gfc_init_block (&block);
 
@@ -1906,34 +1906,124 @@
     }
   else
     {
-      /* If has_vector, pass descriptor for whole array and the
-         vector bounds separately.  */
-      gfc_array_ref *ar, ar2;
-      bool has_vector = false;
+      bool has_vector = gfc_has_vector_subscript (lhs_expr);
 
-      if (gfc_is_coindexed (lhs_expr) && gfc_has_vector_subscript (lhs_expr))
+      if (gfc_is_coindexed (lhs_expr) || !has_vector)
 	{
-          has_vector = true;
-          ar = gfc_find_array_ref (lhs_expr);
-	  ar2 = *ar;
-	  memset (ar, '\0', sizeof (*ar));
-	  ar->as = ar2.as;
-	  ar->type = AR_FULL;
+	  /* If has_vector, pass descriptor for whole array and the
+	     vector bounds separately.  */
+	  gfc_array_ref *ar, ar2;
+	  bool has_tmp_lhs_array = false;
+	  if (has_vector)
+	    {
+	      has_tmp_lhs_array = true;
+	      ar = gfc_find_array_ref (lhs_expr);
+	      ar2 = *ar;
+	      memset (ar, '\0', sizeof (*ar));
+	      ar->as = ar2.as;
+	      ar->type = AR_FULL;
+	    }
+	  lhs_se.want_pointer = 1;
+	  gfc_conv_expr_descriptor (&lhs_se, lhs_expr);
+	  /* Using gfc_conv_expr_descriptor, we only get the descriptor, but
+	     that has the wrong type if component references are done.  */
+	  lhs_type = gfc_typenode_for_spec (&lhs_expr->ts);
+	  tmp = build_fold_indirect_ref_loc (input_location, lhs_se.expr);
+	  gfc_add_modify (&lhs_se.pre, gfc_conv_descriptor_dtype (tmp),
+			  gfc_get_dtype_rank_type (has_vector ? ar2.dimen
+							      : lhs_expr->rank,
+						   lhs_type));
+	  if (has_tmp_lhs_array)
+	    {
+	      vec = conv_caf_vector_subscript (&block, lhs_se.expr, &ar2);
+	      *ar = ar2;
+	    }
 	}
-      lhs_se.want_pointer = 1;
-      gfc_conv_expr_descriptor (&lhs_se, lhs_expr);
-      /* Using gfc_conv_expr_descriptor, we only get the descriptor, but that
-         has the wrong type if component references are done.  */
-      lhs_type = gfc_typenode_for_spec (&lhs_expr->ts);
-      tmp = build_fold_indirect_ref_loc (input_location, lhs_se.expr);
-      gfc_add_modify (&lhs_se.pre, gfc_conv_descriptor_dtype (tmp),
-                      gfc_get_dtype_rank_type (has_vector ? ar2.dimen
-							  : lhs_expr->rank,
-		      lhs_type));
-      if (has_vector)
+      else
 	{
-	  vec = conv_caf_vector_subscript (&block, lhs_se.expr, &ar2);
-	  *ar = ar2;
+	  /* Special casing for arr1 ([...]) = arr2[...], i.e. caf_get to
+	     indexed array expression.  This is rewritten to:
+
+	     tmp_array = arr2[...]
+	     arr1 ([...]) = tmp_array
+
+	     because using the standard gfc_conv_expr (lhs_expr) did the
+	     assignment with lhs and rhs exchanged.  */
+
+	  gfc_ss *lss_for_tmparray, *lss_real;
+	  gfc_loopinfo loop;
+	  gfc_se se;
+	  stmtblock_t body;
+	  tree tmparr_desc, src;
+	  tree index = gfc_index_zero_node;
+	  tree stride = gfc_index_zero_node;
+	  int n;
+
+	  /* Walk both sides of the assignment, once to get the shape of the
+	     temporary array to create right.  */
+	  lss_for_tmparray = gfc_walk_expr (lhs_expr);
+	  /* And a second time to be able to create an assignment of the
+	     temporary to the lhs_expr.  gfc_trans_create_temp_array replaces
+	     the tree in the descriptor with the one for the temporary
+	     array.  */
+	  lss_real = gfc_walk_expr (lhs_expr);
+	  gfc_init_loopinfo (&loop);
+	  gfc_add_ss_to_loop (&loop, lss_for_tmparray);
+	  gfc_add_ss_to_loop (&loop, lss_real);
+	  gfc_conv_ss_startstride (&loop);
+	  gfc_conv_loop_setup (&loop, &lhs_expr->where);
+	  lhs_type = gfc_typenode_for_spec (&lhs_expr->ts);
+	  gfc_trans_create_temp_array (&lhs_se.pre, &lhs_se.post,
+				       lss_for_tmparray, lhs_type, NULL_TREE,
+				       false, true, false,
+				       &lhs_expr->where);
+	  tmparr_desc = lss_for_tmparray->info->data.array.descriptor;
+	  gfc_start_scalarized_body (&loop, &body);
+	  gfc_init_se (&se, NULL);
+	  gfc_copy_loopinfo_to_se (&se, &loop);
+	  se.ss = lss_real;
+	  gfc_conv_expr (&se, lhs_expr);
+	  gfc_add_block_to_block (&body, &se.pre);
+
+	  /* Walk over all indexes of the loop.  */
+	  for (n = loop.dimen - 1; n > 0; --n)
+	    {
+	      tmp = loop.loopvar[n];
+	      tmp = fold_build2_loc (input_location, MINUS_EXPR,
+				     gfc_array_index_type, tmp, loop.from[n]);
+	      tmp = fold_build2_loc (input_location, PLUS_EXPR,
+				     gfc_array_index_type, tmp, index);
+
+	      stride = fold_build2_loc (input_location, MINUS_EXPR,
+					gfc_array_index_type,
+					loop.to[n - 1], loop.from[n - 1]);
+	      stride = fold_build2_loc (input_location, PLUS_EXPR,
+					gfc_array_index_type,
+					stride, gfc_index_one_node);
+
+	      index = fold_build2_loc (input_location, MULT_EXPR,
+				       gfc_array_index_type, tmp, stride);
+	    }
+
+	  index = fold_build2_loc (input_location, MINUS_EXPR,
+				   gfc_array_index_type,
+				   index, loop.from[0]);
+
+	  index = fold_build2_loc (input_location, PLUS_EXPR,
+				   gfc_array_index_type,
+				   loop.loopvar[0], index);
+
+	  src = build_fold_indirect_ref (gfc_conv_array_data (tmparr_desc));
+	  src = gfc_build_array_ref (src, index, NULL);
+	  /* Now create the assignment of lhs_expr = tmp_array.  */
+	  gfc_add_modify (&body, se.expr, src);
+	  gfc_add_block_to_block (&body, &se.post);
+	  lhs_se.expr = gfc_build_addr_expr (NULL_TREE, tmparr_desc);
+	  gfc_trans_scalarizing_loops (&loop, &body);
+	  gfc_add_block_to_block (&loop.pre, &loop.post);
+	  gfc_add_expr_to_block (&lhs_se.post, gfc_finish_block (&loop.pre));
+	  gfc_free_ss (lss_for_tmparray);
+	  gfc_free_ss (lss_real);
 	}
     }
 
@@ -5478,6 +5568,22 @@
 }
 
 static void
+gfc_conv_intrinsic_shape (gfc_se *se, gfc_expr *expr)
+{
+  gfc_actual_arglist *s, *k;
+  gfc_expr *e;
+
+  /* Remove the KIND argument, if present. */
+  s = expr->value.function.actual;
+  k = s->next;
+  e = k->expr;
+  gfc_free_expr (e);
+  k->expr = NULL;
+
+  gfc_conv_intrinsic_funcall (se, expr);
+}
+
+static void
 gfc_conv_intrinsic_shift (gfc_se * se, gfc_expr * expr, bool right_shift,
 			  bool arithmetic)
 {
@@ -6601,7 +6707,7 @@
     gfc_add_class_array_ref (actual->expr);
 
   argse.data_not_needed = 1;
-  if (gfc_is_alloc_class_array_function (actual->expr))
+  if (gfc_is_class_array_function (actual->expr))
     {
       /* For functions that return a class array conv_expr_descriptor is not
 	 able to get the descriptor right.  Therefore this special case.  */
@@ -8589,6 +8695,10 @@
 	      conv_generic_with_optional_char_arg (se, expr, 1, 3);
 	      break;
 
+	    case GFC_ISYM_SHAPE:
+	      gfc_conv_intrinsic_shape (se, expr);
+	      break;
+
 	    default:
 	      gfc_conv_intrinsic_funcall (se, expr);
 	      break;
Index: gcc/fortran/simplify.c
===================================================================
diff --git a/gcc/fortran/simplify.c b/gcc/fortran/simplify.c
--- a/gcc/fortran/simplify.c	(revision 262353)
+++ b/gcc/fortran/simplify.c	(revision 262353)
@@ -25,6 +25,7 @@
 #include "gfortran.h"
 #include "arith.h"
 #include "intrinsic.h"
+#include "match.h"
 #include "target-memory.h"
 #include "constructor.h"
 #include "version.h"	/* For version_string.  */
@@ -4641,43 +4642,48 @@
   gfc_expr *result;
   int kind;
 
-  if (a->expr_type != EXPR_CONSTANT || p->expr_type != EXPR_CONSTANT)
+  /* First check p.  */
+  if (p->expr_type != EXPR_CONSTANT)
     return NULL;
 
-  kind = a->ts.kind > p->ts.kind ? a->ts.kind : p->ts.kind;
-  result = gfc_get_constant_expr (a->ts.type, kind, &a->where);
-
-  switch (a->ts.type)
+  /* p shall not be 0.  */
+  switch (p->ts.type)
     {
       case BT_INTEGER:
 	if (mpz_cmp_ui (p->value.integer, 0) == 0)
 	  {
-	    /* Result is processor-dependent.  */
-	    gfc_error ("Second argument MOD at %L is zero", &a->where);
-	    gfc_free_expr (result);
+	    gfc_error ("Argument %qs of MOD at %L shall not be zero",
+			"P", &p->where);
 	    return &gfc_bad_expr;
 	  }
-	mpz_tdiv_r (result->value.integer, a->value.integer, p->value.integer);
 	break;
-
       case BT_REAL:
 	if (mpfr_cmp_ui (p->value.real, 0) == 0)
 	  {
-	    /* Result is processor-dependent.  */
-	    gfc_error ("Second argument of MOD at %L is zero", &p->where);
-	    gfc_free_expr (result);
+	    gfc_error ("Argument %qs of MOD at %L shall not be zero",
+			"P", &p->where);
 	    return &gfc_bad_expr;
 	  }
-
-	gfc_set_model_kind (kind);
-	mpfr_fmod (result->value.real, a->value.real, p->value.real,
-		   GFC_RND_MODE);
 	break;
-
       default:
 	gfc_internal_error ("gfc_simplify_mod(): Bad arguments");
     }
 
+  if (a->expr_type != EXPR_CONSTANT)
+    return NULL;
+
+  kind = a->ts.kind > p->ts.kind ? a->ts.kind : p->ts.kind;
+  result = gfc_get_constant_expr (a->ts.type, kind, &a->where);
+
+  if (a->ts.type == BT_INTEGER)
+    mpz_tdiv_r (result->value.integer, a->value.integer, p->value.integer);
+  else
+    {
+      gfc_set_model_kind (kind);
+      mpfr_fmod (result->value.real, a->value.real, p->value.real,
+		 GFC_RND_MODE);
+    }
+
   return range_check (result, "MOD");
 }
 
@@ -6579,11 +6585,13 @@
   unsigned char *buffer;
   size_t result_length;
 
+  if (!gfc_is_constant_expr (source) || !gfc_is_constant_expr (size))
+    return NULL;
 
-  if (!gfc_is_constant_expr (source)
-	|| (gfc_init_expr_flag && !gfc_is_constant_expr (mold))
-	|| !gfc_is_constant_expr (size))
+  if (!gfc_resolve_expr (mold))
     return NULL;
+  if (gfc_init_expr_flag && !gfc_is_constant_expr (mold))
+    return NULL;
 
   if (!gfc_calculate_transfer_sizes (source, mold, size, &source_size, 
 				     &result_size, &result_length))
@@ -7172,26 +7180,32 @@
 	{
 	  gfc_expr *tmp;
 	  if (c->iterator == NULL)
-	    tmp = f (c->expr, kind);
+	    {
+	      tmp = f (c->expr, kind);
+	      if (tmp == NULL)
+		{
+		  gfc_free_expr (result);
+		  return NULL;
+		}
+
+	      gfc_constructor_append_expr (&result->value.constructor,
+					   tmp, &c->where);
+	    }
 	  else
 	    {
+	      gfc_constructor *n;
 	      g = gfc_convert_constant (c->expr, type, kind);
-	      if (g == &gfc_bad_expr)
+	      if (g == NULL || g == &gfc_bad_expr)
 	        {
 		  gfc_free_expr (result);
 		  return g;
 		}
-	      tmp = g;
+	      n = gfc_constructor_get ();
+	      n->expr = g;
+	      n->iterator = gfc_copy_iterator (c->iterator);
+	      n->where = c->where;
+	      gfc_constructor_append (&result->value.constructor, n);
 	    }
-
-	  if (tmp == NULL)
-	    {
-	      gfc_free_expr (result);
-	      return NULL;
-	    }
-
-	  gfc_constructor_append_expr (&result->value.constructor,
-				       tmp, &c->where);
 	}
 
       break;
Index: gcc/tree-eh.h
===================================================================
diff --git a/gcc/tree-eh.h b/gcc/tree-eh.h
--- a/gcc/tree-eh.h	(revision 262353)
+++ b/gcc/tree-eh.h	(revision 262353)
@@ -37,6 +37,7 @@
 					   bool, tree, bool *);
 extern bool operation_could_trap_p (enum tree_code, bool, bool, tree);
 extern bool tree_could_trap_p (tree);
+extern tree rewrite_to_non_trapping_overflow (tree);
 extern bool stmt_could_throw_p (gimple *);
 extern bool tree_could_throw_p (tree);
 extern bool stmt_can_throw_external (gimple *);
Index: gcc/ipa-devirt.c
===================================================================
diff --git a/gcc/ipa-devirt.c b/gcc/ipa-devirt.c
--- a/gcc/ipa-devirt.c	(revision 262353)
+++ b/gcc/ipa-devirt.c	(revision 262353)
@@ -1577,8 +1577,15 @@
 				 "in another translation unit"));
 		    return false;
 		  }
-		gcc_assert (DECL_NONADDRESSABLE_P (f1)
-			    == DECL_NONADDRESSABLE_P (f2));
+		if (DECL_BIT_FIELD (f1) != DECL_BIT_FIELD (f2))
+		  {
+		    warn_odr (t1, t2, f1, f2, warn, warned,
+			      G_("one field is bitfield while other is not"));
+		    return false;
+		  }
+		else
+		  gcc_assert (DECL_NONADDRESSABLE_P (f1)
+			      == DECL_NONADDRESSABLE_P (f2));
 	      }
 
 	    /* If one aggregate has more fields than the other, they
Index: gcc/configure.ac
===================================================================
diff --git a/gcc/configure.ac b/gcc/configure.ac
--- a/gcc/configure.ac	(revision 262353)
+++ b/gcc/configure.ac	(revision 262353)
@@ -2946,6 +2946,14 @@
     [elf,2,12,0], [--fatal-warnings],
     [.section .rodata.str, "aMS", %progbits, 1])
 fi
+case "$target" in
+  i?86-*-solaris2.10* | x86_64-*-solaris2.10*)
+    # SHF_MERGE support in Solaris 10/x86 ld is broken.
+    if test x"$gnu_ld" = xno; then
+      gcc_cv_as_shf_merge=no
+    fi
+    ;;
+esac
 AC_DEFINE_UNQUOTED(HAVE_GAS_SHF_MERGE,
   [`if test $gcc_cv_as_shf_merge = yes; then echo 1; else echo 0; fi`],
 [Define 0/1 if your assembler supports marking sections with SHF_MERGE flag.])
@@ -6292,8 +6300,10 @@
 
 # Generate gcc-driver-name.h containing GCC_DRIVER_NAME for the benefit
 # of jit/jit-playback.c.
+gcc_driver_version=`eval "${get_gcc_base_ver} $srcdir/BASE-VER"`
+echo "gcc_driver_version: ${gcc_driver_version}"
 cat > gcc-driver-name.h <<EOF
-#define GCC_DRIVER_NAME "${target_noncanonical}-gcc-${gcc_BASEVER}${exeext}"
+#define GCC_DRIVER_NAME "${target_noncanonical}-gcc-${gcc_driver_version}${exeext}"
 EOF
 
 # Check whether --enable-default-pie was given.
Index: gcc/BASE-VER
===================================================================
diff --git a/gcc/BASE-VER b/gcc/BASE-VER
--- a/gcc/BASE-VER	(revision 262353)
+++ b/gcc/BASE-VER	(revision 262353)
@@ -1 +1 @@
-7.3.0
+7.3.1
Index: gcc/function.c
===================================================================
diff --git a/gcc/function.c b/gcc/function.c
--- a/gcc/function.c	(revision 262353)
+++ b/gcc/function.c	(revision 262353)
@@ -6576,8 +6576,9 @@
       /* Only do the transformation for pseudos.  */
       if (! REG_P (output)
 	  || rtx_equal_p (output, input)
-	  || (GET_MODE (input) != VOIDmode
-	      && GET_MODE (input) != GET_MODE (output)))
+	  || !(REG_P (input) || SUBREG_P (input)
+	       || MEM_P (input) || CONSTANT_P (input))
+	  || !general_operand (input, GET_MODE (output)))
 	continue;
 
       /* We can't do anything if the output is also used as input,
Index: gcc/stor-layout.c
===================================================================
diff --git a/gcc/stor-layout.c b/gcc/stor-layout.c
--- a/gcc/stor-layout.c	(revision 262353)
+++ b/gcc/stor-layout.c	(revision 262353)
@@ -1526,6 +1526,30 @@
 	= size_binop (PLUS_EXPR, rli->offset, DECL_SIZE_UNIT (field));
       rli->bitpos = bitsize_zero_node;
       rli->offset_align = MIN (rli->offset_align, desired_align);
+
+      if (!multiple_of_p (bitsizetype, DECL_SIZE (field),
+			  bitsize_int (rli->offset_align)))
+	{
+	  tree type = strip_array_types (TREE_TYPE (field));
+	  /* The above adjusts offset_align just based on the start of the
+	     field.  The field might not have a size that is a multiple of
+	     that offset_align though.  If the field is an array of fixed
+	     sized elements, assume there can be any multiple of those
+	     sizes.  If it is a variable length aggregate or array of
+	     variable length aggregates, assume worst that the end is
+	     just BITS_PER_UNIT aligned.  */
+	  if (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST)
+	    {
+	      if (TREE_INT_CST_LOW (TYPE_SIZE (type)))
+		{
+		  unsigned HOST_WIDE_INT sz
+		    = least_bit_hwi (TREE_INT_CST_LOW (TYPE_SIZE (type)));
+		  rli->offset_align = MIN (rli->offset_align, sz);
+		}
+	    }
+	  else
+	    rli->offset_align = MIN (rli->offset_align, BITS_PER_UNIT);
+	}
     }
   else if (targetm.ms_bitfield_layout_p (rli->t))
     {
Index: gcc/genmatch.c
===================================================================
diff --git a/gcc/genmatch.c b/gcc/genmatch.c
--- a/gcc/genmatch.c	(revision 262353)
+++ b/gcc/genmatch.c	(revision 262353)
@@ -2054,7 +2054,11 @@
       if (c->what
 	  && (e = dyn_cast <expr *> (c->what)))
 	{
-	  info[where].expr_p = true;
+	  /* Zero-operand expression captures like ADDR_EXPR@0 are
+	     similar as predicates -- if they are not mentioned in
+	     the result we have to force them to have no side-effects.  */
+	  if (e->ops.length () != 0)
+	    info[where].expr_p = true;
 	  info[where].force_single_use |= e->force_single_use;
 	}
     }
Index: gcc/alias.c
===================================================================
diff --git a/gcc/alias.c b/gcc/alias.c
--- a/gcc/alias.c	(revision 262353)
+++ b/gcc/alias.c	(revision 262353)
@@ -2997,7 +2997,8 @@
   int ret;
 
   gcc_checking_assert (x_canonicalized
-		       ? (x_addr != NULL_RTX && x_mode != VOIDmode)
+		       ? (x_addr != NULL_RTX
+			  && (x_mode != VOIDmode || GET_MODE (x) == VOIDmode))
 		       : (x_addr == NULL_RTX && x_mode == VOIDmode));
 
   if (MEM_VOLATILE_P (x) && MEM_VOLATILE_P (mem))
Index: gcc/tree-if-conv.c
===================================================================
diff --git a/gcc/tree-if-conv.c b/gcc/tree-if-conv.c
--- a/gcc/tree-if-conv.c	(revision 262353)
+++ b/gcc/tree-if-conv.c	(revision 262353)
@@ -2248,10 +2248,7 @@
 					 TREE_OPERAND (cond, 0),
 					 TREE_OPERAND (cond, 1));
 		  else
-		    {
-		      gcc_assert (TREE_CODE (cond) == SSA_NAME);
-		      mask = cond;
-		    }
+		    mask = cond;
 
 		  if (swap)
 		    {
Index: gcc/tree-vect-loop.c
===================================================================
diff --git a/gcc/tree-vect-loop.c b/gcc/tree-vect-loop.c
--- a/gcc/tree-vect-loop.c	(revision 262353)
+++ b/gcc/tree-vect-loop.c	(revision 262353)
@@ -50,6 +50,7 @@
 #include "cgraph.h"
 #include "tree-cfg.h"
 #include "tree-if-conv.h"
+#include "tree-eh.h"
 
 /* Loop Vectorization Pass.
 
@@ -1055,7 +1056,8 @@
 							  may_be_zero));
 	  else
 	    niter = fold_build3 (COND_EXPR, TREE_TYPE (niter), may_be_zero,
-				 build_int_cst (TREE_TYPE (niter), 0), niter);
+				 build_int_cst (TREE_TYPE (niter), 0),
+				 rewrite_to_non_trapping_overflow (niter));
 
 	  may_be_zero = NULL_TREE;
 	}
Index: gcc/loop-unroll.c
===================================================================
diff --git a/gcc/loop-unroll.c b/gcc/loop-unroll.c
--- a/gcc/loop-unroll.c	(revision 262353)
+++ b/gcc/loop-unroll.c	(revision 262353)
@@ -477,7 +477,7 @@
 
   exit_mod = niter % (max_unroll + 1);
 
-  auto_sbitmap wont_exit (max_unroll + 1);
+  auto_sbitmap wont_exit (max_unroll + 2);
   bitmap_ones (wont_exit);
 
   auto_vec<edge> remove_edges;
Index: gcc/tree-vect-data-refs.c
===================================================================
diff --git a/gcc/tree-vect-data-refs.c b/gcc/tree-vect-data-refs.c
--- a/gcc/tree-vect-data-refs.c	(revision 262353)
+++ b/gcc/tree-vect-data-refs.c	(revision 262353)
@@ -394,6 +394,16 @@
 		}
 	    }
 
+	  unsigned int step_prec = TYPE_PRECISION (TREE_TYPE (DR_STEP (dra)));
+	  if (loop->safelen < 2
+	      && !expr_not_equal_to (DR_STEP (dra), wi::zero (step_prec)))
+	    {
+	      if (dump_enabled_p ())
+		dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,
+				 "step could be zero.\n");
+	      return true;
+	    }
+
 	  continue;
 	}
 
@@ -2515,7 +2525,7 @@
       /* Allow references with zero step for outer loops marked
 	 with pragma omp simd only - it guarantees absence of
 	 loop-carried dependencies between inner loop iterations.  */
-      if (!loop->force_vectorize)
+      if (!loop->force_vectorize || loop->safelen < 2)
 	{
 	  if (dump_enabled_p ())
 	    dump_printf_loc (MSG_NOTE, vect_location,
Index: gcc/gimplify.c
===================================================================
diff --git a/gcc/gimplify.c b/gcc/gimplify.c
--- a/gcc/gimplify.c	(revision 262353)
+++ b/gcc/gimplify.c	(revision 262353)
@@ -1125,10 +1125,6 @@
 asan_poison_variable (tree decl, bool poison, gimple_stmt_iterator *it,
 		      bool before)
 {
-  /* When within an OMP context, do not emit ASAN_MARK internal fns.  */
-  if (gimplify_omp_ctxp)
-    return;
-
   tree unit_size = DECL_SIZE_UNIT (decl);
   tree base = build_fold_addr_expr (decl);
 
@@ -1640,7 +1636,8 @@
 	  && TREE_ADDRESSABLE (decl)
 	  && !TREE_STATIC (decl)
 	  && !DECL_HAS_VALUE_EXPR_P (decl)
-	  && dbg_cnt (asan_use_after_scope))
+	  && dbg_cnt (asan_use_after_scope)
+	  && !gimplify_omp_ctxp)
 	{
 	  asan_poisoned_variables->add (decl);
 	  asan_poison_variable (decl, false, seq_p);
@@ -4684,7 +4681,7 @@
 	     objects.  Initializers for such objects must explicitly set
 	     every field that needs to be set.  */
 	  cleared = false;
-	else if (!complete_p && !CONSTRUCTOR_NO_CLEARING (ctor))
+	else if (!complete_p)
 	  /* If the constructor isn't complete, clear the whole object
 	     beforehand, unless CONSTRUCTOR_NO_CLEARING is set on it.
 
@@ -4693,7 +4690,7 @@
 	     we'd need to *find* the elements that are not present, and that
 	     requires trickery to avoid quadratic compile-time behavior in
 	     large cases or excessive memory use in small cases.  */
-	  cleared = true;
+	  cleared = !CONSTRUCTOR_NO_CLEARING (ctor);
 	else if (num_ctor_elements - num_nonzero_elements
 		 > CLEAR_RATIO (optimize_function_for_speed_p (cfun))
 		 && num_nonzero_elements < num_ctor_elements / 4)
@@ -5776,8 +5773,11 @@
 	}
       else
 	/* The temporary may not be an SSA name as later abnormal and EH
-	   control flow may invalidate use/def domination.  */
-	val = get_initialized_tmp_var (val, pre_p, post_p, false);
+	   control flow may invalidate use/def domination.  When in SSA
+	   form then assume there are no such issues and SAVE_EXPRs only
+	   appear via GENERIC foldings.  */
+	val = get_initialized_tmp_var (val, pre_p, post_p,
+				       gimple_in_ssa_p (cfun));
 
       TREE_OPERAND (*expr_p, 0) = val;
       SAVE_EXPR_RESOLVED_P (*expr_p) = 1;
@@ -6458,7 +6458,8 @@
 	      clobber = build2 (MODIFY_EXPR, TREE_TYPE (temp), temp, clobber);
 	      gimple_push_cleanup (temp, clobber, false, pre_p, true);
 	    }
-	  if (asan_poisoned_variables && dbg_cnt (asan_use_after_scope))
+	  if (asan_poisoned_variables && dbg_cnt (asan_use_after_scope)
+	      && !gimplify_omp_ctxp)
 	    {
 	      tree asan_cleanup = build_asan_poison_call_expr (temp);
 	      if (asan_cleanup)
Index: gcc/lra-constraints.c
===================================================================
diff --git a/gcc/lra-constraints.c b/gcc/lra-constraints.c
--- a/gcc/lra-constraints.c	(revision 262353)
+++ b/gcc/lra-constraints.c	(revision 262353)
@@ -3724,7 +3724,13 @@
 
   curr_insn_set = single_set (curr_insn);
   if (curr_insn_set != NULL_RTX && simple_move_p ())
-    return false;
+    {
+      /* We assume that the corresponding insn alternative has no
+	 earlier clobbers.  If it is not the case, don't define move
+	 cost equal to 2 for the corresponding register classes.  */
+      lra_set_used_insn_alternative (curr_insn, LRA_NON_CLOBBERED_ALT);
+      return false;
+    }
 
   no_input_reloads_p = no_output_reloads_p = false;
   goal_alt_number = -1;
@@ -3832,7 +3838,7 @@
   if (change_p)
     /* If we've changed the instruction then any alternative that
        we chose previously may no longer be valid.  */
-    lra_set_used_insn_alternative (curr_insn, -1);
+    lra_set_used_insn_alternative (curr_insn, LRA_UNKNOWN_ALT);
 
   if (! check_only_p && curr_insn_set != NULL_RTX
       && check_and_process_move (&change_p, &sec_mem_p))
@@ -3840,7 +3846,7 @@
 
  try_swapped:
 
-  reused_alternative_num = check_only_p ? -1 : curr_id->used_insn_alternative;
+  reused_alternative_num = check_only_p ? LRA_UNKNOWN_ALT : curr_id->used_insn_alternative;
   if (lra_dump_file != NULL && reused_alternative_num >= 0)
     fprintf (lra_dump_file, "Reusing alternative %d for insn #%u\n",
 	     reused_alternative_num, INSN_UID (curr_insn));
@@ -6708,7 +6714,7 @@
 			}
 		      lra_push_insn_and_update_insn_regno_info (curr_insn);
 		      lra_set_used_insn_alternative_by_uid
-			(INSN_UID (curr_insn), -1);
+			(INSN_UID (curr_insn), LRA_UNKNOWN_ALT);
 		      done_p = true;
 		      if (lra_dump_file != NULL)
 			{
@@ -6747,7 +6753,7 @@
 		     constraints pass.  */
 		  lra_push_insn_and_update_insn_regno_info (curr_insn);
 		  lra_set_used_insn_alternative_by_uid
-		    (INSN_UID (curr_insn), -1);
+		    (INSN_UID (curr_insn), LRA_UNKNOWN_ALT);
 		}
 	      else if (restored_regs_p)
 		/* The instruction has been restored to the form that
Index: gcc/calls.c
===================================================================
diff --git a/gcc/calls.c b/gcc/calls.c
--- a/gcc/calls.c	(revision 262353)
+++ b/gcc/calls.c	(revision 262353)
@@ -1196,65 +1196,79 @@
 static tree
 alloc_max_size (void)
 {
-  if (!alloc_object_size_limit)
-    {
-      alloc_object_size_limit = TYPE_MAX_VALUE (ssizetype);
+  if (alloc_object_size_limit)
+    return alloc_object_size_limit;
 
-      if (warn_alloc_size_limit)
-	{
-	  char *end = NULL;
-	  errno = 0;
-	  unsigned HOST_WIDE_INT unit = 1;
-	  unsigned HOST_WIDE_INT limit
-	    = strtoull (warn_alloc_size_limit, &end, 10);
+  alloc_object_size_limit = TYPE_MAX_VALUE (ssizetype);
 
-	  if (!errno)
-	    {
-	      if (end && *end)
-		{
-		  /* Numeric option arguments are at most INT_MAX.  Make it
-		     possible to specify a larger value by accepting common
-		     suffixes.  */
-		  if (!strcmp (end, "kB"))
-		    unit = 1000;
-		  else if (!strcasecmp (end, "KiB") || strcmp (end, "KB"))
-		    unit = 1024;
-		  else if (!strcmp (end, "MB"))
-		    unit = HOST_WIDE_INT_UC (1000) * 1000;
-		  else if (!strcasecmp (end, "MiB"))
-		    unit = HOST_WIDE_INT_UC (1024) * 1024;
-		  else if (!strcasecmp (end, "GB"))
-		    unit = HOST_WIDE_INT_UC (1000) * 1000 * 1000;
-		  else if (!strcasecmp (end, "GiB"))
-		    unit = HOST_WIDE_INT_UC (1024) * 1024 * 1024;
-		  else if (!strcasecmp (end, "TB"))
-		    unit = HOST_WIDE_INT_UC (1000) * 1000 * 1000 * 1000;
-		  else if (!strcasecmp (end, "TiB"))
-		    unit = HOST_WIDE_INT_UC (1024) * 1024 * 1024 * 1024;
-		  else if (!strcasecmp (end, "PB"))
-		    unit = HOST_WIDE_INT_UC (1000) * 1000 * 1000 * 1000 * 1000;
-		  else if (!strcasecmp (end, "PiB"))
-		    unit = HOST_WIDE_INT_UC (1024) * 1024 * 1024 * 1024 * 1024;
-		  else if (!strcasecmp (end, "EB"))
-		    unit = HOST_WIDE_INT_UC (1000) * 1000 * 1000 * 1000 * 1000
-			   * 1000;
-		  else if (!strcasecmp (end, "EiB"))
-		    unit = HOST_WIDE_INT_UC (1024) * 1024 * 1024 * 1024 * 1024
-			   * 1024;
-		  else
-		    unit = 0;
-		}
+  if (!warn_alloc_size_limit)
+    return alloc_object_size_limit;
 
-	      if (unit)
-		{
-		  wide_int w = wi::uhwi (limit, HOST_BITS_PER_WIDE_INT + 64);
-		  w *= unit;
-		  if (wi::ltu_p (w, alloc_object_size_limit))
-		    alloc_object_size_limit = wide_int_to_tree (ssizetype, w);
-		}
-	    }
+  const char *optname = "-Walloc-size-larger-than=";
+
+  char *end = NULL;
+  errno = 0;
+  unsigned HOST_WIDE_INT unit = 1;
+  unsigned HOST_WIDE_INT limit
+    = strtoull (warn_alloc_size_limit, &end, 10);
+
+  /* If the value is too large to be represented use the maximum
+     representable value that strtoull sets limit to (setting
+     errno to ERANGE).  */
+
+  if (end && *end)
+    {
+      /* Numeric option arguments are at most INT_MAX.  Make it
+	 possible to specify a larger value by accepting common
+	 suffixes.  */
+      if (!strcmp (end, "kB"))
+	unit = 1000;
+      else if (!strcasecmp (end, "KiB") || !strcmp (end, "KB"))
+	unit = 1024;
+      else if (!strcmp (end, "MB"))
+	unit = HOST_WIDE_INT_UC (1000) * 1000;
+      else if (!strcasecmp (end, "MiB"))
+	unit = HOST_WIDE_INT_UC (1024) * 1024;
+      else if (!strcasecmp (end, "GB"))
+	unit = HOST_WIDE_INT_UC (1000) * 1000 * 1000;
+      else if (!strcasecmp (end, "GiB"))
+	unit = HOST_WIDE_INT_UC (1024) * 1024 * 1024;
+      else if (!strcasecmp (end, "TB"))
+	unit = HOST_WIDE_INT_UC (1000) * 1000 * 1000 * 1000;
+      else if (!strcasecmp (end, "TiB"))
+	unit = HOST_WIDE_INT_UC (1024) * 1024 * 1024 * 1024;
+      else if (!strcasecmp (end, "PB"))
+	unit = HOST_WIDE_INT_UC (1000) * 1000 * 1000 * 1000 * 1000;
+      else if (!strcasecmp (end, "PiB"))
+	unit = HOST_WIDE_INT_UC (1024) * 1024 * 1024 * 1024 * 1024;
+      else if (!strcasecmp (end, "EB"))
+	unit = HOST_WIDE_INT_UC (1000) * 1000 * 1000 * 1000 * 1000
+	  * 1000;
+      else if (!strcasecmp (end, "EiB"))
+	unit = HOST_WIDE_INT_UC (1024) * 1024 * 1024 * 1024 * 1024
+	  * 1024;
+      else
+	{
+	  /* This could mean an unknown suffix or a bad prefix, like
+	     "+-1".  */
+	  warning_at (UNKNOWN_LOCATION, 0,
+		      "invalid argument %qs to %qs",
+		      warn_alloc_size_limit, optname);
+	  /* Ignore the limit extracted by strtoull.  */
+	  unit = 0;
 	}
     }
+
+  if (unit)
+    {
+      widest_int w = wi::mul (limit, unit);
+      if (w < wi::to_widest (alloc_object_size_limit))
+	alloc_object_size_limit
+	  = wide_int_to_tree (ptrdiff_type_node, w);
+      else
+	alloc_object_size_limit = build_all_ones_cst (size_type_node);
+    }
+
   return alloc_object_size_limit;
 }
 
@@ -3133,9 +3147,14 @@
 	if (CALL_EXPR_RETURN_SLOT_OPT (exp)
 	    && target
 	    && MEM_P (target)
-	    && !(MEM_ALIGN (target) < TYPE_ALIGN (rettype)
-		 && SLOW_UNALIGNED_ACCESS (TYPE_MODE (rettype),
-					   MEM_ALIGN (target))))
+	    /* If rettype is addressable, we may not create a temporary.
+	       If target is properly aligned at runtime and the compiler
+	       just doesn't know about it, it will work fine, otherwise it
+	       will be UB.  */
+	    && (TREE_ADDRESSABLE (rettype)
+		|| !(MEM_ALIGN (target) < TYPE_ALIGN (rettype)
+		     && SLOW_UNALIGNED_ACCESS (TYPE_MODE (rettype),
+					       MEM_ALIGN (target)))))
 	  structure_value_addr = XEXP (target, 0);
 	else
 	  {
Index: gcc/genmodes.c
===================================================================
diff --git a/gcc/genmodes.c b/gcc/genmodes.c
--- a/gcc/genmodes.c	(revision 262353)
+++ b/gcc/genmodes.c	(revision 262353)
@@ -116,6 +116,7 @@
   switch (c)
     {
     case MODE_INT: return MODE_COMPLEX_INT;
+    case MODE_PARTIAL_INT: return MODE_COMPLEX_INT;
     case MODE_FLOAT: return MODE_COMPLEX_FLOAT;
     default:
       error ("no complex class for class %s", mode_class_names[c]);
Index: gcc/lower-subreg.c
===================================================================
diff --git a/gcc/lower-subreg.c b/gcc/lower-subreg.c
--- a/gcc/lower-subreg.c	(revision 262353)
+++ b/gcc/lower-subreg.c	(revision 262353)
@@ -490,7 +490,16 @@
 	     were the same number and size of pieces.  Hopefully this
 	     doesn't happen much.  */
 
-	  if (outer_words == 1 && inner_words > 1)
+	  if (outer_words == 1
+	      && inner_words > 1
+	      /* Don't allow to decompose floating point subregs of
+		 multi-word pseudos if the floating point mode does
+		 not have word size, because otherwise we'd generate
+		 a subreg with that floating mode from a different
+		 sized integral pseudo which is not allowed by
+		 validate_subreg.  */
+	      && (!FLOAT_MODE_P (GET_MODE (x))
+		  || outer_size == UNITS_PER_WORD))
 	    {
 	      bitmap_set_bit (decomposable_context, regno);
 	      iter.skip_subrtxes ();
Index: gcc/expmed.c
===================================================================
diff --git a/gcc/expmed.c b/gcc/expmed.c
--- a/gcc/expmed.c	(revision 262353)
+++ b/gcc/expmed.c	(revision 262353)
@@ -5886,6 +5886,18 @@
   if (tem != 0)
     return tem;
 
+  /* If one operand is constant, make it the second one.  Only do this
+     if the other operand is not constant as well.  */
+
+  if (swap_commutative_operands_p (op0, op1))
+    {
+      std::swap (op0, op1);
+      code = swap_condition (code);
+    }
+
+  if (mode == VOIDmode)
+    mode = GET_MODE (op0);
+
   if (!target)
     target = gen_reg_rtx (word_mode);
 
Index: gcc/tree-dfa.c
===================================================================
diff --git a/gcc/tree-dfa.c b/gcc/tree-dfa.c
--- a/gcc/tree-dfa.c	(revision 262353)
+++ b/gcc/tree-dfa.c	(revision 262353)
@@ -438,7 +438,7 @@
 		   referenced the last field of a struct or a union member
 		   then we have to adjust maxsize by the padding at the end
 		   of our field.  */
-		if (seen_variable_array_ref && maxsize != -1)
+		if (seen_variable_array_ref)
 		  {
 		    tree stype = TREE_TYPE (TREE_OPERAND (exp, 0));
 		    tree next = DECL_CHAIN (field);
@@ -454,7 +454,7 @@
 			    || ssize == NULL
 			    || TREE_CODE (ssize) != INTEGER_CST)
 			  maxsize = -1;
-			else
+			else if (maxsize != -1)
 			  {
 			    offset_int tem = (wi::to_offset (ssize)
 					      - wi::to_offset (fsize));
@@ -463,6 +463,11 @@
 			    maxsize += tem;
 			  }
 		      }
+		    /* An component ref with an adjacent field up in the
+		       structure hierarchy constrains the size of any variable
+		       array ref lower in the access hierarchy.  */
+		    else
+		      seen_variable_array_ref = false;
 		  }
 	      }
 	    else
@@ -617,7 +622,9 @@
 
   if (DECL_P (exp))
     {
-      if (flag_unconstrained_commons && VAR_P (exp) && DECL_COMMON (exp))
+      if (VAR_P (exp)
+	  && ((flag_unconstrained_commons && DECL_COMMON (exp))
+	      || (DECL_EXTERNAL (exp) && seen_variable_array_ref)))
 	{
 	  tree sz_tree = TYPE_SIZE (TREE_TYPE (exp));
 	  /* If size is unknown, or we have read to the end, assume there
Index: gcc/emit-rtl.c
===================================================================
diff --git a/gcc/emit-rtl.c b/gcc/emit-rtl.c
--- a/gcc/emit-rtl.c	(revision 262353)
+++ b/gcc/emit-rtl.c	(revision 262353)
@@ -5851,7 +5851,7 @@
       attrs = ggc_cleared_alloc<mem_attrs> ();
       attrs->align = BITS_PER_UNIT;
       attrs->addrspace = ADDR_SPACE_GENERIC;
-      if (mode != BLKmode)
+      if (mode != BLKmode && mode != VOIDmode)
 	{
 	  attrs->size_known_p = true;
 	  attrs->size = GET_MODE_SIZE (mode);
Index: gcc/cfgexpand.c
===================================================================
diff --git a/gcc/cfgexpand.c b/gcc/cfgexpand.c
--- a/gcc/cfgexpand.c	(revision 262353)
+++ b/gcc/cfgexpand.c	(revision 262353)
@@ -2997,14 +2997,14 @@
 
       generating_concat_p = 0;
 
-      if ((TREE_CODE (val) == INDIRECT_REF
-	   && allows_mem)
+      if ((TREE_CODE (val) == INDIRECT_REF && allows_mem)
 	  || (DECL_P (val)
 	      && (allows_mem || REG_P (DECL_RTL (val)))
 	      && ! (REG_P (DECL_RTL (val))
 		    && GET_MODE (DECL_RTL (val)) != TYPE_MODE (type)))
 	  || ! allows_reg
-	  || is_inout)
+	  || is_inout
+	  || TREE_ADDRESSABLE (type))
 	{
 	  op = expand_expr (val, NULL_RTX, VOIDmode,
 			    !allows_reg ? EXPAND_MEMORY : EXPAND_WRITE);
@@ -3013,7 +3013,7 @@
 
 	  if (! allows_reg && !MEM_P (op))
 	    error ("output number %d not directly addressable", i);
-	  if ((! allows_mem && MEM_P (op))
+	  if ((! allows_mem && MEM_P (op) && GET_MODE (op) != BLKmode)
 	      || GET_CODE (op) == CONCAT)
 	    {
 	      rtx old_op = op;
Index: gcc/simplify-rtx.c
===================================================================
diff --git a/gcc/simplify-rtx.c b/gcc/simplify-rtx.c
--- a/gcc/simplify-rtx.c	(revision 262353)
+++ b/gcc/simplify-rtx.c	(revision 262353)
@@ -3299,7 +3299,8 @@
       if (CONST_INT_P (trueop1)
 	  && exact_log2 (UINTVAL (trueop1)) > 0)
 	return simplify_gen_binary (AND, mode, op0,
-				    gen_int_mode (INTVAL (op1) - 1, mode));
+				    gen_int_mode (UINTVAL (trueop1) - 1,
+						  mode));
       break;
 
     case MOD:
Index: gcc/tree-ssa-pre.c
===================================================================
diff --git a/gcc/tree-ssa-pre.c b/gcc/tree-ssa-pre.c
--- a/gcc/tree-ssa-pre.c	(revision 262353)
+++ b/gcc/tree-ssa-pre.c	(revision 262353)
@@ -2787,11 +2787,7 @@
 	  unsigned int operand = 1;
 	  vn_reference_op_t currop = &ref->operands[0];
 	  tree sc = NULL_TREE;
-	  tree fn;
-	  if (TREE_CODE (currop->op0) == FUNCTION_DECL)
-	    fn = currop->op0;
-	  else
-	    fn = find_or_generate_expression (block, currop->op0, stmts);
+	  tree fn  = find_or_generate_expression (block, currop->op0, stmts);
 	  if (!fn)
 	    return NULL_TREE;
 	  if (currop->op1)
@@ -2809,14 +2805,27 @@
 		return NULL_TREE;
 	      args.quick_push (arg);
 	    }
-	  gcall *call
-	    = gimple_build_call_vec ((TREE_CODE (fn) == FUNCTION_DECL
-				      ? build_fold_addr_expr (fn) : fn), args);
+	  gcall *call = gimple_build_call_vec (fn, args);
 	  gimple_call_set_with_bounds (call, currop->with_bounds);
 	  if (sc)
 	    gimple_call_set_chain (call, sc);
 	  tree forcedname = make_ssa_name (currop->type);
 	  gimple_call_set_lhs (call, forcedname);
+	  /* There's no CCP pass after PRE which would re-compute alignment
+	     information so make sure we re-materialize this here.  */
+	  if (gimple_call_builtin_p (call, BUILT_IN_ASSUME_ALIGNED)
+	      && args.length () - 2 <= 1
+	      && tree_fits_uhwi_p (args[1])
+	      && (args.length () != 3 || tree_fits_uhwi_p (args[2])))
+	    {
+	      unsigned HOST_WIDE_INT halign = tree_to_uhwi (args[1]);
+	      unsigned HOST_WIDE_INT hmisalign
+		= args.length () == 3 ? tree_to_uhwi (args[2]) : 0;
+	      if ((halign & (halign - 1)) == 0
+		  && (hmisalign & ~(halign - 1)) == 0)
+		set_ptr_info_alignment (get_ptr_info (forcedname),
+					halign, hmisalign);
+	    }
 	  gimple_set_vuse (call, BB_LIVE_VOP_ON_EXIT (block));
 	  gimple_seq_add_stmt_without_update (&forced_stmts, call);
 	  folded = forcedname;
Index: gcc/lto/lto.c
===================================================================
diff --git a/gcc/lto/lto.c b/gcc/lto/lto.c
--- a/gcc/lto/lto.c	(revision 262353)
+++ b/gcc/lto/lto.c	(revision 262353)
@@ -53,6 +53,7 @@
 #include "lto-symtab.h"
 #include "stringpool.h"
 #include "fold-const.h"
+#include "builtins.h"
 
 
 /* Number of parallel tasks to run, -1 if we want to use GNU Make jobserver.  */
@@ -829,12 +830,19 @@
 register_resolution (struct lto_file_decl_data *file_data, tree decl,
 		     enum ld_plugin_symbol_resolution resolution)
 {
+  bool existed;
   if (resolution == LDPR_UNKNOWN)
     return;
   if (!file_data->resolution_map)
     file_data->resolution_map
       = new hash_map<tree, ld_plugin_symbol_resolution>;
-  file_data->resolution_map->put (decl, resolution);
+  ld_plugin_symbol_resolution_t &res
+     = file_data->resolution_map->get_or_insert (decl, &existed);
+  if (!existed
+      || resolution == LDPR_PREVAILING_DEF_IRONLY
+      || resolution == LDPR_PREVAILING_DEF
+      || resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)
+    res = resolution;
 }
 
 /* Register DECL with the global symbol table and change its
@@ -877,7 +885,19 @@
 			 decl, get_resolution (data_in, ix));
 }
 
+/* Check if T is a decl and needs register its resolution info.  */
 
+static void
+lto_maybe_register_decl (struct data_in *data_in, tree t, unsigned ix)
+{
+  if (TREE_CODE (t) == VAR_DECL)
+    lto_register_var_decl_in_symtab (data_in, t, ix);
+  else if (TREE_CODE (t) == FUNCTION_DECL
+	   && !DECL_BUILT_IN (t))
+    lto_register_function_decl_in_symtab (data_in, t, ix);
+}
+
+
 /* For the type T re-materialize it in the type variant list and
    the pointer/reference-to chains.  */
 
@@ -1607,7 +1627,10 @@
 	  /* Fixup the streamer cache with the prevailing nodes according
 	     to the tree node mapping computed by compare_tree_sccs.  */
 	  if (len == 1)
-	    streamer_tree_cache_replace_tree (cache, pscc->entries[0], from);
+	    {
+	      lto_maybe_register_decl (data_in, pscc->entries[0], from);
+	      streamer_tree_cache_replace_tree (cache, pscc->entries[0], from);
+	    }
 	  else
 	    {
 	      tree *map2 = XALLOCAVEC (tree, 2 * len);
@@ -1619,8 +1642,12 @@
 	      qsort (map2, len, 2 * sizeof (tree), cmp_tree);
 	      qsort (map, len, 2 * sizeof (tree), cmp_tree);
 	      for (unsigned i = 0; i < len; ++i)
-		streamer_tree_cache_replace_tree (cache, map[2*i],
-						  (uintptr_t)map2[2*i]);
+		{
+		  lto_maybe_register_decl (data_in, map[2*i],
+					   (uintptr_t)map2[2*i]);
+		  streamer_tree_cache_replace_tree (cache, map[2*i],
+						    (uintptr_t)map2[2*i]);
+		}
 	    }
 
 	  /* Free the tree nodes from the read SCC.  */
@@ -1759,13 +1786,7 @@
 		}
 	      if (!flag_ltrans)
 		{
-		  /* Register variables and functions with the
-		     symbol table.  */
-		  if (TREE_CODE (t) == VAR_DECL)
-		    lto_register_var_decl_in_symtab (data_in, t, from + i);
-		  else if (TREE_CODE (t) == FUNCTION_DECL
-			   && !DECL_BUILT_IN (t))
-		    lto_register_function_decl_in_symtab (data_in, t, from + i);
+		  lto_maybe_register_decl (data_in, t, from + i);
 		  /* Scan the tree for references to global functions or
 		     variables and record those for later fixup.  */
 		  if (mentions_vars_p (t))
@@ -2858,13 +2879,25 @@
 
   /* Store resolutions into the symbol table.  */
 
-  ld_plugin_symbol_resolution_t *res;
   FOR_EACH_SYMBOL (snode)
-    if (snode->real_symbol_p ()
-	&& snode->lto_file_data
-	&& snode->lto_file_data->resolution_map
-	&& (res = snode->lto_file_data->resolution_map->get (snode->decl)))
-      snode->resolution = *res;
+    if (snode->externally_visible && snode->real_symbol_p ()
+	&& snode->lto_file_data && snode->lto_file_data->resolution_map
+	&& !is_builtin_fn (snode->decl)
+	&& !(VAR_P (snode->decl) && DECL_HARD_REGISTER (snode->decl)))
+      {
+	ld_plugin_symbol_resolution_t *res;
+
+	res = snode->lto_file_data->resolution_map->get (snode->decl);
+	if (!res || *res == LDPR_UNKNOWN)
+	  {
+	    if (snode->output_to_lto_symbol_table_p ())
+	      fatal_error (input_location, "missing resolution data for %s",
+		           IDENTIFIER_POINTER
+			     (DECL_ASSEMBLER_NAME (snode->decl)));
+	  }
+	else
+          snode->resolution = *res;
+      }
   for (i = 0; all_file_decl_data[i]; i++)
     if (all_file_decl_data[i]->resolution_map)
       {
Index: gcc/lto/lto-partition.c
===================================================================
diff --git a/gcc/lto/lto-partition.c b/gcc/lto/lto-partition.c
--- a/gcc/lto/lto-partition.c	(revision 262353)
+++ b/gcc/lto/lto-partition.c	(revision 262353)
@@ -756,7 +756,8 @@
 	  if (npartitions < n_lto_partitions)
 	    partition_size = total_size / (n_lto_partitions - npartitions);
 	  else
-	    partition_size = INT_MAX;
+	    /* Watch for overflow.  */
+	    partition_size = INT_MAX / 16;
 
 	  if (partition_size < PARAM_VALUE (MIN_PARTITION_SIZE))
 	    partition_size = PARAM_VALUE (MIN_PARTITION_SIZE);
Index: gcc/lto/ChangeLog
===================================================================
diff --git a/gcc/lto/ChangeLog b/gcc/lto/ChangeLog
--- a/gcc/lto/ChangeLog	(revision 262353)
+++ b/gcc/lto/ChangeLog	(revision 262353)
@@ -1,3 +1,102 @@
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-04-19  Martin Liska  <mliska@suse.cz>
+
+	* lto-symtab.c (lto_symtab_resolve_symbols): Do not bail out
+	for multiple PREVAILING_DEF_IRONLY for common symbols.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-04-10  Martin Liska  <mliska@suse.cz>
+
+	PR lto/85248
+	* lto-symtab.c (lto_symtab_merge_p): Do not check for
+	TREE_VALUES of error attributes.
+
+2018-04-24  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-04-10  Richard Biener  <rguenther@suse.de>
+		    Martin Liska  <mliska@suse.cz>
+
+	PR lto/85248
+	* lto-symtab.c (lto_symtab_merge_p): Handle noreturn attribute.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-01-23  Martin Liska  <mliska@suse.cz>
+
+	PR lto/81440
+	* lto-symtab.c (lto_symtab_merge): Handle and do not warn about
+	trailing arrays at the end of a struct.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-08  Jan Hubicka  <hubicka@ucw.cz>
+
+	* lto-partition.c (lto_balanced_map): Watch overflow.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-08  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR ipa/81360
+	* lto.c (unify_scc): Register prevailing trees, not trees to be freed.
+	(read_cgraph_and_symbols): Use
+	symtab_node::output_to_lto_symbol_table_p.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-01-30  Jan Hubicka  <hubicka@ucw.cz>
+
+	* lto.c (register_resolution): Remove forgotten sanity check.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-01-30  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR lto/81004
+	* lto.c: Include builtins.h
+	(register_resolution): Merge resolutions in case trees was
+	merged across units.
+	(lto_maybe_register_decl): Break out from ...
+	(lto_read_decls): ... here.
+	(unify_scc): Also register decls here.
+	(read_cgraph_and_symbols): Sanity check that all resolutions was
+	read.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-02-02  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR lto/83954
+	* lto-symtab.c (warn_type_compatibility_p): Do not recurse into the
+	component type of array types with non-aliased component.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2018-01-30  Jan Hubicka  <hubicka@ucw.cz>
+
+	PR lto/83954
+	* lto-symtab.c (warn_type_compatibility_p): Silence false positive
+	for type match warning on arrays of pointers.
+
+2018-03-06  Martin Liska  <mliska@suse.cz>
+
+	Backport from mainline
+	2017-10-13  Jan Hubicka  <hubicka@ucw.cz>
+
+	* lto-lang.c (lto_post_options): Clean shlib flag when not doing PIC.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
Index: gcc/lto/lto-lang.c
===================================================================
diff --git a/gcc/lto/lto-lang.c b/gcc/lto/lto-lang.c
--- a/gcc/lto/lto-lang.c	(revision 262353)
+++ b/gcc/lto/lto-lang.c	(revision 262353)
@@ -840,11 +840,13 @@
          flag_pie is 2.  */
       flag_pie = MAX (flag_pie, flag_pic);
       flag_pic = flag_pie;
+      flag_shlib = 0;
       break;
 
     case LTO_LINKER_OUTPUT_EXEC: /* Normal executable */
       flag_pic = 0;
       flag_pie = 0;
+      flag_shlib = 0;
       break;
 
     case LTO_LINKER_OUTPUT_UNKNOWN:
Index: gcc/lto/lto-symtab.c
===================================================================
diff --git a/gcc/lto/lto-symtab.c b/gcc/lto/lto-symtab.c
--- a/gcc/lto/lto-symtab.c	(revision 262353)
+++ b/gcc/lto/lto-symtab.c	(revision 262353)
@@ -283,11 +283,25 @@
       alias_set_type set1 = get_alias_set (type);
       alias_set_type set2 = get_alias_set (prevailing_type);
 
-      if (set1 && set2 && set1 != set2 
-          && (!POINTER_TYPE_P (type) || !POINTER_TYPE_P (prevailing_type)
+      if (set1 && set2 && set1 != set2)
+	{
+          tree t1 = type, t2 = prevailing_type;
+
+	  /* Alias sets of arrays with aliased components are the same as alias
+	     sets of the inner types.  */
+	  while (TREE_CODE (t1) == ARRAY_TYPE
+		 && !TYPE_NONALIASED_COMPONENT (t1)
+		 && TREE_CODE (t2) == ARRAY_TYPE
+		 && !TYPE_NONALIASED_COMPONENT (t2))
+	    {
+	      t1 = TREE_TYPE (t1);
+	      t2 = TREE_TYPE (t2);
+	    }
+          if ((!POINTER_TYPE_P (t1) || !POINTER_TYPE_P (t2))
 	      || (set1 != TYPE_ALIAS_SET (ptr_type_node)
-		  && set2 != TYPE_ALIAS_SET (ptr_type_node))))
-        lev |= 5;
+		  && set2 != TYPE_ALIAS_SET (ptr_type_node)))
+             lev |= 5;
+	}
     }
 
   return lev;
@@ -351,7 +365,22 @@
     return false;
 
   if (DECL_SIZE (decl) && DECL_SIZE (prevailing_decl)
-      && !tree_int_cst_equal (DECL_SIZE (decl), DECL_SIZE (prevailing_decl))
+      && !tree_int_cst_equal (DECL_SIZE (decl), DECL_SIZE (prevailing_decl)))
+      {
+	if (!DECL_COMMON (decl) && !DECL_EXTERNAL (decl))
+	  return false;
+
+	tree type = TREE_TYPE (decl);
+
+	/* For record type, check for array at the end of the structure.  */
+	if (TREE_CODE (type) == RECORD_TYPE)
+	  {
+	    tree field = TYPE_FIELDS (type);
+	    while (DECL_CHAIN (field) != NULL_TREE)
+	      field = DECL_CHAIN (field);
+
+	    return TREE_CODE (TREE_TYPE (field)) == ARRAY_TYPE;
+	  }
       /* As a special case do not warn about merging
 	 int a[];
 	 and
@@ -358,11 +387,9 @@
 	 int a[]={1,2,3};
 	 here the first declaration is COMMON
 	 and sizeof(a) == sizeof (int).  */
-      && ((!DECL_COMMON (decl) && !DECL_EXTERNAL (decl))
-	  || TREE_CODE (TREE_TYPE (decl)) != ARRAY_TYPE
-	  || TYPE_SIZE (TREE_TYPE (decl))
-	     != TYPE_SIZE (TREE_TYPE (TREE_TYPE (decl)))))
-    return false;
+	else if (TREE_CODE (type) == ARRAY_TYPE)
+	  return (TYPE_SIZE (decl) == TYPE_SIZE (TREE_TYPE (type)));
+      }
 
   return true;
 }
@@ -438,9 +465,14 @@
   /* If the chain is already resolved there is nothing else to do.  */
   if (prevailing)
     {
-      /* Assert it's the only one.  */
+      /* Assert it's the only one.
+	 GCC should silence multiple PREVAILING_DEF_IRONLY defs error
+	 on COMMON symbols since it isn't error.
+	 See: https://sourceware.org/bugzilla/show_bug.cgi?id=23079.  */
       for (e = prevailing->next_sharing_asm_name; e; e = e->next_sharing_asm_name)
 	if (lto_symtab_symbol_p (e)
+	    && !DECL_COMMON (prevailing->decl)
+	    && !DECL_COMMON (e->decl)
 	    && (e->resolution == LDPR_PREVAILING_DEF_IRONLY
 		|| e->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP
 		|| e->resolution == LDPR_PREVAILING_DEF))
@@ -544,6 +576,9 @@
 	  return false;
 	}
     }
+
+  /* FIXME: after MPX is removed, use flags_from_decl_or_type
+     function instead.  PR lto/85248.  */
   if (DECL_ATTRIBUTES (prevailing) != DECL_ATTRIBUTES (decl))
     {
       tree prev_attr = lookup_attribute ("error", DECL_ATTRIBUTES (prevailing));
@@ -571,6 +606,16 @@
 		     "warning attribute mismatch\n");
 	  return false;
 	}
+
+      prev_attr = lookup_attribute ("noreturn", DECL_ATTRIBUTES (prevailing));
+      attr = lookup_attribute ("noreturn", DECL_ATTRIBUTES (decl));
+      if ((prev_attr == NULL) != (attr == NULL))
+	{
+          if (symtab->dump_file)
+	    fprintf (symtab->dump_file, "Not merging decls; "
+		     "noreturn attribute mismatch\n");
+	  return false;
+	}
     }
   return true;
 }
Index: gcc/ipa-prop.c
===================================================================
diff --git a/gcc/ipa-prop.c b/gcc/ipa-prop.c
--- a/gcc/ipa-prop.c	(revision 262353)
+++ b/gcc/ipa-prop.c	(revision 262353)
@@ -111,12 +111,13 @@
   typedef value_range *compare_type;
   static hashval_t
   hash (const value_range *p)
-  {
-    gcc_checking_assert (!p->equiv);
-    hashval_t t = (hashval_t) p->type;
-    t = iterative_hash_expr (p->min, t);
-    return iterative_hash_expr (p->max, t);
-  }
+    {
+      gcc_checking_assert (!p->equiv);
+      inchash::hash hstate (p->type);
+      hstate.add_ptr (p->min);
+      hstate.add_ptr (p->max);
+      return hstate.end ();
+    }
   static bool
   equal (const value_range *a, const value_range *b)
     {
@@ -4352,8 +4353,7 @@
 
 	  gcc_checking_assert (adj->offset % BITS_PER_UNIT == 0);
 	  base = gimple_call_arg (stmt, adj->base_index);
-	  loc = DECL_P (base) ? DECL_SOURCE_LOCATION (base)
-			      : EXPR_LOCATION (base);
+	  loc = gimple_location (stmt);
 
 	  if (TREE_CODE (base) != ADDR_EXPR
 	      && POINTER_TYPE_P (TREE_TYPE (base)))
@@ -4445,6 +4445,7 @@
 		  else
 		    expr = create_tmp_reg (TREE_TYPE (expr));
 		  gimple_assign_set_lhs (tem, expr);
+		  gimple_set_location (tem, loc);
 		  gsi_insert_before (&gsi, tem, GSI_SAME_STMT);
 		}
 	    }
Index: gcc/gimple-ssa-store-merging.c
===================================================================
diff --git a/gcc/gimple-ssa-store-merging.c b/gcc/gimple-ssa-store-merging.c
--- a/gcc/gimple-ssa-store-merging.c	(revision 262353)
+++ b/gcc/gimple-ssa-store-merging.c	(revision 262353)
@@ -812,12 +812,14 @@
 	{
 	  struct store_immediate_info *info;
 	  unsigned int i;
+	  tree store_lhs
+	    = gimple_store_p (stmt) ? gimple_get_lhs (stmt) : NULL_TREE;
 	  FOR_EACH_VEC_ELT ((*chain_info)->m_store_info, i, info)
 	    {
-	      if (ref_maybe_used_by_stmt_p (stmt,
-					    gimple_assign_lhs (info->stmt))
-		  || stmt_may_clobber_ref_p (stmt,
-					     gimple_assign_lhs (info->stmt)))
+	      tree lhs = gimple_assign_lhs (info->stmt);
+	      if (ref_maybe_used_by_stmt_p (stmt, lhs)
+		  || stmt_may_clobber_ref_p (stmt, lhs)
+		  || (store_lhs && refs_output_dependent_p (store_lhs, lhs)))
 		{
 		  if (dump_file && (dump_flags & TDF_DETAILS))
 		    {
Index: gcc/varasm.c
===================================================================
diff --git a/gcc/varasm.c b/gcc/varasm.c
--- a/gcc/varasm.c	(revision 262353)
+++ b/gcc/varasm.c	(revision 262353)
@@ -1241,10 +1241,9 @@
   if (!VAR_P (decl) && TREE_CODE (decl) != CONST_DECL)
     return false;
 
-  /* Detect decls created by dw2_force_const_mem.  Such decls are
-     special because DECL_INITIAL doesn't specify the decl's true value.
-     dw2_output_indirect_constants will instead call assemble_variable
-     with dont_output_data set to 1 and then print the contents itself.  */
+  /* DECL_INITIAL (decl) set to decl is a hack used for some decls that
+     are never used from code directly and we never want object block handling
+     for those.  */
   if (DECL_INITIAL (decl) == decl)
     return false;
 
Index: gcc/sched-deps.c
===================================================================
diff --git a/gcc/sched-deps.c b/gcc/sched-deps.c
--- a/gcc/sched-deps.c	(revision 262353)
+++ b/gcc/sched-deps.c	(revision 262353)
@@ -2851,9 +2851,11 @@
     {
       rtx insn_set = single_set (insn);
 
+      if (!insn_set)
+	return;
+
       prev = prev_nonnote_nondebug_insn (insn);
       if (!prev
-          || !insn_set
           || !single_set (prev))
         return;
 
@@ -2920,6 +2922,8 @@
 	= alloc_INSN_LIST (insn, deps->sched_before_next_jump);
 
       /* Make sure epilogue insn is scheduled after preceding jumps.  */
+      add_dependence_list (insn, deps->last_pending_memory_flush, 1,
+			   REG_DEP_ANTI, true);
       add_dependence_list (insn, deps->pending_jump_insns, 1, REG_DEP_ANTI,
 			   true);
     }
Index: gcc/tree-ssa.c
===================================================================
diff --git a/gcc/tree-ssa.c b/gcc/tree-ssa.c
--- a/gcc/tree-ssa.c	(revision 262353)
+++ b/gcc/tree-ssa.c	(revision 262353)
@@ -1423,7 +1423,8 @@
       if (! DECL_P (decl))
 	return NULL_TREE;
       if (! is_gimple_reg_type (TREE_TYPE (base))
-	  || VOID_TYPE_P (TREE_TYPE (base)))
+	  || VOID_TYPE_P (TREE_TYPE (base))
+	  || TREE_THIS_VOLATILE (decl) != TREE_THIS_VOLATILE (base))
 	return decl;
       if ((TREE_CODE (TREE_TYPE (decl)) == VECTOR_TYPE
 	   || TREE_CODE (TREE_TYPE (decl)) == COMPLEX_TYPE)
Index: gcc/tree-vect-stmts.c
===================================================================
diff --git a/gcc/tree-vect-stmts.c b/gcc/tree-vect-stmts.c
--- a/gcc/tree-vect-stmts.c	(revision 262353)
+++ b/gcc/tree-vect-stmts.c	(revision 262353)
@@ -2753,7 +2753,7 @@
       if (cfn != CFN_LAST)
 	fndecl = targetm.vectorize.builtin_vectorized_function
 	  (cfn, vectype_out, vectype_in);
-      else
+      else if (callee)
 	fndecl = targetm.vectorize.builtin_md_vectorized_function
 	  (callee, vectype_out, vectype_in);
     }
@@ -5479,15 +5479,34 @@
       /* Handle uses.  */
       if (j == 0)
 	{
-	  if (op_type == binary_op || op_type == ternary_op)
+	  if (op_type == binary_op)
 	    vect_get_vec_defs (op0, op1, stmt, &vec_oprnds0, &vec_oprnds1,
 			       slp_node, -1);
+	  else if (op_type == ternary_op)
+	    {
+	      if (slp_node)
+		{
+		  auto_vec<tree> ops(3);
+		  ops.quick_push (op0);
+		  ops.quick_push (op1);
+		  ops.quick_push (op2);
+		  auto_vec<vec<tree> > vec_defs(3);
+		  vect_get_slp_defs (ops, slp_node, &vec_defs, -1);
+		  vec_oprnds0 = vec_defs[0];
+		  vec_oprnds1 = vec_defs[1];
+		  vec_oprnds2 = vec_defs[2];
+		}
+	      else
+		{ 
+		  vect_get_vec_defs (op0, op1, stmt, &vec_oprnds0, &vec_oprnds1,
+				     NULL, -1);
+		  vect_get_vec_defs (op2, NULL_TREE, stmt, &vec_oprnds2, NULL,
+				     NULL, -1);
+		}
+	    }
 	  else
 	    vect_get_vec_defs (op0, NULL_TREE, stmt, &vec_oprnds0, NULL,
 			       slp_node, -1);
-	  if (op_type == ternary_op)
-	    vect_get_vec_defs (op2, NULL_TREE, stmt, &vec_oprnds2, NULL,
-			       slp_node, -1);
 	}
       else
 	{
Index: gcc/tree-inline.c
===================================================================
diff --git a/gcc/tree-inline.c b/gcc/tree-inline.c
--- a/gcc/tree-inline.c	(revision 262353)
+++ b/gcc/tree-inline.c	(revision 262353)
@@ -57,6 +57,7 @@
 #include "cfgloop.h"
 #include "builtins.h"
 #include "tree-chkp.h"
+#include "attribs.h"
 
 
 /* I'm not real happy about this, but we need to handle gimple and
@@ -1182,6 +1183,7 @@
 	      *tp = gimple_fold_indirect_ref (ptr);
 	      if (! *tp)
 	        {
+		  type = remap_type (type, id);
 		  if (TREE_CODE (ptr) == ADDR_EXPR)
 		    {
 		      *tp
@@ -6024,6 +6026,25 @@
       = copy_arguments_for_versioning (DECL_ARGUMENTS (old_decl), &id,
 				       args_to_skip, &vars);
 
+  /* Remove omp declare simd attribute from the new attributes.  */
+  if (tree a = lookup_attribute ("omp declare simd",
+				 DECL_ATTRIBUTES (new_decl)))
+    {
+      while (tree a2 = lookup_attribute ("omp declare simd", TREE_CHAIN (a)))
+	a = a2;
+      a = TREE_CHAIN (a);
+      for (tree *p = &DECL_ATTRIBUTES (new_decl); *p != a;)
+	if (is_attribute_p ("omp declare simd", get_attribute_name (*p)))
+	  *p = TREE_CHAIN (*p);
+	else
+	  {
+	    tree chain = TREE_CHAIN (*p);
+	    *p = copy_node (*p);
+	    p = &TREE_CHAIN (*p);
+	    *p = chain;
+	  }
+    }
+
   DECL_INITIAL (new_decl) = remap_blocks (DECL_INITIAL (id.src_fn), &id);
   BLOCK_SUPERCONTEXT (DECL_INITIAL (new_decl)) = new_decl;
 
Index: gcc/symtab.c
===================================================================
diff --git a/gcc/symtab.c b/gcc/symtab.c
--- a/gcc/symtab.c	(revision 262353)
+++ b/gcc/symtab.c	(revision 262353)
@@ -35,6 +35,7 @@
 #include "output.h"
 #include "ipa-utils.h"
 #include "calls.h"
+#include "builtins.h"
 
 static const char *ipa_ref_use_name[] = {"read","write","addr","alias","chkp"};
 
@@ -2279,3 +2280,58 @@
 
   return false;
 }
+
+/* Return true if symbol should be output to the symbol table.  */
+
+bool
+symtab_node::output_to_lto_symbol_table_p (void)
+{
+  /* Only externally visible symbols matter.  */
+  if (!TREE_PUBLIC (decl))
+    return false;
+  if (!real_symbol_p ())
+    return false;
+  /* FIXME: variables probably should not be considered as real symbols at
+     first place.  */
+  if (VAR_P (decl) && DECL_HARD_REGISTER (decl))
+    return false;
+  /* FIXME: Builtins corresponding to real functions probably should have
+     symbol table entries.  */
+  if (is_builtin_fn (decl))
+    return false;
+
+  /* We have real symbol that should be in symbol table.  However try to trim
+     down the refernces to libraries bit more because linker will otherwise
+     bring unnecesary object files into the final link.
+     FIXME: The following checks can easily be confused i.e. by self recursive
+     function or self-referring variable.  */
+
+  /* We keep external functions in symtab for sake of inlining
+     and devirtualization.  We do not want to see them in symbol table as
+     references unless they are really used.  */
+  cgraph_node *cnode = dyn_cast <cgraph_node *> (this);
+  if (cnode && (!definition || DECL_EXTERNAL (decl))
+      && cnode->callers)
+    return true;
+
+ /* Ignore all references from external vars initializers - they are not really
+    part of the compilation unit until they are used by folding.  Some symbols,
+    like references to external construction vtables can not be referred to at
+    all.  We decide this at can_refer_decl_in_current_unit_p.  */
+ if (!definition || DECL_EXTERNAL (decl))
+    {
+      int i;
+      struct ipa_ref *ref;
+      for (i = 0; iterate_referring (i, ref); i++)
+	{
+	  if (ref->use == IPA_REF_ALIAS)
+	    continue;
+          if (is_a <cgraph_node *> (ref->referring))
+	    return true;
+	  if (!DECL_EXTERNAL (ref->referring->decl))
+	    return true;
+	}
+      return false;
+    }
+  return true;
+}
Index: gcc/tree-ssa-phiprop.c
===================================================================
diff --git a/gcc/tree-ssa-phiprop.c b/gcc/tree-ssa-phiprop.c
--- a/gcc/tree-ssa-phiprop.c	(revision 262353)
+++ b/gcc/tree-ssa-phiprop.c	(revision 262353)
@@ -270,6 +270,7 @@
   use_operand_p arg_p, use;
   ssa_op_iter i;
   bool phi_inserted;
+  bool changed;
   tree type = NULL_TREE;
 
   if (!POINTER_TYPE_P (TREE_TYPE (ptr))
@@ -317,6 +318,7 @@
   /* Replace the first dereference of *ptr if there is one and if we
      can move the loads to the place of the ptr phi node.  */
   phi_inserted = false;
+  changed = false;
   FOR_EACH_IMM_USE_STMT (use_stmt, ui, ptr)
     {
       gimple *def_stmt;
@@ -403,7 +405,7 @@
 	  unlink_stmt_vdef (use_stmt);
 	  gsi_remove (&gsi, true);
 
-	  phi_inserted = true;
+	  changed = true;
 	}
 
       /* Found a proper dereference.  Insert a phi node if this
@@ -424,6 +426,7 @@
 	  gsi_remove (&gsi, true);
 
 	  phi_inserted = true;
+	  changed = true;
 	}
       else
 	{
@@ -431,6 +434,7 @@
 	     load.  */
 	  gimple_assign_set_rhs1 (use_stmt, res);
 	  update_stmt (use_stmt);
+	  changed = true;
 	}
 
 next:;
@@ -437,7 +441,7 @@
       /* Continue searching for a proper dereference.  */
     }
 
-  return phi_inserted;
+  return changed;
 }
 
 /* Main entry for phiprop pass.  */
Index: gcc/combine.c
===================================================================
diff --git a/gcc/combine.c b/gcc/combine.c
--- a/gcc/combine.c	(revision 262353)
+++ b/gcc/combine.c	(revision 262353)
@@ -5482,11 +5482,15 @@
 		    x = gen_rtx_CLOBBER (mode, const0_rtx);
 		}
 	      else if (CONST_SCALAR_INT_P (new_rtx)
-		       && GET_CODE (x) == ZERO_EXTEND)
+		       && (GET_CODE (x) == ZERO_EXTEND
+			   || GET_CODE (x) == FLOAT
+			   || GET_CODE (x) == UNSIGNED_FLOAT))
 		{
-		  x = simplify_unary_operation (ZERO_EXTEND, GET_MODE (x),
-						new_rtx, GET_MODE (XEXP (x, 0)));
-		  gcc_assert (x);
+		  x = simplify_unary_operation (GET_CODE (x), GET_MODE (x),
+						new_rtx,
+						GET_MODE (XEXP (x, 0)));
+		  if (!x)
+		    return gen_rtx_CLOBBER (VOIDmode, const0_rtx);
 		}
 	      else
 		SUBST (XEXP (x, i), new_rtx);
@@ -5637,7 +5641,11 @@
 	  /* If everything is a comparison, what we have is highly unlikely
 	     to be simpler, so don't use it.  */
 	  && ! (COMPARISON_P (x)
-		&& (COMPARISON_P (true_rtx) || COMPARISON_P (false_rtx))))
+		&& (COMPARISON_P (true_rtx) || COMPARISON_P (false_rtx)))
+	  /* Similarly, if we end up with one of the expressions the same
+	     as the original, it is certainly not simpler.  */
+	  && ! rtx_equal_p (x, true_rtx)
+	  && ! rtx_equal_p (x, false_rtx))
 	{
 	  rtx cop1 = const0_rtx;
 	  enum rtx_code cond_code = simplify_comparison (NE, &cond, &cop1);
@@ -11322,8 +11330,15 @@
 	    x = gen_rtx_LSHIFTRT (inner_mode, XEXP (x, 0), GEN_INT (start));
 	  else
 	    x = XEXP (x, 0);
+
 	  if (mode != inner_mode)
-	    x = gen_lowpart_SUBREG (mode, x);
+	    {
+	      if (REG_P (x) && HARD_REGISTER_P (x)
+		  && !can_change_dest_mode (x, 0, mode))
+		continue;
+
+	      x = gen_lowpart_SUBREG (mode, x);
+	    }
 	}
       else if (GET_CODE (x) == ZERO_EXTEND
 	       && SCALAR_INT_MODE_P (mode)
@@ -11335,7 +11350,13 @@
 	  size = GET_MODE_PRECISION (GET_MODE (XEXP (x, 0)));
 	  x = SUBREG_REG (XEXP (x, 0));
 	  if (GET_MODE (x) != mode)
-	    x = gen_lowpart_SUBREG (mode, x);
+	    {
+	      if (REG_P (x) && HARD_REGISTER_P (x)
+		  && !can_change_dest_mode (x, 0, mode))
+		continue;
+
+	      x = gen_lowpart_SUBREG (mode, x);
+	    }
 	}
       else if (GET_CODE (x) == ZERO_EXTEND
 	       && SCALAR_INT_MODE_P (mode)
@@ -13081,8 +13102,11 @@
   if (REG_P (dest))
     {
       /* If we are setting the whole register, we know its value.  Otherwise
-	 show that we don't know the value.  We can handle SUBREG in
-	 some cases.  */
+	 show that we don't know the value.  We can handle a SUBREG if it's
+	 the low part, but we must be careful with paradoxical SUBREGs on
+	 RISC architectures because we cannot strip e.g. an extension around
+	 a load and record the naked load since the RTL middle-end considers
+	 that the upper bits are defined according to LOAD_EXTEND_OP.  */
       if (GET_CODE (setter) == SET && dest == SET_DEST (setter))
 	record_value_for_reg (dest, record_dead_insn, SET_SRC (setter));
       else if (GET_CODE (setter) == SET
@@ -13091,8 +13115,11 @@
 	       && GET_MODE_PRECISION (GET_MODE (dest)) <= BITS_PER_WORD
 	       && subreg_lowpart_p (SET_DEST (setter)))
 	record_value_for_reg (dest, record_dead_insn,
-			      gen_lowpart (GET_MODE (dest),
-						       SET_SRC (setter)));
+			      WORD_REGISTER_OPERATIONS
+			      && paradoxical_subreg_p (SET_DEST (setter))
+			      ? SET_SRC (setter)
+			      : gen_lowpart (GET_MODE (dest),
+					     SET_SRC (setter)));
       else
 	record_value_for_reg (dest, record_dead_insn, NULL_RTX);
     }
Index: gcc/hsa-gen.c
===================================================================
diff --git a/gcc/hsa-gen.c b/gcc/hsa-gen.c
--- a/gcc/hsa-gen.c	(revision 262353)
+++ b/gcc/hsa-gen.c	(revision 262353)
@@ -917,9 +917,13 @@
 	  else if (lookup_attribute ("hsa_group_segment",
 				     DECL_ATTRIBUTES (decl)))
 	    segment = BRIG_SEGMENT_GROUP;
-	  else if (TREE_STATIC (decl)
-		   || lookup_attribute ("hsa_global_segment",
-					DECL_ATTRIBUTES (decl)))
+	  else if (TREE_STATIC (decl))
+	    {
+	      segment = BRIG_SEGMENT_GLOBAL;
+	      allocation = BRIG_ALLOCATION_PROGRAM;
+	    }
+	  else if (lookup_attribute ("hsa_global_segment",
+				     DECL_ATTRIBUTES (decl)))
 	    segment = BRIG_SEGMENT_GLOBAL;
 	  else
 	    segment = BRIG_SEGMENT_PRIVATE;
Index: gcc/config.gcc
===================================================================
diff --git a/gcc/config.gcc b/gcc/config.gcc
--- a/gcc/config.gcc	(revision 262353)
+++ b/gcc/config.gcc	(revision 262353)
@@ -1461,7 +1461,7 @@
 	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h newlib-stdint.h i386/i386elf.h i386/x86-64.h"
 	;;
 x86_64-*-rtems*)
-	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h newlib-stdint.h i386/i386elf.h i386/x86-64.h i386/rtemself.h"
+	tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h newlib-stdint.h i386/i386elf.h i386/x86-64.h i386/rtemself.h rtems.h"
 	;;
 i[34567]86-*-rdos*)
     tm_file="${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h newlib-stdint.h i386/i386elf.h i386/rdos.h"
@@ -2046,10 +2046,17 @@
 	;;
 riscv*-*-elf* | riscv*-*-rtems*)
 	tm_file="elfos.h newlib-stdint.h ${tm_file} riscv/elf.h"
-	case "x${enable_multilib}" in
-	xno) ;;
-	xyes) tmake_file="${tmake_file} riscv/t-elf-multilib" ;;
-	*) echo "Unknown value for enable_multilib"; exit 1
+	case ${target} in
+	*-*-rtems*)
+	  tm_file="${tm_file} rtems.h riscv/rtems.h"
+	  tmake_file="${tmake_file} riscv/t-rtems"
+	  ;;
+	*)
+	  case "x${enable_multilib}" in
+	  xno) ;;
+	  xyes) tmake_file="${tmake_file} riscv/t-elf-multilib" ;;
+	  *) echo "Unknown value for enable_multilib"; exit 1
+	  esac
 	esac
 	tmake_file="${tmake_file} riscv/t-riscv"
 	gnu_ld=yes
@@ -2057,11 +2064,6 @@
 	# Force .init_array support.  The configure script cannot always
 	# automatically detect that GAS supports it, yet we require it.
 	gcc_cv_initfini_array=yes
-	case ${target} in
-	riscv*-*-rtems*)
-	  tm_file="${tm_file} rtems.h riscv/rtems.h"
-	  ;;
-	esac
 	;;
 mips*-*-netbsd*)			# NetBSD/mips, either endian.
 	target_cpu_default="MASK_ABICALLS"
Index: gcc/tree-ssa-reassoc.c
===================================================================
diff --git a/gcc/tree-ssa-reassoc.c b/gcc/tree-ssa-reassoc.c
--- a/gcc/tree-ssa-reassoc.c	(revision 262353)
+++ b/gcc/tree-ssa-reassoc.c	(revision 262353)
@@ -470,7 +470,8 @@
 
 /* We want integer ones to end up last no matter what, since they are
    the ones we can do the most with.  */
-#define INTEGER_CONST_TYPE 1 << 3
+#define INTEGER_CONST_TYPE 1 << 4
+#define FLOAT_ONE_CONST_TYPE 1 << 3
 #define FLOAT_CONST_TYPE 1 << 2
 #define OTHER_CONST_TYPE 1 << 1
 
@@ -482,7 +483,14 @@
   if (INTEGRAL_TYPE_P (TREE_TYPE (t)))
     return INTEGER_CONST_TYPE;
   else if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (t)))
-    return FLOAT_CONST_TYPE;
+    {
+      /* Sort -1.0 and 1.0 constants last, while in some cases
+	 const_binop can't optimize some inexact operations, multiplication
+	 by -1.0 or 1.0 can be always merged with others.  */
+      if (real_onep (t) || real_minus_onep (t))
+	return FLOAT_ONE_CONST_TYPE;
+      return FLOAT_CONST_TYPE;
+    }
   else
     return OTHER_CONST_TYPE;
 }
@@ -501,7 +509,7 @@
   if (oeb->rank == 0 && oea->rank == 0)
     {
       if (constant_type (oeb->op) != constant_type (oea->op))
-	return constant_type (oeb->op) - constant_type (oea->op);
+	return constant_type (oea->op) - constant_type (oeb->op);
       else
 	/* To make sorting result stable, we use unique IDs to determine
 	   order.  */
@@ -2870,7 +2878,8 @@
 static bool
 optimize_range_tests_var_bound (enum tree_code opcode, int first, int length,
 				vec<operand_entry *> *ops,
-				struct range_entry *ranges)
+				struct range_entry *ranges,
+				basic_block first_bb)
 {
   int i;
   bool any_changes = false;
@@ -2967,6 +2976,60 @@
       if (idx == NULL)
 	continue;
 
+      /* maybe_optimize_range_tests allows statements without side-effects
+	 in the basic blocks as long as they are consumed in the same bb.
+	 Make sure rhs2's def stmt is not among them, otherwise we can't
+	 use safely get_nonzero_bits on it.  E.g. in:
+	  # RANGE [-83, 1] NONZERO 173
+	  # k_32 = PHI <k_47(13), k_12(9)>
+	 ...
+	  if (k_32 >= 0)
+	    goto <bb 5>; [26.46%]
+	  else
+	    goto <bb 9>; [73.54%]
+
+	  <bb 5> [local count: 140323371]:
+	  # RANGE [0, 1] NONZERO 1
+	  _5 = (int) k_32;
+	  # RANGE [0, 4] NONZERO 4
+	  _21 = _5 << 2;
+	  # RANGE [0, 4] NONZERO 4
+	  iftmp.0_44 = (char) _21;
+	  if (k_32 < iftmp.0_44)
+	    goto <bb 6>; [84.48%]
+	  else
+	    goto <bb 9>; [15.52%]
+	 the ranges on _5/_21/iftmp.0_44 are flow sensitive, assume that
+	 k_32 >= 0.  If we'd optimize k_32 >= 0 to true and k_32 < iftmp.0_44
+	 to (unsigned) k_32 < (unsigned) iftmp.0_44, then we would execute
+	 those stmts even for negative k_32 and the value ranges would be no
+	 longer guaranteed and so the optimization would be invalid.  */
+      if (opcode == ERROR_MARK)
+	{
+	  gimple *g = SSA_NAME_DEF_STMT (rhs2);
+	  basic_block bb2 = gimple_bb (g);
+	  if (bb2
+	      && bb2 != first_bb
+	      && dominated_by_p (CDI_DOMINATORS, bb2, first_bb))
+	    {
+	      /* As an exception, handle a few common cases.  */
+	      if (gimple_assign_cast_p (g)
+		  && INTEGRAL_TYPE_P (TREE_TYPE (gimple_assign_rhs1 (g)))
+		  && TYPE_UNSIGNED (TREE_TYPE (gimple_assign_rhs1 (g)))
+		  && (TYPE_PRECISION (TREE_TYPE (rhs2))
+		      > TYPE_PRECISION (TREE_TYPE (gimple_assign_rhs1 (g)))))
+		/* Zero-extension is always ok.  */ ;
+	      else if (is_gimple_assign (g)
+		       && gimple_assign_rhs_code (g) == BIT_AND_EXPR
+		       && TREE_CODE (gimple_assign_rhs2 (g)) == INTEGER_CST
+		       && !wi::neg_p (gimple_assign_rhs2 (g)))
+		/* Masking with INTEGER_CST with MSB clear is always ok
+		   too.  */ ;
+	      else
+		continue;
+	    }
+	}
+
       wide_int nz = get_nonzero_bits (rhs2);
       if (wi::neg_p (nz))
 	continue;
@@ -3093,11 +3156,12 @@
    maybe_optimize_range_tests for inter-bb range optimization.
    In that case if oe->op is NULL, oe->id is bb->index whose
    GIMPLE_COND is && or ||ed into the test, and oe->rank says
-   the actual opcode.  */
+   the actual opcode.
+   FIRST_BB is the first basic block if OPCODE is ERROR_MARK.  */
 
 static bool
 optimize_range_tests (enum tree_code opcode,
-		      vec<operand_entry *> *ops)
+		      vec<operand_entry *> *ops, basic_block first_bb)
 {
   unsigned int length = ops->length (), i, j, first;
   operand_entry *oe;
@@ -3175,7 +3239,7 @@
     any_changes |= optimize_range_tests_to_bit_test (opcode, first, length,
 						     ops, ranges);
   any_changes |= optimize_range_tests_var_bound (opcode, first, length, ops,
-						 ranges);
+						 ranges, first_bb);
 
   if (any_changes && opcode != ERROR_MARK)
     {
@@ -3922,7 +3986,7 @@
 	break;
     }
   if (ops.length () > 1)
-    any_changes = optimize_range_tests (ERROR_MARK, &ops);
+    any_changes = optimize_range_tests (ERROR_MARK, &ops, first_bb);
   if (any_changes)
     {
       unsigned int idx, max_idx = 0;
@@ -5674,7 +5738,7 @@
 		  if (is_vector)
 		    optimize_vec_cond_expr (rhs_code, &ops);
 		  else
-		    optimize_range_tests (rhs_code, &ops);
+		    optimize_range_tests (rhs_code, &ops, NULL);
 	        }
 
 	      if (rhs_code == MULT_EXPR && !is_vector)
Index: gcc/config/nvptx/nvptx.c
===================================================================
diff --git a/gcc/config/nvptx/nvptx.c b/gcc/config/nvptx/nvptx.c
--- a/gcc/config/nvptx/nvptx.c	(revision 262353)
+++ b/gcc/config/nvptx/nvptx.c	(revision 262353)
@@ -1875,9 +1875,15 @@
   
   if (sym)
     {
-      fprintf (asm_out_file, "generic(");
+      bool function = (SYMBOL_REF_DECL (sym)
+		       && (TREE_CODE (SYMBOL_REF_DECL (sym)) == FUNCTION_DECL));
+      if (!function)
+	fprintf (asm_out_file, "generic(");
       output_address (VOIDmode, sym);
-      fprintf (asm_out_file, val ? ") + " : ")");
+      if (!function)
+	fprintf (asm_out_file, ")");
+      if (val)
+	fprintf (asm_out_file, " + ");
     }
 
   if (!sym || val)
@@ -2002,6 +2008,9 @@
 nvptx_assemble_decl_begin (FILE *file, const char *name, const char *section,
 			   const_tree type, HOST_WIDE_INT size, unsigned align)
 {
+  bool atype = (TREE_CODE (type) == ARRAY_TYPE)
+    && (TYPE_DOMAIN (type) == NULL_TREE);
+
   while (TREE_CODE (type) == ARRAY_TYPE)
     type = TREE_TYPE (type);
 
@@ -2041,6 +2050,8 @@
     /* We make everything an array, to simplify any initialization
        emission.  */
     fprintf (file, "[" HOST_WIDE_INT_PRINT_DEC "]", init_frag.remaining);
+  else if (atype)
+    fprintf (file, "[]");
 }
 
 /* Called when the initializer for a decl has been completely output through
Index: gcc/config/alpha/alpha.md
===================================================================
diff --git a/gcc/config/alpha/alpha.md b/gcc/config/alpha/alpha.md
--- a/gcc/config/alpha/alpha.md	(revision 262353)
+++ b/gcc/config/alpha/alpha.md	(revision 262353)
@@ -4915,7 +4915,7 @@
 
 
 ;; Subroutine of stack space allocation.  Perform a stack probe.
-(define_expand "probe_stack"
+(define_expand "stack_probe_internal"
   [(set (match_dup 1) (match_operand:DI 0 "const_int_operand"))]
   ""
 {
@@ -4950,12 +4950,14 @@
 
 	  int probed = 4096;
 
-	  emit_insn (gen_probe_stack (GEN_INT (- probed)));
+	  emit_insn (gen_stack_probe_internal (GEN_INT (- probed)));
 	  while (probed + 8192 < INTVAL (operands[1]))
-	    emit_insn (gen_probe_stack (GEN_INT (- (probed += 8192))));
+	    emit_insn (gen_stack_probe_internal
+		       (GEN_INT (- (probed += 8192))));
 
 	  if (probed + 4096 < INTVAL (operands[1]))
-	    emit_insn (gen_probe_stack (GEN_INT (- INTVAL(operands[1]))));
+	    emit_insn (gen_stack_probe_internal
+		       (GEN_INT (- INTVAL(operands[1]))));
 	}
 
       operands[1] = GEN_INT (- INTVAL (operands[1]));
Index: gcc/config/alpha/alpha.c
===================================================================
diff --git a/gcc/config/alpha/alpha.c b/gcc/config/alpha/alpha.c
--- a/gcc/config/alpha/alpha.c	(revision 262353)
+++ b/gcc/config/alpha/alpha.c	(revision 262353)
@@ -7750,13 +7750,13 @@
 	  int probed;
 
 	  for (probed = 4096; probed < probed_size; probed += 8192)
-	    emit_insn (gen_probe_stack (GEN_INT (-probed)));
+	    emit_insn (gen_stack_probe_internal (GEN_INT (-probed)));
 
 	  /* We only have to do this probe if we aren't saving registers or
 	     if we are probing beyond the frame because of -fstack-check.  */
 	  if ((sa_size == 0 && probed_size > probed - 4096)
 	      || flag_stack_check)
-	    emit_insn (gen_probe_stack (GEN_INT (-probed_size)));
+	    emit_insn (gen_stack_probe_internal (GEN_INT (-probed_size)));
 	}
 
       if (frame_size != 0)
Index: gcc/config/s390/s390.md
===================================================================
diff --git a/gcc/config/s390/s390.md b/gcc/config/s390/s390.md
--- a/gcc/config/s390/s390.md	(revision 262353)
+++ b/gcc/config/s390/s390.md	(revision 262353)
@@ -89,6 +89,7 @@
    UNSPEC_LTREF
    UNSPEC_INSN
    UNSPEC_EXECUTE
+   UNSPEC_EXECUTE_JUMP
 
    ; Atomic Support
    UNSPEC_MB
@@ -302,6 +303,8 @@
   [
    ; Sibling call register.
    (SIBCALL_REGNUM		 1)
+   ; A call-clobbered reg which can be used in indirect branch thunks
+   (INDIRECT_BRANCH_THUNK_REGNUM 1)
    ; Literal pool base register.
    (BASE_REGNUM			13)
    ; Return address register.
@@ -471,7 +474,10 @@
                          z196_cracked"
              (const_string "none"))
 
-(define_attr "mnemonic" "bcr_flush,unknown" (const_string "unknown"))
+; mnemonics which only get defined through if_then_else currently
+; don't get added to the list values automatically and hence need to
+; be listed here.
+(define_attr "mnemonic" "b,bas,bc,bcr_flush,unknown" (const_string "unknown"))
 
 ;; Length in bytes.
 
@@ -9069,7 +9075,7 @@
           (match_operator 1 "s390_comparison" [(reg CC_REGNUM) (const_int 0)])
           (match_operand 0 "address_operand" "ZQZR")
           (pc)))]
-  ""
+  "!TARGET_INDIRECT_BRANCH_NOBP_JUMP"
 {
   if (get_attr_op_type (insn) == OP_TYPE_RR)
     return "b%C1r\t%0";
@@ -9079,6 +9085,9 @@
   [(set (attr "op_type")
         (if_then_else (match_operand 0 "register_operand" "")
                       (const_string "RR") (const_string "RX")))
+   (set (attr "mnemonic")
+        (if_then_else (match_operand 0 "register_operand" "")
+                      (const_string "bcr") (const_string "bc")))
    (set_attr "type"  "branch")
    (set_attr "atype" "agen")])
 
@@ -9090,8 +9099,26 @@
           (ANY_RETURN)
           (pc)))]
   "s390_can_use_<code>_insn ()"
-  "b%C0r\t%%r14"
-  [(set_attr "op_type" "RR")
+{
+  if (TARGET_INDIRECT_BRANCH_NOBP_RET)
+    {
+      s390_indirect_branch_via_thunk (RETURN_REGNUM,
+				      INVALID_REGNUM,
+				      operands[0],
+				      s390_indirect_branch_type_return);
+      return "";
+    }
+  else
+    return "b%C0r\t%%r14";
+}
+  [(set (attr "op_type")
+	(if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_RET")
+		      (const_string "RIL")
+		      (const_string "RR")))
+   (set (attr "mnemonic")
+	(if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_RET")
+		      (const_string "brcl")
+		      (const_string "bcr")))
    (set_attr "type"  "jsr")
    (set_attr "atype" "agen")])
 
@@ -9144,7 +9171,7 @@
           (match_operator 1 "s390_comparison" [(reg CC_REGNUM) (const_int 0)])
           (pc)
           (match_operand 0 "address_operand" "ZQZR")))]
-  ""
+  "!TARGET_INDIRECT_BRANCH_NOBP_JUMP"
 {
   if (get_attr_op_type (insn) == OP_TYPE_RR)
     return "b%D1r\t%0";
@@ -9154,6 +9181,9 @@
   [(set (attr "op_type")
         (if_then_else (match_operand 0 "register_operand" "")
                       (const_string "RR") (const_string "RX")))
+   (set (attr "mnemonic")
+        (if_then_else (match_operand 0 "register_operand" "")
+                      (const_string "bcr") (const_string "bc")))
    (set_attr "type"  "branch")
    (set_attr "atype" "agen")])
 
@@ -9658,22 +9688,145 @@
     ;
   else
     operands[0] = force_reg (Pmode, operands[0]);
+
+  if (TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK)
+    {
+      operands[0] = force_reg (Pmode, operands[0]);
+      if (TARGET_CPU_Z10)
+	{
+	  if (TARGET_64BIT)
+	    emit_jump_insn (gen_indirect_jump_via_thunkdi_z10 (operands[0]));
+	  else
+	    emit_jump_insn (gen_indirect_jump_via_thunksi_z10 (operands[0]));
+	}
+      else
+	{
+	  if (TARGET_64BIT)
+	    emit_jump_insn (gen_indirect_jump_via_thunkdi (operands[0]));
+	  else
+	    emit_jump_insn (gen_indirect_jump_via_thunksi (operands[0]));
+	}
+      DONE;
+    }
+
+  if (TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK)
+    {
+      operands[0] = force_reg (Pmode, operands[0]);
+      rtx label_ref = gen_rtx_LABEL_REF (VOIDmode, gen_label_rtx ());
+      if (TARGET_CPU_Z10)
+	{
+	  if (TARGET_64BIT)
+	    emit_jump_insn (gen_indirect_jump_via_inlinethunkdi_z10 (operands[0],
+								     label_ref));
+	  else
+	    emit_jump_insn (gen_indirect_jump_via_inlinethunksi_z10 (operands[0],
+								     label_ref));
+	}
+      else
+	{
+	  if (TARGET_64BIT)
+	    emit_jump_insn (gen_indirect_jump_via_inlinethunkdi (operands[0],
+								 label_ref,
+								 force_reg (Pmode, label_ref)));
+	  else
+	    emit_jump_insn (gen_indirect_jump_via_inlinethunksi (operands[0],
+								 label_ref,
+								 force_reg (Pmode, label_ref)));
+	}
+      DONE;
+    }
 })
 
-; The first constraint must be an "extra address constraint" in order
-; to trigger address reloading in LRA/reload
 (define_insn "*indirect_jump"
   [(set (pc)
-	(match_operand 0 "address_operand" "ZR,a"))]
- ""
- "@
-  b\t%a0
-  br\t%0"
- [(set_attr "op_type" "RX,RR")
+	(match_operand 0 "address_operand" "ZR"))]
+ "!TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK"
+{
+  if (get_attr_op_type (insn) == OP_TYPE_RR)
+    return "br\t%0";
+  else
+    return "b\t%a0";
+}
+ [(set (attr "op_type")
+       (if_then_else (match_operand 0 "register_operand" "")
+		     (const_string "RR") (const_string "RX")))
+  (set (attr "mnemonic")
+       (if_then_else (match_operand 0 "register_operand" "")
+		     (const_string "br") (const_string "b")))
   (set_attr "type"  "branch")
-  (set_attr "atype" "agen")
-  (set_attr "cpu_facility" "*")])
+  (set_attr "atype" "agen")])
 
+(define_insn "indirect_jump_via_thunk<mode>_z10"
+  [(set (pc)
+	(match_operand:P 0 "register_operand" "a"))]
+ "TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK
+  && TARGET_CPU_Z10"
+{
+  s390_indirect_branch_via_thunk (REGNO (operands[0]),
+				  INVALID_REGNUM,
+				  NULL_RTX,
+				  s390_indirect_branch_type_jump);
+  return "";
+}
+ [(set_attr "op_type"  "RIL")
+  (set_attr "mnemonic" "jg")
+  (set_attr "type"  "branch")
+  (set_attr "atype" "agen")])
+
+(define_insn "indirect_jump_via_thunk<mode>"
+  [(set (pc)
+	(match_operand:P 0 "register_operand" " a"))
+   (clobber (reg:P INDIRECT_BRANCH_THUNK_REGNUM))]
+ "TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK
+  && !TARGET_CPU_Z10"
+{
+  s390_indirect_branch_via_thunk (REGNO (operands[0]),
+				  INVALID_REGNUM,
+				  NULL_RTX,
+				  s390_indirect_branch_type_jump);
+  return "";
+}
+ [(set_attr "op_type"  "RIL")
+  (set_attr "mnemonic" "jg")
+  (set_attr "type"  "branch")
+  (set_attr "atype" "agen")])
+
+
+; The label_ref is wrapped into an if_then_else in order to hide it
+; from mark_jump_label.  Without this the label_ref would become the
+; ONLY jump target of that jump breaking the control flow graph.
+(define_insn "indirect_jump_via_inlinethunk<mode>_z10"
+  [(unspec [(if_then_else (match_operand:P 1 "larl_operand" "X")
+			  (const_int 0)
+			  (const_int 0))
+	    (const_int 0)] UNSPEC_EXECUTE_JUMP)
+   (set (pc) (match_operand:P 0 "register_operand" "a"))]
+  "TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK
+   && TARGET_CPU_Z10"
+{
+  s390_indirect_branch_via_inline_thunk (operands[1]);
+  return "";
+}
+  [(set_attr "op_type" "RIL")
+   (set_attr "type"    "branch")
+   (set_attr "length"  "10")])
+
+(define_insn "indirect_jump_via_inlinethunk<mode>"
+  [(unspec [(if_then_else (match_operand:P 1 "larl_operand" "X")
+			  (const_int 0)
+			  (const_int 0))
+	    (match_operand:P 2 "register_operand" "a")] UNSPEC_EXECUTE_JUMP)
+   (set (pc) (match_operand:P 0 "register_operand" "a"))]
+  "TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK
+   && !TARGET_CPU_Z10"
+{
+  s390_indirect_branch_via_inline_thunk (operands[2]);
+  return "";
+}
+  [(set_attr "op_type" "RX")
+   (set_attr "type"    "branch")
+   (set_attr "length"  "8")])
+
 ; FIXME: LRA does not appear to be able to deal with MEMs being
 ; checked against address constraints like ZR above.  So make this a
 ; separate pattern for now.
@@ -9680,7 +9833,7 @@
 (define_insn "*indirect2_jump"
   [(set (pc)
 	(match_operand 0 "nonimmediate_operand" "a,T"))]
- ""
+ "!TARGET_INDIRECT_BRANCH_NOBP_JUMP"
  "@
   br\t%0
   bi\t%0"
@@ -9693,11 +9846,74 @@
 ; casesi instruction pattern(s).
 ;
 
-(define_insn "casesi_jump"
- [(set (pc) (match_operand 0 "address_operand" "ZR"))
-   (use (label_ref (match_operand 1 "" "")))]
+(define_expand "casesi_jump"
+  [(parallel
+    [(set (pc) (match_operand 0 "address_operand"))
+     (use (label_ref (match_operand 1 "")))])]
   ""
 {
+  if (TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK)
+    {
+      operands[0] = force_reg (GET_MODE (operands[0]), operands[0]);
+
+      if (TARGET_CPU_Z10)
+	{
+	  if (TARGET_64BIT)
+	    emit_jump_insn (gen_casesi_jump_via_thunkdi_z10 (operands[0],
+							     operands[1]));
+	  else
+	    emit_jump_insn (gen_casesi_jump_via_thunksi_z10 (operands[0],
+							     operands[1]));
+	}
+      else
+	{
+	  if (TARGET_64BIT)
+	    emit_jump_insn (gen_casesi_jump_via_thunkdi (operands[0],
+							 operands[1]));
+	  else
+	    emit_jump_insn (gen_casesi_jump_via_thunksi (operands[0],
+							 operands[1]));
+	}
+      DONE;
+    }
+
+    if (TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK)
+    {
+      operands[0] = force_reg (Pmode, operands[0]);
+      rtx label_ref = gen_rtx_LABEL_REF (VOIDmode, gen_label_rtx ());
+      if (TARGET_CPU_Z10)
+	{
+	  if (TARGET_64BIT)
+	    emit_jump_insn (gen_casesi_jump_via_inlinethunkdi_z10 (operands[0],
+								   operands[1],
+								   label_ref));
+	  else
+	    emit_jump_insn (gen_casesi_jump_via_inlinethunksi_z10 (operands[0],
+								   operands[1],
+								   label_ref));
+	}
+      else
+	{
+	  if (TARGET_64BIT)
+	    emit_jump_insn (gen_casesi_jump_via_inlinethunkdi (operands[0],
+							       operands[1],
+							       label_ref,
+							       force_reg (Pmode, label_ref)));
+	  else
+	    emit_jump_insn (gen_casesi_jump_via_inlinethunksi (operands[0],
+							       operands[1],
+							       label_ref,
+							       force_reg (Pmode, label_ref)));
+	}
+      DONE;
+    }
+})
+
+(define_insn "*casesi_jump"
+ [(set (pc) (match_operand 0 "address_operand" "ZR"))
+  (use (label_ref (match_operand 1 "" "")))]
+ "!TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK"
+{
   if (get_attr_op_type (insn) == OP_TYPE_RR)
     return "br\t%0";
   else
@@ -9706,9 +9922,85 @@
   [(set (attr "op_type")
         (if_then_else (match_operand 0 "register_operand" "")
                       (const_string "RR") (const_string "RX")))
+   (set (attr "mnemonic")
+        (if_then_else (match_operand 0 "register_operand" "")
+                      (const_string "br") (const_string "b")))
    (set_attr "type"  "branch")
    (set_attr "atype" "agen")])
 
+(define_insn "casesi_jump_via_thunk<mode>_z10"
+ [(set (pc) (match_operand:P 0 "register_operand" "a"))
+  (use (label_ref (match_operand 1 "" "")))]
+ "TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK
+  && TARGET_CPU_Z10"
+{
+  s390_indirect_branch_via_thunk (REGNO (operands[0]),
+				  INVALID_REGNUM,
+				  NULL_RTX,
+				  s390_indirect_branch_type_jump);
+  return "";
+}
+  [(set_attr "op_type" "RIL")
+   (set_attr "mnemonic" "jg")
+   (set_attr "type"  "branch")
+   (set_attr "atype" "agen")])
+
+(define_insn "casesi_jump_via_thunk<mode>"
+ [(set (pc) (match_operand:P 0 "register_operand" "a"))
+  (use (label_ref (match_operand 1 "" "")))
+  (clobber (reg:P INDIRECT_BRANCH_THUNK_REGNUM))]
+ "TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK
+  && !TARGET_CPU_Z10"
+{
+  s390_indirect_branch_via_thunk (REGNO (operands[0]),
+				  INVALID_REGNUM,
+				  NULL_RTX,
+				  s390_indirect_branch_type_jump);
+  return "";
+}
+  [(set_attr "op_type" "RIL")
+   (set_attr "mnemonic" "jg")
+   (set_attr "type"  "branch")
+   (set_attr "atype" "agen")])
+
+
+; The label_ref is wrapped into an if_then_else in order to hide it
+; from mark_jump_label.  Without this the label_ref would become the
+; ONLY jump target of that jump breaking the control flow graph.
+(define_insn "casesi_jump_via_inlinethunk<mode>_z10"
+  [(unspec [(if_then_else (match_operand:P 2 "larl_operand" "X")
+			  (const_int 0)
+			  (const_int 0))
+	    (const_int 0)] UNSPEC_EXECUTE_JUMP)
+   (set (pc) (match_operand:P 0 "register_operand" "a"))
+   (use (label_ref (match_operand 1 "" "")))]
+  "TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK
+   && TARGET_CPU_Z10"
+{
+  s390_indirect_branch_via_inline_thunk (operands[2]);
+  return "";
+}
+  [(set_attr "op_type" "RIL")
+   (set_attr "type"    "cs")
+   (set_attr "length"  "10")])
+
+(define_insn "casesi_jump_via_inlinethunk<mode>"
+  [(unspec [(if_then_else (match_operand:P 2 "larl_operand" "X")
+			  (const_int 0)
+			  (const_int 0))
+	    (match_operand:P 3 "register_operand" "a")] UNSPEC_EXECUTE_JUMP)
+   (set (pc) (match_operand:P 0 "register_operand" "a"))
+   (use (label_ref (match_operand 1 "" "")))]
+  "TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK
+   && !TARGET_CPU_Z10"
+{
+  s390_indirect_branch_via_inline_thunk (operands[3]);
+  return "";
+}
+  [(set_attr "op_type" "RX")
+   (set_attr "type"    "cs")
+   (set_attr "length"  "8")])
+
 (define_expand "casesi"
   [(match_operand:SI 0 "general_operand" "")
    (match_operand:SI 1 "general_operand" "")
@@ -9813,8 +10105,27 @@
          (match_operand 0 "const_int_operand" "n"))]
   "SIBLING_CALL_P (insn)
    && GET_MODE (XEXP (XEXP (PATTERN (insn), 0), 0)) == Pmode"
-  "br\t%%r1"
-  [(set_attr "op_type" "RR")
+{
+  if (TARGET_INDIRECT_BRANCH_NOBP_CALL)
+    {
+      gcc_assert (TARGET_CPU_Z10);
+      s390_indirect_branch_via_thunk (SIBCALL_REGNUM,
+				      INVALID_REGNUM,
+				      NULL_RTX,
+				      s390_indirect_branch_type_call);
+      return "";
+    }
+  else
+    return "br\t%%r1";
+}
+ [(set (attr "op_type")
+       (if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_CALL")
+		     (const_string "RIL")
+		     (const_string "RR")))
+  (set (attr "mnemonic")
+       (if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_CALL")
+		     (const_string "jg")
+		     (const_string "br")))
    (set_attr "type"  "branch")
    (set_attr "atype" "agen")])
 
@@ -9854,8 +10165,27 @@
 	      (match_operand 1 "const_int_operand" "n")))]
   "SIBLING_CALL_P (insn)
    && GET_MODE (XEXP (XEXP (XEXP (PATTERN (insn), 1), 0), 0)) == Pmode"
-  "br\t%%r1"
-  [(set_attr "op_type" "RR")
+{
+  if (TARGET_INDIRECT_BRANCH_NOBP_CALL)
+    {
+      gcc_assert (TARGET_CPU_Z10);
+      s390_indirect_branch_via_thunk (SIBCALL_REGNUM,
+				      INVALID_REGNUM,
+				      NULL_RTX,
+				      s390_indirect_branch_type_call);
+      return "";
+    }
+  else
+    return "br\t%%r1";
+}
+  [(set (attr "op_type")
+       (if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_CALL")
+		     (const_string "RIL")
+		     (const_string "RR")))
+   (set (attr "mnemonic")
+       (if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_CALL")
+		     (const_string "jg")
+		     (const_string "br")))
    (set_attr "type"  "branch")
    (set_attr "atype" "agen")])
 
@@ -9921,7 +10251,9 @@
   [(call (mem:QI (match_operand 0 "address_operand" "ZR"))
          (match_operand 1 "const_int_operand" "n"))
    (clobber (match_operand 2 "register_operand" "=r"))]
-  "!SIBLING_CALL_P (insn) && GET_MODE (operands[2]) == Pmode"
+  "!TARGET_INDIRECT_BRANCH_NOBP_CALL
+   && !SIBLING_CALL_P (insn)
+   && GET_MODE (operands[2]) == Pmode"
 {
   if (get_attr_op_type (insn) == OP_TYPE_RR)
     return "basr\t%2,%0";
@@ -9931,10 +10263,54 @@
   [(set (attr "op_type")
         (if_then_else (match_operand 0 "register_operand" "")
                       (const_string "RR") (const_string "RX")))
+   (set (attr "mnemonic")
+        (if_then_else (match_operand 0 "register_operand" "")
+                      (const_string "basr") (const_string "bas")))
    (set_attr "type"  "jsr")
    (set_attr "atype" "agen")
    (set_attr "z196prop" "z196_cracked")])
 
+(define_insn "*basr_via_thunk<mode>_z10"
+  [(call (mem:QI (match_operand:P 0 "register_operand" "a"))
+         (match_operand 1 "const_int_operand"          "n"))
+   (clobber (match_operand:P 2 "register_operand"    "=&r"))]
+  "TARGET_INDIRECT_BRANCH_NOBP_CALL
+   && TARGET_CPU_Z10
+   && !SIBLING_CALL_P (insn)"
+{
+  s390_indirect_branch_via_thunk (REGNO (operands[0]),
+				  REGNO (operands[2]),
+				  NULL_RTX,
+				  s390_indirect_branch_type_call);
+  return "";
+}
+  [(set_attr "op_type" "RIL")
+   (set_attr "mnemonic" "brasl")
+   (set_attr "type"  "jsr")
+   (set_attr "atype" "agen")
+   (set_attr "z196prop" "z196_cracked")])
+
+(define_insn "*basr_via_thunk<mode>"
+  [(call (mem:QI (match_operand:P 0 "register_operand" "a"))
+         (match_operand 1 "const_int_operand"          "n"))
+   (clobber (match_operand:P 2 "register_operand"    "=&r"))
+   (clobber (reg:P INDIRECT_BRANCH_THUNK_REGNUM))]
+  "TARGET_INDIRECT_BRANCH_NOBP_CALL
+   && !TARGET_CPU_Z10
+   && !SIBLING_CALL_P (insn)"
+{
+  s390_indirect_branch_via_thunk (REGNO (operands[0]),
+				  REGNO (operands[2]),
+				  NULL_RTX,
+				  s390_indirect_branch_type_call);
+  return "";
+}
+  [(set_attr "op_type" "RIL")
+   (set_attr "mnemonic" "brasl")
+   (set_attr "type"  "jsr")
+   (set_attr "atype" "agen")
+   (set_attr "z196prop" "z196_cracked")])
+
 ;
 ; call_value instruction pattern(s).
 ;
@@ -9982,7 +10358,9 @@
         (call (mem:QI (match_operand 1 "address_operand" "ZR"))
               (match_operand 2 "const_int_operand" "n")))
    (clobber (match_operand 3 "register_operand" "=r"))]
-  "!SIBLING_CALL_P (insn) && GET_MODE (operands[3]) == Pmode"
+  "!TARGET_INDIRECT_BRANCH_NOBP_CALL
+   && !SIBLING_CALL_P (insn)
+   && GET_MODE (operands[3]) == Pmode"
 {
   if (get_attr_op_type (insn) == OP_TYPE_RR)
     return "basr\t%3,%1";
@@ -9992,10 +10370,58 @@
   [(set (attr "op_type")
         (if_then_else (match_operand 1 "register_operand" "")
                       (const_string "RR") (const_string "RX")))
+   (set (attr "mnemonic")
+        (if_then_else (match_operand 1 "register_operand" "")
+                      (const_string "basr") (const_string "bas")))
    (set_attr "type"  "jsr")
    (set_attr "atype" "agen")
    (set_attr "z196prop" "z196_cracked")])
 
+(define_insn "*basr_r_via_thunk_z10"
+  [(set (match_operand 0 "" "")
+        (call (mem:QI (match_operand 1 "register_operand" "a"))
+              (match_operand 2 "const_int_operand"        "n")))
+   (clobber (match_operand 3 "register_operand"         "=&r"))]
+  "TARGET_INDIRECT_BRANCH_NOBP_CALL
+   && TARGET_CPU_Z10
+   && !SIBLING_CALL_P (insn)
+   && GET_MODE (operands[3]) == Pmode"
+{
+  s390_indirect_branch_via_thunk (REGNO (operands[1]),
+				  REGNO (operands[3]),
+				  NULL_RTX,
+				  s390_indirect_branch_type_call);
+  return "";
+}
+  [(set_attr "op_type" "RIL")
+   (set_attr "mnemonic" "brasl")
+   (set_attr "type"  "jsr")
+   (set_attr "atype" "agen")
+   (set_attr "z196prop" "z196_cracked")])
+
+(define_insn "*basr_r_via_thunk"
+  [(set (match_operand 0 "" "")
+        (call (mem:QI (match_operand 1 "register_operand" "a"))
+              (match_operand 2 "const_int_operand"        "n")))
+   (clobber (match_operand 3 "register_operand"         "=&r"))
+   (clobber (reg:P INDIRECT_BRANCH_THUNK_REGNUM))]
+  "TARGET_INDIRECT_BRANCH_NOBP_CALL
+   && !TARGET_CPU_Z10
+   && !SIBLING_CALL_P (insn)
+   && GET_MODE (operands[3]) == Pmode"
+{
+  s390_indirect_branch_via_thunk (REGNO (operands[1]),
+				  REGNO (operands[3]),
+				  NULL_RTX,
+				  s390_indirect_branch_type_call);
+  return "";
+}
+  [(set_attr "op_type" "RIL")
+   (set_attr "mnemonic"  "brasl")
+   (set_attr "type"  "jsr")
+   (set_attr "atype" "agen")
+   (set_attr "z196prop" "z196_cracked")])
+
 ;;
 ;;- Thread-local storage support.
 ;;
@@ -10737,21 +11163,105 @@
 (define_insn "<code>"
   [(ANY_RETURN)]
   "s390_can_use_<code>_insn ()"
-  "br\t%%r14"
-  [(set_attr "op_type" "RR")
+{
+  if (TARGET_INDIRECT_BRANCH_NOBP_RET)
+    {
+      /* The target is always r14 so there is no clobber
+	 of r1 needed for pre z10 targets.  */
+      s390_indirect_branch_via_thunk (RETURN_REGNUM,
+				      INVALID_REGNUM,
+				      NULL_RTX,
+				      s390_indirect_branch_type_return);
+      return "";
+    }
+  else
+    return "br\t%%r14";
+}
+  [(set (attr "op_type")
+	(if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_RET")
+		      (const_string "RIL")
+		      (const_string "RR")))
+   (set (attr "mnemonic")
+	(if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_RET")
+		      (const_string "jg")
+		      (const_string "br")))
    (set_attr "type"    "jsr")
    (set_attr "atype"   "agen")])
 
-(define_insn "*return"
+
+(define_expand "return_use"
+  [(parallel
+    [(return)
+     (use (match_operand 0 "register_operand" "a"))])]
+  ""
+{
+  if (!TARGET_CPU_Z10
+      && TARGET_INDIRECT_BRANCH_NOBP_RET_OPTION)
+    {
+      if (TARGET_64BIT)
+        emit_jump_insn (gen_returndi_prez10 (operands[0]));
+      else
+        emit_jump_insn (gen_returnsi_prez10 (operands[0]));
+      DONE;
+    }
+})
+
+(define_insn "*return<mode>"
   [(return)
-   (use (match_operand 0 "register_operand" "a"))]
-  "GET_MODE (operands[0]) == Pmode"
-  "br\t%0"
-  [(set_attr "op_type" "RR")
+   (use (match_operand:P 0 "register_operand" "a"))]
+  "TARGET_CPU_Z10 || !TARGET_INDIRECT_BRANCH_NOBP_RET_OPTION"
+{
+  if (TARGET_INDIRECT_BRANCH_NOBP_RET)
+    {
+      s390_indirect_branch_via_thunk (REGNO (operands[0]),
+                                      INVALID_REGNUM,
+                                      NULL_RTX,
+                                      s390_indirect_branch_type_return);
+      return "";
+    }
+  else
+    return "br\t%0";
+}
+  [(set (attr "op_type")
+       (if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_RET")
+                     (const_string "RIL")
+                     (const_string "RR")))
+   (set (attr "mnemonic")
+       (if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_RET")
+                     (const_string "jg")
+                     (const_string "br")))
    (set_attr "type"    "jsr")
    (set_attr "atype"   "agen")])
 
+(define_insn "return<mode>_prez10"
+  [(return)
+   (use (match_operand:P 0 "register_operand" "a"))
+   (clobber (reg:P INDIRECT_BRANCH_THUNK_REGNUM))]
+  "!TARGET_CPU_Z10 && TARGET_INDIRECT_BRANCH_NOBP_RET_OPTION"
+{
+  if (TARGET_INDIRECT_BRANCH_NOBP_RET)
+    {
+      s390_indirect_branch_via_thunk (REGNO (operands[0]),
+                                      INVALID_REGNUM,
+                                      NULL_RTX,
+                                      s390_indirect_branch_type_return);
+      return "";
+    }
+  else
+    return "br\t%0";
+}
+  [(set (attr "op_type")
+       (if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_RET")
+                     (const_string "RIL")
+                     (const_string "RR")))
+   (set (attr "mnemonic")
+       (if_then_else (match_test "TARGET_INDIRECT_BRANCH_NOBP_RET")
+                     (const_string "jg")
+                     (const_string "br")))
+   (set_attr "type"    "jsr")
+   (set_attr "atype"   "agen")])
 
+
 ;; Instruction definition to extend a 31-bit pointer into a 64-bit
 ;; pointer. This is used for compatibility.
 
Index: gcc/config/s390/s390.opt
===================================================================
diff --git a/gcc/config/s390/s390.opt b/gcc/config/s390/s390.opt
--- a/gcc/config/s390/s390.opt	(revision 262353)
+++ b/gcc/config/s390/s390.opt	(revision 262353)
@@ -229,3 +229,62 @@
 mlra
 Target Report Var(s390_lra_flag) Init(1) Save
 Use LRA instead of reload.
+
+mindirect-branch=
+Target Report RejectNegative Joined Enum(indirect_branch) Var(s390_indirect_branch) Init(indirect_branch_keep)
+Wrap all indirect branches into execute in order to disable branch
+prediction.
+
+mindirect-branch-jump=
+Target Report RejectNegative Joined Enum(indirect_branch) Var(s390_indirect_branch_jump) Init(indirect_branch_keep)
+Wrap indirect table jumps and computed gotos into execute in order to
+disable branch prediction.  Using thunk or thunk-extern with this
+option requires the thunks to be considered signal handlers to order to
+generate correct CFI.  For environments where unwinding (e.g. for
+exceptions) is required please use thunk-inline instead.
+
+mindirect-branch-call=
+Target Report RejectNegative Joined Enum(indirect_branch) Var(s390_indirect_branch_call) Init(indirect_branch_keep)
+Wrap all indirect calls into execute in order to disable branch prediction.
+
+mfunction-return=
+Target Report RejectNegative Joined Enum(indirect_branch) Var(s390_function_return) Init(indirect_branch_keep)
+Wrap all indirect return branches into execute in order to disable branch
+prediction.
+
+mfunction-return-mem=
+Target Report RejectNegative Joined Enum(indirect_branch) Var(s390_function_return_mem) Init(indirect_branch_keep)
+Wrap indirect return branches into execute in order to disable branch
+prediction. This affects only branches where the return address is
+going to be restored from memory.
+
+mfunction-return-reg=
+Target Report RejectNegative Joined Enum(indirect_branch) Var(s390_function_return_reg) Init(indirect_branch_keep)
+Wrap indirect return branches into execute in order to disable branch
+prediction. This affects only branches where the return address
+doesn't need to be restored from memory.
+
+Enum
+Name(indirect_branch) Type(enum indirect_branch)
+Known indirect branch choices (for use with the -mindirect-branch=/-mfunction-return= options):
+
+EnumValue
+Enum(indirect_branch) String(keep) Value(indirect_branch_keep)
+
+EnumValue
+Enum(indirect_branch) String(thunk) Value(indirect_branch_thunk)
+
+EnumValue
+Enum(indirect_branch) String(thunk-inline) Value(indirect_branch_thunk_inline)
+
+EnumValue
+Enum(indirect_branch) String(thunk-extern) Value(indirect_branch_thunk_extern)
+
+mindirect-branch-table
+Target Report Var(s390_indirect_branch_table) Init(TARGET_DEFAULT_INDIRECT_BRANCH_TABLE)
+Generate sections .s390_indirect_jump, .s390_indirect_call,
+.s390_return_reg, and .s390_return_mem to contain the indirect branch
+locations which have been patched as part of using one of the
+-mindirect-branch* or -mfunction-return* options.  The sections
+consist of an array of 32 bit elements. Each entry holds the offset
+from the entry to the patched location.
Index: gcc/config/s390/s390-builtin-types.def
===================================================================
diff --git a/gcc/config/s390/s390-builtin-types.def b/gcc/config/s390/s390-builtin-types.def
--- a/gcc/config/s390/s390-builtin-types.def	(revision 262353)
+++ b/gcc/config/s390/s390-builtin-types.def	(revision 262353)
@@ -124,6 +124,7 @@
 DEF_OPAQUE_VECTOR_TYPE (BT_BV4SI, BT_BINT, 4)
 DEF_FN_TYPE_0 (BT_FN_INT, BT_INT)
 DEF_FN_TYPE_0 (BT_FN_UINT, BT_UINT)
+DEF_FN_TYPE_0 (BT_FN_VOID, BT_VOID)
 DEF_FN_TYPE_1 (BT_FN_INT_INT, BT_INT, BT_INT)
 DEF_FN_TYPE_1 (BT_FN_INT_VOIDPTR, BT_INT, BT_VOIDPTR)
 DEF_FN_TYPE_1 (BT_FN_OV4SI_INT, BT_OV4SI, BT_INT)
Index: gcc/config/s390/s390-opts.h
===================================================================
diff --git a/gcc/config/s390/s390-opts.h b/gcc/config/s390/s390-opts.h
--- a/gcc/config/s390/s390-opts.h	(revision 262353)
+++ b/gcc/config/s390/s390-opts.h	(revision 262353)
@@ -43,4 +43,13 @@
   PROCESSOR_max
 };
 
+
+/* Values for -mindirect-branch and -mfunction-return options.  */
+enum indirect_branch {
+  indirect_branch_unset = 0,
+  indirect_branch_keep,
+  indirect_branch_thunk,
+  indirect_branch_thunk_inline,
+  indirect_branch_thunk_extern
+};
 #endif
Index: gcc/config/s390/s390-protos.h
===================================================================
diff --git a/gcc/config/s390/s390-protos.h b/gcc/config/s390/s390-protos.h
--- a/gcc/config/s390/s390-protos.h	(revision 262353)
+++ b/gcc/config/s390/s390-protos.h	(revision 262353)
@@ -53,6 +53,7 @@
 extern int s390_cannot_change_mode_class (machine_mode, machine_mode,
 					  enum reg_class);
 extern bool s390_function_arg_vector (machine_mode, const_tree);
+extern bool s390_return_addr_from_memory(void);
 #if S390_USE_TARGET_ATTRIBUTE
 extern tree s390_valid_target_attribute_tree (tree args,
 					      struct gcc_options *opts,
@@ -147,6 +148,17 @@
 extern bool s390_extzv_shift_ok (int, int, unsigned HOST_WIDE_INT);
 extern void s390_asm_output_function_label (FILE *, const char *, tree);
 
+enum s390_indirect_branch_type
+  {
+    s390_indirect_branch_type_jump = 0,
+    s390_indirect_branch_type_call,
+    s390_indirect_branch_type_return
+  };
+extern void s390_indirect_branch_via_thunk (unsigned int regno,
+					    unsigned int return_addr_regno,
+					    rtx comparison_operator,
+					    enum s390_indirect_branch_type type);
+extern void s390_indirect_branch_via_inline_thunk (rtx execute_target);
 #endif /* RTX_CODE */
 
 /* s390-c.c routines */
Index: gcc/config/s390/s390.c
===================================================================
diff --git a/gcc/config/s390/s390.c b/gcc/config/s390/s390.c
--- a/gcc/config/s390/s390.c	(revision 262353)
+++ b/gcc/config/s390/s390.c	(revision 262353)
@@ -377,84 +377,6 @@
   bool literal_pool;
 };
 
-/* The following structure is embedded in the machine
-   specific part of struct function.  */
-
-struct GTY (()) s390_frame_layout
-{
-  /* Offset within stack frame.  */
-  HOST_WIDE_INT gprs_offset;
-  HOST_WIDE_INT f0_offset;
-  HOST_WIDE_INT f4_offset;
-  HOST_WIDE_INT f8_offset;
-  HOST_WIDE_INT backchain_offset;
-
-  /* Number of first and last gpr where slots in the register
-     save area are reserved for.  */
-  int first_save_gpr_slot;
-  int last_save_gpr_slot;
-
-  /* Location (FP register number) where GPRs (r0-r15) should
-     be saved to.
-      0 - does not need to be saved at all
-     -1 - stack slot  */
-#define SAVE_SLOT_NONE   0
-#define SAVE_SLOT_STACK -1
-  signed char gpr_save_slots[16];
-
-  /* Number of first and last gpr to be saved, restored.  */
-  int first_save_gpr;
-  int first_restore_gpr;
-  int last_save_gpr;
-  int last_restore_gpr;
-
-  /* Bits standing for floating point registers. Set, if the
-     respective register has to be saved. Starting with reg 16 (f0)
-     at the rightmost bit.
-     Bit 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
-     fpr 15 13 11  9 14 12 10  8  7  5  3  1  6  4  2  0
-     reg 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16  */
-  unsigned int fpr_bitmap;
-
-  /* Number of floating point registers f8-f15 which must be saved.  */
-  int high_fprs;
-
-  /* Set if return address needs to be saved.
-     This flag is set by s390_return_addr_rtx if it could not use
-     the initial value of r14 and therefore depends on r14 saved
-     to the stack.  */
-  bool save_return_addr_p;
-
-  /* Size of stack frame.  */
-  HOST_WIDE_INT frame_size;
-};
-
-/* Define the structure for the machine field in struct function.  */
-
-struct GTY(()) machine_function
-{
-  struct s390_frame_layout frame_layout;
-
-  /* Literal pool base register.  */
-  rtx base_reg;
-
-  /* True if we may need to perform branch splitting.  */
-  bool split_branches_pending_p;
-
-  bool has_landing_pad_p;
-
-  /* True if the current function may contain a tbegin clobbering
-     FPRs.  */
-  bool tbegin_p;
-
-  /* For -fsplit-stack support: A stack local which holds a pointer to
-     the stack arguments for a function with a variable number of
-     arguments.  This is set at the start of the function and is used
-     to initialize the overflow_arg_area field of the va_list
-     structure.  */
-  rtx split_stack_varargs_pointer;
-};
-
 /* Few accessor macros for struct cfun->machine->s390_frame_layout.  */
 
 #define cfun_frame_layout (cfun->machine->frame_layout)
@@ -495,7 +417,34 @@
    bytes on a z10 (or higher) CPU.  */
 #define PREDICT_DISTANCE (TARGET_Z10 ? 384 : 2048)
 
+/* Masks per jump target register indicating which thunk need to be
+   generated.  */
+static GTY(()) int indirect_branch_prez10thunk_mask = 0;
+static GTY(()) int indirect_branch_z10thunk_mask = 0;
 
+#define INDIRECT_BRANCH_NUM_OPTIONS 4
+
+enum s390_indirect_branch_option
+  {
+    s390_opt_indirect_branch_jump = 0,
+    s390_opt_indirect_branch_call,
+    s390_opt_function_return_reg,
+    s390_opt_function_return_mem
+  };
+
+static GTY(()) int indirect_branch_table_label_no[INDIRECT_BRANCH_NUM_OPTIONS] = { 0 };
+const char *indirect_branch_table_label[INDIRECT_BRANCH_NUM_OPTIONS] = \
+  { "LJUMP", "LCALL", "LRETREG", "LRETMEM" };
+const char *indirect_branch_table_name[INDIRECT_BRANCH_NUM_OPTIONS] =	\
+  { ".s390_indirect_jump", ".s390_indirect_call",
+    ".s390_return_reg", ".s390_return_mem" };
+
+bool
+s390_return_addr_from_memory ()
+{
+  return cfun_gpr_save_slot(RETURN_REGNUM) == SAVE_SLOT_STACK;
+}
+
 /* Indicate which ABI has been used for passing vector args.
    0 - no vector type arguments have been passed where the ABI is relevant
    1 - the old ABI has been used
@@ -1148,9 +1097,83 @@
   return NULL_TREE;
 }
 
+/* Check syntax of function decl attributes having a string type value.  */
+
+static tree
+s390_handle_string_attribute (tree *node, tree name ATTRIBUTE_UNUSED,
+			      tree args ATTRIBUTE_UNUSED,
+			      int flags ATTRIBUTE_UNUSED,
+			      bool *no_add_attrs)
+{
+  tree cst;
+
+  if (TREE_CODE (*node) != FUNCTION_DECL)
+    {
+      warning (OPT_Wattributes, "%qE attribute only applies to functions",
+	       name);
+      *no_add_attrs = true;
+    }
+
+  cst = TREE_VALUE (args);
+
+  if (TREE_CODE (cst) != STRING_CST)
+    {
+      warning (OPT_Wattributes,
+	       "%qE attribute requires a string constant argument",
+	       name);
+      *no_add_attrs = true;
+    }
+
+  if (is_attribute_p ("indirect_branch", name)
+      || is_attribute_p ("indirect_branch_call", name)
+      || is_attribute_p ("function_return", name)
+      || is_attribute_p ("function_return_reg", name)
+      || is_attribute_p ("function_return_mem", name))
+    {
+      if (strcmp (TREE_STRING_POINTER (cst), "keep") != 0
+	  && strcmp (TREE_STRING_POINTER (cst), "thunk") != 0
+	  && strcmp (TREE_STRING_POINTER (cst), "thunk-extern") != 0)
+      {
+	warning (OPT_Wattributes,
+		 "argument to %qE attribute is not "
+		 "(keep|thunk|thunk-extern)", name);
+	*no_add_attrs = true;
+      }
+    }
+
+  if (is_attribute_p ("indirect_branch_jump", name)
+      && strcmp (TREE_STRING_POINTER (cst), "keep") != 0
+      && strcmp (TREE_STRING_POINTER (cst), "thunk") != 0
+      && strcmp (TREE_STRING_POINTER (cst), "thunk-inline") != 0
+      && strcmp (TREE_STRING_POINTER (cst), "thunk-extern") != 0)
+    {
+      warning (OPT_Wattributes,
+	       "argument to %qE attribute is not "
+	       "(keep|thunk|thunk-inline|thunk-extern)", name);
+      *no_add_attrs = true;
+    }
+
+  return NULL_TREE;
+}
+
 static const struct attribute_spec s390_attribute_table[] = {
-  { "hotpatch", 2, 2, true, false, false, s390_handle_hotpatch_attribute, false },
-  { "s390_vector_bool", 0, 0, false, true, false, s390_handle_vectorbool_attribute, true },
+  { "hotpatch", 2, 2, true, false, false,
+    s390_handle_hotpatch_attribute, false },
+  { "s390_vector_bool", 0, 0, false, true, false,
+    s390_handle_vectorbool_attribute, true },
+  { "indirect_branch", 1, 1, true, false, false,
+    s390_handle_string_attribute, false },
+  { "indirect_branch_jump", 1, 1, true, false, false,
+    s390_handle_string_attribute, false },
+  { "indirect_branch_call", 1, 1, true, false, false,
+    s390_handle_string_attribute, false },
+  { "function_return", 1, 1, true, false, false,
+    s390_handle_string_attribute, false },
+  { "function_return_reg", 1, 1, true, false, false,
+    s390_handle_string_attribute, false },
+  { "function_return_mem", 1, 1, true, false, false,
+    s390_handle_string_attribute, false },
+
   /* End element.  */
   { NULL,        0, 0, false, false, false, NULL, false }
 };
@@ -8583,11 +8606,25 @@
 static rtx
 s390_execute_label (rtx insn)
 {
-  if (NONJUMP_INSN_P (insn)
+  if (INSN_P (insn)
       && GET_CODE (PATTERN (insn)) == PARALLEL
       && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == UNSPEC
-      && XINT (XVECEXP (PATTERN (insn), 0, 0), 1) == UNSPEC_EXECUTE)
-    return XVECEXP (XVECEXP (PATTERN (insn), 0, 0), 0, 2);
+      && (XINT (XVECEXP (PATTERN (insn), 0, 0), 1) == UNSPEC_EXECUTE
+	  || XINT (XVECEXP (PATTERN (insn), 0, 0), 1) == UNSPEC_EXECUTE_JUMP))
+    {
+      if (XINT (XVECEXP (PATTERN (insn), 0, 0), 1) == UNSPEC_EXECUTE)
+	return XVECEXP (XVECEXP (PATTERN (insn), 0, 0), 0, 2);
+      else
+	{
+	  gcc_assert (JUMP_P (insn));
+	  /* For jump insns as execute target:
+	     - There is one operand less in the parallel (the
+	       modification register of the execute is always 0).
+	     - The execute target label is wrapped into an
+	       if_then_else in order to hide it from jump analysis.  */
+	  return XEXP (XVECEXP (XVECEXP (PATTERN (insn), 0, 0), 0, 0), 0);
+	}
+    }
 
   return NULL_RTX;
 }
@@ -11273,7 +11310,6 @@
   rtx frame_pointer, return_reg, cfa_restores = NULL_RTX;
   int area_bottom, area_top, offset = 0;
   int next_offset;
-  rtvec p;
   int i;
 
   if (TARGET_TPF_PROFILING)
@@ -11427,10 +11463,15 @@
 	  if (cfun_gpr_save_slot (RETURN_REGNUM) == SAVE_SLOT_STACK)
 	    {
 	      int return_regnum = find_unused_clobbered_reg();
-	      if (!return_regnum)
-		return_regnum = 4;
+	      if (!return_regnum
+		  || (TARGET_INDIRECT_BRANCH_NOBP_RET_OPTION
+		      && !TARGET_CPU_Z10
+		      && return_regnum == INDIRECT_BRANCH_THUNK_REGNUM))
+		{
+		  gcc_assert (INDIRECT_BRANCH_THUNK_REGNUM != 4);
+		  return_regnum = 4;
+		}
 	      return_reg = gen_rtx_REG (Pmode, return_regnum);
-
 	      addr = plus_constant (Pmode, frame_pointer,
 				    offset + cfun_frame_layout.gprs_offset
 				    + (RETURN_REGNUM
@@ -11466,16 +11507,7 @@
   s390_restore_gprs_from_fprs ();
 
   if (! sibcall)
-    {
-
-      /* Return to caller.  */
-
-      p = rtvec_alloc (2);
-
-      RTVEC_ELT (p, 0) = ret_rtx;
-      RTVEC_ELT (p, 1) = gen_rtx_USE (VOIDmode, return_reg);
-      emit_jump_insn (gen_rtx_PARALLEL (VOIDmode, p));
-    }
+    emit_jump_insn (gen_return_use (return_reg));
 }
 
 /* Implement TARGET_SET_UP_BY_PROLOGUE.  */
@@ -13053,6 +13085,112 @@
   final_end_function ();
 }
 
+/* Output either an indirect jump or a an indirect call
+   (RETURN_ADDR_REGNO != INVALID_REGNUM) with target register REGNO
+   using a branch trampoline disabling branch target prediction.  */
+
+void
+s390_indirect_branch_via_thunk (unsigned int regno,
+				unsigned int return_addr_regno,
+				rtx comparison_operator,
+				enum s390_indirect_branch_type type)
+{
+  enum s390_indirect_branch_option option;
+
+  if (type == s390_indirect_branch_type_return)
+    {
+      if (s390_return_addr_from_memory ())
+	option = s390_opt_function_return_mem;
+      else
+	option = s390_opt_function_return_reg;
+    }
+  else if (type == s390_indirect_branch_type_jump)
+    option = s390_opt_indirect_branch_jump;
+  else if (type == s390_indirect_branch_type_call)
+    option = s390_opt_indirect_branch_call;
+  else
+    gcc_unreachable ();
+
+  if (TARGET_INDIRECT_BRANCH_TABLE)
+    {
+      char label[32];
+
+      ASM_GENERATE_INTERNAL_LABEL (label,
+				   indirect_branch_table_label[option],
+				   indirect_branch_table_label_no[option]++);
+      ASM_OUTPUT_LABEL (asm_out_file, label);
+    }
+
+  if (return_addr_regno != INVALID_REGNUM)
+    {
+      gcc_assert (comparison_operator == NULL_RTX);
+      fprintf (asm_out_file, " \tbrasl\t%%r%d,", return_addr_regno);
+    }
+  else
+    {
+      fputs (" \tjg", asm_out_file);
+      if (comparison_operator != NULL_RTX)
+	print_operand (asm_out_file, comparison_operator, 'C');
+
+      fputs ("\t", asm_out_file);
+    }
+
+  if (TARGET_CPU_Z10)
+    fprintf (asm_out_file,
+	     TARGET_INDIRECT_BRANCH_THUNK_NAME_EXRL "\n",
+	     regno);
+  else
+    fprintf (asm_out_file,
+	     TARGET_INDIRECT_BRANCH_THUNK_NAME_EX "\n",
+	     INDIRECT_BRANCH_THUNK_REGNUM, regno);
+
+  if ((option == s390_opt_indirect_branch_jump
+       && cfun->machine->indirect_branch_jump == indirect_branch_thunk)
+      || (option == s390_opt_indirect_branch_call
+	  && cfun->machine->indirect_branch_call == indirect_branch_thunk)
+      || (option == s390_opt_function_return_reg
+	  && cfun->machine->function_return_reg == indirect_branch_thunk)
+      || (option == s390_opt_function_return_mem
+	  && cfun->machine->function_return_mem == indirect_branch_thunk))
+    {
+      if (TARGET_CPU_Z10)
+	indirect_branch_z10thunk_mask |= (1 << regno);
+      else
+	indirect_branch_prez10thunk_mask |= (1 << regno);
+    }
+}
+
+/* Output an inline thunk for indirect jumps.  EXECUTE_TARGET can
+   either be an address register or a label pointing to the location
+   of the jump instruction.  */
+
+void
+s390_indirect_branch_via_inline_thunk (rtx execute_target)
+{
+  if (TARGET_INDIRECT_BRANCH_TABLE)
+    {
+      char label[32];
+
+      ASM_GENERATE_INTERNAL_LABEL (label,
+				   indirect_branch_table_label[s390_opt_indirect_branch_jump],
+				   indirect_branch_table_label_no[s390_opt_indirect_branch_jump]++);
+      ASM_OUTPUT_LABEL (asm_out_file, label);
+    }
+
+  if (!TARGET_ZARCH)
+    fputs ("\t.machinemode zarch\n", asm_out_file);
+
+  if (REG_P (execute_target))
+    fprintf (asm_out_file, "\tex\t%%r0,0(%%r%d)\n", REGNO (execute_target));
+  else
+    output_asm_insn ("exrl\t%%r0,%0", &execute_target);
+
+  if (!TARGET_ZARCH)
+    fputs ("\t.machinemode esa\n", asm_out_file);
+
+  fputs ("0:\tj\t0b\n", asm_out_file);
+}
+
 static bool
 s390_valid_pointer_mode (machine_mode mode)
 {
@@ -13158,6 +13296,14 @@
   if (!TARGET_64BIT && flag_pic && decl && !targetm.binds_local_p (decl))
     return false;
 
+  /* The thunks for indirect branches require r1 if no exrl is
+     available.  r1 might not be available when doing a sibling
+     call.  */
+  if (TARGET_INDIRECT_BRANCH_NOBP_CALL
+      && !TARGET_CPU_Z10
+      && !decl)
+    return false;
+
   /* Register 6 on s390 is available as an argument register but unfortunately
      "caller saved". This makes functions needing this register for arguments
      not suitable for sibcalls.  */
@@ -13191,9 +13337,13 @@
 {
   bool plt_call = false;
   rtx_insn *insn;
-  rtx call;
-  rtx clobber;
-  rtvec vec;
+  rtx vec[4] = { NULL_RTX };
+  int elts = 0;
+  rtx *call = &vec[0];
+  rtx *clobber_ret_reg = &vec[1];
+  rtx *use = &vec[2];
+  rtx *clobber_thunk_reg = &vec[3];
+  int i;
 
   /* Direct function calls need special treatment.  */
   if (GET_CODE (addr_location) == SYMBOL_REF)
@@ -13245,26 +13395,58 @@
       addr_location = gen_rtx_REG (Pmode, SIBCALL_REGNUM);
     }
 
+  if (TARGET_INDIRECT_BRANCH_NOBP_CALL
+      && GET_CODE (addr_location) != SYMBOL_REF
+      && !plt_call)
+    {
+      /* Indirect branch thunks require the target to be a single GPR.  */
+      addr_location = force_reg (Pmode, addr_location);
+
+      /* Without exrl the indirect branch thunks need an additional
+	 register for larl;ex */
+      if (!TARGET_CPU_Z10)
+	{
+	  *clobber_thunk_reg = gen_rtx_REG (Pmode, INDIRECT_BRANCH_THUNK_REGNUM);
+	  *clobber_thunk_reg = gen_rtx_CLOBBER (VOIDmode, *clobber_thunk_reg);
+	}
+    }
+
   addr_location = gen_rtx_MEM (QImode, addr_location);
-  call = gen_rtx_CALL (VOIDmode, addr_location, const0_rtx);
+  *call = gen_rtx_CALL (VOIDmode, addr_location, const0_rtx);
 
   if (result_reg != NULL_RTX)
-    call = gen_rtx_SET (result_reg, call);
+    *call = gen_rtx_SET (result_reg, *call);
 
   if (retaddr_reg != NULL_RTX)
     {
-      clobber = gen_rtx_CLOBBER (VOIDmode, retaddr_reg);
+      *clobber_ret_reg = gen_rtx_CLOBBER (VOIDmode, retaddr_reg);
 
       if (tls_call != NULL_RTX)
-	vec = gen_rtvec (3, call, clobber,
-			 gen_rtx_USE (VOIDmode, tls_call));
-      else
-	vec = gen_rtvec (2, call, clobber);
+	*use = gen_rtx_USE (VOIDmode, tls_call);
+    }
 
-      call = gen_rtx_PARALLEL (VOIDmode, vec);
+
+  for (i = 0; i < 4; i++)
+    if (vec[i] != NULL_RTX)
+      elts++;
+
+  if (elts > 1)
+    {
+      rtvec v;
+      int e = 0;
+
+      v = rtvec_alloc (elts);
+      for (i = 0; i < 4; i++)
+	if (vec[i] != NULL_RTX)
+	  {
+	    RTVEC_ELT (v, e) = vec[i];
+	    e++;
+	  }
+
+      *call = gen_rtx_PARALLEL (VOIDmode, v);
     }
 
-  insn = emit_call_insn (call);
+  insn = emit_call_insn (*call);
 
   /* 31-bit PLT stubs and tls calls use the GOT register implicitly.  */
   if ((!TARGET_64BIT && plt_call) || tls_call != NULL_RTX)
@@ -14046,7 +14228,16 @@
 	  target = emit_label (XEXP (label, 0));
 	  INSN_ADDRESSES_NEW (target, -1);
 
-	  target = emit_insn (s390_execute_target (insn));
+	  if (JUMP_P (insn))
+	    {
+	      target = emit_jump_insn (s390_execute_target (insn));
+	      /* This is important in order to keep a table jump
+		 pointing at the jump table label.  Only this makes it
+		 being recognized as table jump.  */
+	      JUMP_LABEL (target) = JUMP_LABEL (insn);
+	    }
+	  else
+	    target = emit_insn (s390_execute_target (insn));
 	  INSN_ADDRESSES_NEW (target, -1);
 	}
     }
@@ -14699,6 +14890,42 @@
   if (TARGET_64BIT && !TARGET_ZARCH_P (opts->x_target_flags))
     error ("64-bit ABI not supported in ESA/390 mode");
 
+  if (opts->x_s390_indirect_branch == indirect_branch_thunk_inline
+      || opts->x_s390_indirect_branch_call == indirect_branch_thunk_inline
+      || opts->x_s390_function_return == indirect_branch_thunk_inline
+      || opts->x_s390_function_return_reg == indirect_branch_thunk_inline
+      || opts->x_s390_function_return_mem == indirect_branch_thunk_inline)
+    error ("thunk-inline is only supported with -mindirect-branch-jump");
+
+  if (opts->x_s390_indirect_branch != indirect_branch_keep)
+    {
+      if (!opts_set->x_s390_indirect_branch_call)
+	opts->x_s390_indirect_branch_call = opts->x_s390_indirect_branch;
+
+      if (!opts_set->x_s390_indirect_branch_jump)
+	opts->x_s390_indirect_branch_jump = opts->x_s390_indirect_branch;
+    }
+
+  if (opts->x_s390_function_return != indirect_branch_keep)
+    {
+      if (!opts_set->x_s390_function_return_reg)
+	opts->x_s390_function_return_reg = opts->x_s390_function_return;
+
+      if (!opts_set->x_s390_function_return_mem)
+	opts->x_s390_function_return_mem = opts->x_s390_function_return;
+    }
+
+  if (!TARGET_CPU_ZARCH)
+    {
+      if (opts->x_s390_indirect_branch_call != indirect_branch_keep
+	  || opts->x_s390_indirect_branch_jump != indirect_branch_keep)
+	error ("-mindirect-branch* options require -march=z900 or higher");
+      if (opts->x_s390_function_return_reg != indirect_branch_keep
+	  || opts->x_s390_function_return_mem != indirect_branch_keep)
+	error ("-mfunction-return* options require -march=z900 or higher");
+    }
+
+
   /* Enable hardware transactions if available and not explicitly
      disabled by user.  E.g. with -m31 -march=zEC12 -mzarch */
   if (!TARGET_OPT_HTM_P (opts_set->x_target_flags))
@@ -15267,6 +15494,79 @@
   return ret;
 }
 
+/* Set VAL to correct enum value according to the indirect-branch or
+   function-return attribute in ATTR.  */
+
+static inline void
+s390_indirect_branch_attrvalue (tree attr, enum indirect_branch *val)
+{
+  const char *str = TREE_STRING_POINTER (TREE_VALUE (TREE_VALUE (attr)));
+  if (strcmp (str, "keep") == 0)
+    *val = indirect_branch_keep;
+  else if (strcmp (str, "thunk") == 0)
+    *val = indirect_branch_thunk;
+  else if (strcmp (str, "thunk-inline") == 0)
+    *val = indirect_branch_thunk_inline;
+  else if (strcmp (str, "thunk-extern") == 0)
+    *val = indirect_branch_thunk_extern;
+}
+
+/* Memorize the setting for -mindirect-branch* and -mfunction-return*
+   from either the cmdline or the function attributes in
+   cfun->machine.  */
+
+static void
+s390_indirect_branch_settings (tree fndecl)
+{
+  tree attr;
+
+  if (!fndecl)
+    return;
+
+  /* Initialize with the cmdline options and let the attributes
+     override it.  */
+  cfun->machine->indirect_branch_jump = s390_indirect_branch_jump;
+  cfun->machine->indirect_branch_call = s390_indirect_branch_call;
+
+  cfun->machine->function_return_reg = s390_function_return_reg;
+  cfun->machine->function_return_mem = s390_function_return_mem;
+
+  if ((attr = lookup_attribute ("indirect_branch",
+				DECL_ATTRIBUTES (fndecl))))
+    {
+      s390_indirect_branch_attrvalue (attr,
+				      &cfun->machine->indirect_branch_jump);
+      s390_indirect_branch_attrvalue (attr,
+				      &cfun->machine->indirect_branch_call);
+    }
+
+  if ((attr = lookup_attribute ("indirect_branch_jump",
+				DECL_ATTRIBUTES (fndecl))))
+    s390_indirect_branch_attrvalue (attr, &cfun->machine->indirect_branch_jump);
+
+  if ((attr = lookup_attribute ("indirect_branch_call",
+				DECL_ATTRIBUTES (fndecl))))
+    s390_indirect_branch_attrvalue (attr, &cfun->machine->indirect_branch_call);
+
+  if ((attr = lookup_attribute ("function_return",
+				DECL_ATTRIBUTES (fndecl))))
+    {
+      s390_indirect_branch_attrvalue (attr,
+				      &cfun->machine->function_return_reg);
+      s390_indirect_branch_attrvalue (attr,
+				      &cfun->machine->function_return_mem);
+    }
+
+  if ((attr = lookup_attribute ("function_return_reg",
+				DECL_ATTRIBUTES (fndecl))))
+    s390_indirect_branch_attrvalue (attr, &cfun->machine->function_return_reg);
+
+  if ((attr = lookup_attribute ("function_return_mem",
+				DECL_ATTRIBUTES (fndecl))))
+    s390_indirect_branch_attrvalue (attr, &cfun->machine->function_return_mem);
+}
+
+
 /* Restore targets globals from NEW_TREE and invalidate s390_previous_fndecl
    cache.  */
 
@@ -15293,7 +15593,10 @@
      several times in the course of compiling a function, and we don't want to
      slow things down too much or call target_reinit when it isn't safe.  */
   if (fndecl == s390_previous_fndecl)
-    return;
+    {
+      s390_indirect_branch_settings (fndecl);
+      return;
+    }
 
   tree old_tree;
   if (s390_previous_fndecl == NULL_TREE)
@@ -15317,6 +15620,8 @@
   if (old_tree != new_tree)
     s390_activate_target_options (new_tree);
   s390_previous_fndecl = fndecl;
+
+  s390_indirect_branch_settings (fndecl);
 }
 #endif
 
@@ -15598,6 +15903,186 @@
   return TARGET_64BIT ? HOST_WIDE_INT_1U << 52 : HOST_WIDE_INT_UC (0x20000000);
 }
 
+#ifdef HAVE_GAS_HIDDEN
+# define USE_HIDDEN_LINKONCE 1
+#else
+# define USE_HIDDEN_LINKONCE 0
+#endif
+
+/* Output an indirect branch trampoline for target register REGNO.  */
+
+static void
+s390_output_indirect_thunk_function (unsigned int regno, bool z10_p)
+{
+  tree decl;
+  char thunk_label[32];
+  int i;
+
+  if (z10_p)
+    sprintf (thunk_label, TARGET_INDIRECT_BRANCH_THUNK_NAME_EXRL, regno);
+  else
+    sprintf (thunk_label, TARGET_INDIRECT_BRANCH_THUNK_NAME_EX,
+	     INDIRECT_BRANCH_THUNK_REGNUM, regno);
+
+  decl = build_decl (BUILTINS_LOCATION, FUNCTION_DECL,
+		     get_identifier (thunk_label),
+		     build_function_type_list (void_type_node, NULL_TREE));
+  DECL_RESULT (decl) = build_decl (BUILTINS_LOCATION, RESULT_DECL,
+				   NULL_TREE, void_type_node);
+  TREE_PUBLIC (decl) = 1;
+  TREE_STATIC (decl) = 1;
+  DECL_IGNORED_P (decl) = 1;
+
+  if (USE_HIDDEN_LINKONCE)
+    {
+      cgraph_node::create (decl)->set_comdat_group (DECL_ASSEMBLER_NAME (decl));
+
+      targetm.asm_out.unique_section (decl, 0);
+      switch_to_section (get_named_section (decl, NULL, 0));
+
+      targetm.asm_out.globalize_label (asm_out_file, thunk_label);
+      fputs ("\t.hidden\t", asm_out_file);
+      assemble_name (asm_out_file, thunk_label);
+      putc ('\n', asm_out_file);
+      ASM_DECLARE_FUNCTION_NAME (asm_out_file, thunk_label, decl);
+    }
+  else
+    {
+      switch_to_section (text_section);
+      ASM_OUTPUT_LABEL (asm_out_file, thunk_label);
+    }
+
+  DECL_INITIAL (decl) = make_node (BLOCK);
+  current_function_decl = decl;
+  allocate_struct_function (decl, false);
+  init_function_start (decl);
+  cfun->is_thunk = true;
+  first_function_block_is_cold = false;
+  final_start_function (emit_barrier (), asm_out_file, 1);
+
+  /* This makes CFI at least usable for indirect jumps.
+
+     Stopping in the thunk: backtrace will point to the thunk target
+     is if it was interrupted by a signal.  For a call this means that
+     the call chain will be: caller->callee->thunk   */
+  if (flag_asynchronous_unwind_tables && flag_dwarf2_cfi_asm)
+    {
+      fputs ("\t.cfi_signal_frame\n", asm_out_file);
+      fprintf (asm_out_file, "\t.cfi_return_column %d\n", regno);
+      for (i = 0; i < FPR15_REGNUM; i++)
+	fprintf (asm_out_file, "\t.cfi_same_value %s\n", reg_names[i]);
+    }
+
+  if (z10_p)
+    {
+      /* exrl  0,1f  */
+
+      /* We generate a thunk for z10 compiled code although z10 is
+	 currently not enabled.  Tell the assembler to accept the
+	 instruction.  */
+      if (!TARGET_CPU_Z10)
+	{
+	  fputs ("\t.machine push\n", asm_out_file);
+	  fputs ("\t.machine z10\n", asm_out_file);
+	}
+      /* We use exrl even if -mzarch hasn't been specified on the
+	 command line so we have to tell the assembler to accept
+	 it.  */
+      if (!TARGET_ZARCH)
+	fputs ("\t.machinemode zarch\n", asm_out_file);
+
+      fputs ("\texrl\t0,1f\n", asm_out_file);
+
+      if (!TARGET_ZARCH)
+	fputs ("\t.machinemode esa\n", asm_out_file);
+
+      if (!TARGET_CPU_Z10)
+	fputs ("\t.machine pop\n", asm_out_file);
+    }
+  else if (TARGET_CPU_ZARCH)
+    {
+      /* larl %r1,1f  */
+      fprintf (asm_out_file, "\tlarl\t%%r%d,1f\n",
+	       INDIRECT_BRANCH_THUNK_REGNUM);
+
+      /* ex 0,0(%r1)  */
+      fprintf (asm_out_file, "\tex\t0,0(%%r%d)\n",
+	       INDIRECT_BRANCH_THUNK_REGNUM);
+    }
+  else
+    gcc_unreachable ();
+
+  /* 0:    j 0b  */
+  fputs ("0:\tj\t0b\n", asm_out_file);
+
+  /* 1:    br <regno>  */
+  fprintf (asm_out_file, "1:\tbr\t%%r%d\n", regno);
+
+  final_end_function ();
+  init_insn_lengths ();
+  free_after_compilation (cfun);
+  set_cfun (NULL);
+  current_function_decl = NULL;
+}
+
+/* Implement the asm.code_end target hook.  */
+
+static void
+s390_code_end (void)
+{
+  int i;
+
+  for (i = 1; i < 16; i++)
+    {
+      if (indirect_branch_z10thunk_mask & (1 << i))
+	s390_output_indirect_thunk_function (i, true);
+
+      if (indirect_branch_prez10thunk_mask & (1 << i))
+	s390_output_indirect_thunk_function (i, false);
+    }
+
+  if (TARGET_INDIRECT_BRANCH_TABLE)
+    {
+      int o;
+      int i;
+
+      for (o = 0; o < INDIRECT_BRANCH_NUM_OPTIONS; o++)
+	{
+	  if (indirect_branch_table_label_no[o] == 0)
+	    continue;
+
+	  switch_to_section (get_section (indirect_branch_table_name[o],
+					  0,
+					  NULL_TREE));
+	  for (i = 0; i < indirect_branch_table_label_no[o]; i++)
+	    {
+	      char label_start[32];
+
+	      ASM_GENERATE_INTERNAL_LABEL (label_start,
+					   indirect_branch_table_label[o], i);
+
+	      fputs ("\t.long\t", asm_out_file);
+	      assemble_name_raw (asm_out_file, label_start);
+	      fputs ("-.\n", asm_out_file);
+	    }
+	  switch_to_section (current_function_section ());
+	}
+    }
+}
+
+/* Implement the TARGET_CASE_VALUES_THRESHOLD target hook.  */
+
+unsigned int
+s390_case_values_threshold (void)
+{
+  /* Disabling branch prediction for indirect jumps makes jump tables
+     much more expensive.  */
+  if (TARGET_INDIRECT_BRANCH_NOBP_JUMP)
+    return 20;
+
+  return default_case_values_threshold ();
+}
+
 /* Initialize GCC target structure.  */
 
 #undef  TARGET_ASM_ALIGNED_HI_OP
@@ -15854,6 +16339,12 @@
 #undef TARGET_OPTION_RESTORE
 #define TARGET_OPTION_RESTORE s390_function_specific_restore
 
+#undef TARGET_ASM_CODE_END
+#define TARGET_ASM_CODE_END s390_code_end
+
+#undef TARGET_CASE_VALUES_THRESHOLD
+#define TARGET_CASE_VALUES_THRESHOLD s390_case_values_threshold
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 #include "gt-s390.h"
Index: gcc/config/s390/s390-builtins.def
===================================================================
diff --git a/gcc/config/s390/s390-builtins.def b/gcc/config/s390/s390-builtins.def
--- a/gcc/config/s390/s390-builtins.def	(revision 262353)
+++ b/gcc/config/s390/s390-builtins.def	(revision 262353)
@@ -294,7 +294,7 @@
    flags: Flags applying to all its variants should be mentioned in the OB_DEF line instead.  */
 
 
-B_DEF      (tbeginc,                    tbeginc,            0,                  B_HTM,              0,                  BT_FN_INT)
+B_DEF      (tbeginc,                    tbeginc,            0,                  B_HTM,              0,                  BT_FN_VOID)
 B_DEF      (tbegin,                     tbegin,             returns_twice_attr, B_HTM,              0,                  BT_FN_INT_VOIDPTR)
 B_DEF      (tbegin_nofloat,             tbegin_nofloat,     returns_twice_attr, B_HTM,              0,                  BT_FN_INT_VOIDPTR)
 B_DEF      (tbegin_retry,               tbegin_retry,       returns_twice_attr, B_HTM,              0,                  BT_FN_INT_VOIDPTR_INT)
Index: gcc/config/s390/s390.h
===================================================================
diff --git a/gcc/config/s390/s390.h b/gcc/config/s390/s390.h
--- a/gcc/config/s390/s390.h	(revision 262353)
+++ b/gcc/config/s390/s390.h	(revision 262353)
@@ -205,7 +205,7 @@
 #define OPTION_DEFAULT_SPECS 					\
   { "mode", "%{!mesa:%{!mzarch:-m%(VALUE)}}" },			\
   { "arch", "%{!march=*:-march=%(VALUE)}" },			\
-  { "tune", "%{!mtune=*:-mtune=%(VALUE)}" }
+  { "tune", "%{!mtune=*:%{!march=*:-mtune=%(VALUE)}}" }
 
 #ifdef __s390__
 extern const char *s390_host_detect_local_cpu (int argc, const char **argv);
@@ -1120,4 +1120,124 @@
     s390_register_target_pragmas ();		\
   } while (0)
 
+#ifndef USED_FOR_TARGET
+/* The following structure is embedded in the machine
+   specific part of struct function.  */
+
+struct GTY (()) s390_frame_layout
+{
+  /* Offset within stack frame.  */
+  HOST_WIDE_INT gprs_offset;
+  HOST_WIDE_INT f0_offset;
+  HOST_WIDE_INT f4_offset;
+  HOST_WIDE_INT f8_offset;
+  HOST_WIDE_INT backchain_offset;
+
+  /* Number of first and last gpr where slots in the register
+     save area are reserved for.  */
+  int first_save_gpr_slot;
+  int last_save_gpr_slot;
+
+  /* Location (FP register number) where GPRs (r0-r15) should
+     be saved to.
+      0 - does not need to be saved at all
+     -1 - stack slot  */
+#define SAVE_SLOT_NONE   0
+#define SAVE_SLOT_STACK -1
+  signed char gpr_save_slots[16];
+
+  /* Number of first and last gpr to be saved, restored.  */
+  int first_save_gpr;
+  int first_restore_gpr;
+  int last_save_gpr;
+  int last_restore_gpr;
+
+  /* Bits standing for floating point registers. Set, if the
+     respective register has to be saved. Starting with reg 16 (f0)
+     at the rightmost bit.
+     Bit 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0
+     fpr 15 13 11  9 14 12 10  8  7  5  3  1  6  4  2  0
+     reg 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16  */
+  unsigned int fpr_bitmap;
+
+  /* Number of floating point registers f8-f15 which must be saved.  */
+  int high_fprs;
+
+  /* Set if return address needs to be saved.
+     This flag is set by s390_return_addr_rtx if it could not use
+     the initial value of r14 and therefore depends on r14 saved
+     to the stack.  */
+  bool save_return_addr_p;
+
+  /* Size of stack frame.  */
+  HOST_WIDE_INT frame_size;
+};
+
+
+/* Define the structure for the machine field in struct function.  */
+
+struct GTY(()) machine_function
+{
+  struct s390_frame_layout frame_layout;
+
+  /* Literal pool base register.  */
+  rtx base_reg;
+
+  /* True if we may need to perform branch splitting.  */
+  bool split_branches_pending_p;
+
+  bool has_landing_pad_p;
+
+  /* True if the current function may contain a tbegin clobbering
+     FPRs.  */
+  bool tbegin_p;
+
+  /* For -fsplit-stack support: A stack local which holds a pointer to
+     the stack arguments for a function with a variable number of
+     arguments.  This is set at the start of the function and is used
+     to initialize the overflow_arg_area field of the va_list
+     structure.  */
+  rtx split_stack_varargs_pointer;
+
+  enum indirect_branch indirect_branch_jump;
+  enum indirect_branch indirect_branch_call;
+
+  enum indirect_branch function_return_mem;
+  enum indirect_branch function_return_reg;
+};
+#endif
+
+#define TARGET_INDIRECT_BRANCH_NOBP_RET_OPTION				\
+  (cfun->machine->function_return_reg != indirect_branch_keep		\
+   || cfun->machine->function_return_mem != indirect_branch_keep)
+
+#define TARGET_INDIRECT_BRANCH_NOBP_RET					\
+  ((cfun->machine->function_return_reg != indirect_branch_keep		\
+    && !s390_return_addr_from_memory ())				\
+   || (cfun->machine->function_return_mem != indirect_branch_keep	\
+       && s390_return_addr_from_memory ()))
+
+#define TARGET_INDIRECT_BRANCH_NOBP_JUMP				\
+  (cfun->machine->indirect_branch_jump != indirect_branch_keep)
+
+#define TARGET_INDIRECT_BRANCH_NOBP_JUMP_THUNK				\
+  (cfun->machine->indirect_branch_jump == indirect_branch_thunk		\
+   || cfun->machine->indirect_branch_jump == indirect_branch_thunk_extern)
+
+#define TARGET_INDIRECT_BRANCH_NOBP_JUMP_INLINE_THUNK			\
+  (cfun->machine->indirect_branch_jump == indirect_branch_thunk_inline)
+
+#define TARGET_INDIRECT_BRANCH_NOBP_CALL			\
+  (cfun->machine->indirect_branch_call != indirect_branch_keep)
+
+#ifndef TARGET_DEFAULT_INDIRECT_BRANCH_TABLE
+#define TARGET_DEFAULT_INDIRECT_BRANCH_TABLE 0
+#endif
+
+#define TARGET_INDIRECT_BRANCH_THUNK_NAME_EXRL "__s390_indirect_jump_r%d"
+#define TARGET_INDIRECT_BRANCH_THUNK_NAME_EX   "__s390_indirect_jump_r%duse_r%d"
+
+#define TARGET_INDIRECT_BRANCH_TABLE s390_indirect_branch_table
+
+
 #endif /* S390_H */
Index: gcc/config/sparc/sparc.md
===================================================================
diff --git a/gcc/config/sparc/sparc.md b/gcc/config/sparc/sparc.md
--- a/gcc/config/sparc/sparc.md	(revision 262353)
+++ b/gcc/config/sparc/sparc.md	(revision 262353)
@@ -1758,7 +1758,7 @@
 
 (define_expand "movsi_pic_label_ref"
   [(set (match_dup 3) (high:SI
-     (unspec:SI [(match_operand:SI 1 "label_ref_operand" "")
+     (unspec:SI [(match_operand:SI 1 "symbolic_operand" "")
 		 (match_dup 2)] UNSPEC_MOVE_PIC_LABEL)))
    (set (match_dup 4) (lo_sum:SI (match_dup 3)
      (unspec:SI [(match_dup 1) (match_dup 2)] UNSPEC_MOVE_PIC_LABEL)))
@@ -1784,7 +1784,7 @@
 (define_insn "*movsi_high_pic_label_ref"
   [(set (match_operand:SI 0 "register_operand" "=r")
       (high:SI
-        (unspec:SI [(match_operand:SI 1 "label_ref_operand" "")
+        (unspec:SI [(match_operand:SI 1 "symbolic_operand" "")
 		    (match_operand:SI 2 "" "")] UNSPEC_MOVE_PIC_LABEL)))]
   "flag_pic"
   "sethi\t%%hi(%a2-(%a1-.)), %0")
@@ -1792,7 +1792,7 @@
 (define_insn "*movsi_lo_sum_pic_label_ref"
   [(set (match_operand:SI 0 "register_operand" "=r")
       (lo_sum:SI (match_operand:SI 1 "register_operand" "r")
-        (unspec:SI [(match_operand:SI 2 "label_ref_operand" "")
+        (unspec:SI [(match_operand:SI 2 "symbolic_operand" "")
 		    (match_operand:SI 3 "" "")] UNSPEC_MOVE_PIC_LABEL)))]
   "flag_pic"
   "or\t%1, %%lo(%a3-(%a2-.)), %0")
@@ -1896,7 +1896,7 @@
 
 (define_expand "movdi_pic_label_ref"
   [(set (match_dup 3) (high:DI
-     (unspec:DI [(match_operand:DI 1 "label_ref_operand" "")
+     (unspec:DI [(match_operand:DI 1 "symbolic_operand" "")
                  (match_dup 2)] UNSPEC_MOVE_PIC_LABEL)))
    (set (match_dup 4) (lo_sum:DI (match_dup 3)
      (unspec:DI [(match_dup 1) (match_dup 2)] UNSPEC_MOVE_PIC_LABEL)))
@@ -1922,7 +1922,7 @@
 (define_insn "*movdi_high_pic_label_ref"
   [(set (match_operand:DI 0 "register_operand" "=r")
         (high:DI
-          (unspec:DI [(match_operand:DI 1 "label_ref_operand" "")
+          (unspec:DI [(match_operand:DI 1 "symbolic_operand" "")
                       (match_operand:DI 2 "" "")] UNSPEC_MOVE_PIC_LABEL)))]
   "TARGET_ARCH64 && flag_pic"
   "sethi\t%%hi(%a2-(%a1-.)), %0")
@@ -1930,7 +1930,7 @@
 (define_insn "*movdi_lo_sum_pic_label_ref"
   [(set (match_operand:DI 0 "register_operand" "=r")
       (lo_sum:DI (match_operand:DI 1 "register_operand" "r")
-        (unspec:DI [(match_operand:DI 2 "label_ref_operand" "")
+        (unspec:DI [(match_operand:DI 2 "symbolic_operand" "")
                     (match_operand:DI 3 "" "")] UNSPEC_MOVE_PIC_LABEL)))]
   "TARGET_ARCH64 && flag_pic"
   "or\t%1, %%lo(%a3-(%a2-.)), %0")
Index: gcc/config/sparc/sparc.c
===================================================================
diff --git a/gcc/config/sparc/sparc.c b/gcc/config/sparc/sparc.c
--- a/gcc/config/sparc/sparc.c	(revision 262353)
+++ b/gcc/config/sparc/sparc.c	(revision 262353)
@@ -2188,7 +2188,7 @@
 	}
     }
 
-  /* Fixup TLS cases.  */
+  /* Fix up TLS cases.  */
   if (TARGET_HAVE_TLS
       && CONSTANT_P (operands[1])
       && sparc_tls_referenced_p (operands [1]))
@@ -2197,7 +2197,7 @@
       return false;
     }
 
-  /* Fixup PIC cases.  */
+  /* Fix up PIC cases.  */
   if (flag_pic && CONSTANT_P (operands[1]))
     {
       if (pic_address_needs_scratch (operands[1]))
@@ -2204,8 +2204,13 @@
 	operands[1] = sparc_legitimize_pic_address (operands[1], NULL_RTX);
 
       /* We cannot use the mov{si,di}_pic_label_ref patterns in all cases.  */
-      if (GET_CODE (operands[1]) == LABEL_REF
-	  && can_use_mov_pic_label_ref (operands[1]))
+      if ((GET_CODE (operands[1]) == LABEL_REF
+	   && can_use_mov_pic_label_ref (operands[1]))
+	  || (GET_CODE (operands[1]) == CONST
+	      && GET_CODE (XEXP (operands[1], 0)) == PLUS
+	      && GET_CODE (XEXP (XEXP (operands[1], 0), 0)) == LABEL_REF
+	      && GET_CODE (XEXP (XEXP (operands[1], 0), 1)) == CONST_INT
+	      && can_use_mov_pic_label_ref (XEXP (XEXP (operands[1], 0), 0))))
 	{
 	  if (mode == SImode)
 	    {
@@ -2215,7 +2220,6 @@
 
 	  if (mode == DImode)
 	    {
-	      gcc_assert (TARGET_ARCH64);
 	      emit_insn (gen_movdi_pic_label_ref (operands[0], operands[1]));
 	      return true;
 	    }
@@ -4216,10 +4220,11 @@
 pic_address_needs_scratch (rtx x)
 {
   /* An address which is a symbolic plus a non SMALL_INT needs a temp reg.  */
-  if (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == PLUS
+  if (GET_CODE (x) == CONST
+      && GET_CODE (XEXP (x, 0)) == PLUS
       && GET_CODE (XEXP (XEXP (x, 0), 0)) == SYMBOL_REF
       && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT
-      && ! SMALL_INT (XEXP (XEXP (x, 0), 1)))
+      && !SMALL_INT (XEXP (XEXP (x, 0), 1)))
     return 1;
 
   return 0;
@@ -4667,16 +4672,15 @@
 static rtx
 sparc_legitimize_pic_address (rtx orig, rtx reg)
 {
-  bool gotdata_op = false;
-
   if (GET_CODE (orig) == SYMBOL_REF
       /* See the comment in sparc_expand_move.  */
       || (GET_CODE (orig) == LABEL_REF && !can_use_mov_pic_label_ref (orig)))
     {
+      bool gotdata_op = false;
       rtx pic_ref, address;
       rtx_insn *insn;
 
-      if (reg == 0)
+      if (!reg)
 	{
 	  gcc_assert (can_create_pseudo_p ());
 	  reg = gen_reg_rtx (Pmode);
@@ -4687,8 +4691,7 @@
 	  /* If not during reload, allocate another temp reg here for loading
 	     in the address, so that these instructions can be optimized
 	     properly.  */
-	  rtx temp_reg = (! can_create_pseudo_p ()
-			  ? reg : gen_reg_rtx (Pmode));
+	  rtx temp_reg = can_create_pseudo_p () ? gen_reg_rtx (Pmode) : reg;
 
 	  /* Must put the SYMBOL_REF inside an UNSPEC here so that cse
 	     won't get confused into thinking that these two instructions
@@ -4704,6 +4707,7 @@
 	      emit_insn (gen_movsi_high_pic (temp_reg, orig));
 	      emit_insn (gen_movsi_lo_sum_pic (temp_reg, temp_reg, orig));
 	    }
+
 	  address = temp_reg;
 	  gotdata_op = true;
 	}
@@ -4744,7 +4748,7 @@
 	  && XEXP (XEXP (orig, 0), 0) == pic_offset_table_rtx)
 	return orig;
 
-      if (reg == 0)
+      if (!reg)
 	{
 	  gcc_assert (can_create_pseudo_p ());
 	  reg = gen_reg_rtx (Pmode);
@@ -4853,7 +4857,11 @@
       && XINT (XEXP (XEXP (x, 1), 1), 1) == UNSPEC_MOVE_PIC_LABEL)
     {
       x = XVECEXP (XEXP (XEXP (x, 1), 1), 0, 0);
-      gcc_assert (GET_CODE (x) == LABEL_REF);
+      gcc_assert (GET_CODE (x) == LABEL_REF
+		  || (GET_CODE (x) == CONST
+		      && GET_CODE (XEXP (x, 0)) == PLUS
+		      && GET_CODE (XEXP (XEXP (x, 0), 0)) == LABEL_REF
+		      && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT));
     }
 
   return x;
Index: gcc/config/i386/i386.h
===================================================================
diff --git a/gcc/config/i386/i386.h b/gcc/config/i386/i386.h
--- a/gcc/config/i386/i386.h	(revision 262353)
+++ b/gcc/config/i386/i386.h	(revision 262353)
@@ -2719,6 +2719,11 @@
 #define TARGET_RECIP_VEC_DIV	((recip_mask & RECIP_MASK_VEC_DIV) != 0)
 #define TARGET_RECIP_VEC_SQRT	((recip_mask & RECIP_MASK_VEC_SQRT) != 0)
 
+
+#define TARGET_INDIRECT_BRANCH_REGISTER \
+  (ix86_indirect_branch_register \
+   || cfun->machine->indirect_branch_type != indirect_branch_keep)
+
 #define IX86_HLE_ACQUIRE (1 << 16)
 #define IX86_HLE_RELEASE (1 << 17)
 
Index: gcc/config/i386/i386.md
===================================================================
diff --git a/gcc/config/i386/i386.md b/gcc/config/i386/i386.md
--- a/gcc/config/i386/i386.md	(revision 262353)
+++ b/gcc/config/i386/i386.md	(revision 262353)
@@ -739,7 +739,7 @@
 	   (if_then_else (match_operand 1 "constant_call_address_operand")
 	     (const_string "none")
 	     (const_string "load"))
-	 (and (eq_attr "type" "alu1,negnot,ishift1,sselog1,sseshuf1")
+	 (and (eq_attr "type" "alu1,negnot,ishift1,rotate1,sselog1,sseshuf1")
 	      (match_operand 1 "memory_operand"))
 	   (const_string "both")
 	 (and (match_operand 0 "memory_operand")
@@ -750,7 +750,7 @@
 	 (match_operand 1 "memory_operand")
 	   (const_string "load")
 	 (and (eq_attr "type"
-		 "!alu1,negnot,ishift1,
+		 "!alu1,negnot,ishift1,rotate1,
 		   imov,imovx,icmp,test,bitmanip,
 		   fmov,fcmp,fsgn,
 		   sse,ssemov,ssecmp,ssecomi,ssecvt,ssecvt1,sseicvt,
@@ -6685,6 +6685,20 @@
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "<MODE>")])
 
+(define_insn "*add<mode>3_carry_0"
+  [(set (match_operand:SWI 0 "nonimmediate_operand" "=<r>m")
+	(plus:SWI
+	  (match_operator:SWI 3 "ix86_carry_flag_operator"
+	    [(match_operand 2 "flags_reg_operand") (const_int 0)])
+	  (match_operand:SWI 1 "nonimmediate_operand" "0")))
+   (clobber (reg:CC FLAGS_REG))]
+  "ix86_unary_operator_ok (PLUS, <MODE>mode, operands)"
+  "adc{<imodesuffix>}\t{$0, %0|%0, 0}"
+  [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
+   (set_attr "pent_pair" "pu")
+   (set_attr "mode" "<MODE>")])
+
 (define_insn "*addsi3_carry_zext"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(zero_extend:DI
@@ -6701,6 +6715,20 @@
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "SI")])
 
+(define_insn "*addsi3_carry_zext_0"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(zero_extend:DI
+	  (plus:SI (match_operator:SI 2 "ix86_carry_flag_operator"
+		    [(reg FLAGS_REG) (const_int 0)])
+		   (match_operand:SI 1 "register_operand" "0"))))
+   (clobber (reg:CC FLAGS_REG))]
+  "TARGET_64BIT"
+  "adc{l}\t{$0, %k0|%k0, 0}"
+  [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
+   (set_attr "pent_pair" "pu")
+   (set_attr "mode" "SI")])
+
 ;; There is no point to generate ADCX instruction. ADC is shorter and faster.
 
 (define_insn "addcarry<mode>"
@@ -6741,6 +6769,20 @@
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "<MODE>")])
 
+(define_insn "*sub<mode>3_carry_0"
+  [(set (match_operand:SWI 0 "nonimmediate_operand" "=<r>m")
+	(minus:SWI
+	  (match_operand:SWI 1 "nonimmediate_operand" "0")
+	  (match_operator:SWI 3 "ix86_carry_flag_operator"
+	    [(match_operand 2 "flags_reg_operand") (const_int 0)])))
+   (clobber (reg:CC FLAGS_REG))]
+  "ix86_unary_operator_ok (MINUS, <MODE>mode, operands)"
+  "sbb{<imodesuffix>}\t{$0, %0|%0, 0}"
+  [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
+   (set_attr "pent_pair" "pu")
+   (set_attr "mode" "<MODE>")])
+
 (define_insn "*subsi3_carry_zext"
   [(set (match_operand:DI 0 "register_operand" "=r")
 	(zero_extend:DI
@@ -6758,6 +6800,21 @@
    (set_attr "pent_pair" "pu")
    (set_attr "mode" "SI")])
 
+(define_insn "*subsi3_carry_zext_0"
+  [(set (match_operand:DI 0 "register_operand" "=r")
+	(zero_extend:DI
+	  (minus:SI
+	    (match_operand:SI 1 "register_operand" "0")
+	    (match_operator:SI 2 "ix86_carry_flag_operator"
+	      [(reg FLAGS_REG) (const_int 0)]))))
+   (clobber (reg:CC FLAGS_REG))]
+  "TARGET_64BIT"
+  "sbb{l}\t{$0, %k0|%k0, 0}"
+  [(set_attr "type" "alu")
+   (set_attr "use_carry" "1")
+   (set_attr "pent_pair" "pu")
+   (set_attr "mode" "SI")])
+
 (define_insn "subborrow<mode>"
   [(set (reg:CCC FLAGS_REG)
 	(compare:CCC
@@ -8584,14 +8641,14 @@
 })
 
 (define_insn "*andndi3_doubleword"
-  [(set (match_operand:DI 0 "register_operand" "=r,&r")
+  [(set (match_operand:DI 0 "register_operand" "=&r,r,r,&r")
 	(and:DI
-	  (not:DI (match_operand:DI 1 "register_operand" "r,0"))
-	  (match_operand:DI 2 "nonimmediate_operand" "rm,rm")))
+	  (not:DI (match_operand:DI 1 "register_operand" "r,0,r,0"))
+	  (match_operand:DI 2 "nonimmediate_operand" "rm,rm,0,rm")))
    (clobber (reg:CC FLAGS_REG))]
   "!TARGET_64BIT && TARGET_STV && TARGET_SSE2"
   "#"
-  [(set_attr "isa" "bmi,*")])
+  [(set_attr "isa" "bmi,bmi,bmi,*")])
 
 (define_split
   [(set (match_operand:DI 0 "register_operand")
@@ -9916,7 +9973,7 @@
 {
   switch (get_attr_type (insn))
     {
-    case TYPE_ALU:
+    case TYPE_ALU1:
       gcc_assert (operands[1] == const1_rtx);
       return "add{b}\t%0, %0";
 
@@ -9932,12 +9989,12 @@
      (cond [(and (and (match_test "TARGET_DOUBLE_WITH_ADD")
 		      (match_operand 0 "register_operand"))
 		 (match_operand 1 "const1_operand"))
-	      (const_string "alu")
+	      (const_string "alu1")
 	   ]
 	   (const_string "ishift1")))
    (set (attr "length_immediate")
      (if_then_else
-       (ior (eq_attr "type" "alu")
+       (ior (eq_attr "type" "alu1")
 	    (and (eq_attr "type" "ishift1")
 		 (and (match_operand 1 "const1_operand")
 		      (ior (match_test "TARGET_SHIFT1")
@@ -11625,7 +11682,7 @@
   [(set (pc) (match_operand 0 "indirect_branch_operand"))]
   ""
 {
-  if (TARGET_X32 || ix86_indirect_branch_register)
+  if (TARGET_X32 || TARGET_INDIRECT_BRANCH_REGISTER)
     operands[0] = convert_memory_address (word_mode, operands[0]);
   cfun->machine->has_local_indirect_jump = true;
 })
@@ -11633,7 +11690,7 @@
 (define_insn "*indirect_jump"
   [(set (pc) (match_operand:W 0 "indirect_branch_operand" "rBw"))]
   ""
-  "* return ix86_output_indirect_jmp (operands[0], false);"
+  "* return ix86_output_indirect_jmp (operands[0]);"
   [(set (attr "type")
      (if_then_else (match_test "(cfun->machine->indirect_branch_type
 				 != indirect_branch_keep)")
@@ -11679,7 +11736,7 @@
 					 OPTAB_DIRECT);
     }
 
-  if (TARGET_X32 || ix86_indirect_branch_register)
+  if (TARGET_X32 || TARGET_INDIRECT_BRANCH_REGISTER)
     operands[0] = convert_memory_address (word_mode, operands[0]);
   cfun->machine->has_local_indirect_jump = true;
 })
@@ -11688,7 +11745,7 @@
   [(set (pc) (match_operand:W 0 "indirect_branch_operand" "rBw"))
    (use (label_ref (match_operand 1)))]
   ""
-  "* return ix86_output_indirect_jmp (operands[0], false);"
+  "* return ix86_output_indirect_jmp (operands[0]);"
   [(set (attr "type")
      (if_then_else (match_test "(cfun->machine->indirect_branch_type
 				 != indirect_branch_keep)")
@@ -11730,6 +11787,7 @@
   "(peep2_reg_dead_p (3, operands[1])
     || operands_match_p (operands[1], operands[3]))
    && ! reg_overlap_mentioned_p (operands[3], operands[0])
+   && ! reg_overlap_mentioned_p (operands[3], operands[4])
    && ! reg_set_p (operands[3], operands[4])
    && peep2_regno_dead_p (0, FLAGS_REG)"
   [(parallel [(set (match_dup 5) (match_dup 0))
@@ -11776,6 +11834,7 @@
   "(peep2_reg_dead_p (3, operands[1])
     || operands_match_p (operands[1], operands[3]))
    && ! reg_overlap_mentioned_p (operands[3], operands[0])
+   && ! reg_overlap_mentioned_p (operands[3], operands[4])
    && ! reg_set_p (operands[3], operands[4])
    && peep2_regno_dead_p (0, FLAGS_REG)"
   [(parallel [(set (match_dup 5) (match_dup 0))
@@ -11852,7 +11911,10 @@
 		     (match_operand:SI 0 "register_no_elim_operand" "U")
 		     (match_operand:SI 1 "GOT32_symbol_operand"))))
 	 (match_operand 2))]
-  "!TARGET_MACHO && !TARGET_64BIT && SIBLING_CALL_P (insn)"
+  "!TARGET_MACHO
+  && !TARGET_64BIT
+  && !TARGET_INDIRECT_BRANCH_REGISTER
+  && SIBLING_CALL_P (insn)"
 {
   rtx fnaddr = gen_rtx_PLUS (SImode, operands[0], operands[1]);
   fnaddr = gen_const_mem (SImode, fnaddr);
@@ -11871,7 +11933,7 @@
   [(call (mem:QI (match_operand:W 0 "memory_operand" "m"))
 	 (match_operand 1))
    (unspec [(const_int 0)] UNSPEC_PEEPSIB)]
-  "!TARGET_X32 && !ix86_indirect_branch_register"
+  "!TARGET_X32 && !TARGET_INDIRECT_BRANCH_REGISTER"
   "* return ix86_output_call_insn (insn, operands[0]);"
   [(set_attr "type" "call")])
 
@@ -11881,7 +11943,7 @@
    (call (mem:QI (match_dup 0))
 	 (match_operand 3))]
   "!TARGET_X32
-   && !ix86_indirect_branch_register
+   && !TARGET_INDIRECT_BRANCH_REGISTER
    && SIBLING_CALL_P (peep2_next_insn (1))
    && !reg_mentioned_p (operands[0],
 			CALL_INSN_FUNCTION_USAGE (peep2_next_insn (1)))"
@@ -11896,7 +11958,7 @@
    (call (mem:QI (match_dup 0))
 	 (match_operand 3))]
   "!TARGET_X32
-   && !ix86_indirect_branch_register
+   && !TARGET_INDIRECT_BRANCH_REGISTER
    && SIBLING_CALL_P (peep2_next_insn (2))
    && !reg_mentioned_p (operands[0],
 			CALL_INSN_FUNCTION_USAGE (peep2_next_insn (2)))"
@@ -11994,7 +12056,7 @@
         (match_operand:W 1 "memory_operand"))
    (set (pc) (match_dup 0))]
   "!TARGET_X32
-   && !ix86_indirect_branch_register
+   && !TARGET_INDIRECT_BRANCH_REGISTER
    && peep2_reg_dead_p (2, operands[0])"
   [(set (pc) (match_dup 1))])
 
@@ -12055,7 +12117,10 @@
 			  (match_operand:SI 1 "register_no_elim_operand" "U")
 			  (match_operand:SI 2 "GOT32_symbol_operand"))))
 	 (match_operand 3)))]
-  "!TARGET_MACHO && !TARGET_64BIT && SIBLING_CALL_P (insn)"
+  "!TARGET_MACHO
+   && !TARGET_64BIT
+   && !TARGET_INDIRECT_BRANCH_REGISTER
+   && SIBLING_CALL_P (insn)"
 {
   rtx fnaddr = gen_rtx_PLUS (SImode, operands[1], operands[2]);
   fnaddr = gen_const_mem (SImode, fnaddr);
@@ -12076,7 +12141,7 @@
  	(call (mem:QI (match_operand:W 1 "memory_operand" "m"))
 	      (match_operand 2)))
    (unspec [(const_int 0)] UNSPEC_PEEPSIB)]
-  "!TARGET_X32 && !ix86_indirect_branch_register"
+  "!TARGET_X32 && !TARGET_INDIRECT_BRANCH_REGISTER"
   "* return ix86_output_call_insn (insn, operands[1]);"
   [(set_attr "type" "callv")])
 
@@ -12087,7 +12152,7 @@
    (call (mem:QI (match_dup 0))
 		 (match_operand 3)))]
   "!TARGET_X32
-   && !ix86_indirect_branch_register
+   && !TARGET_INDIRECT_BRANCH_REGISTER
    && SIBLING_CALL_P (peep2_next_insn (1))
    && !reg_mentioned_p (operands[0],
 			CALL_INSN_FUNCTION_USAGE (peep2_next_insn (1)))"
@@ -12104,7 +12169,7 @@
 	(call (mem:QI (match_dup 0))
 	      (match_operand 3)))]
   "!TARGET_X32
-   && !ix86_indirect_branch_register
+   && !TARGET_INDIRECT_BRANCH_REGISTER
    && SIBLING_CALL_P (peep2_next_insn (2))
    && !reg_mentioned_p (operands[0],
 			CALL_INSN_FUNCTION_USAGE (peep2_next_insn (2)))"
@@ -12354,11 +12419,14 @@
    (set_attr "prefix_rep" "1")
    (set_attr "modrm" "0")])
 
-(define_insn "simple_return_pop_internal"
+(define_insn_and_split "simple_return_pop_internal"
   [(simple_return)
    (use (match_operand:SI 0 "const_int_operand"))]
   "reload_completed"
   "%!ret\t%0"
+  "&& cfun->machine->function_return_type != indirect_branch_keep"
+  [(const_int 0)]
+  "ix86_split_simple_return_pop_internal (operands[0]); DONE;"
   [(set_attr "length" "3")
    (set_attr "atom_unit" "jeu")
    (set_attr "length_immediate" "2")
@@ -12369,7 +12437,7 @@
   [(simple_return)
    (use (match_operand:SI 0 "register_operand" "r"))]
   "reload_completed"
-  "* return ix86_output_indirect_jmp (operands[0], true);"
+  "* return ix86_output_indirect_function_return (operands[0]);"
   [(set (attr "type")
      (if_then_else (match_test "(cfun->machine->indirect_branch_type
 				 != indirect_branch_keep)")
@@ -15527,7 +15595,8 @@
   "(TARGET_USE_FANCY_MATH_387
     && (!(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)
 	|| TARGET_MIX_SSE_I387)
-    && flag_unsafe_math_optimizations)
+    && flag_unsafe_math_optimizations
+    && (flag_fp_int_builtin_inexact || !flag_trapping_math))
    || (SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH
        && !flag_trapping_math && !flag_rounding_math)"
 {
Index: gcc/config/i386/constraints.md
===================================================================
diff --git a/gcc/config/i386/constraints.md b/gcc/config/i386/constraints.md
--- a/gcc/config/i386/constraints.md	(revision 262353)
+++ b/gcc/config/i386/constraints.md	(revision 262353)
@@ -198,7 +198,7 @@
 
 (define_constraint "Bs"
   "@internal Sibcall memory operand."
-  (ior (and (not (match_test "ix86_indirect_branch_register"))
+  (ior (and (not (match_test "TARGET_INDIRECT_BRANCH_REGISTER"))
 	    (not (match_test "TARGET_X32"))
 	    (match_operand 0 "sibcall_memory_operand"))
        (and (match_test "TARGET_X32 && Pmode == DImode")
@@ -206,7 +206,7 @@
 
 (define_constraint "Bw"
   "@internal Call memory operand."
-  (ior (and (not (match_test "ix86_indirect_branch_register"))
+  (ior (and (not (match_test "TARGET_INDIRECT_BRANCH_REGISTER"))
 	    (not (match_test "TARGET_X32"))
 	    (match_operand 0 "memory_operand"))
        (and (match_test "TARGET_X32 && Pmode == DImode")
Index: gcc/config/i386/predicates.md
===================================================================
diff --git a/gcc/config/i386/predicates.md b/gcc/config/i386/predicates.md
--- a/gcc/config/i386/predicates.md	(revision 262353)
+++ b/gcc/config/i386/predicates.md	(revision 262353)
@@ -635,7 +635,7 @@
 ;; Test for a valid operand for indirect branch.
 (define_predicate "indirect_branch_operand"
   (ior (match_operand 0 "register_operand")
-       (and (not (match_test "ix86_indirect_branch_register"))
+       (and (not (match_test "TARGET_INDIRECT_BRANCH_REGISTER"))
 	    (not (match_test "TARGET_X32"))
 	    (match_operand 0 "memory_operand"))))
 
@@ -679,7 +679,7 @@
   (ior (match_test "constant_call_address_operand
 		     (op, mode == VOIDmode ? mode : Pmode)")
        (match_operand 0 "call_register_no_elim_operand")
-       (and (not (match_test "ix86_indirect_branch_register"))
+       (and (not (match_test "TARGET_INDIRECT_BRANCH_REGISTER"))
 	    (ior (and (not (match_test "TARGET_X32"))
 		      (match_operand 0 "memory_operand"))
 		 (and (match_test "TARGET_X32 && Pmode == DImode")
@@ -690,7 +690,7 @@
   (ior (match_test "constant_call_address_operand
 		     (op, mode == VOIDmode ? mode : Pmode)")
        (match_operand 0 "register_no_elim_operand")
-       (and (not (match_test "ix86_indirect_branch_register"))
+       (and (not (match_test "TARGET_INDIRECT_BRANCH_REGISTER"))
 	    (ior (and (not (match_test "TARGET_X32"))
 		      (match_operand 0 "sibcall_memory_operand"))
 		 (and (match_test "TARGET_X32 && Pmode == DImode")
Index: gcc/config/i386/sse.md
===================================================================
diff --git a/gcc/config/i386/sse.md b/gcc/config/i386/sse.md
--- a/gcc/config/i386/sse.md	(revision 262353)
+++ b/gcc/config/i386/sse.md	(revision 262353)
@@ -1134,11 +1134,8 @@
 					     operands[2]));
    }
  else if (memory_operand (operands[1], DImode))
-   {
-     rtx tmp = gen_reg_rtx (V2DImode);
-     emit_insn (gen_vec_concatv2di (tmp, operands[1], const0_rtx));
-     emit_move_insn (operands[0], gen_lowpart (V4SImode, tmp));
-   }
+   emit_insn (gen_vec_concatv2di (gen_lowpart (V2DImode, operands[0]),
+				  operands[1], const0_rtx));
  else
    gcc_unreachable ();
  DONE;
@@ -4398,7 +4395,7 @@
 	  (match_operand:VF_128 1 "register_operand" "v")
 	  (const_int 1)))]
   "TARGET_AVX512F && TARGET_64BIT"
-  "vcvtusi2<ssescalarmodesuffix>\t{%2, <round_op3>%1, %0|%0, %1<round_op3>, %2}"
+  "vcvtusi2<ssescalarmodesuffix>{q}\t{%2, <round_op3>%1, %0|%0, %1<round_op3>, %2}"
   [(set_attr "type" "sseicvt")
    (set_attr "prefix" "evex")
    (set_attr "mode" "<ssescalarmode>")])
@@ -8883,14 +8880,14 @@
 ;; see comment above inline_secondary_memory_needed function in i386.c
 (define_insn "sse2_loadhpd"
   [(set (match_operand:V2DF 0 "nonimmediate_operand"
-	  "=x,v,x,v,o,o ,o")
+	  "=x,v,x,v ,o,o ,o")
 	(vec_concat:V2DF
 	  (vec_select:DF
 	    (match_operand:V2DF 1 "nonimmediate_operand"
-	  " 0,v,0,v,0,0 ,0")
+	  " 0,v,0,v ,0,0 ,0")
 	    (parallel [(const_int 0)]))
 	  (match_operand:DF 2 "nonimmediate_operand"
-	  " m,m,x,v,x,*f,r")))]
+	  " m,m,x,Yv,x,*f,r")))]
   "TARGET_SSE2 && !(MEM_P (operands[1]) && MEM_P (operands[2]))"
   "@
    movhpd\t{%2, %0|%0, %2}
@@ -9938,11 +9935,11 @@
    && ix86_binary_operator_ok (<CODE>, <MODE>mode, operands)"
   "@
    p<plusminus_mnemonic><ssemodesuffix>\t{%2, %0|%0, %2}
-   vp<plusminus_mnemonic><ssemodesuffix>\t{%2, %1, %0<mask_operand3>|%0<mask_operand3>, %1, %2}"
+   vp<plusminus_mnemonic><ssemodesuffix>\t{%2, %1, %0|%0, %1, %2}"
   [(set_attr "isa" "noavx,avx")
    (set_attr "type" "sseiadd")
    (set_attr "prefix_data16" "1,*")
-   (set_attr "prefix" "<mask_prefix3>")
+   (set_attr "prefix" "orig,vex")
    (set_attr "mode" "<sseinsnmode>")])
 
 (define_insn "*<plusminus_insn><mode>3_mask"
@@ -10683,11 +10680,14 @@
        (const_string "0")))
    (set_attr "mode" "<sseinsnmode>")])
 
+(define_mode_attr vshift_count
+  [(V32HI "v") (V16HI "Yv") (V8HI "Yv")])
+
 (define_insn "<shift_insn><mode>3<mask_name>"
   [(set (match_operand:VI2_AVX2_AVX512BW 0 "register_operand" "=x,v")
 	(any_lshift:VI2_AVX2_AVX512BW
 	  (match_operand:VI2_AVX2_AVX512BW 1 "register_operand" "0,v")
-	  (match_operand:DI 2 "nonmemory_operand" "xN,vN")))]
+	  (match_operand:DI 2 "nonmemory_operand" "xN,<vshift_count>N")))]
   "TARGET_SSE2 && <mask_mode512bit_condition> && <mask_avx512bw_condition>"
   "@
    p<vshift><ssemodesuffix>\t{%2, %0|%0, %2}
@@ -10706,7 +10706,7 @@
   [(set (match_operand:VI48_AVX2 0 "register_operand" "=x,x,v")
 	(any_lshift:VI48_AVX2
 	  (match_operand:VI48_AVX2 1 "register_operand" "0,x,v")
-	  (match_operand:DI 2 "nonmemory_operand" "xN,xN,vN")))]
+	  (match_operand:DI 2 "nonmemory_operand" "xN,xN,YvN")))]
   "TARGET_SSE2 && <mask_mode512bit_condition>"
   "@
    p<vshift><ssemodesuffix>\t{%2, %0|%0, %2}
@@ -11822,7 +11822,7 @@
 	    (eq_attr "mode" "TI"))
        (const_string "1")
        (const_string "*")))
-   (set_attr "prefix" "<mask_prefix3>")
+   (set_attr "prefix" "orig,vex")
    (set (attr "mode")
 	(cond [(and (match_test "<MODE_SIZE> == 16")
 		    (match_test "TARGET_SSE_PACKED_SINGLE_INSN_OPTIMAL"))
Index: gcc/config/i386/i386-protos.h
===================================================================
diff --git a/gcc/config/i386/i386-protos.h b/gcc/config/i386/i386-protos.h
--- a/gcc/config/i386/i386-protos.h	(revision 262353)
+++ b/gcc/config/i386/i386-protos.h	(revision 262353)
@@ -313,8 +313,10 @@
 #endif
 
 extern const char * ix86_output_call_insn (rtx_insn *insn, rtx call_op);
-extern const char * ix86_output_indirect_jmp (rtx call_op, bool ret_p);
+extern const char * ix86_output_indirect_jmp (rtx call_op);
 extern const char * ix86_output_function_return (bool long_p);
+extern const char * ix86_output_indirect_function_return (rtx ret_op);
+extern void ix86_split_simple_return_pop_internal (rtx);
 extern bool ix86_operands_ok_for_move_multiple (rtx *operands, bool load,
 						enum machine_mode mode);
 
Index: gcc/config/i386/avx512vlintrin.h
===================================================================
diff --git a/gcc/config/i386/avx512vlintrin.h b/gcc/config/i386/avx512vlintrin.h
--- a/gcc/config/i386/avx512vlintrin.h	(revision 262353)
+++ b/gcc/config/i386/avx512vlintrin.h	(revision 262353)
@@ -9099,6 +9099,17 @@
 
 extern __inline __m256i
 __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm256_permutexvar_epi64 (__m256i __X, __m256i __Y)
+{
+  return (__m256i) __builtin_ia32_permvardi256_mask ((__v4di) __Y,
+						     (__v4di) __X,
+						     (__v4di)
+						     _mm256_setzero_si256 (),
+						     (__mmask8) -1);
+}
+
+extern __inline __m256i
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
 _mm256_mask_permutexvar_epi64 (__m256i __W, __mmask8 __M, __m256i __X,
 			       __m256i __Y)
 {
@@ -9163,6 +9174,17 @@
 
 extern __inline __m256i
 __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm256_permutexvar_epi32 (__m256i __X, __m256i __Y)
+{
+  return (__m256i) __builtin_ia32_permvarsi256_mask ((__v8si) __Y,
+						     (__v8si) __X,
+						     (__v8si)
+						     _mm256_setzero_si256 (),
+						     (__mmask8) -1);
+}
+
+extern __inline __m256i
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
 _mm256_mask_permutexvar_epi32 (__m256i __W, __mmask8 __M, __m256i __X,
 			       __m256i __Y)
 {
@@ -9751,6 +9773,17 @@
 #ifdef __OPTIMIZE__
 extern __inline __m256i
 __attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
+_mm256_permutex_epi64 (__m256i __X, const int __I)
+{
+  return (__m256i) __builtin_ia32_permdi256_mask ((__v4di) __X,
+					      __I,
+					      (__v4di)
+					      _mm256_setzero_si256 (),
+					      (__mmask8) -1);
+}
+
+extern __inline __m256i
+__attribute__ ((__gnu_inline__, __always_inline__, __artificial__))
 _mm256_mask_permutex_epi64 (__m256i __W, __mmask8 __M,
 			    __m256i __X, const int __I)
 {
@@ -12367,6 +12400,13 @@
 					    _mm256_undefined_pd (),		\
 					    (__mmask8)-1))
 
+#define _mm256_permutex_epi64(X, I)				\
+  ((__m256i) __builtin_ia32_permdi256_mask ((__v4di)(__m256i)(X), \
+					    (int)(I),		\
+					    (__v4di)(__m256i)	\
+					    (_mm256_setzero_si256 ()),\
+					    (__mmask8) -1))
+
 #define _mm256_maskz_permutex_epi64(M, X, I)                    \
   ((__m256i) __builtin_ia32_permdi256_mask ((__v4di)(__m256i)(X),    \
 					    (int)(I),                \
Index: gcc/config/i386/i386.c
===================================================================
diff --git a/gcc/config/i386/i386.c b/gcc/config/i386/i386.c
--- a/gcc/config/i386/i386.c	(revision 262353)
+++ b/gcc/config/i386/i386.c	(revision 262353)
@@ -12031,19 +12031,29 @@
    labels in call and return thunks.  */
 static int indirectlabelno;
 
-/* True if call and return thunk functions are needed.  */
+/* True if call thunk function is needed.  */
 static bool indirect_thunk_needed = false;
-/* True if call and return thunk functions with the BND prefix are
-   needed.  */
+/* True if call thunk function with the BND prefix is needed.  */
 static bool indirect_thunk_bnd_needed = false;
 
 /* Bit masks of integer registers, which contain branch target, used
-   by call and return thunks functions.  */
+   by call thunk functions.  */
 static int indirect_thunks_used;
 /* Bit masks of integer registers, which contain branch target, used
-   by call and return thunks functions with the BND prefix.  */
+   by call thunk functions with the BND prefix.  */
 static int indirect_thunks_bnd_used;
 
+/* True if return thunk function is needed.  */
+static bool indirect_return_needed = false;
+/* True if return thunk function with the BND prefix is needed.  */
+static bool indirect_return_bnd_needed = false;
+
+/* True if return thunk function via CX is needed.  */
+static bool indirect_return_via_cx;
+/* True if return thunk function via CX with the BND prefix is
+   needed.  */
+static bool indirect_return_via_cx_bnd;
+
 #ifndef INDIRECT_LABEL
 # define INDIRECT_LABEL "LIND"
 #endif
@@ -12051,16 +12061,17 @@
 /* Fills in the label name that should be used for the indirect thunk.  */
 
 static void
-indirect_thunk_name (char name[32], int regno, bool need_bnd_p,
-		     bool ret_p)
+indirect_thunk_name (char name[32], unsigned int regno,
+		     bool need_bnd_p, bool ret_p)
 {
-  if (regno >= 0 && ret_p)
+  if (regno != INVALID_REGNUM && regno != CX_REG && ret_p)
     gcc_unreachable ();
 
   if (USE_HIDDEN_LINKONCE)
     {
       const char *bnd = need_bnd_p ? "_bnd" : "";
-      if (regno >= 0)
+      const char *ret = ret_p ? "return" : "indirect";
+      if (regno != INVALID_REGNUM)
 	{
 	  const char *reg_prefix;
 	  if (LEGACY_INT_REGNO_P (regno))
@@ -12067,18 +12078,15 @@
 	    reg_prefix = TARGET_64BIT ? "r" : "e";
 	  else
 	    reg_prefix = "";
-	  sprintf (name, "__x86_indirect_thunk%s_%s%s",
-		   bnd, reg_prefix, reg_names[regno]);
+	  sprintf (name, "__x86_%s_thunk%s_%s%s",
+		   ret, bnd, reg_prefix, reg_names[regno]);
 	}
       else
-	{
-	  const char *ret = ret_p ? "return" : "indirect";
-	  sprintf (name, "__x86_%s_thunk%s", ret, bnd);
-	}
+	sprintf (name, "__x86_%s_thunk%s", ret, bnd);
     }
   else
     {
-      if (regno >= 0)
+      if (regno != INVALID_REGNUM)
 	{
 	  if (need_bnd_p)
 	    ASM_GENERATE_INTERNAL_LABEL (name, "LITBR", regno);
@@ -12130,7 +12138,7 @@
  */
 
 static void
-output_indirect_thunk (bool need_bnd_p, int regno)
+output_indirect_thunk (bool need_bnd_p, unsigned int regno)
 {
   char indirectlabel1[32];
   char indirectlabel2[32];
@@ -12160,7 +12168,7 @@
 
   ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, indirectlabel2);
 
-  if (regno >= 0)
+  if (regno != INVALID_REGNUM)
     {
       /* MOV.  */
       rtx xops[2];
@@ -12184,18 +12192,20 @@
 }
 
 /* Output a funtion with a call and return thunk for indirect branch.
-   If BND_P is true, the BND prefix is needed.   If REGNO != -1,  the
-   function address is in REGNO.  Otherwise, the function address is
-   on the top of stack.  */
+   If BND_P is true, the BND prefix is needed.  If REGNO != INVALID_REGNUM,
+   the function address is in REGNO.  Otherwise, the function address is
+   on the top of stack.  Thunk is used for function return if RET_P is
+   true.  */
 
 static void
-output_indirect_thunk_function (bool need_bnd_p, int regno)
+output_indirect_thunk_function (bool need_bnd_p, unsigned int regno,
+				bool ret_p)
 {
   char name[32];
   tree decl;
 
   /* Create __x86_indirect_thunk/__x86_indirect_thunk_bnd.  */
-  indirect_thunk_name (name, regno, need_bnd_p, false);
+  indirect_thunk_name (name, regno, need_bnd_p, ret_p);
   decl = build_decl (BUILTINS_LOCATION, FUNCTION_DECL,
 		     get_identifier (name),
 		     build_function_type_list (void_type_node, NULL_TREE));
@@ -12238,36 +12248,6 @@
 	ASM_OUTPUT_LABEL (asm_out_file, name);
       }
 
-  if (regno < 0)
-    {
-      /* Create alias for __x86.return_thunk/__x86.return_thunk_bnd.  */
-      char alias[32];
-
-      indirect_thunk_name (alias, regno, need_bnd_p, true);
-#if TARGET_MACHO
-      if (TARGET_MACHO)
-	{
-	  fputs ("\t.weak_definition\t", asm_out_file);
-	  assemble_name (asm_out_file, alias);
-	  fputs ("\n\t.private_extern\t", asm_out_file);
-	  assemble_name (asm_out_file, alias);
-	  putc ('\n', asm_out_file);
-	  ASM_OUTPUT_LABEL (asm_out_file, alias);
-	}
-#else
-      ASM_OUTPUT_DEF (asm_out_file, alias, name);
-      if (USE_HIDDEN_LINKONCE)
-	{
-	  fputs ("\t.globl\t", asm_out_file);
-	  assemble_name (asm_out_file, alias);
-	  putc ('\n', asm_out_file);
-	  fputs ("\t.hidden\t", asm_out_file);
-	  assemble_name (asm_out_file, alias);
-	  putc ('\n', asm_out_file);
-	}
-#endif
-    }
-
   DECL_INITIAL (decl) = make_node (BLOCK);
   current_function_decl = decl;
   allocate_struct_function (decl, false);
@@ -12312,21 +12292,31 @@
 ix86_code_end (void)
 {
   rtx xops[2];
-  int regno;
+  unsigned int regno;
 
+  if (indirect_return_needed)
+    output_indirect_thunk_function (false, INVALID_REGNUM, true);
+  if (indirect_return_bnd_needed)
+    output_indirect_thunk_function (true, INVALID_REGNUM, true);
+
+  if (indirect_return_via_cx)
+    output_indirect_thunk_function (false, CX_REG, true);
+  if (indirect_return_via_cx_bnd)
+    output_indirect_thunk_function (true, CX_REG, true);
+
   if (indirect_thunk_needed)
-    output_indirect_thunk_function (false, -1);
+    output_indirect_thunk_function (false, INVALID_REGNUM, false);
   if (indirect_thunk_bnd_needed)
-    output_indirect_thunk_function (true, -1);
+    output_indirect_thunk_function (true, INVALID_REGNUM, false);
 
   for (regno = FIRST_REX_INT_REG; regno <= LAST_REX_INT_REG; regno++)
     {
-      int i = regno - FIRST_REX_INT_REG + LAST_INT_REG + 1;
+      unsigned int i = regno - FIRST_REX_INT_REG + LAST_INT_REG + 1;
       if ((indirect_thunks_used & (1 << i)))
-	output_indirect_thunk_function (false, regno);
+	output_indirect_thunk_function (false, regno, false);
 
       if ((indirect_thunks_bnd_used & (1 << i)))
-	output_indirect_thunk_function (true, regno);
+	output_indirect_thunk_function (true, regno, false);
     }
 
   for (regno = AX_REG; regno <= SP_REG; regno++)
@@ -12335,10 +12325,10 @@
       tree decl;
 
       if ((indirect_thunks_used & (1 << regno)))
-	output_indirect_thunk_function (false, regno);
+	output_indirect_thunk_function (false, regno, false);
 
       if ((indirect_thunks_bnd_used & (1 << regno)))
-	output_indirect_thunk_function (true, regno);
+	output_indirect_thunk_function (true, regno, false);
 
       if (!(pic_labels_used & (1 << regno)))
 	continue;
@@ -14061,7 +14051,6 @@
 {
   struct machine_function *m = cfun->machine;
   rtx insn, t;
-  struct ix86_frame frame;
   HOST_WIDE_INT allocate;
   bool int_registers_saved;
   bool sse_registers_saved;
@@ -14085,7 +14074,7 @@
   m->fs.sp_valid = true;
 
   ix86_compute_frame_layout ();
-  frame = m->frame;
+  const struct ix86_frame &frame = cfun->machine->frame;
 
   if (!TARGET_64BIT && ix86_function_ms_hook_prologue (current_function_decl))
     {
@@ -14748,13 +14737,12 @@
 {
   struct machine_function *m = cfun->machine;
   struct machine_frame_state frame_state_save = m->fs;
-  struct ix86_frame frame;
   bool restore_regs_via_mov;
   bool using_drap;
 
   ix86_finalize_stack_realign_flags ();
   ix86_compute_frame_layout ();
-  frame = m->frame;
+  const struct ix86_frame &frame = cfun->machine->frame;
 
   m->fs.sp_valid = (!frame_pointer_needed
 		    || (crtl->sp_is_unchanging
@@ -14796,11 +14784,13 @@
 				  + UNITS_PER_WORD);
     }
 
+  HOST_WIDE_INT reg_save_offset = frame.reg_save_offset;
+
   /* Special care must be taken for the normal return case of a function
      using eh_return: the eax and edx registers are marked as saved, but
      not restored along this path.  Adjust the save location to match.  */
   if (crtl->calls_eh_return && style != 2)
-    frame.reg_save_offset -= 2 * UNITS_PER_WORD;
+    reg_save_offset -= 2 * UNITS_PER_WORD;
 
   /* EH_RETURN requires the use of moves to function properly.  */
   if (crtl->calls_eh_return)
@@ -14816,11 +14806,11 @@
   else if (TARGET_EPILOGUE_USING_MOVE
 	   && cfun->machine->use_fast_prologue_epilogue
 	   && (frame.nregs > 1
-	       || m->fs.sp_offset != frame.reg_save_offset))
+	       || m->fs.sp_offset != reg_save_offset))
     restore_regs_via_mov = true;
   else if (frame_pointer_needed
 	   && !frame.nregs
-	   && m->fs.sp_offset != frame.reg_save_offset)
+	   && m->fs.sp_offset != reg_save_offset)
     restore_regs_via_mov = true;
   else if (frame_pointer_needed
 	   && TARGET_USE_LEAVE
@@ -14858,7 +14848,7 @@
       rtx t;
 
       if (frame.nregs)
-	ix86_emit_restore_regs_using_mov (frame.reg_save_offset, style == 2);
+	ix86_emit_restore_regs_using_mov (reg_save_offset, style == 2);
 
       /* eh_return epilogues need %ecx added to the stack pointer.  */
       if (style == 2)
@@ -14948,19 +14938,19 @@
 	 epilogues.  */
       if (!m->fs.sp_valid
  	  || (TARGET_SEH
-	      && (m->fs.sp_offset - frame.reg_save_offset
+	      && (m->fs.sp_offset - reg_save_offset
 		  >= SEH_MAX_FRAME_SIZE)))
 	{
 	  pro_epilogue_adjust_stack (stack_pointer_rtx, hard_frame_pointer_rtx,
 				     GEN_INT (m->fs.fp_offset
-					      - frame.reg_save_offset),
+					      - reg_save_offset),
 				     style, false);
 	}
-      else if (m->fs.sp_offset != frame.reg_save_offset)
+      else if (m->fs.sp_offset != reg_save_offset)
 	{
 	  pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,
 				     GEN_INT (m->fs.sp_offset
-					      - frame.reg_save_offset),
+					      - reg_save_offset),
 				     style,
 				     m->fs.cfa_reg == stack_pointer_rtx);
 	}
@@ -18842,7 +18832,8 @@
 	 since we can in fact encode that into an immediate.  */
       if (GET_CODE (x) == CONST_VECTOR)
 	{
-	  gcc_assert (x == CONST0_RTX (GET_MODE (x)));
+	  if (x != CONST0_RTX (GET_MODE (x)))
+	    output_operand_lossage ("invalid vector immediate");
 	  x = const0_rtx;
 	}
 
@@ -19807,74 +19798,38 @@
   emit_insn (gen_x86_fnstcw_1 (stored_mode));
   emit_move_insn (reg, copy_rtx (stored_mode));
 
-  if (TARGET_64BIT || TARGET_PARTIAL_REG_STALL
-      || optimize_insn_for_size_p ())
+  switch (mode)
     {
-      switch (mode)
-	{
-	case I387_CW_TRUNC:
-	  /* round toward zero (truncate) */
-	  emit_insn (gen_iorhi3 (reg, reg, GEN_INT (0x0c00)));
-	  slot = SLOT_CW_TRUNC;
-	  break;
+    case I387_CW_TRUNC:
+      /* round toward zero (truncate) */
+      emit_insn (gen_iorhi3 (reg, reg, GEN_INT (0x0c00)));
+      slot = SLOT_CW_TRUNC;
+      break;
 
-	case I387_CW_FLOOR:
-	  /* round down toward -oo */
-	  emit_insn (gen_andhi3 (reg, reg, GEN_INT (~0x0c00)));
-	  emit_insn (gen_iorhi3 (reg, reg, GEN_INT (0x0400)));
-	  slot = SLOT_CW_FLOOR;
-	  break;
+    case I387_CW_FLOOR:
+      /* round down toward -oo */
+      emit_insn (gen_andhi3 (reg, reg, GEN_INT (~0x0c00)));
+      emit_insn (gen_iorhi3 (reg, reg, GEN_INT (0x0400)));
+      slot = SLOT_CW_FLOOR;
+      break;
 
-	case I387_CW_CEIL:
-	  /* round up toward +oo */
-	  emit_insn (gen_andhi3 (reg, reg, GEN_INT (~0x0c00)));
-	  emit_insn (gen_iorhi3 (reg, reg, GEN_INT (0x0800)));
-	  slot = SLOT_CW_CEIL;
-	  break;
+    case I387_CW_CEIL:
+      /* round up toward +oo */
+      emit_insn (gen_andhi3 (reg, reg, GEN_INT (~0x0c00)));
+      emit_insn (gen_iorhi3 (reg, reg, GEN_INT (0x0800)));
+      slot = SLOT_CW_CEIL;
+      break;
 
-	case I387_CW_MASK_PM:
-	  /* mask precision exception for nearbyint() */
-	  emit_insn (gen_iorhi3 (reg, reg, GEN_INT (0x0020)));
-	  slot = SLOT_CW_MASK_PM;
-	  break;
+    case I387_CW_MASK_PM:
+      /* mask precision exception for nearbyint() */
+      emit_insn (gen_iorhi3 (reg, reg, GEN_INT (0x0020)));
+      slot = SLOT_CW_MASK_PM;
+      break;
 
-	default:
-	  gcc_unreachable ();
-	}
+    default:
+      gcc_unreachable ();
     }
-  else
-    {
-      switch (mode)
-	{
-	case I387_CW_TRUNC:
-	  /* round toward zero (truncate) */
-	  emit_insn (gen_insvsi_1 (reg, GEN_INT (0xc)));
-	  slot = SLOT_CW_TRUNC;
-	  break;
 
-	case I387_CW_FLOOR:
-	  /* round down toward -oo */
-	  emit_insn (gen_insvsi_1 (reg, GEN_INT (0x4)));
-	  slot = SLOT_CW_FLOOR;
-	  break;
-
-	case I387_CW_CEIL:
-	  /* round up toward +oo */
-	  emit_insn (gen_insvsi_1 (reg, GEN_INT (0x8)));
-	  slot = SLOT_CW_CEIL;
-	  break;
-
-	case I387_CW_MASK_PM:
-	  /* mask precision exception for nearbyint() */
-	  emit_insn (gen_iorhi3 (reg, reg, GEN_INT (0x0020)));
-	  slot = SLOT_CW_MASK_PM;
-	  break;
-
-	default:
-	  gcc_unreachable ();
-	}
-    }
-
   gcc_assert (slot < MAX_386_STACK_LOCALS);
 
   new_mode = assign_386_stack_local (HImode, slot);
@@ -29109,18 +29064,17 @@
   else
     ix86_output_indirect_branch_via_push (call_op, xasm, sibcall_p);
 }
-/* Output indirect jump.  CALL_OP is the jump target.  Jump is a
-   function return if RET_P is true.  */
 
+/* Output indirect jump.  CALL_OP is the jump target.  */
+
 const char *
-ix86_output_indirect_jmp (rtx call_op, bool ret_p)
+ix86_output_indirect_jmp (rtx call_op)
 {
   if (cfun->machine->indirect_branch_type != indirect_branch_keep)
     {
-      /* We can't have red-zone if this isn't a function return since
-	 "call" in the indirect thunk pushes the return address onto
-	 stack, destroying red-zone.  */
-      if (!ret_p && ix86_red_zone_size != 0)
+      /* We can't have red-zone since "call" in the indirect thunk
+         pushes the return address onto stack, destroying red-zone.  */
+      if (ix86_red_zone_size != 0)
 	gcc_unreachable ();
 
       ix86_output_indirect_branch (call_op, "%0", true);
@@ -29146,20 +29100,21 @@
 	{
 	  bool need_thunk = (cfun->machine->function_return_type
 			     == indirect_branch_thunk);
-	  indirect_thunk_name (thunk_name, -1, need_bnd_p, true);
+	  indirect_thunk_name (thunk_name, INVALID_REGNUM, need_bnd_p,
+			       true);
 	  if (need_bnd_p)
 	    {
-	      indirect_thunk_bnd_needed |= need_thunk;
+	      indirect_return_bnd_needed |= need_thunk;
 	      fprintf (asm_out_file, "\tbnd jmp\t%s\n", thunk_name);
 	    }
 	  else
 	    {
-	      indirect_thunk_needed |= need_thunk;
+	      indirect_return_needed |= need_thunk;
 	      fprintf (asm_out_file, "\tjmp\t%s\n", thunk_name);
 	    }
 	}
       else
-	output_indirect_thunk (need_bnd_p, -1);
+	output_indirect_thunk (need_bnd_p, INVALID_REGNUM);
 
       return "";
     }
@@ -29170,6 +29125,86 @@
   return "rep%; ret";
 }
 
+/* Output indirect function return.  RET_OP is the function return
+   target.  */
+
+const char *
+ix86_output_indirect_function_return (rtx ret_op)
+{
+  if (cfun->machine->function_return_type != indirect_branch_keep)
+    {
+      char thunk_name[32];
+      bool need_bnd_p = ix86_bnd_prefixed_insn_p (current_output_insn);
+      unsigned int regno = REGNO (ret_op);
+      gcc_assert (regno == CX_REG);
+
+      if (cfun->machine->function_return_type
+	  != indirect_branch_thunk_inline)
+	{
+	  bool need_thunk = (cfun->machine->function_return_type
+			     == indirect_branch_thunk);
+	  indirect_thunk_name (thunk_name, regno, need_bnd_p, true);
+	  if (need_bnd_p)
+	    {
+	      if (need_thunk)
+		{
+		  indirect_return_via_cx_bnd = true;
+		  indirect_thunks_bnd_used |= 1 << CX_REG;
+		}
+	      fprintf (asm_out_file, "\tbnd jmp\t%s\n", thunk_name);
+	    }
+	  else
+	    {
+	      if (need_thunk)
+		{
+		  indirect_return_via_cx = true;
+		  indirect_thunks_used |= 1 << CX_REG;
+		}
+	      fprintf (asm_out_file, "\tjmp\t%s\n", thunk_name);
+	    }
+	}
+      else
+	output_indirect_thunk (need_bnd_p, regno);
+
+      return "";
+    }
+  else
+    return "%!jmp\t%A0";
+}
+
+/* Split simple return with popping POPC bytes from stack to indirect
+   branch with stack adjustment .  */
+
+void
+ix86_split_simple_return_pop_internal (rtx popc)
+{
+  struct machine_function *m = cfun->machine;
+  rtx ecx = gen_rtx_REG (SImode, CX_REG);
+  rtx_insn *insn;
+
+  /* There is no "pascal" calling convention in any 64bit ABI.  */
+  gcc_assert (!TARGET_64BIT);
+
+  insn = emit_insn (gen_pop (ecx));
+  m->fs.cfa_offset -= UNITS_PER_WORD;
+  m->fs.sp_offset -= UNITS_PER_WORD;
+
+  rtx x = plus_constant (Pmode, stack_pointer_rtx, UNITS_PER_WORD);
+  x = gen_rtx_SET (stack_pointer_rtx, x);
+  add_reg_note (insn, REG_CFA_ADJUST_CFA, x);
+  add_reg_note (insn, REG_CFA_REGISTER, gen_rtx_SET (ecx, pc_rtx));
+  RTX_FRAME_RELATED_P (insn) = 1;
+
+  x = gen_rtx_PLUS (Pmode, stack_pointer_rtx, popc);
+  x = gen_rtx_SET (stack_pointer_rtx, x);
+  insn = emit_insn (x);
+  add_reg_note (insn, REG_CFA_ADJUST_CFA, x);
+  RTX_FRAME_RELATED_P (insn) = 1;
+
+  /* Now return address is in ECX.  */
+  emit_jump_insn (gen_simple_return_indirect_internal (ecx));
+}
+
 /* Output the assembly for a call instruction.  */
 
 const char *
Index: gcc/config/avr/avr.md
===================================================================
diff --git a/gcc/config/avr/avr.md b/gcc/config/avr/avr.md
--- a/gcc/config/avr/avr.md	(revision 262353)
+++ b/gcc/config/avr/avr.md	(revision 262353)
@@ -3362,6 +3362,8 @@
         (match_operand:HI 1 "reg_or_0_operand"))]
   "optimize
    && reload_completed
+   && GENERAL_REG_P (operands[0])
+   && (operands[1] == const0_rtx || GENERAL_REG_P (operands[1]))
    && (!AVR_HAVE_MOVW
        || const0_rtx == operands[1])"
   [(set (match_dup 2) (match_dup 3))
Index: gcc/config/avr/avr.h
===================================================================
diff --git a/gcc/config/avr/avr.h b/gcc/config/avr/avr.h
--- a/gcc/config/avr/avr.h	(revision 262353)
+++ b/gcc/config/avr/avr.h	(revision 262353)
@@ -153,6 +153,9 @@
 
 #define FIRST_PSEUDO_REGISTER 36
 
+#define GENERAL_REGNO_P(N)	IN_RANGE (N, 2, 31)
+#define GENERAL_REG_P(X)	(REG_P (X) && GENERAL_REGNO_P (REGNO (X)))
+
 #define FIXED_REGISTERS {\
   1,1,/* r0 r1 */\
   0,0,/* r2 r3 */\
Index: gcc/config/xtensa/xtensa.md
===================================================================
diff --git a/gcc/config/xtensa/xtensa.md b/gcc/config/xtensa/xtensa.md
--- a/gcc/config/xtensa/xtensa.md	(revision 262353)
+++ b/gcc/config/xtensa/xtensa.md	(revision 262353)
@@ -38,6 +38,7 @@
   (UNSPEC_MEMW		11)
   (UNSPEC_LSETUP_START  12)
   (UNSPEC_LSETUP_END    13)
+  (UNSPEC_FRAME_BLOCKAGE 14)
 
   (UNSPECV_SET_FP	1)
   (UNSPECV_ENTRY	2)
@@ -1676,6 +1677,32 @@
 
 ;; Miscellaneous instructions.
 
+;; In windowed ABI stack pointer adjustment must happen before any access
+;; to the space allocated on stack is allowed, otherwise register spill
+;; area may be clobbered.  That's what frame blockage is supposed to enforce.
+
+(define_expand "allocate_stack"
+  [(set (match_operand 0 "nonimmed_operand")
+        (minus (reg A1_REG) (match_operand 1 "add_operand")))
+   (set (reg A1_REG)
+        (minus (reg A1_REG) (match_dup 1)))]
+  "TARGET_WINDOWED_ABI"
+{
+  if (CONST_INT_P (operands[1]))
+    {
+      rtx neg_op0 = GEN_INT (-INTVAL (operands[1]));
+      emit_insn (gen_addsi3 (stack_pointer_rtx, stack_pointer_rtx, neg_op0));
+    }
+  else
+    {
+      emit_insn (gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx,
+			     operands[1]));
+    }
+  emit_move_insn (operands[0], virtual_stack_dynamic_rtx);
+  emit_insn (gen_frame_blockage ());
+  DONE;
+})
+
 (define_expand "prologue"
   [(const_int 0)]
   ""
@@ -1767,6 +1794,25 @@
   [(set_attr "length" "0")
    (set_attr "type" "nop")])
 
+;; Do not schedule instructions accessing memory before this point.
+
+(define_expand "frame_blockage"
+  [(set (match_dup 0)
+        (unspec:BLK [(match_dup 1)] UNSPEC_FRAME_BLOCKAGE))]
+  ""
+{
+  operands[0] = gen_rtx_MEM (BLKmode, gen_rtx_SCRATCH (Pmode));
+  MEM_VOLATILE_P (operands[0]) = 1;
+  operands[1] = stack_pointer_rtx;
+})
+
+(define_insn "*frame_blockage"
+  [(set (match_operand:BLK 0 "" "")
+        (unspec:BLK [(match_operand:SI 1 "" "")] UNSPEC_FRAME_BLOCKAGE))]
+  ""
+  ""
+  [(set_attr "length" "0")])
+
 (define_insn "trap"
   [(trap_if (const_int 1) (const_int 0))]
   ""
Index: gcc/config/rtems.h
===================================================================
diff --git a/gcc/config/rtems.h b/gcc/config/rtems.h
--- a/gcc/config/rtems.h	(revision 262353)
+++ b/gcc/config/rtems.h	(revision 262353)
@@ -48,3 +48,7 @@
  -latomic -lc -lgcc --end-group %{!qnolinkcmds: -T linkcmds%s}}}"
 
 #define TARGET_POSIX_IO
+
+/* Prefer int for int32_t (see stdint-newlib.h).  */
+#undef STDINT_LONG32
+#define STDINT_LONG32 (INT_TYPE_SIZE != 32 && LONG_TYPE_SIZE == 32)
Index: gcc/config/m68k/m68k.c
===================================================================
diff --git a/gcc/config/m68k/m68k.c b/gcc/config/m68k/m68k.c
--- a/gcc/config/m68k/m68k.c	(revision 262353)
+++ b/gcc/config/m68k/m68k.c	(revision 262353)
@@ -185,6 +185,8 @@
 static void m68k_init_sync_libfuncs (void) ATTRIBUTE_UNUSED;
 static enum flt_eval_method
 m68k_excess_precision (enum excess_precision_type);
+static machine_mode m68k_promote_function_mode (const_tree, machine_mode,
+						int *, const_tree, int);
 
 /* Initialize the GCC target structure.  */
 
@@ -332,6 +334,9 @@
 #undef TARGET_ATOMIC_TEST_AND_SET_TRUEVAL
 #define TARGET_ATOMIC_TEST_AND_SET_TRUEVAL 128
 
+#undef TARGET_PROMOTE_FUNCTION_MODE
+#define TARGET_PROMOTE_FUNCTION_MODE m68k_promote_function_mode
+
 static const struct attribute_spec m68k_attribute_table[] =
 {
   /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler,
@@ -6571,4 +6576,20 @@
   return FLT_EVAL_METHOD_UNPREDICTABLE;
 }
 
+/* Implement TARGET_PROMOTE_FUNCTION_MODE.  */
+
+static machine_mode
+m68k_promote_function_mode (const_tree type, machine_mode mode,
+                            int *punsignedp ATTRIBUTE_UNUSED,
+                            const_tree fntype ATTRIBUTE_UNUSED,
+                            int for_return)
+{
+  /* Promote libcall arguments narrower than int to match the normal C
+     ABI (for which promotions are handled via
+     TARGET_PROMOTE_PROTOTYPES).  */
+  if (type == NULL_TREE && !for_return && (mode == QImode || mode == HImode))
+    return SImode;
+  return mode;
+}
+
 #include "gt-m68k.h"
Index: gcc/config/riscv/t-rtems
===================================================================
diff --git a/gcc/config/riscv/t-rtems b/gcc/config/riscv/t-rtems
new file mode 10644
--- /dev/null	(nonexistent)
+++ b/gcc/config/riscv/t-rtems	(revision 262353)
@@ -0,0 +1,25 @@
+MULTILIB_OPTIONS	=
+MULTILIB_DIRNAMES	=
+
+MULTILIB_OPTIONS	+= march=rv32i/march=rv32im/march=rv32imafd/march=rv32iac/march=rv32imac/march=rv32imafc/march=rv64imafd/march=rv64imac/march=rv64imafdc
+MULTILIB_DIRNAMES	+= rv32i       rv32im       rv32imafd       rv32iac       rv32imac       rv32imafc       rv64imafd       rv64imac       rv64imafdc
+
+MULTILIB_OPTIONS	+= mabi=ilp32/mabi=ilp32f/mabi=ilp32d/mabi=lp64/mabi=lp64d
+MULTILIB_DIRNAMES	+= ilp32      ilp32f      ilp32d      lp64      lp64d
+
+MULTILIB_OPTIONS	+= mcmodel=medany
+MULTILIB_DIRNAMES	+= medany
+
+MULTILIB_REQUIRED	=
+MULTILIB_REQUIRED	+= march=rv32i/mabi=ilp32
+MULTILIB_REQUIRED	+= march=rv32im/mabi=ilp32
+MULTILIB_REQUIRED	+= march=rv32imafd/mabi=ilp32d
+MULTILIB_REQUIRED	+= march=rv32iac/mabi=ilp32
+MULTILIB_REQUIRED	+= march=rv32imac/mabi=ilp32
+MULTILIB_REQUIRED	+= march=rv32imafc/mabi=ilp32f
+MULTILIB_REQUIRED	+= march=rv64imafd/mabi=lp64d
+MULTILIB_REQUIRED	+= march=rv64imafd/mabi=lp64d/mcmodel=medany
+MULTILIB_REQUIRED	+= march=rv64imac/mabi=lp64
+MULTILIB_REQUIRED	+= march=rv64imac/mabi=lp64/mcmodel=medany
+MULTILIB_REQUIRED	+= march=rv64imafdc/mabi=lp64d
+MULTILIB_REQUIRED	+= march=rv64imafdc/mabi=lp64d/mcmodel=medany
Index: gcc/config/aarch64/aarch64-simd.md
===================================================================
diff --git a/gcc/config/aarch64/aarch64-simd.md b/gcc/config/aarch64/aarch64-simd.md
--- a/gcc/config/aarch64/aarch64-simd.md	(revision 262353)
+++ b/gcc/config/aarch64/aarch64-simd.md	(revision 262353)
@@ -2462,10 +2462,10 @@
 	  break;
 	}
       /* Fall through.  */
-    case UNGE:
+    case UNLT:
       std::swap (operands[2], operands[3]);
       /* Fall through.  */
-    case UNLE:
+    case UNGT:
     case GT:
       comparison = gen_aarch64_cmgt<mode>;
       break;
@@ -2476,10 +2476,10 @@
 	  break;
 	}
       /* Fall through.  */
-    case UNGT:
+    case UNLE:
       std::swap (operands[2], operands[3]);
       /* Fall through.  */
-    case UNLT:
+    case UNGE:
     case GE:
       comparison = gen_aarch64_cmge<mode>;
       break;
@@ -2490,6 +2490,7 @@
     case UNEQ:
     case ORDERED:
     case UNORDERED:
+    case LTGT:
       break;
     default:
       gcc_unreachable ();
@@ -2501,21 +2502,35 @@
     case UNGT:
     case UNLE:
     case UNLT:
-    case NE:
-      /* FCM returns false for lanes which are unordered, so if we use
-	 the inverse of the comparison we actually want to emit, then
-	 invert the result, we will end up with the correct result.
-	 Note that a NE NaN and NaN NE b are true for all a, b.
+      {
+	/* All of the above must not raise any FP exceptions.  Thus we first
+	   check each operand for NaNs and force any elements containing NaN to
+	   zero before using them in the compare.
+	   Example: UN<cc> (a, b) -> UNORDERED (a, b) |
+				     (cm<cc> (isnan (a) ? 0.0 : a,
+					      isnan (b) ? 0.0 : b))
+	   We use the following transformations for doing the comparisions:
+	   a UNGE b -> a GE b
+	   a UNGT b -> a GT b
+	   a UNLE b -> b GE a
+	   a UNLT b -> b GT a.  */
 
-	 Our transformations are:
-	 a UNGE b -> !(b GT a)
-	 a UNGT b -> !(b GE a)
-	 a UNLE b -> !(a GT b)
-	 a UNLT b -> !(a GE b)
-	 a   NE b -> !(a EQ b)  */
-      gcc_assert (comparison != NULL);
-      emit_insn (comparison (operands[0], operands[2], operands[3]));
-      emit_insn (gen_one_cmpl<v_cmp_result>2 (operands[0], operands[0]));
+	rtx tmp0 = gen_reg_rtx (<V_cmp_result>mode);
+	rtx tmp1 = gen_reg_rtx (<V_cmp_result>mode);
+	rtx tmp2 = gen_reg_rtx (<V_cmp_result>mode);
+	emit_insn (gen_aarch64_cmeq<mode> (tmp0, operands[2], operands[2]));
+	emit_insn (gen_aarch64_cmeq<mode> (tmp1, operands[3], operands[3]));
+	emit_insn (gen_and<v_cmp_result>3 (tmp2, tmp0, tmp1));
+	emit_insn (gen_and<v_cmp_result>3 (tmp0, tmp0,
+			lowpart_subreg (<V_cmp_result>mode, operands[2], <MODE>mode)));
+	emit_insn (gen_and<v_cmp_result>3 (tmp1, tmp1,
+			lowpart_subreg (<V_cmp_result>mode, operands[3], <MODE>mode)));
+	gcc_assert (comparison != NULL);
+	emit_insn (comparison (operands[0],
+			       lowpart_subreg (<MODE>mode, tmp0, <V_cmp_result>mode),
+			       lowpart_subreg (<MODE>mode, tmp1, <V_cmp_result>mode)));
+	emit_insn (gen_orn<v_cmp_result>3 (operands[0], tmp2, operands[0]));
+      }
       break;
 
     case LT:
@@ -2523,6 +2538,7 @@
     case GT:
     case GE:
     case EQ:
+    case NE:
       /* The easy case.  Here we emit one of FCMGE, FCMGT or FCMEQ.
 	 As a LT b <=> b GE a && a LE b <=> b GT a.  Our transformations are:
 	 a GE b -> a GE b
@@ -2529,36 +2545,39 @@
 	 a GT b -> a GT b
 	 a LE b -> b GE a
 	 a LT b -> b GT a
-	 a EQ b -> a EQ b  */
+	 a EQ b -> a EQ b
+	 a NE b -> ~(a EQ b)  */
       gcc_assert (comparison != NULL);
       emit_insn (comparison (operands[0], operands[2], operands[3]));
+      if (code == NE)
+	emit_insn (gen_one_cmpl<v_cmp_result>2 (operands[0], operands[0]));
       break;
 
-    case UNEQ:
-      /* We first check (a > b ||  b > a) which is !UNEQ, inverting
-	 this result will then give us (a == b || a UNORDERED b).  */
+    case LTGT:
+      /* LTGT is not guranteed to not generate a FP exception.  So let's
+	 go the faster way : ((a > b) || (b > a)).  */
       emit_insn (gen_aarch64_cmgt<mode> (operands[0],
 					 operands[2], operands[3]));
       emit_insn (gen_aarch64_cmgt<mode> (tmp, operands[3], operands[2]));
       emit_insn (gen_ior<v_cmp_result>3 (operands[0], operands[0], tmp));
-      emit_insn (gen_one_cmpl<v_cmp_result>2 (operands[0], operands[0]));
       break;
 
+    case ORDERED:
     case UNORDERED:
-      /* Operands are ORDERED iff (a > b || b >= a), so we can compute
-	 UNORDERED as !ORDERED.  */
-      emit_insn (gen_aarch64_cmgt<mode> (tmp, operands[2], operands[3]));
-      emit_insn (gen_aarch64_cmge<mode> (operands[0],
-					 operands[3], operands[2]));
-      emit_insn (gen_ior<v_cmp_result>3 (operands[0], operands[0], tmp));
-      emit_insn (gen_one_cmpl<v_cmp_result>2 (operands[0], operands[0]));
-      break;
+    case UNEQ:
+      /* cmeq (a, a) & cmeq (b, b).  */
+      emit_insn (gen_aarch64_cmeq<mode> (operands[0],
+					 operands[2], operands[2]));
+      emit_insn (gen_aarch64_cmeq<mode> (tmp, operands[3], operands[3]));
+      emit_insn (gen_and<v_cmp_result>3 (operands[0], operands[0], tmp));
 
-    case ORDERED:
-      emit_insn (gen_aarch64_cmgt<mode> (tmp, operands[2], operands[3]));
-      emit_insn (gen_aarch64_cmge<mode> (operands[0],
-					 operands[3], operands[2]));
-      emit_insn (gen_ior<v_cmp_result>3 (operands[0], operands[0], tmp));
+      if (code == UNORDERED)
+	emit_insn (gen_one_cmpl<v_cmp_result>2 (operands[0], operands[0]));
+      else if (code == UNEQ)
+	{
+	  emit_insn (gen_aarch64_cmeq<mode> (tmp, operands[2], operands[3]));
+	  emit_insn (gen_orn<v_cmp_result>3 (operands[0], operands[0], tmp));
+	}
       break;
 
     default:
Index: gcc/config/aarch64/aarch64.md
===================================================================
diff --git a/gcc/config/aarch64/aarch64.md b/gcc/config/aarch64/aarch64.md
--- a/gcc/config/aarch64/aarch64.md	(revision 262353)
+++ b/gcc/config/aarch64/aarch64.md	(revision 262353)
@@ -3093,7 +3093,8 @@
 (define_insn_and_split "*compare_cstore<mode>_insn"
   [(set (match_operand:GPI 0 "register_operand" "=r")
 	 (EQL:GPI (match_operand:GPI 1 "register_operand" "r")
-		  (match_operand:GPI 2 "aarch64_imm24" "n")))]
+		  (match_operand:GPI 2 "aarch64_imm24" "n")))
+   (clobber (reg:CC CC_REGNUM))]
   "!aarch64_move_imm (INTVAL (operands[2]), <MODE>mode)
    && !aarch64_plus_operand (operands[2], <MODE>mode)
    && !reload_completed"
Index: gcc/config/aarch64/constraints.md
===================================================================
diff --git a/gcc/config/aarch64/constraints.md b/gcc/config/aarch64/constraints.md
--- a/gcc/config/aarch64/constraints.md	(revision 262353)
+++ b/gcc/config/aarch64/constraints.md	(revision 262353)
@@ -21,8 +21,8 @@
 (define_register_constraint "k" "STACK_REG"
   "@internal The stack register.")
 
-(define_register_constraint "Ucs" "CALLER_SAVE_REGS"
-  "@internal The caller save registers.")
+(define_register_constraint "Ucs" "TAILCALL_ADDR_REGS"
+  "@internal Registers suitable for an indirect tail call")
 
 (define_register_constraint "w" "FP_REGS"
   "Floating point and SIMD vector registers.")
Index: gcc/config/aarch64/aarch64.c
===================================================================
diff --git a/gcc/config/aarch64/aarch64.c b/gcc/config/aarch64/aarch64.c
--- a/gcc/config/aarch64/aarch64.c	(revision 262353)
+++ b/gcc/config/aarch64/aarch64.c	(revision 262353)
@@ -4664,7 +4664,6 @@
 	case UNGT:
 	case UNGE:
 	case UNEQ:
-	case LTGT:
 	  return CCFPmode;
 
 	case LT:
@@ -4671,6 +4670,7 @@
 	case LE:
 	case GT:
 	case GE:
+	case LTGT:
 	  return CCFPEmode;
 
 	default:
@@ -5721,7 +5721,7 @@
 {
   switch (regclass)
     {
-    case CALLER_SAVE_REGS:
+    case TAILCALL_ADDR_REGS:
     case POINTER_REGS:
     case GENERAL_REGS:
     case ALL_REGS:
@@ -7799,10 +7799,10 @@
     = aarch64_tune_params.regmove_cost;
 
   /* Caller save and pointer regs are equivalent to GENERAL_REGS.  */
-  if (to == CALLER_SAVE_REGS || to == POINTER_REGS)
+  if (to == TAILCALL_ADDR_REGS || to == POINTER_REGS)
     to = GENERAL_REGS;
 
-  if (from == CALLER_SAVE_REGS || from == POINTER_REGS)
+  if (from == TAILCALL_ADDR_REGS || from == POINTER_REGS)
     from = GENERAL_REGS;
 
   /* Moving between GPR and stack cost is the same as GP2GP.  */
@@ -8608,17 +8608,6 @@
   if (opts->x_pcrelative_literal_loads == 1)
     aarch64_pcrelative_literal_loads = true;
 
-  /* This is PR70113. When building the Linux kernel with
-     CONFIG_ARM64_ERRATUM_843419, support for relocations
-     R_AARCH64_ADR_PREL_PG_HI21 and R_AARCH64_ADR_PREL_PG_HI21_NC is
-     removed from the kernel to avoid loading objects with possibly
-     offending sequences.  Without -mpc-relative-literal-loads we would
-     generate such relocations, preventing the kernel build from
-     succeeding.  */
-  if (opts->x_pcrelative_literal_loads == 2
-      && TARGET_FIX_ERR_A53_843419)
-    aarch64_pcrelative_literal_loads = true;
-
   /* In the tiny memory model it makes no sense to disallow PC relative
      literal pool loads.  */
   if (aarch64_cmodel == AARCH64_CMODEL_TINY
Index: gcc/config/aarch64/aarch64.h
===================================================================
diff --git a/gcc/config/aarch64/aarch64.h b/gcc/config/aarch64/aarch64.h
--- a/gcc/config/aarch64/aarch64.h	(revision 262353)
+++ b/gcc/config/aarch64/aarch64.h	(revision 262353)
@@ -439,7 +439,7 @@
 enum reg_class
 {
   NO_REGS,
-  CALLER_SAVE_REGS,
+  TAILCALL_ADDR_REGS,
   GENERAL_REGS,
   STACK_REG,
   POINTER_REGS,
@@ -454,7 +454,7 @@
 #define REG_CLASS_NAMES				\
 {						\
   "NO_REGS",					\
-  "CALLER_SAVE_REGS",				\
+  "TAILCALL_ADDR_REGS",				\
   "GENERAL_REGS",				\
   "STACK_REG",					\
   "POINTER_REGS",				\
@@ -466,7 +466,7 @@
 #define REG_CLASS_CONTENTS						\
 {									\
   { 0x00000000, 0x00000000, 0x00000000 },	/* NO_REGS */		\
-  { 0x0007ffff, 0x00000000, 0x00000000 },	/* CALLER_SAVE_REGS */	\
+  { 0x0004ffff, 0x00000000, 0x00000000 },	/* TAILCALL_ADDR_REGS */\
   { 0x7fffffff, 0x00000000, 0x00000003 },	/* GENERAL_REGS */	\
   { 0x80000000, 0x00000000, 0x00000000 },	/* STACK_REG */		\
   { 0xffffffff, 0x00000000, 0x00000003 },	/* POINTER_REGS */	\
Index: gcc/config/rs6000/vector.md
===================================================================
diff --git a/gcc/config/rs6000/vector.md b/gcc/config/rs6000/vector.md
--- a/gcc/config/rs6000/vector.md	(revision 262353)
+++ b/gcc/config/rs6000/vector.md	(revision 262353)
@@ -180,12 +180,7 @@
       operands[1] = rs6000_address_for_altivec (operands[1]);
       rtx and_op = XEXP (operands[1], 0);
       gcc_assert (GET_CODE (and_op) == AND);
-      rtx addr = XEXP (and_op, 0);
-      if (GET_CODE (addr) == PLUS)
-        emit_insn (gen_altivec_lvx_<mode>_2op (operands[0], XEXP (addr, 0),
-	                                       XEXP (addr, 1)));
-      else
-        emit_insn (gen_altivec_lvx_<mode>_1op (operands[0], operands[1]));
+      emit_insn (gen_altivec_lvx_<mode> (operands[0], operands[1]));
       DONE;
     }
 }")
@@ -203,12 +198,7 @@
       operands[0] = rs6000_address_for_altivec (operands[0]);
       rtx and_op = XEXP (operands[0], 0);
       gcc_assert (GET_CODE (and_op) == AND);
-      rtx addr = XEXP (and_op, 0);
-      if (GET_CODE (addr) == PLUS)
-        emit_insn (gen_altivec_stvx_<mode>_2op (operands[1], XEXP (addr, 0),
-	                                        XEXP (addr, 1)));
-      else
-        emit_insn (gen_altivec_stvx_<mode>_1op (operands[1], operands[0]));
+      emit_insn (gen_altivec_stvx_<mode> (operands[1], operands[0]));
       DONE;
     }
 }")
Index: gcc/config/rs6000/predicates.md
===================================================================
diff --git a/gcc/config/rs6000/predicates.md b/gcc/config/rs6000/predicates.md
--- a/gcc/config/rs6000/predicates.md	(revision 262353)
+++ b/gcc/config/rs6000/predicates.md	(revision 262353)
@@ -1468,13 +1468,12 @@
   rtx elt;
   int count = XVECLEN (op, 0);
 
-  if (count != 59)
+  if (count != 58)
     return 0;
 
   index = 0;
   if (GET_CODE (XVECEXP (op, 0, index++)) != RETURN
       || GET_CODE (XVECEXP (op, 0, index++)) != USE
-      || GET_CODE (XVECEXP (op, 0, index++)) != USE
       || GET_CODE (XVECEXP (op, 0, index++)) != CLOBBER)
     return 0;
 
Index: gcc/config/rs6000/sysv4.opt
===================================================================
diff --git a/gcc/config/rs6000/sysv4.opt b/gcc/config/rs6000/sysv4.opt
--- a/gcc/config/rs6000/sysv4.opt	(revision 262353)
+++ b/gcc/config/rs6000/sysv4.opt	(revision 262353)
@@ -27,6 +27,10 @@
 Target RejectNegative Joined Var(rs6000_sdata_name)
 Select method for sdata handling.
 
+mreadonly-in-sdata
+Target Report Var(rs6000_readonly_in_sdata) Init(1) Save
+Allow readonly data in sdata.
+
 mtls-size=
 Target RejectNegative Joined Var(rs6000_tls_size) Enum(rs6000_tls_size)
 Specify bit size of immediate TLS offsets.
Index: gcc/config/rs6000/rs6000-protos.h
===================================================================
diff --git a/gcc/config/rs6000/rs6000-protos.h b/gcc/config/rs6000/rs6000-protos.h
--- a/gcc/config/rs6000/rs6000-protos.h	(revision 262353)
+++ b/gcc/config/rs6000/rs6000-protos.h	(revision 262353)
@@ -139,7 +139,6 @@
 extern int rs6000_emit_cmove (rtx, rtx, rtx, rtx);
 extern int rs6000_emit_vector_cond_expr (rtx, rtx, rtx, rtx, rtx, rtx);
 extern void rs6000_emit_minmax (rtx, enum rtx_code, rtx, rtx);
-extern void rs6000_split_signbit (rtx, rtx);
 extern void rs6000_expand_atomic_compare_and_swap (rtx op[]);
 extern void rs6000_expand_atomic_exchange (rtx op[]);
 extern void rs6000_expand_atomic_op (enum rtx_code, rtx, rtx, rtx, rtx, rtx);
Index: gcc/config/rs6000/rs6000-builtin.def
===================================================================
diff --git a/gcc/config/rs6000/rs6000-builtin.def b/gcc/config/rs6000/rs6000-builtin.def
--- a/gcc/config/rs6000/rs6000-builtin.def	(revision 262353)
+++ b/gcc/config/rs6000/rs6000-builtin.def	(revision 262353)
@@ -1,5 +1,5 @@
 /* Builtin functions for rs6000/powerpc.
-   Copyright (C) 2009-2017 Free Software Foundation, Inc.
+   Copyright (C) 2009-2018 Free Software Foundation, Inc.
    Contributed by Michael Meissner (meissner@linux.vnet.ibm.com)
 
    This file is part of GCC.
@@ -659,6 +659,14 @@
 		     | RS6000_BTC_BINARY),				\
 		    CODE_FOR_ ## ICODE)			/* ICODE */
 
+#define BU_P7_POWERPC64_MISC_2(ENUM, NAME, ATTR, ICODE)			\
+  RS6000_BUILTIN_2 (MISC_BUILTIN_ ## ENUM,		/* ENUM */      \
+		    "__builtin_" NAME,			/* NAME */      \
+		    RS6000_BTM_POPCNTD			/* MASK */	\
+		    | RS6000_BTM_POWERPC64,				\
+		    (RS6000_BTC_ ## ATTR		/* ATTR */      \
+		    | RS6000_BTC_BINARY),				\
+		    CODE_FOR_ ## ICODE)			/* ICODE */
 
 /* Miscellaneous builtins for instructions added in ISA 2.07.  These
    instructions do require the ISA 2.07 vector support, but they aren't vector
@@ -2034,8 +2042,8 @@
 
 /* Insert/extract 4 byte word into a vector.  */
 BU_P9V_VSX_2 (VEXTRACT4B,   "vextract4b",	CONST,	vextract4b)
-BU_P9V_VSX_3 (VINSERT4B,    "vinsert4b",	CONST,	vinsert4b)
-BU_P9V_VSX_3 (VINSERT4B_DI, "vinsert4b_di",	CONST,	vinsert4b_di)
+BU_P9V_VSX_3 (INSERT4B,    "insert4b",		CONST,  insert4b)
+BU_P9V_VSX_2 (EXTRACT4B,   "extract4b", 	CONST,  extract4b)
 
 /* 3 argument vector functions returning void, treated as SPECIAL,
    added in ISA 3.0 (power9).  */
@@ -2084,10 +2092,11 @@
 BU_P9V_OVERLOAD_2 (VEXTULX,	"vextulx")
 BU_P9V_OVERLOAD_2 (VEXTURX,	"vexturx")
 BU_P9V_OVERLOAD_2 (VEXTRACT4B,	"vextract4b")
+BU_P9V_OVERLOAD_2 (EXTRACT4B,  "extract4b")
 
 /* ISA 3.0 Vector scalar overloaded 3 argument functions */
 BU_P9V_OVERLOAD_3 (STXVL,	"stxvl")
-BU_P9V_OVERLOAD_3 (VINSERT4B,	"vinsert4b")
+BU_P9V_OVERLOAD_3 (INSERT4B,    "insert4b")
 
 /* Overloaded CMPNE support was implemented prior to Power 9,
    so is not mentioned here.  */
@@ -2103,13 +2112,9 @@
 
 /* 2 argument extended divide functions added in ISA 2.06.  */
 BU_P7_MISC_2 (DIVWE,		"divwe",	CONST,	dive_si)
-BU_P7_MISC_2 (DIVWEO,		"divweo",	CONST,	diveo_si)
 BU_P7_MISC_2 (DIVWEU,		"divweu",	CONST,	diveu_si)
-BU_P7_MISC_2 (DIVWEUO,		"divweuo",	CONST,	diveuo_si)
-BU_P7_MISC_2 (DIVDE,		"divde",	CONST,	dive_di)
-BU_P7_MISC_2 (DIVDEO,		"divdeo",	CONST,	diveo_di)
-BU_P7_MISC_2 (DIVDEU,		"divdeu",	CONST,	diveu_di)
-BU_P7_MISC_2 (DIVDEUO,		"divdeuo",	CONST,	diveuo_di)
+BU_P7_POWERPC64_MISC_2 (DIVDE,	"divde",	CONST,	dive_di)
+BU_P7_POWERPC64_MISC_2 (DIVDEU,	"divdeu",	CONST,	diveu_di)
 
 /* 1 argument DFP (decimal floating point) functions added in ISA 2.05.  */
 BU_DFP_MISC_1 (DXEX,		"dxex",		CONST,	dfp_dxex_dd)
Index: gcc/config/rs6000/rs6000-c.c
===================================================================
diff --git a/gcc/config/rs6000/rs6000-c.c b/gcc/config/rs6000/rs6000-c.c
--- a/gcc/config/rs6000/rs6000-c.c	(revision 262353)
+++ b/gcc/config/rs6000/rs6000-c.c	(revision 262353)
@@ -2393,7 +2393,7 @@
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },
   { ALTIVEC_BUILTIN_VEC_PACKSU, P8V_BUILTIN_VPKSDUS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_V2DI, RS6000_BTI_V2DI, 0 },
-  { ALTIVEC_BUILTIN_VEC_PACKSU, P8V_BUILTIN_VPKSDUS,
+  { ALTIVEC_BUILTIN_VEC_PACKSU, P8V_BUILTIN_VPKUDUS,
     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },
   { ALTIVEC_BUILTIN_VEC_VPKSWUS, ALTIVEC_BUILTIN_VPKSWUS,
     RS6000_BTI_unsigned_V8HI, RS6000_BTI_V4SI, RS6000_BTI_V4SI, 0 },
@@ -5047,6 +5047,8 @@
     RS6000_BTI_INTDI, RS6000_BTI_V16QI, RS6000_BTI_UINTSI, 0 },
   { P9V_BUILTIN_VEC_VEXTRACT4B, P9V_BUILTIN_VEXTRACT4B,
     RS6000_BTI_INTDI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_UINTSI, 0 },
+  { P9V_BUILTIN_VEC_EXTRACT4B, P9V_BUILTIN_EXTRACT4B,
+    RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI, 0 },
 
   { P9V_BUILTIN_VEC_VEXTULX, P9V_BUILTIN_VEXTUBLX,
     RS6000_BTI_INTQI, RS6000_BTI_UINTSI,
@@ -5101,27 +5103,12 @@
   { P8V_BUILTIN_VEC_VGBBD, P8V_BUILTIN_VGBBD,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V16QI, 0, 0 },
 
-  { P9V_BUILTIN_VEC_VINSERT4B, P9V_BUILTIN_VINSERT4B,
-    RS6000_BTI_V16QI, RS6000_BTI_V4SI,
-    RS6000_BTI_V16QI, RS6000_BTI_UINTSI },
-  { P9V_BUILTIN_VEC_VINSERT4B, P9V_BUILTIN_VINSERT4B,
-    RS6000_BTI_V16QI, RS6000_BTI_unsigned_V4SI,
-    RS6000_BTI_V16QI, RS6000_BTI_UINTSI },
-  { P9V_BUILTIN_VEC_VINSERT4B, P9V_BUILTIN_VINSERT4B,
+  { P9V_BUILTIN_VEC_INSERT4B, P9V_BUILTIN_INSERT4B,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_V4SI,
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI },
+  { P9V_BUILTIN_VEC_INSERT4B, P9V_BUILTIN_INSERT4B,
     RS6000_BTI_unsigned_V16QI, RS6000_BTI_unsigned_V4SI,
-    RS6000_BTI_unsigned_V16QI, RS6000_BTI_UINTSI },
-  { P9V_BUILTIN_VEC_VINSERT4B, P9V_BUILTIN_VINSERT4B_DI,
-    RS6000_BTI_V16QI, RS6000_BTI_INTDI,
-    RS6000_BTI_V16QI, RS6000_BTI_UINTDI },
-  { P9V_BUILTIN_VEC_VINSERT4B, P9V_BUILTIN_VINSERT4B_DI,
-    RS6000_BTI_V16QI, RS6000_BTI_UINTDI,
-    RS6000_BTI_V16QI, RS6000_BTI_UINTDI },
-  { P9V_BUILTIN_VEC_VINSERT4B, P9V_BUILTIN_VINSERT4B_DI,
-    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTDI,
-    RS6000_BTI_unsigned_V16QI, RS6000_BTI_UINTDI },
-  { P9V_BUILTIN_VEC_VINSERT4B, P9V_BUILTIN_VINSERT4B_DI,
-    RS6000_BTI_unsigned_V16QI, RS6000_BTI_UINTDI,
-    RS6000_BTI_unsigned_V16QI, RS6000_BTI_UINTDI },
+    RS6000_BTI_unsigned_V16QI, RS6000_BTI_INTSI },
 
   { P8V_BUILTIN_VEC_VADDECUQ, P8V_BUILTIN_VADDECUQ,
     RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_V1TI, RS6000_BTI_V1TI },
@@ -6088,6 +6075,15 @@
       stmt = build_binary_op (loc, PLUS_EXPR, stmt, arg2, 1);
       stmt = build_indirect_ref (loc, stmt, RO_NULL);
 
+      /* PR83660: We mark this as having side effects so that
+	 downstream in fold_build_cleanup_point_expr () it will get a
+	 CLEANUP_POINT_EXPR.  If it does not we can run into an ICE
+	 later in gimplify_cleanup_point_expr ().  Potentially this
+	 causes missed optimization because the actually is no side
+	 effect.  */
+      if (c_dialect_cxx ())
+	TREE_SIDE_EFFECTS (stmt) = 1;
+
       return stmt;
     }
 
Index: gcc/config/rs6000/rs6000.c
===================================================================
diff --git a/gcc/config/rs6000/rs6000.c b/gcc/config/rs6000/rs6000.c
--- a/gcc/config/rs6000/rs6000.c	(revision 262353)
+++ b/gcc/config/rs6000/rs6000.c	(revision 262353)
@@ -1,5 +1,5 @@
 /* Subroutines used for code generation on IBM RS/6000.
-   Copyright (C) 1991-2017 Free Software Foundation, Inc.
+   Copyright (C) 1991-2018 Free Software Foundation, Inc.
    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)
 
    This file is part of GCC.
@@ -1372,6 +1372,7 @@
 						   int, int, int *);
 static bool rs6000_mode_dependent_address (const_rtx);
 static bool rs6000_debug_mode_dependent_address (const_rtx);
+static bool rs6000_offsettable_memref_p (rtx, machine_mode, bool);
 static enum reg_class rs6000_secondary_reload_class (enum reg_class,
 						     machine_mode, rtx);
 static enum reg_class rs6000_debug_secondary_reload_class (enum reg_class,
@@ -3890,6 +3891,7 @@
 	  | ((TARGET_P9_MISC)		    ? RS6000_BTM_P9_MISC   : 0)
 	  | ((TARGET_MODULO)		    ? RS6000_BTM_MODULO    : 0)
 	  | ((TARGET_64BIT)		    ? RS6000_BTM_64BIT     : 0)
+	  | ((TARGET_POWERPC64)		    ? RS6000_BTM_POWERPC64 : 0)
 	  | ((TARGET_CRYPTO)		    ? RS6000_BTM_CRYPTO	   : 0)
 	  | ((TARGET_HTM)		    ? RS6000_BTM_HTM	   : 0)
 	  | ((TARGET_DFP)		    ? RS6000_BTM_DFP	   : 0)
@@ -5563,6 +5565,11 @@
   if (TARGET_LINK_STACK == -1)
     SET_TARGET_LINK_STACK (rs6000_cpu == PROCESSOR_PPC476 && flag_pic);
 
+  /* Deprecate use of -mno-speculate-indirect-jumps.  */
+  if (!rs6000_speculate_indirect_jumps)
+    warning (0, "%qs is deprecated and not recommended in any circumstances",
+	     "-mno-speculate-indirect-jumps");
+
   return ret;
 }
 
@@ -8558,6 +8565,17 @@
   int extra;
   rtx addr = XEXP (op, 0);
 
+  /* PR85755: Allow PRE_INC and PRE_DEC addresses.  */
+  if (TARGET_UPDATE
+      && (GET_CODE (addr) == PRE_INC || GET_CODE (addr) == PRE_DEC)
+      && mode_supports_pre_incdec_p (mode)
+      && legitimate_indirect_address_p (XEXP (addr, 0), false))
+    return true;
+
+  /* Don't allow non-offsettable addresses.  See PRs 83969 and 84279.  */
+  if (!rs6000_offsettable_memref_p (op, mode, false))
+    return false;
+
   op = address_offset (addr);
   if (op == NULL_RTX)
     return true;
@@ -10328,7 +10346,7 @@
    in 32-bit mode, that the recog predicate rejects.  */
 
 static bool
-rs6000_offsettable_memref_p (rtx op, machine_mode reg_mode)
+rs6000_offsettable_memref_p (rtx op, machine_mode reg_mode, bool strict)
 {
   bool worst_case;
 
@@ -10336,7 +10354,7 @@
     return false;
 
   /* First mimic offsettable_memref_p.  */
-  if (offsettable_address_p (true, GET_MODE (op), XEXP (op, 0)))
+  if (offsettable_address_p (strict, GET_MODE (op), XEXP (op, 0)))
     return true;
 
   /* offsettable_address_p invokes rs6000_mode_dependent_address, but
@@ -10350,7 +10368,7 @@
   worst_case = ((TARGET_POWERPC64 && GET_MODE_CLASS (reg_mode) == MODE_INT)
 		|| GET_MODE_SIZE (reg_mode) == 4);
   return rs6000_legitimate_offset_address_p (GET_MODE (op), XEXP (op, 0),
-					     true, worst_case);
+					     strict, worst_case);
 }
 
 /* Determine the reassociation width to be used in reassociate_bb.
@@ -14106,6 +14124,7 @@
 
       tree copy = build_call_expr (builtin_decl_implicit (BUILT_IN_MEMCPY),
 				   3, dest_addr, addr, size_int (rsize * 4));
+      TREE_ADDRESSABLE (tmp) = 1;
 
       gimplify_and_add (copy, pre_p);
       addr = dest_addr;
@@ -15087,12 +15106,12 @@
   /* For LVX, express the RTL accurately by ANDing the address with -16.
      LVXL and LVE*X expand to use UNSPECs to hide their special behavior,
      so the raw address is fine.  */
-  if (icode == CODE_FOR_altivec_lvx_v2df_2op
-      || icode == CODE_FOR_altivec_lvx_v2di_2op
-      || icode == CODE_FOR_altivec_lvx_v4sf_2op
-      || icode == CODE_FOR_altivec_lvx_v4si_2op
-      || icode == CODE_FOR_altivec_lvx_v8hi_2op
-      || icode == CODE_FOR_altivec_lvx_v16qi_2op)
+  if (icode == CODE_FOR_altivec_lvx_v2df
+      || icode == CODE_FOR_altivec_lvx_v2di
+      || icode == CODE_FOR_altivec_lvx_v4sf
+      || icode == CODE_FOR_altivec_lvx_v4si
+      || icode == CODE_FOR_altivec_lvx_v8hi
+      || icode == CODE_FOR_altivec_lvx_v16qi)
     {
       rtx rawaddr;
       if (op0 == const0_rtx)
@@ -15278,12 +15297,12 @@
   /* For STVX, express the RTL accurately by ANDing the address with -16.
      STVXL and STVE*X expand to use UNSPECs to hide their special behavior,
      so the raw address is fine.  */
-  if (icode == CODE_FOR_altivec_stvx_v2df_2op
-      || icode == CODE_FOR_altivec_stvx_v2di_2op
-      || icode == CODE_FOR_altivec_stvx_v4sf_2op
-      || icode == CODE_FOR_altivec_stvx_v4si_2op
-      || icode == CODE_FOR_altivec_stvx_v8hi_2op
-      || icode == CODE_FOR_altivec_stvx_v16qi_2op)
+  if (icode == CODE_FOR_altivec_stvx_v2df
+      || icode == CODE_FOR_altivec_stvx_v2di
+      || icode == CODE_FOR_altivec_stvx_v4sf
+      || icode == CODE_FOR_altivec_stvx_v4si
+      || icode == CODE_FOR_altivec_stvx_v8hi
+      || icode == CODE_FOR_altivec_stvx_v16qi)
     {
       if (op1 == const0_rtx)
 	rawaddr = op2;
@@ -16184,18 +16203,18 @@
   switch (fcode)
     {
     case ALTIVEC_BUILTIN_STVX_V2DF:
-      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v2df_2op, exp);
+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v2df, exp);
     case ALTIVEC_BUILTIN_STVX_V2DI:
-      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v2di_2op, exp);
+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v2di, exp);
     case ALTIVEC_BUILTIN_STVX_V4SF:
-      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v4sf_2op, exp);
+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v4sf, exp);
     case ALTIVEC_BUILTIN_STVX:
     case ALTIVEC_BUILTIN_STVX_V4SI:
-      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v4si_2op, exp);
+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v4si, exp);
     case ALTIVEC_BUILTIN_STVX_V8HI:
-      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v8hi_2op, exp);
+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v8hi, exp);
     case ALTIVEC_BUILTIN_STVX_V16QI:
-      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v16qi_2op, exp);
+      return altivec_expand_stv_builtin (CODE_FOR_altivec_stvx_v16qi, exp);
     case ALTIVEC_BUILTIN_STVEBX:
       return altivec_expand_stv_builtin (CODE_FOR_altivec_stvebx, exp);
     case ALTIVEC_BUILTIN_STVEHX:
@@ -16374,6 +16393,7 @@
 
     case P9V_BUILTIN_VEXTRACT4B:
     case P9V_BUILTIN_VEC_VEXTRACT4B:
+    case P9V_BUILTIN_VEC_EXTRACT4B:
       arg1 = CALL_EXPR_ARG (exp, 1);
       STRIP_NOPS (arg1);
 
@@ -16388,9 +16408,7 @@
 	}
       break;
 
-    case P9V_BUILTIN_VINSERT4B:
-    case P9V_BUILTIN_VINSERT4B_DI:
-    case P9V_BUILTIN_VEC_VINSERT4B:
+    case P9V_BUILTIN_VEC_INSERT4B:
       arg2 = CALL_EXPR_ARG (exp, 2);
       STRIP_NOPS (arg2);
 
@@ -16400,7 +16418,7 @@
 
       if (TREE_CODE (arg2) != INTEGER_CST || TREE_INT_CST_LOW (arg2) > 12)
 	{
-	  error ("third argument to vec_vinsert4b must be 0..12");
+	  error ("third argument to vec_insert4b must be 0..12");
 	  return expand_call (exp, target, false);
 	}
       break;
@@ -16460,23 +16478,23 @@
       return altivec_expand_lv_builtin (CODE_FOR_altivec_lvxl_v16qi,
 					exp, target, false);
     case ALTIVEC_BUILTIN_LVX_V2DF:
-      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v2df_2op,
+      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v2df,
 					exp, target, false);
     case ALTIVEC_BUILTIN_LVX_V2DI:
-      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v2di_2op,
+      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v2di,
 					exp, target, false);
     case ALTIVEC_BUILTIN_LVX_V4SF:
-      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v4sf_2op,
+      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v4sf,
 					exp, target, false);
     case ALTIVEC_BUILTIN_LVX:
     case ALTIVEC_BUILTIN_LVX_V4SI:
-      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v4si_2op,
+      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v4si,
 					exp, target, false);
     case ALTIVEC_BUILTIN_LVX_V8HI:
-      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v8hi_2op,
+      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v8hi,
 					exp, target, false);
     case ALTIVEC_BUILTIN_LVX_V16QI:
-      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v16qi_2op,
+      return altivec_expand_lv_builtin (CODE_FOR_altivec_lvx_v16qi,
 					exp, target, false);
     case ALTIVEC_BUILTIN_LVLX:
       return altivec_expand_lv_builtin (CODE_FOR_altivec_lvlx,
@@ -17040,6 +17058,11 @@
     error ("Builtin function %s requires the -mhard-float option", name);
   else if ((fnmask & RS6000_BTM_FLOAT128) != 0)
     error ("Builtin function %s requires the -mfloat128 option", name);
+  else if ((fnmask & (RS6000_BTM_POPCNTD | RS6000_BTM_POWERPC64))
+	   == (RS6000_BTM_POPCNTD | RS6000_BTM_POWERPC64))
+    error ("builtin function %qs requires the %qs (or newer), and "
+	   "%qs or %qs options",
+	   name, "-mcpu=power7", "-m64", "-mpowerpc64");
   else
     error ("Builtin function %s is not supported with the current options",
 	   name);
@@ -18804,9 +18827,7 @@
     case CRYPTO_BUILTIN_VPMSUM:
     case MISC_BUILTIN_ADDG6S:
     case MISC_BUILTIN_DIVWEU:
-    case MISC_BUILTIN_DIVWEUO:
     case MISC_BUILTIN_DIVDEU:
-    case MISC_BUILTIN_DIVDEUO:
       h.uns_p[0] = 1;
       h.uns_p[1] = 1;
       h.uns_p[2] = 1;
@@ -23267,7 +23288,7 @@
 	}
 
       else if (TARGET_ALTIVEC && src_vmx_p
-	       && altivec_indexed_or_indirect_operand (src, mode))
+	       && altivec_indexed_or_indirect_operand (dest, mode))
 	return "stvx %1,%y0";
 
       else if (TARGET_VSX && src_vsx_p)
@@ -23980,7 +24001,7 @@
 
 	    /* Fall through.  Must be [reg+reg].  */
 	  }
-	if (VECTOR_MEM_ALTIVEC_P (GET_MODE (x))
+	if (VECTOR_MEM_ALTIVEC_OR_VSX_P (GET_MODE (x))
 	    && GET_CODE (tmp) == AND
 	    && GET_CODE (XEXP (tmp, 1)) == CONST_INT
 	    && INTVAL (XEXP (tmp, 1)) == -16)
@@ -25907,49 +25928,6 @@
     emit_move_insn (dest, target);
 }
 
-/* Split a signbit operation on 64-bit machines with direct move.  Also allow
-   for the value to come from memory or if it is already loaded into a GPR.  */
-
-void
-rs6000_split_signbit (rtx dest, rtx src)
-{
-  machine_mode d_mode = GET_MODE (dest);
-  machine_mode s_mode = GET_MODE (src);
-  rtx dest_di = (d_mode == DImode) ? dest : gen_lowpart (DImode, dest);
-  rtx shift_reg = dest_di;
-
-  gcc_assert (FLOAT128_IEEE_P (s_mode) && TARGET_POWERPC64);
-
-  if (MEM_P (src))
-    {
-      rtx mem = (WORDS_BIG_ENDIAN
-		 ? adjust_address (src, DImode, 0)
-		 : adjust_address (src, DImode, 8));
-      emit_insn (gen_rtx_SET (dest_di, mem));
-    }
-
-  else
-    {
-      unsigned int r = reg_or_subregno (src);
-
-      if (INT_REGNO_P (r))
-	shift_reg = gen_rtx_REG (DImode, r + (BYTES_BIG_ENDIAN == 0));
-
-      else
-	{
-	  /* Generate the special mfvsrd instruction to get it in a GPR.  */
-	  gcc_assert (VSX_REGNO_P (r));
-	  if (s_mode == KFmode)
-	    emit_insn (gen_signbitkf2_dm2 (dest_di, src));
-	  else
-	    emit_insn (gen_signbittf2_dm2 (dest_di, src));
-	}
-    }
-
-  emit_insn (gen_lshrdi3 (dest_di, shift_reg, GEN_INT (63)));
-  return;
-}
-
 /* A subroutine of the atomic operation splitters.  Jump to LABEL if
    COND is true.  Mark the jump as unlikely to be taken.  */
 
@@ -26588,7 +26566,7 @@
 	      emit_insn (gen_add3_insn (breg, breg, delta_rtx));
 	      src = replace_equiv_address (src, breg);
 	    }
-	  else if (! rs6000_offsettable_memref_p (src, reg_mode))
+	  else if (! rs6000_offsettable_memref_p (src, reg_mode, true))
 	    {
 	      if (GET_CODE (XEXP (src, 0)) == PRE_MODIFY)
 		{
@@ -26655,7 +26633,7 @@
 		emit_insn (gen_add3_insn (breg, breg, delta_rtx));
 	      dst = replace_equiv_address (dst, breg);
 	    }
-	  else if (!rs6000_offsettable_memref_p (dst, reg_mode)
+	  else if (!rs6000_offsettable_memref_p (dst, reg_mode, true)
 		   && GET_CODE (XEXP (dst, 0)) != LO_SUM)
 	    {
 	      if (GET_CODE (XEXP (dst, 0)) == PRE_MODIFY)
@@ -26694,7 +26672,7 @@
 		}
 	    }
 	  else if (GET_CODE (XEXP (dst, 0)) != LO_SUM)
-	    gcc_assert (rs6000_offsettable_memref_p (dst, reg_mode));
+	    gcc_assert (rs6000_offsettable_memref_p (dst, reg_mode, true));
 	}
 
       for (i = 0; i < nregs; i++)
@@ -31988,8 +31966,9 @@
 	  emit_insn_after (pat, get_insns ());
 	  pop_topmost_sequence ();
 	}
-      return plus_constant (Pmode, cfun->machine->split_stack_arg_pointer,
-			    FIRST_PARM_OFFSET (current_function_decl));
+      rtx ret = plus_constant (Pmode, cfun->machine->split_stack_arg_pointer,
+			       FIRST_PARM_OFFSET (current_function_decl));
+      return copy_to_reg (ret);
     }
   return virtual_incoming_args_rtx;
 }
@@ -35647,6 +35626,11 @@
     }
   else
     {
+      /* If we are told not to put readonly data in sdata, then don't.  */
+      if (TREE_READONLY (decl) && rs6000_sdata != SDATA_EABI
+	  && !rs6000_readonly_in_sdata)
+	return false;
+
       HOST_WIDE_INT size = int_size_in_bytes (TREE_TYPE (decl));
 
       if (size > 0
@@ -39167,6 +39151,7 @@
   { "hard-dfp",		 RS6000_BTM_DFP,	false, false },
   { "hard-float",	 RS6000_BTM_HARD_FLOAT,	false, false },
   { "long-double-128",	 RS6000_BTM_LDBL128,	false, false },
+  { "powerpc64",	 RS6000_BTM_POWERPC64,  false, false },
   { "float128",		 RS6000_BTM_FLOAT128,   false, false },
 };
 
@@ -41657,6 +41642,38 @@
   return 1;
 }
 
+/* Return 1 iff UID, known to reference a swap, is both fed by a load
+   and a feeder of a store.  */
+static unsigned int
+swap_feeds_both_load_and_store (swap_web_entry *insn_entry)
+{
+  rtx insn = insn_entry->insn;
+  struct df_insn_info *insn_info = DF_INSN_INFO_GET (insn);
+  df_ref def, use;
+  struct df_link *link = 0;
+  rtx_insn *load = 0, *store = 0;
+  bool fed_by_load = 0;
+  bool feeds_store = 0;
+
+  FOR_EACH_INSN_INFO_USE (use, insn_info)
+    {
+      link = DF_REF_CHAIN (use);
+      load = DF_REF_INSN (link->ref);
+      if (insn_is_load_p (load) && insn_is_swap_p (load))
+	fed_by_load = 1;
+    }
+
+  FOR_EACH_INSN_INFO_DEF (def, insn_info)
+    {
+      link = DF_REF_CHAIN (def);
+      store = DF_REF_INSN (link->ref);
+      if (insn_is_store_p (store) && insn_is_swap_p (store))
+	feeds_store = 1;
+    }
+
+  return fed_by_load && feeds_store;
+}
+
 /* Return TRUE if insn is a swap fed by a load from the constant pool.  */
 static bool
 const_load_sequence_p (swap_web_entry *insn_entry, rtx insn)
@@ -41860,6 +41877,7 @@
 	  {
 	  default:
 	    break;
+	  case UNSPEC_VBPERMQ:
 	  case UNSPEC_VMRGH_DIRECT:
 	  case UNSPEC_VMRGL_DIRECT:
 	  case UNSPEC_VPACK_SIGN_SIGN_SAT:
@@ -41871,6 +41889,7 @@
 	  case UNSPEC_VPERM_UNS:
 	  case UNSPEC_VPERMHI:
 	  case UNSPEC_VPERMSI:
+	  case UNSPEC_VPERMXOR:
 	  case UNSPEC_VPKPX:
 	  case UNSPEC_VSLDOI:
 	  case UNSPEC_VSLO:
@@ -43129,6 +43148,14 @@
 	  && !insn_entry[i].is_swap && !insn_entry[i].is_swappable)
 	root->web_not_optimizable = 1;
 
+      /* If we have a swap that is both fed by a permuting load
+	 and a feeder of a permuting store, then the optimization
+	 isn't appropriate.  (Consider vec_xl followed by vec_xst_be.)  */
+      else if (insn_entry[i].is_swap && !insn_entry[i].is_load
+	       && !insn_entry[i].is_store
+	       && swap_feeds_both_load_and_store (&insn_entry[i]))
+	root->web_not_optimizable = 1;
+
       /* If we have permuting loads or stores that are not accompanied
 	 by a register swap, the optimization isn't appropriate.  */
       else if (insn_entry[i].is_load && insn_entry[i].is_swap)
Index: gcc/config/rs6000/vsx.md
===================================================================
diff --git a/gcc/config/rs6000/vsx.md b/gcc/config/rs6000/vsx.md
--- a/gcc/config/rs6000/vsx.md	(revision 262353)
+++ b/gcc/config/rs6000/vsx.md	(revision 262353)
@@ -157,6 +157,22 @@
 			 (TF	"wp")
 			 (KF	"wq")])
 
+;; A mode attribute to disparage use of GPR registers, except for scalar
+;; interger modes.
+(define_mode_attr ??r	[(V16QI "??r")
+			 (V8HI  "??r")
+			 (V4SI  "??r")
+			 (V4SF  "??r")
+			 (V2DI  "??r")
+			 (V2DF  "??r")
+			 (DI    "r")
+			 (DF    "??r")
+			 (SF    "??r")
+			 (V1TI  "??r")
+			 (TI    "r")
+			 (TF    "??r")
+			 (KF    "??r")])
+
 ;; Same size integer type for floating point data
 (define_mode_attr VSi [(V4SF  "v4si")
 		       (V2DF  "v2di")
@@ -385,7 +401,7 @@
 ;; VSX moves so they match first.
 (define_insn_and_split "*vsx_le_perm_load_<mode>"
   [(set (match_operand:VSX_D 0 "vsx_register_operand" "=<VSa>")
-        (match_operand:VSX_D 1 "memory_operand" "Z"))]
+        (match_operand:VSX_D 1 "indexed_or_indirect_operand" "Z"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
   "#"
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
@@ -408,7 +424,7 @@
 
 (define_insn_and_split "*vsx_le_perm_load_<mode>"
   [(set (match_operand:VSX_W 0 "vsx_register_operand" "=<VSa>")
-        (match_operand:VSX_W 1 "memory_operand" "Z"))]
+        (match_operand:VSX_W 1 "indexed_or_indirect_operand" "Z"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
   "#"
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
@@ -433,7 +449,7 @@
 
 (define_insn_and_split "*vsx_le_perm_load_v8hi"
   [(set (match_operand:V8HI 0 "vsx_register_operand" "=wa")
-        (match_operand:V8HI 1 "memory_operand" "Z"))]
+        (match_operand:V8HI 1 "indexed_or_indirect_operand" "Z"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
   "#"
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
@@ -462,7 +478,7 @@
 
 (define_insn_and_split "*vsx_le_perm_load_v16qi"
   [(set (match_operand:V16QI 0 "vsx_register_operand" "=wa")
-        (match_operand:V16QI 1 "memory_operand" "Z"))]
+        (match_operand:V16QI 1 "indexed_or_indirect_operand" "Z"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
   "#"
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
@@ -498,7 +514,7 @@
    (set_attr "length" "8")])
 
 (define_insn "*vsx_le_perm_store_<mode>"
-  [(set (match_operand:VSX_D 0 "memory_operand" "=Z")
+  [(set (match_operand:VSX_D 0 "indexed_or_indirect_operand" "=Z")
         (match_operand:VSX_D 1 "vsx_register_operand" "+<VSa>"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
   "#"
@@ -506,7 +522,7 @@
    (set_attr "length" "12")])
 
 (define_split
-  [(set (match_operand:VSX_D 0 "memory_operand" "")
+  [(set (match_operand:VSX_D 0 "indexed_or_indirect_operand" "")
         (match_operand:VSX_D 1 "vsx_register_operand" ""))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR && !reload_completed"
   [(set (match_dup 2)
@@ -525,7 +541,7 @@
 ;; The post-reload split requires that we re-permute the source
 ;; register in case it is still live.
 (define_split
-  [(set (match_operand:VSX_D 0 "memory_operand" "")
+  [(set (match_operand:VSX_D 0 "indexed_or_indirect_operand" "")
         (match_operand:VSX_D 1 "vsx_register_operand" ""))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR && reload_completed"
   [(set (match_dup 1)
@@ -543,7 +559,7 @@
   "")
 
 (define_insn "*vsx_le_perm_store_<mode>"
-  [(set (match_operand:VSX_W 0 "memory_operand" "=Z")
+  [(set (match_operand:VSX_W 0 "indexed_or_indirect_operand" "=Z")
         (match_operand:VSX_W 1 "vsx_register_operand" "+<VSa>"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
   "#"
@@ -551,7 +567,7 @@
    (set_attr "length" "12")])
 
 (define_split
-  [(set (match_operand:VSX_W 0 "memory_operand" "")
+  [(set (match_operand:VSX_W 0 "indexed_or_indirect_operand" "")
         (match_operand:VSX_W 1 "vsx_register_operand" ""))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR && !reload_completed"
   [(set (match_dup 2)
@@ -572,7 +588,7 @@
 ;; The post-reload split requires that we re-permute the source
 ;; register in case it is still live.
 (define_split
-  [(set (match_operand:VSX_W 0 "memory_operand" "")
+  [(set (match_operand:VSX_W 0 "indexed_or_indirect_operand" "")
         (match_operand:VSX_W 1 "vsx_register_operand" ""))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR && reload_completed"
   [(set (match_dup 1)
@@ -593,7 +609,7 @@
   "")
 
 (define_insn "*vsx_le_perm_store_v8hi"
-  [(set (match_operand:V8HI 0 "memory_operand" "=Z")
+  [(set (match_operand:V8HI 0 "indexed_or_indirect_operand" "=Z")
         (match_operand:V8HI 1 "vsx_register_operand" "+wa"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
   "#"
@@ -601,7 +617,7 @@
    (set_attr "length" "12")])
 
 (define_split
-  [(set (match_operand:V8HI 0 "memory_operand" "")
+  [(set (match_operand:V8HI 0 "indexed_or_indirect_operand" "")
         (match_operand:V8HI 1 "vsx_register_operand" ""))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR && !reload_completed"
   [(set (match_dup 2)
@@ -626,7 +642,7 @@
 ;; The post-reload split requires that we re-permute the source
 ;; register in case it is still live.
 (define_split
-  [(set (match_operand:V8HI 0 "memory_operand" "")
+  [(set (match_operand:V8HI 0 "indexed_or_indirect_operand" "")
         (match_operand:V8HI 1 "vsx_register_operand" ""))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR && reload_completed"
   [(set (match_dup 1)
@@ -653,7 +669,7 @@
   "")
 
 (define_insn "*vsx_le_perm_store_v16qi"
-  [(set (match_operand:V16QI 0 "memory_operand" "=Z")
+  [(set (match_operand:V16QI 0 "indexed_or_indirect_operand" "=Z")
         (match_operand:V16QI 1 "vsx_register_operand" "+wa"))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR"
   "#"
@@ -661,7 +677,7 @@
    (set_attr "length" "12")])
 
 (define_split
-  [(set (match_operand:V16QI 0 "memory_operand" "")
+  [(set (match_operand:V16QI 0 "indexed_or_indirect_operand" "")
         (match_operand:V16QI 1 "vsx_register_operand" ""))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR && !reload_completed"
   [(set (match_dup 2)
@@ -694,7 +710,7 @@
 ;; The post-reload split requires that we re-permute the source
 ;; register in case it is still live.
 (define_split
-  [(set (match_operand:V16QI 0 "memory_operand" "")
+  [(set (match_operand:V16QI 0 "indexed_or_indirect_operand" "")
         (match_operand:V16QI 1 "vsx_register_operand" ""))]
   "!BYTES_BIG_ENDIAN && TARGET_VSX && !TARGET_P9_VECTOR && reload_completed"
   [(set (match_dup 1)
@@ -961,7 +977,7 @@
 (define_insn "*vsx_mov<mode>_64bit"
   [(set (match_operand:VSX_M 0 "nonimmediate_operand"
                "=ZwO,      <VSa>,     <VSa>,     r,         we,        ?wQ,
-                ?&r,       ??r,       ??Y,       ??r,       wo,        v,
+                ?&r,       ??r,       ??Y,       <??r>,     wo,        v,
                 ?<VSa>,    *r,        v,         ??r,       wZ,        v")
 
 	(match_operand:VSX_M 1 "input_operand" 
@@ -990,7 +1006,7 @@
 ;;              LVX (VMX)  STVX (VMX)
 (define_insn "*vsx_mov<mode>_32bit"
   [(set (match_operand:VSX_M 0 "nonimmediate_operand"
-               "=ZwO,      <VSa>,     <VSa>,     ??r,       ??Y,       ??r,
+               "=ZwO,      <VSa>,     <VSa>,     ??r,       ??Y,       <??r>,
                 wo,        v,         ?<VSa>,    *r,        v,         ??r,
                 wZ,        v")
 
@@ -4084,46 +4100,21 @@
 
 ;; Vector insert/extract word at arbitrary byte values.  Note, the little
 ;; endian version needs to adjust the byte number, and the V4SI element in
-;; vinsert4b.
-(define_expand "vextract4b"
-  [(set (match_operand:DI 0 "gpc_reg_operand")
-	(unspec:DI [(match_operand:V16QI 1 "vsx_register_operand")
-		    (match_operand:QI 2 "const_0_to_12_operand")]
-		   UNSPEC_XXEXTRACTUW))]
+;; insert4b.
+(define_insn "extract4b"
+  [(set (match_operand:V2DI 0 "vsx_register_operand")
+       (unspec:V2DI [(match_operand:V16QI 1 "vsx_register_operand" "wa")
+                     (match_operand:QI 2 "const_0_to_12_operand" "n")]
+                    UNSPEC_XXEXTRACTUW))]
   "TARGET_P9_VECTOR"
 {
   if (!VECTOR_ELT_ORDER_BIG)
     operands[2] = GEN_INT (12 - INTVAL (operands[2]));
+
+  return "xxextractuw %x0,%x1,%2";
 })
 
-(define_insn_and_split "*vextract4b_internal"
-  [(set (match_operand:DI 0 "gpc_reg_operand" "=wj,r")
-	(unspec:DI [(match_operand:V16QI 1 "vsx_register_operand" "wa,v")
-		    (match_operand:QI 2 "const_0_to_12_operand" "n,n")]
-		   UNSPEC_XXEXTRACTUW))]
-  "TARGET_P9_VECTOR"
-  "@
-   xxextractuw %x0,%x1,%2
-   #"
-  "&& reload_completed && int_reg_operand (operands[0], DImode)"
-  [(const_int 0)]
-{
-  rtx op0 = operands[0];
-  rtx op1 = operands[1];
-  rtx op2 = operands[2];
-  rtx op0_si = gen_rtx_REG (SImode, REGNO (op0));
-  rtx op1_v4si = gen_rtx_REG (V4SImode, REGNO (op1));
-
-  emit_move_insn (op0, op2);
-  if (VECTOR_ELT_ORDER_BIG)
-    emit_insn (gen_vextuwlx (op0_si, op0_si, op1_v4si));
-  else
-    emit_insn (gen_vextuwrx (op0_si, op0_si, op1_v4si));
-  DONE;
-}
-  [(set_attr "type" "vecperm")])
-
-(define_expand "vinsert4b"
+(define_expand "insert4b"
   [(set (match_operand:V16QI 0 "vsx_register_operand")
 	(unspec:V16QI [(match_operand:V4SI 1 "vsx_register_operand")
 		       (match_operand:V16QI 2 "vsx_register_operand")
@@ -4141,7 +4132,7 @@
     }
 })
 
-(define_insn "*vinsert4b_internal"
+(define_insn "*insert4b_internal"
   [(set (match_operand:V16QI 0 "vsx_register_operand" "=wa")
 	(unspec:V16QI [(match_operand:V4SI 1 "vsx_register_operand" "wa")
 		       (match_operand:V16QI 2 "vsx_register_operand" "0")
@@ -4151,26 +4142,42 @@
   "xxinsertw %x0,%x1,%3"
   [(set_attr "type" "vecperm")])
 
-(define_expand "vinsert4b_di"
-  [(set (match_operand:V16QI 0 "vsx_register_operand")
-	(unspec:V16QI [(match_operand:DI 1 "vsx_register_operand")
-		       (match_operand:V16QI 2 "vsx_register_operand")
-		       (match_operand:QI 3 "const_0_to_12_operand")]
-		   UNSPEC_XXINSERTW))]
+(define_expand "vextract4b"
+  [(set (match_operand:DI 0 "gpc_reg_operand")
+	(unspec:DI [(match_operand:V16QI 1 "vsx_register_operand")
+		    (match_operand:QI 2 "const_0_to_12_operand")]
+		   UNSPEC_XXEXTRACTUW))]
   "TARGET_P9_VECTOR"
 {
   if (!VECTOR_ELT_ORDER_BIG)
-    operands[3] = GEN_INT (12 - INTVAL (operands[3]));
+    operands[2] = GEN_INT (12 - INTVAL (operands[2]));
 })
 
-(define_insn "*vinsert4b_di_internal"
-  [(set (match_operand:V16QI 0 "vsx_register_operand" "=wa")
-	(unspec:V16QI [(match_operand:DI 1 "vsx_register_operand" "wj")
-		       (match_operand:V16QI 2 "vsx_register_operand" "0")
-		       (match_operand:QI 3 "const_0_to_12_operand" "n")]
-		   UNSPEC_XXINSERTW))]
+(define_insn_and_split "*vextract4b_internal"
+  [(set (match_operand:DI 0 "gpc_reg_operand" "=wj,r")
+	(unspec:DI [(match_operand:V16QI 1 "vsx_register_operand" "wa,v")
+		    (match_operand:QI 2 "const_0_to_12_operand" "n,n")]
+		   UNSPEC_XXEXTRACTUW))]
   "TARGET_P9_VECTOR"
-  "xxinsertw %x0,%x1,%3"
+  "@
+   xxextractuw %x0,%x1,%2
+   #"
+  "&& reload_completed && int_reg_operand (operands[0], DImode)"
+  [(const_int 0)]
+{
+  rtx op0 = operands[0];
+  rtx op1 = operands[1];
+  rtx op2 = operands[2];
+  rtx op0_si = gen_rtx_REG (SImode, REGNO (op0));
+  rtx op1_v4si = gen_rtx_REG (V4SImode, REGNO (op1));
+
+  emit_move_insn (op0, op2);
+  if (VECTOR_ELT_ORDER_BIG)
+    emit_insn (gen_vextuwlx (op0_si, op0_si, op1_v4si));
+  else
+    emit_insn (gen_vextuwrx (op0_si, op0_si, op1_v4si));
+  DONE;
+}
   [(set_attr "type" "vecperm")])
 
 
Index: gcc/config/rs6000/rs6000.h
===================================================================
diff --git a/gcc/config/rs6000/rs6000.h b/gcc/config/rs6000/rs6000.h
--- a/gcc/config/rs6000/rs6000.h	(revision 262353)
+++ b/gcc/config/rs6000/rs6000.h	(revision 262353)
@@ -1,5 +1,5 @@
 /* Definitions of target machine for GNU compiler, for IBM RS/6000.
-   Copyright (C) 1992-2017 Free Software Foundation, Inc.
+   Copyright (C) 1992-2018 Free Software Foundation, Inc.
    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)
 
    This file is part of GCC.
@@ -110,7 +110,8 @@
 /* Common ASM definitions used by ASM_SPEC among the various targets for
    handling -mcpu=xxx switches.  There is a parallel list in driver-rs6000.c to
    provide the default assembler options if the user uses -mcpu=native, so if
-   you make changes here, make them also there.  */
+   you make changes here, make them also there.  PR63177: Do not pass -mpower8
+   to the assembler if -mpower9-vector was also used.  */
 #define ASM_CPU_SPEC \
 "%{!mcpu*: \
   %{mpowerpc64*: -mppc64} \
@@ -124,7 +125,7 @@
 %{mcpu=power6: %(asm_cpu_power6) -maltivec} \
 %{mcpu=power6x: %(asm_cpu_power6) -maltivec} \
 %{mcpu=power7: %(asm_cpu_power7)} \
-%{mcpu=power8: %(asm_cpu_power8)} \
+%{mcpu=power8: %{!mpower9-vector: %(asm_cpu_power8)}} \
 %{mcpu=power9: %(asm_cpu_power9)} \
 %{mcpu=a2: -ma2} \
 %{mcpu=powerpc: -mppc} \
@@ -173,6 +174,7 @@
 %{maltivec: -maltivec} \
 %{mvsx: -mvsx %{!maltivec: -maltivec} %{!mcpu*: %(asm_cpu_power7)}} \
 %{mpower8-vector|mcrypto|mdirect-move|mhtm: %{!mcpu*: %(asm_cpu_power8)}} \
+%{mpower9-vector: %{!mcpu*|mcpu=power8: %(asm_cpu_power9)}} \
 -many"
 
 #define CPP_DEFAULT_SPEC ""
@@ -2735,6 +2737,7 @@
 #define RS6000_BTM_HARD_FLOAT	MASK_SOFT_FLOAT	/* Hardware floating point.  */
 #define RS6000_BTM_LDBL128	MASK_MULTIPLE	/* 128-bit long double.  */
 #define RS6000_BTM_64BIT	MASK_64BIT	/* 64-bit addressing.  */
+#define RS6000_BTM_POWERPC64	MASK_POWERPC64	/* 64-bit registers.  */
 #define RS6000_BTM_FLOAT128	MASK_FLOAT128_TYPE /* IEEE 128-bit float.  */
 
 #define RS6000_BTM_COMMON	(RS6000_BTM_ALTIVEC			\
@@ -2754,6 +2757,7 @@
 				 | RS6000_BTM_DFP			\
 				 | RS6000_BTM_HARD_FLOAT		\
 				 | RS6000_BTM_LDBL128			\
+				 | RS6000_BTM_POWERPC64			\
 				 | RS6000_BTM_FLOAT128)
 
 /* Define builtin enum index.  */
Index: gcc/config/rs6000/altivec.md
===================================================================
diff --git a/gcc/config/rs6000/altivec.md b/gcc/config/rs6000/altivec.md
--- a/gcc/config/rs6000/altivec.md	(revision 262353)
+++ b/gcc/config/rs6000/altivec.md	(revision 262353)
@@ -414,7 +414,6 @@
 (define_insn "*restore_world"
  [(match_parallel 0 "restore_world_operation"
                   [(return)
-		   (use (reg:SI LR_REGNO))
                    (use (match_operand:SI 1 "call_operand" "s"))
                    (clobber (match_operand:SI 2 "gpc_reg_operand" "=r"))])]
  "TARGET_MACHO && (DEFAULT_ABI == ABI_DARWIN) && TARGET_32BIT"
@@ -2616,42 +2615,52 @@
   "lvx %0,%y1"
   [(set_attr "type" "vecload")])
 
+; The following patterns embody what lvx should usually look like.
+(define_expand "altivec_lvx_<VM2:mode>"
+  [(set (match_operand:VM2 0 "register_operand")
+	(match_operand:VM2 1 "altivec_indexed_or_indirect_operand"))]
+  "TARGET_ALTIVEC"
+{
+  rtx addr = XEXP (operand1, 0);
+  if (GET_CODE (addr) == PLUS
+      && REG_P (XEXP (addr, 0))
+      && REG_P (XEXP (addr, 1)))
+    {
+      rtx op1 = XEXP (addr, 0);
+      rtx op2 = XEXP (addr, 1);
+      if (TARGET_64BIT)
+	emit_insn (gen_altivec_lvx_<VM2:mode>_2op_di (operand0, op1, op2));
+      else
+	emit_insn (gen_altivec_lvx_<VM2:mode>_2op_si (operand0, op1, op2));
+    }
+  else
+    {
+      if (TARGET_64BIT)
+	emit_insn (gen_altivec_lvx_<VM2:mode>_1op_di (operand0, addr));
+      else
+	emit_insn (gen_altivec_lvx_<VM2:mode>_1op_si (operand0, addr));
+    }
+  DONE;
+})
+
 ; The next two patterns embody what lvx should usually look like.
-(define_insn "altivec_lvx_<mode>_2op"
+(define_insn "altivec_lvx_<VM2:mode>_2op_<P:mptrsize>"
   [(set (match_operand:VM2 0 "register_operand" "=v")
-        (mem:VM2 (and:DI (plus:DI (match_operand:DI 1 "register_operand" "b")
-                                  (match_operand:DI 2 "register_operand" "r"))
-		         (const_int -16))))]
-  "TARGET_ALTIVEC && TARGET_64BIT"
+	(mem:VM2 (and:P (plus:P (match_operand:P 1 "register_operand" "b")
+				(match_operand:P 2 "register_operand" "r"))
+			(const_int -16))))]
+  "TARGET_ALTIVEC"
   "lvx %0,%1,%2"
   [(set_attr "type" "vecload")])
 
-(define_insn "altivec_lvx_<mode>_1op"
+(define_insn "altivec_lvx_<VM2:mode>_1op_<P:mptrsize>"
   [(set (match_operand:VM2 0 "register_operand" "=v")
-        (mem:VM2 (and:DI (match_operand:DI 1 "register_operand" "r")
-			 (const_int -16))))]
-  "TARGET_ALTIVEC && TARGET_64BIT"
+	(mem:VM2 (and:P (match_operand:P 1 "register_operand" "r")
+			(const_int -16))))]
+  "TARGET_ALTIVEC"
   "lvx %0,0,%1"
   [(set_attr "type" "vecload")])
 
-; 32-bit versions of the above.
-(define_insn "altivec_lvx_<mode>_2op_si"
-  [(set (match_operand:VM2 0 "register_operand" "=v")
-        (mem:VM2 (and:SI (plus:SI (match_operand:SI 1 "register_operand" "b")
-                                  (match_operand:SI 2 "register_operand" "r"))
-		         (const_int -16))))]
-  "TARGET_ALTIVEC && TARGET_32BIT"
-  "lvx %0,%1,%2"
-  [(set_attr "type" "vecload")])
-
-(define_insn "altivec_lvx_<mode>_1op_si"
-  [(set (match_operand:VM2 0 "register_operand" "=v")
-        (mem:VM2 (and:SI (match_operand:SI 1 "register_operand" "r")
-			 (const_int -16))))]
-  "TARGET_ALTIVEC && TARGET_32BIT"
-  "lvx %0,0,%1"
-  [(set_attr "type" "vecload")])
-
 ; This version of stvx is used only in cases where we need to force an stvx
 ; over any other store, and we don't care about losing CSE opportunities.
 ; Its primary use is for epilogue register restores.
@@ -2664,42 +2673,52 @@
   "stvx %1,%y0"
   [(set_attr "type" "vecstore")])
 
+; The following patterns embody what stvx should usually look like.
+(define_expand "altivec_stvx_<VM2:mode>"
+  [(set (match_operand:VM2 1 "altivec_indexed_or_indirect_operand")
+	(match_operand:VM2 0 "register_operand"))]
+  "TARGET_ALTIVEC"
+{
+  rtx addr = XEXP (operand1, 0);
+  if (GET_CODE (addr) == PLUS
+      && REG_P (XEXP (addr, 0))
+      && REG_P (XEXP (addr, 1)))
+    {
+      rtx op1 = XEXP (addr, 0);
+      rtx op2 = XEXP (addr, 1);
+      if (TARGET_64BIT)
+	emit_insn (gen_altivec_stvx_<VM2:mode>_2op_di (operand0, op1, op2));
+      else
+	emit_insn (gen_altivec_stvx_<VM2:mode>_2op_si (operand0, op1, op2));
+    }
+  else
+    {
+      if (TARGET_64BIT)
+	emit_insn (gen_altivec_stvx_<VM2:mode>_1op_di (operand0, addr));
+      else
+	emit_insn (gen_altivec_stvx_<VM2:mode>_1op_si (operand0, addr));
+    }
+  DONE;
+})
+
 ; The next two patterns embody what stvx should usually look like.
-(define_insn "altivec_stvx_<mode>_2op"
-  [(set (mem:VM2 (and:DI (plus:DI (match_operand:DI 1 "register_operand" "b")
-  	                          (match_operand:DI 2 "register_operand" "r"))
-	                 (const_int -16)))
-        (match_operand:VM2 0 "register_operand" "v"))]
-  "TARGET_ALTIVEC && TARGET_64BIT"
+(define_insn "altivec_stvx_<VM2:mode>_2op_<P:mptrsize>"
+  [(set (mem:VM2 (and:P (plus:P (match_operand:P 1 "register_operand" "b")
+				(match_operand:P 2 "register_operand" "r"))
+			(const_int -16)))
+	(match_operand:VM2 0 "register_operand" "v"))]
+  "TARGET_ALTIVEC"
   "stvx %0,%1,%2"
   [(set_attr "type" "vecstore")])
 
-(define_insn "altivec_stvx_<mode>_1op"
-  [(set (mem:VM2 (and:DI (match_operand:DI 1 "register_operand" "r")
-	                 (const_int -16)))
-        (match_operand:VM2 0 "register_operand" "v"))]
-  "TARGET_ALTIVEC && TARGET_64BIT"
+(define_insn "altivec_stvx_<VM2:mode>_1op_<P:mptrsize>"
+  [(set (mem:VM2 (and:P (match_operand:P 1 "register_operand" "r")
+			(const_int -16)))
+	(match_operand:VM2 0 "register_operand" "v"))]
+  "TARGET_ALTIVEC"
   "stvx %0,0,%1"
   [(set_attr "type" "vecstore")])
 
-; 32-bit versions of the above.
-(define_insn "altivec_stvx_<mode>_2op_si"
-  [(set (mem:VM2 (and:SI (plus:SI (match_operand:SI 1 "register_operand" "b")
-  	                          (match_operand:SI 2 "register_operand" "r"))
-	                 (const_int -16)))
-        (match_operand:VM2 0 "register_operand" "v"))]
-  "TARGET_ALTIVEC && TARGET_32BIT"
-  "stvx %0,%1,%2"
-  [(set_attr "type" "vecstore")])
-
-(define_insn "altivec_stvx_<mode>_1op_si"
-  [(set (mem:VM2 (and:SI (match_operand:SI 1 "register_operand" "r")
-	                 (const_int -16)))
-        (match_operand:VM2 0 "register_operand" "v"))]
-  "TARGET_ALTIVEC && TARGET_32BIT"
-  "stvx %0,0,%1"
-  [(set_attr "type" "vecstore")])
-
 (define_expand "altivec_stvxl_<mode>"
   [(parallel
     [(set (match_operand:VM2 0 "memory_operand" "=Z")
Index: gcc/config/rs6000/rs6000.md
===================================================================
diff --git a/gcc/config/rs6000/rs6000.md b/gcc/config/rs6000/rs6000.md
--- a/gcc/config/rs6000/rs6000.md	(revision 262353)
+++ b/gcc/config/rs6000/rs6000.md	(revision 262353)
@@ -1,5 +1,5 @@
 ;; Machine description for IBM RISC System 6000 (POWER) for GNU C compiler
-;; Copyright (C) 1990-2017 Free Software Foundation, Inc.
+;; Copyright (C) 1990-2018 Free Software Foundation, Inc.
 ;; Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)
 
 ;; This file is part of GCC.
@@ -135,9 +135,7 @@
    UNSPEC_CDTBCD
    UNSPEC_CBCDTD
    UNSPEC_DIVE
-   UNSPEC_DIVEO
    UNSPEC_DIVEU
-   UNSPEC_DIVEUO
    UNSPEC_UNPACK_128BIT
    UNSPEC_PACK_128BIT
    UNSPEC_LSQ
@@ -544,7 +542,7 @@
 (define_code_attr su [(sign_extend	"s")
 		      (zero_extend	"u")
 		      (fix		"s")
-		      (unsigned_fix	"s")
+		      (unsigned_fix	"u")
 		      (float		"s")
 		      (unsigned_float	"u")])
 
@@ -4757,12 +4755,19 @@
 {
   if (FLOAT128_IEEE_P (<MODE>mode))
     {
+      rtx dest = operands[0];
+      rtx src = operands[1];
+      rtx tmp = gen_reg_rtx (DImode);
+      rtx dest_di = gen_lowpart (DImode, dest);
+
       if (<MODE>mode == KFmode)
-	emit_insn (gen_signbitkf2_dm (operands[0], operands[1]));
+	emit_insn (gen_signbitkf2_dm (tmp, src));
       else if (<MODE>mode == TFmode)
-	emit_insn (gen_signbittf2_dm (operands[0], operands[1]));
+	emit_insn (gen_signbittf2_dm (tmp, src));
       else
 	gcc_unreachable ();
+
+      emit_insn (gen_lshrdi3 (dest_di, tmp, GEN_INT (63)));
       DONE;
     }
   operands[2] = gen_reg_rtx (DFmode);
@@ -4783,6 +4788,66 @@
     }
 })
 
+;; Optimize IEEE 128-bit signbit on 64-bit systems with direct move to avoid
+;; multiple direct moves.  If we used a SUBREG:DI of the Floa128 type, the
+;; register allocator would typically move the entire _Float128 item to GPRs (2
+;; instructions on ISA 3.0, 3-4 instructions on ISA 2.07).
+;;
+;; After register allocation, if the _Float128 had originally been in GPRs, the
+;; split allows the post reload phases to eliminate the move, and do the shift
+;; directly with the register that contains the signbit.
+(define_insn_and_split "signbit<mode>2_dm"
+  [(set (match_operand:DI 0 "gpc_reg_operand" "=r,r")
+	(unspec:DI [(match_operand:SIGNBIT 1 "gpc_reg_operand" "wa,r")]
+		   UNSPEC_SIGNBIT))]
+  "TARGET_POWERPC64 && TARGET_DIRECT_MOVE"
+  "@
+   mfvsrd %0,%x1
+   #"
+  "&& reload_completed && int_reg_operand (operands[1], <MODE>mode)"
+  [(set (match_dup 0)
+	(match_dup 2))]
+{
+  operands[2] = gen_highpart (DImode, operands[1]);
+}
+ [(set_attr "type" "mftgpr,*")])
+
+;; Optimize IEEE 128-bit signbit on to avoid loading the value into a vector
+;; register and then doing a direct move if the value comes from memory.  On
+;; little endian, we have to load the 2nd double-word to get the sign bit.
+(define_insn_and_split "*signbit<mode>2_dm_mem"
+  [(set (match_operand:DI 0 "gpc_reg_operand" "=b")
+	(unspec:DI [(match_operand:SIGNBIT 1 "memory_operand" "m")]
+		   UNSPEC_SIGNBIT))]
+  "TARGET_POWERPC64 && TARGET_DIRECT_MOVE"
+  "#"
+  "&& 1"
+  [(set (match_dup 0)
+	(match_dup 2))]
+{
+  rtx dest = operands[0];
+  rtx src = operands[1];
+  rtx addr = XEXP (src, 0);
+
+  if (WORDS_BIG_ENDIAN)
+    operands[2] = adjust_address (src, DImode, 0);
+
+  else if (REG_P (addr) || SUBREG_P (addr))
+    operands[2] = adjust_address (src, DImode, 8);
+
+  else if (GET_CODE (addr) == PLUS && REG_P (XEXP (addr, 0))
+	   && CONST_INT_P (XEXP (addr, 1)) && mem_operand_gpr (src, DImode))
+    operands[2] = adjust_address (src, DImode, 8);
+
+  else
+    {
+      rtx tmp = can_create_pseudo_p () ? gen_reg_rtx (DImode) : dest;
+      emit_insn (gen_rtx_SET (tmp, addr));
+      operands[2] = change_address (src, DImode,
+				    gen_rtx_PLUS (DImode, tmp, GEN_INT (8)));
+    }
+})
+
 (define_expand "copysign<mode>3"
   [(set (match_dup 3)
         (abs:SFDF (match_operand:SFDF 1 "gpc_reg_operand" "")))
@@ -4812,54 +4877,6 @@
    operands[5] = CONST0_RTX (<MODE>mode);
   })
 
-;; Optimize signbit on 64-bit systems with direct move to avoid doing the store
-;; and load.
-(define_insn_and_split "signbit<mode>2_dm"
-  [(set (match_operand:SI 0 "gpc_reg_operand" "=r,r,r")
-	(unspec:SI
-	 [(match_operand:SIGNBIT 1 "input_operand" "wa,m,r")]
-	 UNSPEC_SIGNBIT))]
-  "TARGET_POWERPC64 && TARGET_DIRECT_MOVE"
-  "#"
-  "&& reload_completed"
-  [(const_int 0)]
-{
-  rs6000_split_signbit (operands[0], operands[1]);
-  DONE;
-}
- [(set_attr "length" "8,8,4")
-  (set_attr "type" "mftgpr,load,integer")])
-
-(define_insn_and_split "*signbit<mode>2_dm_<su>ext"
-  [(set (match_operand:DI 0 "gpc_reg_operand" "=r,r,r")
-	(any_extend:DI
-	 (unspec:SI
-	  [(match_operand:SIGNBIT 1 "input_operand" "wa,m,r")]
-	  UNSPEC_SIGNBIT)))]
-  "TARGET_POWERPC64 && TARGET_DIRECT_MOVE"
-  "#"
-  "&& reload_completed"
-  [(const_int 0)]
-{
-  rs6000_split_signbit (operands[0], operands[1]);
-  DONE;
-}
- [(set_attr "length" "8,8,4")
-  (set_attr "type" "mftgpr,load,integer")])
-
-;; MODES_TIEABLE_P doesn't allow DImode to be tied with the various floating
-;; point types, which makes normal SUBREG's problematical. Instead use a
-;; special pattern to avoid using a normal movdi.
-(define_insn "signbit<mode>2_dm2"
-  [(set (match_operand:DI 0 "gpc_reg_operand" "=r")
-	(unspec:DI [(match_operand:SIGNBIT 1 "gpc_reg_operand" "wa")
-		    (const_int 0)]
-		   UNSPEC_SIGNBIT))]
-  "TARGET_POWERPC64 && TARGET_DIRECT_MOVE"
-  "mfvsrd %0,%x1"
- [(set_attr "type" "mftgpr")])
-
-
 ;; Use an unspec rather providing an if-then-else in RTL, to prevent the
 ;; compiler from optimizing -0.0
 (define_insn "copysign<mode>3_fcpsgn"
@@ -5694,45 +5711,59 @@
    xscvdpsxds %x0,%x1"
   [(set_attr "type" "fp")])
 
-(define_expand "fix_trunc<SFDF:mode><QHI:mode>2"
-  [(parallel [(set (match_operand:<QHI:MODE> 0 "nonimmediate_operand")
-		   (fix:QHI (match_operand:SFDF 1 "gpc_reg_operand")))
-	      (clobber (match_scratch:DI 2))])]
-  "TARGET_P9_VECTOR && TARGET_DIRECT_MOVE_64BIT
-   && TARGET_VSX_SMALL_INTEGER"
+;; If we have ISA 3.0, QI/HImode values can go in both VSX registers and GPR
+;; registers.  If we have ISA 2.07, we don't allow QI/HImode values in the
+;; vector registers, so we need to do direct moves to the GPRs, but SImode
+;; values can go in VSX registers.  Keeping the direct move part through
+;; register allocation prevents the register allocator from doing a direct move
+;; of the SImode value to a GPR, and then a store/load.
+(define_insn_and_split "fix<uns>_trunc<SFDF:mode><QHI:mode>2"
+  [(set (match_operand:<QHI:MODE> 0 "gpc_reg_operand" "=wJ,wJwK,r")
+	(any_fix:QHI (match_operand:SFDF 1 "gpc_reg_operand" "wJ,wJwK,wa")))
+   (clobber (match_scratch:SI 2 "=X,X,wi"))]
+  "TARGET_DIRECT_MOVE"
+  "@
+   fctiw<u>z %0,%1
+   xscvdp<su>xws %x0,%x1
+   #"
+  "&& reload_completed && int_reg_operand (operands[0], <QHI:MODE>mode)"
+  [(set (match_dup 2)
+	(any_fix:SI (match_dup 1)))
+   (set (match_dup 3)
+	(match_dup 2))]
 {
-  if (MEM_P (operands[0]))
-    operands[0] = rs6000_address_for_fpconvert (operands[0]);
-})
+  operands[3] = gen_rtx_REG (SImode, REGNO (operands[0]));
+}
+  [(set_attr "length" "4,4,8")
+   (set_attr "type" "fp")])
 
-(define_insn_and_split "*fix_trunc<SFDF:mode><QHI:mode>2_internal"
-  [(set (match_operand:<QHI:MODE> 0 "reg_or_indexed_operand" "=wIwJ,rZ")
-	(fix:QHI
-	 (match_operand:SFDF 1 "gpc_reg_operand" "<SFDF:Fv>,<SFDF:Fv>")))
-   (clobber (match_scratch:DI 2 "=X,wi"))]
-  "TARGET_P9_VECTOR && TARGET_DIRECT_MOVE_64BIT
-   && TARGET_VSX_SMALL_INTEGER"
+(define_insn "*fix<uns>_trunc<SFDF:mode>si2_p8"
+  [(set (match_operand:SI 0 "gpc_reg_operand" "=d,wa")
+	(any_fix:SI (match_operand:SFDF 1 "gpc_reg_operand" "d,wa")))]
+  "TARGET_DIRECT_MOVE"
+  "@
+   fctiw<u>z %0,%1
+   xscvdp<su>xws %x0,%x1"
+  [(set_attr "type" "fp")])
+
+;; Keep the convert and store together through register allocation to prevent
+;; the register allocator from getting clever and doing a direct move to a GPR
+;; and then store for reg+offset stores.
+(define_insn_and_split "*fix<uns>_trunc<SFDF:mode><QHSI:mode>2_mem"
+  [(set (match_operand:QHSI 0 "memory_operand" "=Z")
+	(any_fix:QHSI (match_operand:SFDF 1 "gpc_reg_operand" "wa")))
+   (clobber (match_scratch:SI 2 "=wa"))]
+    "(<QHSI:MODE>mode == SImode && TARGET_P8_VECTOR) || TARGET_P9_VECTOR"
   "#"
   "&& reload_completed"
-  [(const_int 0)]
+  [(set (match_dup 2)
+	(any_fix:SI (match_dup 1)))
+   (set (match_dup 0)
+	(match_dup 3))]
 {
-  rtx dest = operands[0];
-  rtx src = operands[1];
-
-  if (vsx_register_operand (dest, <QHI:MODE>mode))
-    {
-      rtx di_dest = gen_rtx_REG (DImode, REGNO (dest));
-      emit_insn (gen_fix_trunc<SFDF:mode>di2 (di_dest, src));
-    }
-  else
-    {
-      rtx tmp = operands[2];
-      rtx tmp2 = gen_rtx_REG (<QHI:MODE>mode, REGNO (tmp));
-
-      emit_insn (gen_fix_trunc<SFDF:mode>di2 (tmp, src));
-      emit_move_insn (dest, tmp2);
-    }
-  DONE;
+  operands[3] = (<QHSI:MODE>mode == SImode
+		 ? operands[2]
+		 : gen_rtx_REG (<QHSI:MODE>mode, REGNO (operands[2])));
 })
 
 (define_expand "fixuns_trunc<mode>si2"
@@ -5801,75 +5832,6 @@
    xscvdpuxds %x0,%x1"
   [(set_attr "type" "fp")])
 
-(define_expand "fixuns_trunc<SFDF:mode><QHI:mode>2"
-  [(parallel [(set (match_operand:<QHI:MODE> 0 "nonimmediate_operand")
-		   (unsigned_fix:QHI (match_operand:SFDF 1 "gpc_reg_operand")))
-	      (clobber (match_scratch:DI 2))])]
-  "TARGET_P9_VECTOR && TARGET_DIRECT_MOVE_64BIT
-   && TARGET_VSX_SMALL_INTEGER"
-{
-  if (MEM_P (operands[0]))
-    operands[0] = rs6000_address_for_fpconvert (operands[0]);
-})
-
-(define_insn_and_split "*fixuns_trunc<SFDF:mode><QHI:mode>2_internal"
-  [(set (match_operand:<QHI:MODE> 0 "reg_or_indexed_operand" "=wIwJ,rZ")
-	(unsigned_fix:QHI
-	 (match_operand:SFDF 1 "gpc_reg_operand" "<SFDF:Fv>,<SFDF:Fv>")))
-   (clobber (match_scratch:DI 2 "=X,wi"))]
-  "TARGET_P9_VECTOR && TARGET_DIRECT_MOVE_64BIT
-   && TARGET_VSX_SMALL_INTEGER"
-  "#"
-  "&& reload_completed"
-  [(const_int 0)]
-{
-  rtx dest = operands[0];
-  rtx src = operands[1];
-
-  if (vsx_register_operand (dest, <QHI:MODE>mode))
-    {
-      rtx di_dest = gen_rtx_REG (DImode, REGNO (dest));
-      emit_insn (gen_fixuns_trunc<SFDF:mode>di2 (di_dest, src));
-    }
-  else
-    {
-      rtx tmp = operands[2];
-      rtx tmp2 = gen_rtx_REG (<QHI:MODE>mode, REGNO (tmp));
-
-      emit_insn (gen_fixuns_trunc<SFDF:mode>di2 (tmp, src));
-      emit_move_insn (dest, tmp2);
-    }
-  DONE;
-})
-
-;; If -mvsx-small-integer, we can represent the FIX operation directly.  On
-;; older machines, we have to use an UNSPEC to produce a SImode and move it
-;; to another location, since SImode is not allowed in vector registers.
-(define_insn "*fctiw<u>z_<mode>_smallint"
-  [(set (match_operand:SI 0 "vsx_register_operand" "=d,wi")
-	(any_fix:SI (match_operand:SFDF 1 "gpc_reg_operand" "<Ff>,<Fv>")))]
-  "TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT
-   && TARGET_VSX_SMALL_INTEGER"
-  "@
-   fctiw<u>z %0,%1
-   xscvdp<su>xws %x0,%x1"
-  [(set_attr "type" "fp")])
-
-;; Combiner pattern to prevent moving the result of converting a floating point
-;; value to 32-bit integer to GPR in order to save it.
-(define_insn_and_split "*fctiw<u>z_<mode>_mem"
-  [(set (match_operand:SI 0 "memory_operand" "=Z")
-	(any_fix:SI (match_operand:SFDF 1 "gpc_reg_operand" "wa")))
-   (clobber (match_scratch:SI 2 "=wa"))]
-  "TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_DOUBLE_FLOAT
-   && TARGET_VSX_SMALL_INTEGER"
-  "#"
-  "&& reload_completed"
-  [(set (match_dup 2)
-	(any_fix:SI (match_dup 1)))
-   (set (match_dup 0)
-	(match_dup 2))])
-
 ;; Here, we use (set (reg) (unspec:DI [(fix:SI ...)] UNSPEC_FCTIWZ))
 ;; rather than (set (subreg:SI (reg)) (fix:SI ...))
 ;; because the first makes it clear that operand 0 is not live
@@ -8678,7 +8640,7 @@
 ;;              FPR->GPR   GPR->FPR   VSX->GPR   GPR->VSX
 (define_insn "*movdi_internal64"
   [(set (match_operand:DI 0 "nonimmediate_operand"
-               "=Y,        r,         r,         r,         r,          r,
+               "=YZ,       r,         r,         r,         r,          r,
                 ^m,        ^d,        ^d,        ^wY,       $Z,         $wb,
                 $wv,       ^wi,       *wo,       *wo,       *wv,        *wi,
                 *wi,       *wv,       *wv,       r,         *h,         *h,
@@ -8685,7 +8647,7 @@
                 ?*r,       ?*wg,      ?*r,       ?*wj")
 
 	(match_operand:DI 1 "input_operand"
-                "r,        Y,         r,         I,         L,          nF,
+                "r,        YZ,        r,         I,         L,          nF,
                  d,        m,         d,         wb,        wv,         wY,
                  Z,        wi,        Oj,        wM,        OjwM,       Oj,
                  wM,       wS,        wB,        *h,        r,          0,
@@ -14419,14 +14381,10 @@
    (set_attr "length" "4")])
 
 (define_int_iterator UNSPEC_DIV_EXTEND [UNSPEC_DIVE
-					UNSPEC_DIVEO
-					UNSPEC_DIVEU
-					UNSPEC_DIVEUO])
+					UNSPEC_DIVEU])
 
 (define_int_attr div_extend [(UNSPEC_DIVE	"e")
-			     (UNSPEC_DIVEO	"eo")
-			     (UNSPEC_DIVEU	"eu")
-			     (UNSPEC_DIVEUO	"euo")])
+			     (UNSPEC_DIVEU	"eu")])
 
 (define_insn "div<div_extend>_<mode>"
   [(set (match_operand:GPR 0 "register_operand" "=r")
@@ -14505,16 +14463,14 @@
    (set_attr "length" "4")])
 
 (define_insn_and_split "pack<mode>"
-  [(set (match_operand:FMOVE128 0 "register_operand" "=d,&d")
+  [(set (match_operand:FMOVE128 0 "register_operand" "=&d")
 	(unspec:FMOVE128
-	 [(match_operand:<FP128_64> 1 "register_operand" "0,d")
-	  (match_operand:<FP128_64> 2 "register_operand" "d,d")]
+	 [(match_operand:<FP128_64> 1 "register_operand" "d")
+	  (match_operand:<FP128_64> 2 "register_operand" "d")]
 	 UNSPEC_PACK_128BIT))]
   "FLOAT128_2REG_P (<MODE>mode)"
-  "@
-   fmr %L0,%2
-   #"
-  "&& reload_completed && REGNO (operands[0]) != REGNO (operands[1])"
+  "#"
+  "&& reload_completed"
   [(set (match_dup 3) (match_dup 1))
    (set (match_dup 4) (match_dup 2))]
 {
@@ -14527,8 +14483,8 @@
   operands[3] = gen_rtx_REG (<FP128_64>mode, dest_hi);
   operands[4] = gen_rtx_REG (<FP128_64>mode, dest_lo);
 }
-  [(set_attr "type" "fpsimple,fp")
-   (set_attr "length" "4,8")])
+  [(set_attr "type" "fp")
+   (set_attr "length" "8")])
 
 (define_insn "unpack<mode>"
   [(set (match_operand:DI 0 "register_operand" "=d,d")
@@ -14803,49 +14759,45 @@
    (set_attr "length" "8")])
 
 ;; Conversion between IEEE 128-bit and integer types
-(define_insn "fix_<mode>di2_hw"
-  [(set (match_operand:DI 0 "altivec_register_operand" "=v")
-	(fix:DI (match_operand:IEEE128 1 "altivec_register_operand" "v")))]
-  "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
-  "xscvqpsdz %0,%1"
-  [(set_attr "type" "vecfloat")
-   (set_attr "size" "128")])
 
-(define_insn "fixuns_<mode>di2_hw"
-  [(set (match_operand:DI 0 "altivec_register_operand" "=v")
-	(unsigned_fix:DI (match_operand:IEEE128 1 "altivec_register_operand" "v")))]
-  "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
-  "xscvqpudz %0,%1"
+;; The fix function for DImode and SImode was declared earlier as a
+;; define_expand.  It calls into rs6000_expand_float128_convert if we don't
+;; have IEEE 128-bit hardware support.  QImode and HImode are not provided
+;; unless we have the IEEE 128-bit hardware.
+;;
+;; Unlike the code for converting SFmode/DFmode to QImode/HImode, we don't have
+;; to provide a GPR target that used direct move and a conversion in the GPR
+;; which works around QImode/HImode not being allowed in vector registers in
+;; ISA 2.07 (power8).
+(define_insn "fix<uns>_<IEEE128:mode><SDI:mode>2_hw"
+  [(set (match_operand:SDI 0 "altivec_register_operand" "=v")
+	(any_fix:SDI (match_operand:IEEE128 1 "altivec_register_operand" "v")))]
+  "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<IEEE128:MODE>mode)"
+  "xscvqp<su><wd>z %0,%1"
   [(set_attr "type" "vecfloat")
    (set_attr "size" "128")])
 
-(define_insn "fix_<mode>si2_hw"
-  [(set (match_operand:SI 0 "altivec_register_operand" "=v")
-	(fix:SI (match_operand:IEEE128 1 "altivec_register_operand" "v")))]
-  "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
-  "xscvqpswz %0,%1"
+(define_insn "fix<uns>_trunc<IEEE128:mode><QHI:mode>2"
+  [(set (match_operand:QHI 0 "altivec_register_operand" "=v")
+	(any_fix:QHI
+	 (match_operand:IEEE128 1 "altivec_register_operand" "v")))]
+  "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<IEEE128:MODE>mode)"
+  "xscvqp<su>wz %0,%1"
   [(set_attr "type" "vecfloat")
    (set_attr "size" "128")])
 
-(define_insn "fixuns_<mode>si2_hw"
-  [(set (match_operand:SI 0 "altivec_register_operand" "=v")
-	(unsigned_fix:SI (match_operand:IEEE128 1 "altivec_register_operand" "v")))]
+;; Combiner patterns to prevent moving the result of converting an IEEE 128-bit
+;; floating point value to 8/16/32-bit integer to GPR in order to save it.
+(define_insn_and_split "*fix<uns>_trunc<IEEE128:mode><QHSI:mode>2_mem"
+  [(set (match_operand:QHSI 0 "memory_operand" "=Z")
+	(any_fix:QHSI
+	 (match_operand:IEEE128 1 "altivec_register_operand" "v")))
+   (clobber (match_scratch:QHSI 2 "=v"))]
   "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
-  "xscvqpuwz %0,%1"
-  [(set_attr "type" "vecfloat")
-   (set_attr "size" "128")])
-
-;; Combiner pattern to prevent moving the result of converting an IEEE 128-bit
-;; floating point value to 32-bit integer to GPR in order to save it.
-(define_insn_and_split "*fix<uns>_<mode>_mem"
-  [(set (match_operand:SI 0 "memory_operand" "=Z")
-	(any_fix:SI (match_operand:IEEE128 1 "altivec_register_operand" "v")))
-   (clobber (match_scratch:SI 2 "=v"))]
-  "TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)"
   "#"
   "&& reload_completed"
   [(set (match_dup 2)
-	(any_fix:SI (match_dup 1)))
+	(any_fix:QHSI (match_dup 1)))
    (set (match_dup 0)
 	(match_dup 2))])
 
Index: gcc/config/rs6000/driver-rs6000.c
===================================================================
diff --git a/gcc/config/rs6000/driver-rs6000.c b/gcc/config/rs6000/driver-rs6000.c
--- a/gcc/config/rs6000/driver-rs6000.c	(revision 262353)
+++ b/gcc/config/rs6000/driver-rs6000.c	(revision 262353)
@@ -21,6 +21,8 @@
 #include "system.h"
 #include "coretypes.h"
 #include "tm.h"
+#include "diagnostic.h"
+#include "opts.h"
 #include <stdlib.h>
 
 #ifdef _AIX
@@ -36,6 +38,44 @@
 # include <sys/sysctl.h>
 #endif
 
+#ifdef __linux__
+/* Canonical GCC cpu name table.  */
+static const char *rs6000_supported_cpu_names[] =
+{
+#define RS6000_CPU(NAME, CPU, FLAGS) NAME,
+#include "rs6000-cpus.def"
+#undef RS6000_CPU
+};
+
+/* This table holds a list of cpus where their Linux AT_PLATFORM name differs
+   from their GCC canonical name.  The first column in a row contains the GCC
+   canonical cpu name and the other columns in that row contain AT_PLATFORM
+   names that should be mapped to the canonical name.  */
+
+static const char *linux_cpu_translation_table[][4] = {
+  { "403", "ppc403", NULL },
+  { "405", "ppc405", NULL },
+  { "440", "ppc440", "ppc440gp", NULL },
+  { "476", "ppc470", NULL },
+  { "601", "ppc601", NULL },
+  { "603", "ppc603", NULL },
+  { "604", "ppc604", NULL },
+  { "7400", "ppc7400", NULL },
+  { "7450", "ppc7450", NULL },
+  { "750", "ppc750", NULL },
+  { "823", "ppc823", NULL },
+  { "8540", "ppc8540", NULL },
+  { "8548", "ppc8548", NULL },
+  { "970", "ppc970", NULL },
+  { "cell", "ppc-cell-be", NULL },
+  { "e500mc", "ppce500mc", NULL },
+  { "e5500", "ppce5500", NULL },
+  { "e6500", "ppce6500", NULL },
+  { "power7", "power7+", NULL },
+  { NULL } /* End of table sentinel.  */
+};
+#endif
+
 const char *host_detect_local_cpu (int argc, const char **argv);
 
 #if GCC_VERSION >= 0
@@ -156,15 +196,20 @@
 
 #ifdef __linux__
 
-/* Returns AT_PLATFORM if present, otherwise generic PowerPC.  */
+/* Returns the canonical AT_PLATFORM if present, otherwise NULL.  */
 
 static const char *
 elf_platform (void)
 {
-  int fd;
+  /* Used to cache the result we determine below.  */
+  static const char *cpu = NULL;
 
-  fd = open ("/proc/self/auxv", O_RDONLY);
+  /* Use the cached AT_PLATFORM cpu name if we've already determined it.  */
+  if (cpu != NULL)
+    return cpu;
 
+  int fd = open ("/proc/self/auxv", O_RDONLY);
+
   if (fd != -1)
     {
       char buf[1024];
@@ -177,15 +222,51 @@
       if (n > 0)
 	{
 	  for (av = (ElfW(auxv_t) *) buf; av->a_type != AT_NULL; ++av)
-	    switch (av->a_type)
+	    if (av->a_type == AT_PLATFORM)
 	      {
-	      case AT_PLATFORM:
-		return (const char *) av->a_un.a_val;
-
-	      default:
+		/* Cache the result.  */
+		cpu = (const char *) av->a_un.a_val;
 		break;
 	      }
 	}
+
+      /* Verify that CPU is either a valid -mcpu=<cpu> option name, or is a
+	 valid alternative name.  If it is a valid alternative name, then use
+	 the canonical name.  */
+      if (cpu != NULL)
+	{
+	  size_t i, j;
+	  char *s;
+
+	  /* Check if AT_PLATFORM is a GCC canonical cpu name.  */
+	  for (i = 0; i < ARRAY_SIZE (rs6000_supported_cpu_names); i++)
+	    if (!strcmp (cpu, rs6000_supported_cpu_names[i]))
+	      return cpu;
+
+	  /* Check if AT_PLATFORM can be translated to a canonical cpu name.  */
+	  for (i = 0; linux_cpu_translation_table[i][0] != NULL; i++)
+	    {
+	      const char *canonical = linux_cpu_translation_table[i][0];
+	      for (j = 1; linux_cpu_translation_table[i][j] != NULL; j++)
+		if (!strcmp (cpu, linux_cpu_translation_table[i][j]))
+		  {
+		    /* Cache the result.  */
+		    cpu = canonical;
+		    return cpu;
+		  }
+	    }
+
+	  /* The kernel returned an AT_PLATFORM name we do not support.  */
+	  auto_vec <const char *> candidates;
+	  for (i = 0; i < ARRAY_SIZE (rs6000_supported_cpu_names); i++)
+	    candidates.safe_push (rs6000_supported_cpu_names[i]);
+	  candidates_list_and_hint (cpu, s, candidates);
+	  fatal_error (
+	    input_location,
+	    "Unsupported cpu name returned from kernel for -mcpu=native: %s\n"
+	    "Please use an explicit cpu name.  Valid cpu names are: %s",
+	    cpu, s);
+	}
     }
   return NULL;
 }
Index: gcc/config/rs6000/altivec.h
===================================================================
diff --git a/gcc/config/rs6000/altivec.h b/gcc/config/rs6000/altivec.h
--- a/gcc/config/rs6000/altivec.h	(revision 262353)
+++ b/gcc/config/rs6000/altivec.h	(revision 262353)
@@ -398,8 +398,8 @@
 #define vec_vctzd __builtin_vec_vctzd
 #define vec_vctzh __builtin_vec_vctzh
 #define vec_vctzw __builtin_vec_vctzw
-#define vec_vextract4b __builtin_vec_vextract4b
-#define vec_vinsert4b __builtin_vec_vinsert4b
+#define vec_extract4b __builtin_vec_extract4b
+#define vec_insert4b __builtin_vec_insert4b
 #define vec_vprtyb __builtin_vec_vprtyb
 #define vec_vprtybd __builtin_vec_vprtybd
 #define vec_vprtybw __builtin_vec_vprtybw
Index: gcc/config/arm/arm-builtins.c
===================================================================
diff --git a/gcc/config/arm/arm-builtins.c b/gcc/config/arm/arm-builtins.c
--- a/gcc/config/arm/arm-builtins.c	(revision 262353)
+++ b/gcc/config/arm/arm-builtins.c	(revision 262353)
@@ -2576,7 +2576,7 @@
 	  icode = CODE_FOR_set_fpscr;
 	  arg0 = CALL_EXPR_ARG (exp, 0);
 	  op0 = expand_normal (arg0);
-	  pat = GEN_FCN (icode) (op0);
+	  pat = GEN_FCN (icode) (force_reg (SImode, op0));
 	}
       emit_insn (pat);
       return target;
@@ -2584,7 +2584,9 @@
     case ARM_BUILTIN_CMSE_NONSECURE_CALLER:
       target = gen_reg_rtx (SImode);
       op0 = arm_return_addr (0, NULL_RTX);
-      emit_insn (gen_addsi3 (target, op0, const1_rtx));
+      emit_insn (gen_andsi3 (target, op0, const1_rtx));
+      op1 = gen_rtx_EQ (SImode, target, const0_rtx);
+      emit_insn (gen_cstoresi4 (target, op1, target, const0_rtx));
       return target;
 
     case ARM_BUILTIN_TEXTRMSB:
Index: gcc/config/arm/arm.c
===================================================================
diff --git a/gcc/config/arm/arm.c b/gcc/config/arm/arm.c
--- a/gcc/config/arm/arm.c	(revision 262353)
+++ b/gcc/config/arm/arm.c	(revision 262353)
@@ -19097,6 +19097,11 @@
 static int
 arm_compute_static_chain_stack_bytes (void)
 {
+  /* Once the value is updated from the init value of -1, do not
+     re-compute.  */
+  if (cfun->machine->static_chain_stack_bytes != -1)
+    return cfun->machine->static_chain_stack_bytes;
+
   /* See the defining assertion in arm_expand_prologue.  */
   if (IS_NESTED (arm_current_func_type ())
       && ((TARGET_APCS_FRAME && frame_pointer_needed && TARGET_ARM)
@@ -21395,6 +21400,11 @@
       emit_insn (gen_movsi (stack_pointer_rtx, r1));
     }
 
+  /* Let's compute the static_chain_stack_bytes required and store it.  Right
+     now the value must the -1 as stored by arm_init_machine_status ().  */
+  cfun->machine->static_chain_stack_bytes
+    = arm_compute_static_chain_stack_bytes ();
+
   /* The static chain register is the same as the IP register.  If it is
      clobbered when creating the frame, we need to save and restore it.  */
   clobber_ip = IS_NESTED (func_type)
@@ -24542,6 +24552,7 @@
 #if ARM_FT_UNKNOWN != 0
   machine->func_type = ARM_FT_UNKNOWN;
 #endif
+  machine->static_chain_stack_bytes = -1;
   return machine;
 }
 
@@ -26853,7 +26864,10 @@
 arm_array_mode_supported_p (machine_mode mode,
 			    unsigned HOST_WIDE_INT nelems)
 {
-  if (TARGET_NEON
+  /* We don't want to enable interleaved loads and stores for BYTES_BIG_ENDIAN
+     for now, as the lane-swapping logic needs to be extended in the expanders.
+     See PR target/82518.  */
+  if (TARGET_NEON && !BYTES_BIG_ENDIAN
       && (VALID_NEON_DREG_MODE (mode) || VALID_NEON_QREG_MODE (mode))
       && (nelems >= 2 && nelems <= 4))
     return true;
Index: gcc/config/arm/arm.h
===================================================================
diff --git a/gcc/config/arm/arm.h b/gcc/config/arm/arm.h
--- a/gcc/config/arm/arm.h	(revision 262353)
+++ b/gcc/config/arm/arm.h	(revision 262353)
@@ -1420,6 +1420,9 @@
   machine_mode thumb1_cc_mode;
   /* Set to 1 after arm_reorg has started.  */
   int after_arm_reorg;
+  /* The number of bytes used to store the static chain register on the
+     stack, above the stack frame.  */
+  int static_chain_stack_bytes;
 }
 machine_function;
 #endif
Index: gcc/config/arm/arm_cmse.h
===================================================================
diff --git a/gcc/config/arm/arm_cmse.h b/gcc/config/arm/arm_cmse.h
--- a/gcc/config/arm/arm_cmse.h	(revision 262353)
+++ b/gcc/config/arm/arm_cmse.h	(revision 262353)
@@ -35,7 +35,6 @@
 #if __ARM_FEATURE_CMSE & 1
 
 #include <stddef.h>
-#include <stdint.h>
 
 #ifdef __ARM_BIG_ENDIAN
 
@@ -174,9 +173,9 @@
 #define CMSE_MPU_NONSECURE	16
 #define CMSE_NONSECURE		18
 
-#define cmse_nsfptr_create(p) ((typeof ((p))) ((intptr_t) (p) & ~1))
+#define cmse_nsfptr_create(p) ((__typeof__ ((p))) ((__INTPTR_TYPE__) (p) & ~1))
 
-#define cmse_is_nsfptr(p) (!((intptr_t) (p) & 1))
+#define cmse_is_nsfptr(p) (!((__INTPTR_TYPE__) (p) & 1))
 
 #endif /* __ARM_FEATURE_CMSE & 2 */
 
@@ -188,7 +187,7 @@
 cmse_check_address_range (void *, size_t, int);
 
 #define cmse_check_pointed_object(p, f) \
-  ((typeof ((p))) cmse_check_address_range ((p), sizeof (*(p)), (f)))
+  ((__typeof__ ((p))) cmse_check_address_range ((p), sizeof (*(p)), (f)))
 
 #endif /* __ARM_FEATURE_CMSE & 1 */
 
Index: gcc/config/arm/neon.md
===================================================================
diff --git a/gcc/config/arm/neon.md b/gcc/config/arm/neon.md
--- a/gcc/config/arm/neon.md	(revision 262353)
+++ b/gcc/config/arm/neon.md	(revision 262353)
@@ -1143,12 +1143,12 @@
 )
 
 (define_insn_and_split "ashldi3_neon"
-  [(set (match_operand:DI 0 "s_register_operand"	    "= w, w,?&r,?r,?&r, ?w,w")
-	(ashift:DI (match_operand:DI 1 "s_register_operand" " 0w, w, 0r, 0,  r, 0w,w")
-		   (match_operand:SI 2 "general_operand"    "rUm, i,  r, i,  i,rUm,i")))
-   (clobber (match_scratch:SI 3				    "= X, X,?&r, X,  X,  X,X"))
-   (clobber (match_scratch:SI 4				    "= X, X,?&r, X,  X,  X,X"))
-   (clobber (match_scratch:DI 5				    "=&w, X,  X, X,  X, &w,X"))
+  [(set (match_operand:DI 0 "s_register_operand"	    "= w, w, &r, r, &r, ?w,?w")
+	(ashift:DI (match_operand:DI 1 "s_register_operand" " 0w, w, 0r, 0,  r, 0w, w")
+		   (match_operand:SI 2 "general_operand"    "rUm, i,  r, i,  i,rUm, i")))
+   (clobber (match_scratch:SI 3				    "= X, X, &r, X,  X,  X, X"))
+   (clobber (match_scratch:SI 4				    "= X, X, &r, X,  X,  X, X"))
+   (clobber (match_scratch:DI 5				    "=&w, X,  X, X,  X, &w, X"))
    (clobber (reg:CC_C CC_REGNUM))]
   "TARGET_NEON"
   "#"
@@ -1243,7 +1243,7 @@
 ;; ashrdi3_neon
 ;; lshrdi3_neon
 (define_insn_and_split "<shift>di3_neon"
-  [(set (match_operand:DI 0 "s_register_operand"	     "= w, w,?&r,?r,?&r,?w,?w")
+  [(set (match_operand:DI 0 "s_register_operand"	     "= w, w, &r, r, &r,?w,?w")
 	(RSHIFTS:DI (match_operand:DI 1 "s_register_operand" " 0w, w, 0r, 0,  r,0w, w")
 		    (match_operand:SI 2 "reg_or_int_operand" "  r, i,  r, i,  i, r, i")))
    (clobber (match_scratch:SI 3				     "=2r, X, &r, X,  X,2r, X"))
Index: gcc/config/arm/arm.md
===================================================================
diff --git a/gcc/config/arm/arm.md b/gcc/config/arm/arm.md
--- a/gcc/config/arm/arm.md	(revision 262353)
+++ b/gcc/config/arm/arm.md	(revision 262353)
@@ -4498,16 +4498,13 @@
    (set_attr "type" "load1")])
 
 (define_insn "unaligned_loadhis"
-  [(set (match_operand:SI 0 "s_register_operand" "=l,r")
+  [(set (match_operand:SI 0 "s_register_operand" "=r")
 	(sign_extend:SI
-	  (unspec:HI [(match_operand:HI 1 "memory_operand" "Uw,Uh")]
+	  (unspec:HI [(match_operand:HI 1 "memory_operand" "Uh")]
 		     UNSPEC_UNALIGNED_LOAD)))]
   "unaligned_access"
   "ldrsh%?\t%0, %1\t@ unaligned"
-  [(set_attr "arch" "t2,any")
-   (set_attr "length" "2,4")
-   (set_attr "predicable" "yes")
-   (set_attr "predicable_short_it" "yes,no")
+  [(set_attr "predicable" "yes")
    (set_attr "type" "load_byte")])
 
 (define_insn "unaligned_loadhiu"
Index: gcc/config/pa/predicates.md
===================================================================
diff --git a/gcc/config/pa/predicates.md b/gcc/config/pa/predicates.md
--- a/gcc/config/pa/predicates.md	(revision 262353)
+++ b/gcc/config/pa/predicates.md	(revision 262353)
@@ -277,6 +277,9 @@
     case HImode:
       return true;
 
+    case VOIDmode:
+      return false;
+
     default:
       return (INTVAL (op) % GET_MODE_SIZE (mode)) == 0;
     }
Index: gcc/config/pa/pa64-hpux.h
===================================================================
diff --git a/gcc/config/pa/pa64-hpux.h b/gcc/config/pa/pa64-hpux.h
--- a/gcc/config/pa/pa64-hpux.h	(revision 262353)
+++ b/gcc/config/pa/pa64-hpux.h	(revision 262353)
@@ -245,9 +245,19 @@
 
 /* We need to use the HP style for internal labels.  */
 #undef ASM_GENERATE_INTERNAL_LABEL
-#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)	\
-  sprintf (LABEL, "*%c$%s%04ld", (PREFIX)[0], (PREFIX) + 1, (long)(NUM))
+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)		\
+  do								\
+    {								\
+      char *__p;						\
+      (LABEL)[0] = '*';						\
+      (LABEL)[1] = (PREFIX)[0];					\
+      (LABEL)[2] = '$';						\
+      __p = stpcpy (&(LABEL)[3], &(PREFIX)[1]);			\
+      sprint_ul (__p, (unsigned long) (NUM));			\
+    }								\
+  while (0)
 
+
 #else /* USING_ELFOS_H */
 
 /* We are not using GAS.  */
Index: gcc/config/pa/pa.md
===================================================================
diff --git a/gcc/config/pa/pa.md b/gcc/config/pa/pa.md
--- a/gcc/config/pa/pa.md	(revision 262353)
+++ b/gcc/config/pa/pa.md	(revision 262353)
@@ -2536,24 +2536,40 @@
 
   xoperands[0] = operands[0];
   xoperands[1] = operands[1];
-  xoperands[2] = gen_label_rtx ();
 
-  (*targetm.asm_out.internal_label) (asm_out_file, \"L\",
-				     CODE_LABEL_NUMBER (xoperands[2]));
-  output_asm_insn (\"mfia %0\", xoperands);
+  if (GET_CODE (operands[1]) == LABEL_REF
+      && !LABEL_REF_NONLOCAL_P (operands[1]))
+    {
+      xoperands[2] = gen_label_rtx ();
+      (*targetm.asm_out.internal_label) (asm_out_file, \"L\",
+					 CODE_LABEL_NUMBER (xoperands[2]));
+      output_asm_insn (\"mfia %0\", xoperands);
 
-  /* If we're trying to load the address of a label that happens to be
-     close, then we can use a shorter sequence.  */
-  if (GET_CODE (operands[1]) == LABEL_REF
-      && !LABEL_REF_NONLOCAL_P (operands[1])
-      && INSN_ADDRESSES_SET_P ()
-      && abs (INSN_ADDRESSES (INSN_UID (XEXP (operands[1], 0)))
-	        - INSN_ADDRESSES (INSN_UID (insn))) < 8100)
-    output_asm_insn (\"ldo %1-%2(%0),%0\", xoperands);
+      /* If we're trying to load the address of a label that happens to be
+	 close, then we can use a shorter sequence.  */
+      if (INSN_ADDRESSES_SET_P ()
+	  && abs (INSN_ADDRESSES (INSN_UID (XEXP (operands[1], 0)))
+		  - INSN_ADDRESSES (INSN_UID (insn))) < 8100)
+	output_asm_insn (\"ldo %1-%2(%0),%0\", xoperands);
+      else
+	{
+	  output_asm_insn (\"addil L%%%1-%2,%0\", xoperands);
+	  output_asm_insn (\"ldo R%%%1-%2(%0),%0\", xoperands);
+	}
+    }
   else
     {
-      output_asm_insn (\"addil L%%%1-%2,%0\", xoperands);
-      output_asm_insn (\"ldo R%%%1-%2(%0),%0\", xoperands);
+      /* Load using linkage table.  */
+      if (TARGET_64BIT)
+	{
+	  output_asm_insn (\"addil LT%%%1,%%r27\", xoperands);
+	  output_asm_insn (\"ldd RT%%%1(%0),%0\", xoperands);
+	}
+      else
+	{
+	  output_asm_insn (\"addil LT%%%1,%%r19\", xoperands);
+	  output_asm_insn (\"ldw RT%%%1(%0),%0\", xoperands);
+	}
     }
   return \"\";
 }"
@@ -2570,25 +2586,33 @@
 
   xoperands[0] = operands[0];
   xoperands[1] = operands[1];
-  xoperands[2] = gen_label_rtx ();
 
-  output_asm_insn (\"bl .+8,%0\", xoperands);
-  output_asm_insn (\"depi 0,31,2,%0\", xoperands);
-  (*targetm.asm_out.internal_label) (asm_out_file, \"L\",
-				     CODE_LABEL_NUMBER (xoperands[2]));
+  if (GET_CODE (operands[1]) == LABEL_REF
+      && !LABEL_REF_NONLOCAL_P (operands[1]))
+    {
+      xoperands[2] = gen_label_rtx ();
+      output_asm_insn (\"bl .+8,%0\", xoperands);
+      output_asm_insn (\"depi 0,31,2,%0\", xoperands);
+      (*targetm.asm_out.internal_label) (asm_out_file, \"L\",
+					 CODE_LABEL_NUMBER (xoperands[2]));
 
-  /* If we're trying to load the address of a label that happens to be
-     close, then we can use a shorter sequence.  */
-  if (GET_CODE (operands[1]) == LABEL_REF
-      && !LABEL_REF_NONLOCAL_P (operands[1])
-      && INSN_ADDRESSES_SET_P ()
-      && abs (INSN_ADDRESSES (INSN_UID (XEXP (operands[1], 0)))
-	        - INSN_ADDRESSES (INSN_UID (insn))) < 8100)
-    output_asm_insn (\"ldo %1-%2(%0),%0\", xoperands);
+      /* If we're trying to load the address of a label that happens to be
+	 close, then we can use a shorter sequence.  */
+      if (INSN_ADDRESSES_SET_P ()
+	  && abs (INSN_ADDRESSES (INSN_UID (XEXP (operands[1], 0)))
+		  - INSN_ADDRESSES (INSN_UID (insn))) < 8100)
+	output_asm_insn (\"ldo %1-%2(%0),%0\", xoperands);
+      else
+	{
+	  output_asm_insn (\"addil L%%%1-%2,%0\", xoperands);
+	  output_asm_insn (\"ldo R%%%1-%2(%0),%0\", xoperands);
+	}
+    }
   else
     {
-      output_asm_insn (\"addil L%%%1-%2,%0\", xoperands);
-      output_asm_insn (\"ldo R%%%1-%2(%0),%0\", xoperands);
+      /* Load using linkage table.  */
+      output_asm_insn (\"addil LT%%%1,%%r19\", xoperands);
+      output_asm_insn (\"ldw RT%%%1(%0),%0\", xoperands);
     }
   return \"\";
 }"
Index: gcc/config/pa/pa.c
===================================================================
diff --git a/gcc/config/pa/pa.c b/gcc/config/pa/pa.c
--- a/gcc/config/pa/pa.c	(revision 262353)
+++ b/gcc/config/pa/pa.c	(revision 262353)
@@ -1725,9 +1725,7 @@
 		}
 	      else
 		emit_move_insn (scratch_reg, XEXP (op1, 0));
-	      emit_insn (gen_rtx_SET (operand0,
-				  replace_equiv_address (op1, scratch_reg)));
-	      return 1;
+	      op1 = replace_equiv_address (op1, scratch_reg);
 	    }
 	}
       else if ((!INT14_OK_STRICT && symbolic_memory_operand (op1, VOIDmode))
@@ -1737,10 +1735,10 @@
 	  /* Load memory address into SCRATCH_REG.  */
 	  scratch_reg = force_mode (word_mode, scratch_reg);
 	  emit_move_insn (scratch_reg, XEXP (op1, 0));
-	  emit_insn (gen_rtx_SET (operand0,
-				  replace_equiv_address (op1, scratch_reg)));
-	  return 1;
+	  op1 = replace_equiv_address (op1, scratch_reg);
 	}
+      emit_insn (gen_rtx_SET (operand0, op1));
+      return 1;
     }
   else if (scratch_reg
 	   && FP_REG_P (operand1)
@@ -1778,9 +1776,7 @@
 		}
 	      else
 		emit_move_insn (scratch_reg, XEXP (op0, 0));
-	      emit_insn (gen_rtx_SET (replace_equiv_address (op0, scratch_reg),
-				      operand1));
-	      return 1;
+	      op0 = replace_equiv_address (op0, scratch_reg);
 	    }
 	}
       else if ((!INT14_OK_STRICT && symbolic_memory_operand (op0, VOIDmode))
@@ -1790,10 +1786,10 @@
 	  /* Load memory address into SCRATCH_REG.  */
 	  scratch_reg = force_mode (word_mode, scratch_reg);
 	  emit_move_insn (scratch_reg, XEXP (op0, 0));
-	  emit_insn (gen_rtx_SET (replace_equiv_address (op0, scratch_reg),
-				  operand1));
-	  return 1;
+	  op0 = replace_equiv_address (op0, scratch_reg);
 	}
+      emit_insn (gen_rtx_SET (op0, operand1));
+      return 1;
     }
   /* Handle secondary reloads for loads of FP registers from constant
      expressions by forcing the constant into memory.  For the most part,
@@ -4562,13 +4558,17 @@
      lcla2 and load_offset_label_address insn patterns.  */
   rtx reg = gen_reg_rtx (SImode);
   rtx_code_label *label_rtx = gen_label_rtx ();
-  rtx mcount = gen_rtx_MEM (Pmode, gen_rtx_SYMBOL_REF (Pmode, "_mcount"));
   int reg_parm_stack_space = REG_PARM_STACK_SPACE (NULL_TREE);
-  rtx arg_bytes, begin_label_rtx;
+  rtx arg_bytes, begin_label_rtx, mcount, sym;
   rtx_insn *call_insn;
   char begin_label_name[16];
   bool use_mcount_pcrel_call;
 
+  /* Set up call destination.  */
+  sym = gen_rtx_SYMBOL_REF (Pmode, "_mcount");
+  pa_encode_label (sym);
+  mcount = gen_rtx_MEM (Pmode, sym);
+
   /* If we can reach _mcount with a pc-relative call, we can optimize
      loading the address of the current function.  This requires linker
      long branch stub support.  */
Index: gcc/config/pa/pa.h
===================================================================
diff --git a/gcc/config/pa/pa.h b/gcc/config/pa/pa.h
--- a/gcc/config/pa/pa.h	(revision 262353)
+++ b/gcc/config/pa/pa.h	(revision 262353)
@@ -1153,9 +1153,19 @@
    PREFIX is the class of label and NUM is the number within the class.
    This is suitable for output with `assemble_name'.  */
 
-#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)	\
-  sprintf (LABEL, "*%c$%s%04ld", (PREFIX)[0], (PREFIX) + 1, (long)(NUM))
+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)		\
+  do								\
+    {								\
+      char *__p;						\
+      (LABEL)[0] = '*';						\
+      (LABEL)[1] = (PREFIX)[0];					\
+      (LABEL)[2] = '$';						\
+      __p = stpcpy (&(LABEL)[3], &(PREFIX)[1]);			\
+      sprint_ul (__p, (unsigned long) (NUM));			\
+    }								\
+  while (0)
 
+
 /* Output the definition of a compiler-generated label named NAME.  */
 
 #define ASM_OUTPUT_INTERNAL_LABEL(FILE,NAME) \
@@ -1193,7 +1203,7 @@
 /* This is how to output an element of a case-vector that is absolute.  */
 
 #define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \
-  fprintf (FILE, "\t.word L$%04d\n", VALUE)
+  fprintf (FILE, "\t.word L$%d\n", VALUE)
 
 /* This is how to output an element of a case-vector that is relative. 
    Since we always place jump tables in the text section, the difference
@@ -1200,7 +1210,7 @@
    is absolute and requires no relocation.  */
 
 #define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)  \
-  fprintf (FILE, "\t.word L$%04d-L$%04d\n", VALUE, REL)
+  fprintf (FILE, "\t.word L$%d-L$%d\n", VALUE, REL)
 
 /* This is how to output an absolute case-vector.  */
 
Index: gcc/config/msp430/msp430.c
===================================================================
diff --git a/gcc/config/msp430/msp430.c b/gcc/config/msp430/msp430.c
--- a/gcc/config/msp430/msp430.c	(revision 262353)
+++ b/gcc/config/msp430/msp430.c	(revision 262353)
@@ -905,6 +905,8 @@
 {
   if (mode == PSImode && msp430x)
     return 1;
+  if (mode == CPSImode && msp430x)
+    return 2;
   return ((GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1)
 	  / UNITS_PER_WORD);
 }
@@ -927,6 +929,8 @@
 {
   if (mode == PSImode)
     return 2;
+  if (mode == CPSImode)
+    return 4;
   return msp430_hard_regno_nregs (regno, mode);
 }
 
Index: gcc/gimple-ssa-backprop.c
===================================================================
diff --git a/gcc/gimple-ssa-backprop.c b/gcc/gimple-ssa-backprop.c
--- a/gcc/gimple-ssa-backprop.c	(revision 262353)
+++ b/gcc/gimple-ssa-backprop.c	(revision 262353)
@@ -260,6 +260,11 @@
      post-order walk.  */
   auto_sbitmap m_visited_blocks;
 
+  /* A bitmap of phis that we have finished processing in the initial
+     post-order walk, excluding those from blocks mentioned in
+     M_VISITED_BLOCKS.  */
+  auto_bitmap m_visited_phis;
+
   /* A worklist of SSA names whose definitions need to be reconsidered.  */
   auto_vec <tree, 64> m_worklist;
 
@@ -500,8 +505,11 @@
     {
       if (is_gimple_debug (stmt))
 	continue;
-      if (is_a <gphi *> (stmt)
-	  && !bitmap_bit_p (m_visited_blocks, gimple_bb (stmt)->index))
+      gphi *phi = dyn_cast <gphi *> (stmt);
+      if (phi
+	  && !bitmap_bit_p (m_visited_blocks, gimple_bb (phi)->index)
+	  && !bitmap_bit_p (m_visited_phis,
+			    SSA_NAME_VERSION (gimple_phi_result (phi))))
 	{
 	  /* Skip unprocessed phis.  */
 	  if (dump_file && (dump_flags & TDF_DETAILS))
@@ -509,7 +517,7 @@
 	      fprintf (dump_file, "[BACKEDGE] ");
 	      print_generic_expr (dump_file, var, 0);
 	      fprintf (dump_file, " in ");
-	      print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);
+	      print_gimple_stmt (dump_file, phi, 0, TDF_SLIM);
 	    }
 	}
       else
@@ -633,7 +641,12 @@
     }
   for (gphi_iterator gpi = gsi_start_phis (bb); !gsi_end_p (gpi);
        gsi_next (&gpi))
-    process_var (gimple_phi_result (gpi.phi ()));
+    {
+      tree result = gimple_phi_result (gpi.phi ());
+      process_var (result);
+      bitmap_set_bit (m_visited_phis, SSA_NAME_VERSION (result));
+    }
+  bitmap_clear (m_visited_phis);
 }
 
 /* Delete the definition of VAR, which has no uses.  */
Index: gcc/dce.c
===================================================================
diff --git a/gcc/dce.c b/gcc/dce.c
--- a/gcc/dce.c	(revision 262353)
+++ b/gcc/dce.c	(revision 262353)
@@ -131,6 +131,12 @@
 	     && REGNO (pic_offset_table_rtx) >= FIRST_PSEUDO_REGISTER)
       return false;
 
+  /* Callee-save restores are needed.  */
+  if (RTX_FRAME_RELATED_P (insn)
+      && crtl->shrink_wrapped_separate
+      && find_reg_note (insn, REG_CFA_RESTORE, NULL))
+    return false;
+
   body = PATTERN (insn);
   switch (GET_CODE (body))
     {
@@ -560,9 +566,19 @@
     FOR_BB_INSNS_REVERSE_SAFE (bb, insn, next)
       if (NONDEBUG_INSN_P (insn))
 	{
+	  rtx turn_into_use = NULL_RTX;
+
 	  /* Always delete no-op moves.  */
 	  if (noop_move_p (insn))
-	    ;
+	    {
+	      if (RTX_FRAME_RELATED_P (insn))
+		turn_into_use
+		  = find_reg_note (insn, REG_CFA_RESTORE, NULL);
+	      if (turn_into_use && REG_P (XEXP (turn_into_use, 0)))
+		turn_into_use = XEXP (turn_into_use, 0);
+	      else
+		turn_into_use = NULL_RTX;
+	    }
 
 	  /* Otherwise rely only on the DCE algorithm.  */
 	  else if (marked_insn_p (insn))
@@ -589,15 +605,6 @@
 	  if (!dbg_cnt (dce))
 	    continue;
 
-	  if (crtl->shrink_wrapped_separate
-	      && find_reg_note (insn, REG_CFA_RESTORE, NULL))
-	    {
-	      if (dump_file)
-		fprintf (dump_file, "DCE: NOT deleting insn %d, it's a "
-				    "callee-save restore\n", INSN_UID (insn));
-	      continue;
-	    }
-
 	  if (dump_file)
 	    fprintf (dump_file, "DCE: Deleting insn %d\n", INSN_UID (insn));
 
@@ -611,8 +618,19 @@
 	  if (CALL_P (insn))
 	    must_clean = true;
 
-	  /* Now delete the insn.  */
-	  delete_insn_and_edges (insn);
+	  if (turn_into_use)
+	    {
+	      /* Don't remove frame related noop moves if they cary
+		 REG_CFA_RESTORE note, while we don't need to emit any code,
+		 we need it to emit the CFI restore note.  */
+	      PATTERN (insn)
+		= gen_rtx_USE (GET_MODE (turn_into_use), turn_into_use);
+	      INSN_CODE (insn) = -1;
+	      df_insn_rescan (insn);
+	    }
+	  else
+	    /* Now delete the insn.  */
+	    delete_insn_and_edges (insn);
 	}
 
   /* Deleted a pure or const call.  */
Index: gcc/params.def
===================================================================
diff --git a/gcc/params.def b/gcc/params.def
--- a/gcc/params.def	(revision 262353)
+++ b/gcc/params.def	(revision 262353)
@@ -344,11 +344,11 @@
 	"The maximum number of unswitchings in a single loop.",
 	3, 0, 0)
 
-/* The maximum number of insns in loop header duplicated by he copy loop
+/* The maximum number of insns in loop header duplicated by the copy loop
    headers pass.  */
 DEFPARAM(PARAM_MAX_LOOP_HEADER_INSNS,
 	"max-loop-header-insns",
-	"The maximum number of insns in loop header duplicated by he copy loop headers pass.",
+	"The maximum number of insns in loop header duplicated by the copy loop headers pass.",
 	20, 0, 0)
 
 /* The maximum number of iterations of a loop the brute force algorithm
Index: gcc/collect2.c
===================================================================
diff --git a/gcc/collect2.c b/gcc/collect2.c
--- a/gcc/collect2.c	(revision 262353)
+++ b/gcc/collect2.c	(revision 262353)
@@ -1,6 +1,6 @@
 /* Collect static initialization info into data structures that can be
    traversed by C++ initialization and finalization routines.
-   Copyright (C) 1992-2017 Free Software Foundation, Inc.
+   Copyright (C) 1992-2018 Free Software Foundation, Inc.
    Contributed by Chris Smith (csmith@convex.com).
    Heavily modified by Michael Meissner (meissner@cygnus.com),
    Per Bothner (bothner@cygnus.com), and John Gilmore (gnu@cygnus.com).
@@ -201,6 +201,7 @@
 bool helpflag;			/* true if --help */
 
 static int shared_obj;			/* true if -shared */
+static int static_obj;			/* true if -static */
 
 static const char *c_file;		/* <xxx>.c for constructor/destructor list.  */
 static const char *o_file;		/* <xxx>.o for constructor/destructor list.  */
@@ -255,6 +256,7 @@
 #ifdef COLLECT_EXPORT_LIST
 /* Lists to keep libraries to be scanned for global constructors/destructors.  */
 static struct head libs;                    /* list of libraries */
+static struct head static_libs;             /* list of statically linked libraries */
 static struct path_prefix cmdline_lib_dirs; /* directories specified with -L */
 static struct path_prefix libpath_lib_dirs; /* directories in LIBPATH */
 static struct path_prefix *libpaths[3] = {&cmdline_lib_dirs,
@@ -320,9 +322,7 @@
 static void scan_libraries (const char *);
 #endif
 #ifdef COLLECT_EXPORT_LIST
-#if 0
 static int is_in_list (const char *, struct id *);
-#endif
 static void write_aix_file (FILE *, struct id *);
 static char *resolve_lib_name (const char *);
 #endif
@@ -911,6 +911,9 @@
   int first_file;
   int num_c_args;
   char **old_argv;
+#ifdef COLLECT_EXPORT_LIST
+  bool is_static = false;
+#endif
   int i;
 
   for (i = 0; i < USE_LD_MAX; i++)
@@ -1241,6 +1244,8 @@
 	*c_ptr++ = xstrdup (q);
       if (strcmp (q, "-shared") == 0)
 	shared_obj = 1;
+      if (strcmp (q, "-static") == 0)
+	static_obj = 1;
       if (*q == '-' && q[1] == 'B')
 	{
 	  *c_ptr++ = xstrdup (q);
@@ -1269,6 +1274,9 @@
   /* Parse arguments.  Remember output file spec, pass the rest to ld.  */
   /* After the first file, put in the c++ rt0.  */
 
+#ifdef COLLECT_EXPORT_LIST
+  is_static = static_obj;
+#endif
   first_file = 1;
   while ((arg = *++argv) != (char *) 0)
     {
@@ -1374,6 +1382,18 @@
 #endif
               break;
 
+#ifdef COLLECT_EXPORT_LIST
+	    case 'b':
+	      if (!strcmp (arg, "-bstatic"))
+		{
+		  is_static = true;
+		}
+	      else if (!strcmp (arg, "-bdynamic") || !strcmp (arg, "-bshared"))
+		{
+		  is_static = false;
+		}
+	      break;
+#endif
 	    case 'l':
 	      if (first_file)
 		{
@@ -1390,6 +1410,8 @@
 
 		/* Saving a full library name.  */
 		add_to_list (&libs, s);
+		if (is_static)
+		    add_to_list (&static_libs, s);
 	      }
 #endif
 	      break;
@@ -1490,6 +1512,8 @@
 	    {
 	      /* Saving a full library name.  */
 	      add_to_list (&libs, arg);
+	      if (is_static)
+		add_to_list (&static_libs, arg);
 	    }
 #endif
 	}
@@ -1501,6 +1525,8 @@
     {
       fprintf (stderr, "List of libraries:\n");
       dump_list (stderr, "\t", libs.first);
+      fprintf (stderr, "List of statically linked libraries:\n");
+      dump_list (stderr, "\t", static_libs.first);
     }
 
   /* The AIX linker will discard static constructors in object files if
@@ -1525,9 +1551,11 @@
       this_filter &= ~SCAN_DWEH;
 #endif
 
+    /* Scan object files.  */
     while (export_object_lst < object)
       scan_prog_file (*export_object_lst++, PASS_OBJ, this_filter);
 
+    /* Scan libraries.  */
     for (; list; list = list->next)
       scan_prog_file (list->name, PASS_FIRST, this_filter);
 
@@ -1975,7 +2003,6 @@
 
 #ifdef COLLECT_EXPORT_LIST
 /* This function is really used only on AIX, but may be useful.  */
-#if 0
 static int
 is_in_list (const char *prefix, struct id *list)
 {
@@ -1986,7 +2013,6 @@
     }
     return 0;
 }
-#endif
 #endif /* COLLECT_EXPORT_LIST */
 
 /* Added for debugging purpose.  */
@@ -2815,7 +2841,12 @@
 			case SYM_AIXI:
 			  if (! (filter & SCAN_CTOR))
 			    break;
-			  if (is_shared && !aixlazy_flag)
+			  if (is_shared && !aixlazy_flag
+#ifdef COLLECT_EXPORT_LIST
+			      && ! static_obj
+			      && ! is_in_list (prog_name, static_libs.first)
+#endif
+			      )
 			    add_to_list (&constructors, name);
 			  break;
 
Index: gcc/ipa-icf.c
===================================================================
diff --git a/gcc/ipa-icf.c b/gcc/ipa-icf.c
--- a/gcc/ipa-icf.c	(revision 262353)
+++ b/gcc/ipa-icf.c	(revision 262353)
@@ -2132,23 +2132,6 @@
   return m_hash;
 }
 
-/* Set all points-to UIDs of aliases pointing to node N as UID.  */
-
-static void
-set_alias_uids (symtab_node *n, int uid)
-{
-  ipa_ref *ref;
-  FOR_EACH_ALIAS (n, ref)
-    {
-      if (dump_file)
-	fprintf (dump_file, "  Setting points-to UID of [%s] as %d\n",
-		 xstrdup_for_dump (ref->referring->asm_name ()), uid);
-
-      SET_DECL_PT_UID (ref->referring->decl, uid);
-      set_alias_uids (ref->referring, uid);
-    }
-}
-
 /* Merges instance with an ALIAS_ITEM, where alias, thunk or redirection can
    be applied.  */
 
@@ -2275,7 +2258,6 @@
       if (dump_file)
 	fprintf (dump_file, "Unified; Variable alias has been created.\n");
 
-      set_alias_uids (original, DECL_UID (original->decl));
       return true;
     }
 }
@@ -2295,7 +2277,7 @@
 
 sem_item_optimizer::sem_item_optimizer ()
 : worklist (0), m_classes (0), m_classes_count (0), m_cgraph_node_hooks (NULL),
-  m_varpool_node_hooks (NULL)
+  m_varpool_node_hooks (NULL), m_merged_variables ()
 {
   m_items.create (0);
   bitmap_obstack_initialize (&m_bmstack);
@@ -2320,6 +2302,7 @@
   m_items.release ();
 
   bitmap_obstack_release (&m_bmstack);
+  m_merged_variables.release ();
 }
 
 /* Write IPA ICF summary for symbols.  */
@@ -3571,13 +3554,103 @@
 	      }
 
 	    if (dbg_cnt (merged_ipa_icf))
-	      merged_p |= source->merge (alias);
+	      {
+		bool merged = source->merge (alias);
+		merged_p |= merged;
+
+		if (merged && alias->type == VAR)
+		  {
+		    symtab_pair p = symtab_pair (source->node, alias->node);
+		    m_merged_variables.safe_push (p);
+		  }
+	      }
 	  }
       }
 
+  if (!m_merged_variables.is_empty ())
+    fixup_points_to_sets ();
+
   return merged_p;
 }
 
+/* Fixup points to set PT.  */
+
+void
+sem_item_optimizer::fixup_pt_set (struct pt_solution *pt)
+{
+  if (pt->vars == NULL)
+    return;
+
+  unsigned i;
+  symtab_pair *item;
+  FOR_EACH_VEC_ELT (m_merged_variables, i, item)
+    if (bitmap_bit_p (pt->vars, DECL_UID (item->second->decl)))
+      bitmap_set_bit (pt->vars, DECL_UID (item->first->decl));
+}
+
+/* Set all points-to UIDs of aliases pointing to node N as UID.  */
+
+static void
+set_alias_uids (symtab_node *n, int uid)
+{
+  ipa_ref *ref;
+  FOR_EACH_ALIAS (n, ref)
+    {
+      if (dump_file)
+	fprintf (dump_file, "  Setting points-to UID of [%s] as %d\n",
+		 xstrdup_for_dump (ref->referring->asm_name ()), uid);
+
+      SET_DECL_PT_UID (ref->referring->decl, uid);
+      set_alias_uids (ref->referring, uid);
+    }
+}
+
+/* Fixup points to analysis info.  */
+
+void
+sem_item_optimizer::fixup_points_to_sets (void)
+{
+  /* TODO: remove in GCC 9 and trigger PTA re-creation after IPA passes.  */
+  cgraph_node *cnode;
+
+  FOR_EACH_DEFINED_FUNCTION (cnode)
+    {
+      tree name;
+      unsigned i;
+      function *fn = DECL_STRUCT_FUNCTION (cnode->decl);
+      if (!gimple_in_ssa_p (fn))
+	continue;
+
+      FOR_EACH_SSA_NAME (i, name, fn)
+	if (POINTER_TYPE_P (TREE_TYPE (name))
+	    && SSA_NAME_PTR_INFO (name))
+	  fixup_pt_set (&SSA_NAME_PTR_INFO (name)->pt);
+      fixup_pt_set (&fn->gimple_df->escaped);
+
+       /* The above get's us to 99% I guess, at least catching the
+	  address compares.  Below also gets us aliasing correct
+	  but as said we're giving leeway to the situation with
+	  readonly vars anyway, so ... */
+       basic_block bb;
+       FOR_EACH_BB_FN (bb, fn)
+	for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);
+	     gsi_next (&gsi))
+	  {
+	    gcall *call = dyn_cast<gcall *> (gsi_stmt (gsi));
+	    if (call)
+	      {
+		fixup_pt_set (gimple_call_use_set (call));
+		fixup_pt_set (gimple_call_clobber_set (call));
+	      }
+	  }
+    }
+
+  unsigned i;
+  symtab_pair *item;
+  FOR_EACH_VEC_ELT (m_merged_variables, i, item)
+    set_alias_uids (item->first, DECL_UID (item->first->decl));
+}
+
 /* Dump function prints all class members to a FILE with an INDENT.  */
 
 void
Index: gcc/ipa-icf.h
===================================================================
diff --git a/gcc/ipa-icf.h b/gcc/ipa-icf.h
--- a/gcc/ipa-icf.h	(revision 262353)
+++ b/gcc/ipa-icf.h	(revision 262353)
@@ -141,6 +141,8 @@
   unsigned int index;
 };
 
+typedef std::pair<symtab_node *, symtab_node *> symtab_pair;
+
 /* Semantic item is a base class that encapsulates all shared functionality
    for both semantic function and variable items.  */
 class sem_item
@@ -563,6 +565,12 @@
      processed.  */
   bool merge_classes (unsigned int prev_class_count);
 
+  /* Fixup points to analysis info.  */
+  void fixup_points_to_sets (void);
+
+  /* Fixup points to set PT.  */
+  void fixup_pt_set (struct pt_solution *pt);
+
   /* Adds a newly created congruence class CLS to worklist.  */
   void worklist_push (congruence_class *cls);
 
@@ -632,6 +640,10 @@
 
   /* Bitmap stack.  */
   bitmap_obstack m_bmstack;
+
+  /* Vector of merged variables.  Needed for fixup of points-to-analysis
+     info.  */
+  vec <symtab_pair> m_merged_variables;
 }; // class sem_item_optimizer
 
 } // ipa_icf namespace
Index: libgo/configure
===================================================================
diff --git a/libgo/configure b/libgo/configure
--- a/libgo/configure	(revision 262353)
+++ b/libgo/configure	(revision 262353)
@@ -14784,39 +14784,6 @@
 done
 
 
-{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether <ustat.h> can be used" >&5
-$as_echo_n "checking whether <ustat.h> can be used... " >&6; }
-if test "${libgo_cv_c_ustat_h+set}" = set; then :
-  $as_echo_n "(cached) " >&6
-else
-  CFLAGS_hold=$CFLAGS
-CFLAGS="$CFLAGS -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE $OSCFLAGS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
-/* end confdefs.h.  */
-
-#include <sys/types.h>
-#ifdef HAVE_LINUX_FILTER_H
-#include <linux/filter.h>
-#endif
-#include <ustat.h>
-
-_ACEOF
-if ac_fn_c_try_compile "$LINENO"; then :
-  libgo_cv_c_ustat_h=yes
-else
-  libgo_cv_c_ustat_h=no
-fi
-rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
-CFLAGS=$CFLAGS_hold
-fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $libgo_cv_c_ustat_h" >&5
-$as_echo "$libgo_cv_c_ustat_h" >&6; }
-if test $libgo_cv_c_ustat_h = yes; then
-
-$as_echo "#define HAVE_USTAT_H 1" >>confdefs.h
-
-fi
-
  if test "$ac_cv_header_sys_mman_h" = yes; then
   HAVE_SYS_MMAN_H_TRUE=
   HAVE_SYS_MMAN_H_FALSE='#'
Index: libgo/mksysinfo.sh
===================================================================
diff --git a/libgo/mksysinfo.sh b/libgo/mksysinfo.sh
--- a/libgo/mksysinfo.sh	(revision 262353)
+++ b/libgo/mksysinfo.sh	(revision 262353)
@@ -1107,20 +1107,6 @@
       -e 's/mem_unit/Unit/' \
     >> ${OUT}
 
-# The ustat struct.
-grep '^type _ustat ' gen-sysinfo.go | \
-    sed -e 's/_ustat/Ustat_t/' \
-      -e 's/f_tfree/Tfree/' \
-      -e 's/f_tinode/Tinoe/' \
-      -e 's/f_fname/Fname/' \
-      -e 's/f_fpack/Fpack/' \
-    >> ${OUT}
-# Force it to be defined, as on some older GNU/Linux systems the
-# header file fails when using with <linux/filter.h>.
-if ! grep 'type _ustat ' gen-sysinfo.go >/dev/null 2>&1; then
-  echo 'type Ustat_t struct { Tfree int32; Tinoe uint64; Fname [5+1]int8; Fpack [5+1]int8; }' >> ${OUT}
-fi
-
 # The utimbuf struct.
 grep '^type _utimbuf ' gen-sysinfo.go | \
     sed -e 's/_utimbuf/Utimbuf/' \
Index: libgo/config.h.in
===================================================================
diff --git a/libgo/config.h.in b/libgo/config.h.in
--- a/libgo/config.h.in	(revision 262353)
+++ b/libgo/config.h.in	(revision 262353)
@@ -340,9 +340,6 @@
 /* Define to 1 if you have the `unshare' function. */
 #undef HAVE_UNSHARE
 
-/* Define to 1 if you have the <ustat.h> header file and it works. */
-#undef HAVE_USTAT_H
-
 /* Define to 1 if you have the `utimensat' function. */
 #undef HAVE_UTIMENSAT
 
Index: libgo/configure.ac
===================================================================
diff --git a/libgo/configure.ac b/libgo/configure.ac
--- a/libgo/configure.ac	(revision 262353)
+++ b/libgo/configure.ac	(revision 262353)
@@ -572,24 +572,6 @@
 #endif
 ])
 
-AC_CACHE_CHECK([whether <ustat.h> can be used],
-[libgo_cv_c_ustat_h],
-[CFLAGS_hold=$CFLAGS
-CFLAGS="$CFLAGS -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE $OSCFLAGS"
-AC_COMPILE_IFELSE(
-[AC_LANG_SOURCE([
-#include <sys/types.h>
-#ifdef HAVE_LINUX_FILTER_H
-#include <linux/filter.h>
-#endif
-#include <ustat.h>
-])], [libgo_cv_c_ustat_h=yes], [libgo_cv_c_ustat_h=no])
-CFLAGS=$CFLAGS_hold])
-if test $libgo_cv_c_ustat_h = yes; then
-  AC_DEFINE(HAVE_USTAT_H, 1,
-    [Define to 1 if you have the <ustat.h> header file and it works.])
-fi
-
 AM_CONDITIONAL(HAVE_SYS_MMAN_H, test "$ac_cv_header_sys_mman_h" = yes)
 
 AC_CHECK_FUNCS(strerror_r strsignal wait4 mincore setenv unsetenv dl_iterate_phdr)
Index: libgo/go/os/wait_waitid.go
===================================================================
diff --git a/libgo/go/os/wait_waitid.go b/libgo/go/os/wait_waitid.go
--- a/libgo/go/os/wait_waitid.go	(revision 262353)
+++ b/libgo/go/os/wait_waitid.go	(revision 262353)
@@ -25,9 +25,12 @@
 	// We don't care about the values it returns.
 	var siginfo [16]uint64
 	psig := &siginfo[0]
-	_, _, e := syscall.Syscall6(syscall.SYS_WAITID, _P_PID, uintptr(p.Pid), uintptr(unsafe.Pointer(psig)), syscall.WEXITED|syscall.WNOWAIT, 0, 0)
+	r, _, e := syscall.Syscall6(syscall.SYS_WAITID, _P_PID, uintptr(p.Pid), uintptr(unsafe.Pointer(psig)), syscall.WEXITED|syscall.WNOWAIT, 0, 0)
 	runtime.KeepAlive(p)
-	if e != 0 {
+	// Check r as well as e because syscall.Syscall6 currently
+	// just returns errno, and the SIGCHLD signal handler may
+	// change errno. See https://gcc.gnu.org/PR86331.
+	if r != 0 && e != 0 {
 		// waitid has been available since Linux 2.6.9, but
 		// reportedly is not available in Ubuntu on Windows.
 		// See issue 16610.
Index: libgo/go/syscall/libcall_linux_ustat.go
===================================================================
diff --git a/libgo/go/syscall/libcall_linux_ustat.go b/libgo/go/syscall/libcall_linux_ustat.go
deleted file mode 10644
--- a/libgo/go/syscall/libcall_linux_ustat.go	(revision 262353)
+++ /dev/null	(nonexistent)
@@ -1,12 +0,0 @@
-// Copyright 2015 The Go Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-// GNU/Linux library ustat call.
-// This is not supported on some kernels, such as arm64.
-// +build !arm64
-
-package syscall
-
-//sys	Ustat(dev int, ubuf *Ustat_t) (err error)
-//ustat(dev _dev_t, ubuf *Ustat_t) _C_int
Index: libgo/sysinfo.c
===================================================================
diff --git a/libgo/sysinfo.c b/libgo/sysinfo.c
--- a/libgo/sysinfo.c	(revision 262353)
+++ b/libgo/sysinfo.c	(revision 262353)
@@ -135,9 +135,6 @@
 #if defined(HAVE_SYS_SYSINFO_H)
 #include <sys/sysinfo.h>
 #endif
-#if defined(HAVE_USTAT_H)
-#include <ustat.h>
-#endif
 #if defined(HAVE_UTIME_H)
 #include <utime.h>
 #endif
Index: libobjc/configure
===================================================================
diff --git a/libobjc/configure b/libobjc/configure
--- a/libobjc/configure	(revision 262353)
+++ b/libobjc/configure	(revision 262353)
@@ -11708,7 +11708,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
Index: libobjc/ChangeLog
===================================================================
diff --git a/libobjc/ChangeLog b/libobjc/ChangeLog
--- a/libobjc/ChangeLog	(revision 262353)
+++ b/libobjc/ChangeLog	(revision 262353)
@@ -1,3 +1,11 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
Index: libvtv/configure
===================================================================
diff --git a/libvtv/configure b/libvtv/configure
--- a/libvtv/configure	(revision 262353)
+++ b/libvtv/configure	(revision 262353)
@@ -15516,7 +15516,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
Index: libvtv/ChangeLog
===================================================================
diff --git a/libvtv/ChangeLog b/libvtv/ChangeLog
--- a/libvtv/ChangeLog	(revision 262353)
+++ b/libvtv/ChangeLog	(revision 262353)
@@ -1,3 +1,11 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
Index: libgfortran/configure
===================================================================
diff --git a/libgfortran/configure b/libgfortran/configure
--- a/libgfortran/configure	(revision 262353)
+++ b/libgfortran/configure	(revision 262353)
@@ -26370,7 +26370,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
Index: libgfortran/ChangeLog
===================================================================
diff --git a/libgfortran/ChangeLog b/libgfortran/ChangeLog
--- a/libgfortran/ChangeLog	(revision 262353)
+++ b/libgfortran/ChangeLog	(revision 262353)
@@ -1,3 +1,32 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
+2018-06-09  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk.
+	PR libgfortran/86070
+	* io/write_float.def (build_float_string): Initialize *len.
+
+2018-06-01  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk.
+	PR libgfortran/85840
+	* io/write.c (write_float_0, write_real, write_real_g0,
+	write_complex): Use separate local variables for the float
+	string length.
+
+2018-02-18  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from trunk
+	PR libgfortran/84412
+	* io/transfer.c (finalize_transfer): After completng an internal unit
+	I/O operation, clear internal_unit_kind.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
Index: libgfortran/io/transfer.c
===================================================================
diff --git a/libgfortran/io/transfer.c b/libgfortran/io/transfer.c
--- a/libgfortran/io/transfer.c	(revision 262353)
+++ b/libgfortran/io/transfer.c	(revision 262353)
@@ -3987,6 +3987,10 @@
 
   if (dtp->u.p.unit_is_internal)
     {
+      /* The unit structure may be reused later so clear the
+	 internal unit kind.  */
+      dtp->u.p.current_unit->internal_unit_kind = 0;
+
       fbuf_destroy (dtp->u.p.current_unit);
       if (dtp->u.p.current_unit
 	  && (dtp->u.p.current_unit->child_dtio  == 0)
Index: libgfortran/io/write.c
===================================================================
diff --git a/libgfortran/io/write.c b/libgfortran/io/write.c
--- a/libgfortran/io/write.c	(revision 262353)
+++ b/libgfortran/io/write.c	(revision 262353)
@@ -1483,7 +1483,7 @@
 
 /* Floating point helper functions.  */
 
-#define BUF_STACK_SZ 256
+#define BUF_STACK_SZ 384
 
 static int
 get_precision (st_parameter_dt *dtp, const fnode *f, const char *source, int kind)
@@ -1584,7 +1584,7 @@
   char buf_stack[BUF_STACK_SZ];
   char str_buf[BUF_STACK_SZ];
   char *buffer, *result;
-  size_t buf_size, res_len;
+  size_t buf_size, res_len, flt_str_len;
 
   /* Precision for snprintf call.  */
   int precision = get_precision (dtp, f, source, kind);
@@ -1595,8 +1595,8 @@
   buffer = select_buffer (dtp, f, precision, buf_stack, &buf_size, kind);
   
   get_float_string (dtp, f, source , kind, 0, buffer,
-                           precision, buf_size, result, &res_len);
-  write_float_string (dtp, result, res_len);
+                           precision, buf_size, result, &flt_str_len);
+  write_float_string (dtp, result, flt_str_len);
 
   if (buf_size > BUF_STACK_SZ)
     free (buffer);
@@ -1699,7 +1699,7 @@
   char buf_stack[BUF_STACK_SZ];
   char str_buf[BUF_STACK_SZ];
   char *buffer, *result;
-  size_t buf_size, res_len;
+  size_t buf_size, res_len, flt_str_len;
   int orig_scale = dtp->u.p.scale_factor;
   dtp->u.p.scale_factor = 1;
   set_fnode_default (dtp, &f, kind);
@@ -1714,8 +1714,8 @@
   buffer = select_buffer (dtp, &f, precision, buf_stack, &buf_size, kind);
   
   get_float_string (dtp, &f, source , kind, 1, buffer,
-                           precision, buf_size, result, &res_len);
-  write_float_string (dtp, result, res_len);
+                           precision, buf_size, result, &flt_str_len);
+  write_float_string (dtp, result, flt_str_len);
 
   dtp->u.p.scale_factor = orig_scale;
   if (buf_size > BUF_STACK_SZ)
@@ -1734,7 +1734,7 @@
   char buf_stack[BUF_STACK_SZ];
   char str_buf[BUF_STACK_SZ];
   char *buffer, *result;
-  size_t buf_size, res_len;
+  size_t buf_size, res_len, flt_str_len;
   int comp_d;
   set_fnode_default (dtp, &f, kind);
 
@@ -1758,8 +1758,8 @@
   buffer = select_buffer (dtp, &f, precision, buf_stack, &buf_size, kind);
 
   get_float_string (dtp, &f, source , kind, comp_d, buffer,
-                           precision, buf_size, result, &res_len);
-  write_float_string (dtp, result, res_len);
+                           precision, buf_size, result, &flt_str_len);
+  write_float_string (dtp, result, flt_str_len);
 
   dtp->u.p.g0_no_blanks = 0;
   if (buf_size > BUF_STACK_SZ)
@@ -1784,7 +1784,7 @@
   char str1_buf[BUF_STACK_SZ];
   char str2_buf[BUF_STACK_SZ];
   char *buffer, *result1, *result2;
-  size_t buf_size, res_len1, res_len2;
+  size_t buf_size, res_len1, res_len2, flt_str_len1, flt_str_len2;
   int width, lblanks, orig_scale = dtp->u.p.scale_factor;
 
   dtp->u.p.scale_factor = 1;
@@ -1807,18 +1807,18 @@
   buffer = select_buffer (dtp, &f, precision, buf_stack, &buf_size, kind);
 
   get_float_string (dtp, &f, source , kind, 0, buffer,
-                           precision, buf_size, result1, &res_len1);
+                           precision, buf_size, result1, &flt_str_len1);
   get_float_string (dtp, &f, source + size / 2 , kind, 0, buffer,
-                           precision, buf_size, result2, &res_len2);
+                           precision, buf_size, result2, &flt_str_len2);
   if (!dtp->u.p.namelist_mode)
     {
-      lblanks = width - res_len1 - res_len2 - 3;
+      lblanks = width - flt_str_len1 - flt_str_len2 - 3;
       write_x (dtp, lblanks, lblanks);
     }
   write_char (dtp, '(');
-  write_float_string (dtp, result1, res_len1);
+  write_float_string (dtp, result1, flt_str_len1);
   write_char (dtp, semi_comma);
-  write_float_string (dtp, result2, res_len2);
+  write_float_string (dtp, result2, flt_str_len2);
   write_char (dtp, ')');
 
   dtp->u.p.scale_factor = orig_scale;
Index: libgfortran/io/write_float.def
===================================================================
diff --git a/libgfortran/io/write_float.def b/libgfortran/io/write_float.def
--- a/libgfortran/io/write_float.def	(revision 262353)
+++ b/libgfortran/io/write_float.def	(revision 262353)
@@ -135,6 +135,7 @@
   w = f->u.real.w;
   d = f->u.real.d;
   p = dtp->u.p.scale_factor;
+  *len = 0;
 
   rchar = '5';
 
Index: libhsail-rt/configure
===================================================================
diff --git a/libhsail-rt/configure b/libhsail-rt/configure
--- a/libhsail-rt/configure	(revision 262353)
+++ b/libhsail-rt/configure	(revision 262353)
@@ -14414,7 +14414,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
Index: libhsail-rt/ChangeLog
===================================================================
diff --git a/libhsail-rt/ChangeLog b/libhsail-rt/ChangeLog
--- a/libhsail-rt/ChangeLog	(revision 262353)
+++ b/libhsail-rt/ChangeLog	(revision 262353)
@@ -1,3 +1,11 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
Index: libada/configure
===================================================================
diff --git a/libada/configure b/libada/configure
--- a/libada/configure	(revision 262353)
+++ b/libada/configure	(revision 262353)
@@ -3018,7 +3018,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
Index: libada/ChangeLog
===================================================================
diff --git a/libada/ChangeLog b/libada/ChangeLog
--- a/libada/ChangeLog	(revision 262353)
+++ b/libada/ChangeLog	(revision 262353)
@@ -1,3 +1,11 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
Index: libffi/configure
===================================================================
diff --git a/libffi/configure b/libffi/configure
--- a/libffi/configure	(revision 262353)
+++ b/libffi/configure	(revision 262353)
@@ -16444,7 +16444,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
Index: libffi/ChangeLog
===================================================================
diff --git a/libffi/ChangeLog b/libffi/ChangeLog
--- a/libffi/ChangeLog	(revision 262353)
+++ b/libffi/ChangeLog	(revision 262353)
@@ -1,3 +1,11 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
Index: libssp/configure
===================================================================
diff --git a/libssp/configure b/libssp/configure
--- a/libssp/configure	(revision 262353)
+++ b/libssp/configure	(revision 262353)
@@ -11082,7 +11082,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
Index: libssp/ChangeLog
===================================================================
diff --git a/libssp/ChangeLog b/libssp/ChangeLog
--- a/libssp/ChangeLog	(revision 262353)
+++ b/libssp/ChangeLog	(revision 262353)
@@ -1,3 +1,11 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
Index: libcilkrts/configure
===================================================================
diff --git a/libcilkrts/configure b/libcilkrts/configure
--- a/libcilkrts/configure	(revision 262353)
+++ b/libcilkrts/configure	(revision 262353)
@@ -15413,7 +15413,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
Index: libcilkrts/ChangeLog
===================================================================
diff --git a/libcilkrts/ChangeLog b/libcilkrts/ChangeLog
--- a/libcilkrts/ChangeLog	(revision 262353)
+++ b/libcilkrts/ChangeLog	(revision 262353)
@@ -1,3 +1,11 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
Index: libcpp/include/cpplib.h
===================================================================
diff --git a/libcpp/include/cpplib.h b/libcpp/include/cpplib.h
--- a/libcpp/include/cpplib.h	(revision 262353)
+++ b/libcpp/include/cpplib.h	(revision 262353)
@@ -702,7 +702,7 @@
   BT_COUNTER,			/* `__COUNTER__' */
   BT_HAS_ATTRIBUTE,		/* `__has_attribute__(x)' */
   BT_FIRST_USER,		/* User defined builtin macros.  */
-  BT_LAST_USER = BT_FIRST_USER + 31
+  BT_LAST_USER = BT_FIRST_USER + 63
 };
 
 #define CPP_HASHNODE(HNODE)	((cpp_hashnode *) (HNODE))
Index: libcpp/ChangeLog
===================================================================
diff --git a/libcpp/ChangeLog b/libcpp/ChangeLog
--- a/libcpp/ChangeLog	(revision 262353)
+++ b/libcpp/ChangeLog	(revision 262353)
@@ -1,3 +1,19 @@
+2018-03-03  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-01-31  Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/69869
+	* traditional.c (skip_macro_block_comment): Return bool, true if
+	the macro block comment is unterminated.
+	(copy_comment): Use return value from skip_macro_block_comment instead
+	of always false.
+
+	2018-01-27  Jakub Jelinek  <jakub@redhat.com>
+
+	* include/cpplib.h (enum cpp_builtin_type): Change BT_LAST_USER from
+	BT_FIRST_USER + 31 to BT_FIRST_USER + 63.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
Index: libcpp/traditional.c
===================================================================
diff --git a/libcpp/traditional.c b/libcpp/traditional.c
--- a/libcpp/traditional.c	(revision 262353)
+++ b/libcpp/traditional.c	(revision 262353)
@@ -119,8 +119,11 @@
 }
 
 /* Skip a C-style block comment in a macro as a result of -CC.
-   Buffer->cur points to the initial asterisk of the comment.  */
-static void
+   PFILE->buffer->cur points to the initial asterisk of the comment,
+   change it to point to after the '*' and '/' characters that terminate it.
+   Return true if the macro has not been termined, in that case set
+   PFILE->buffer->cur to the end of the buffer.  */
+static bool
 skip_macro_block_comment (cpp_reader *pfile)
 {
   const uchar *cur = pfile->buffer->cur;
@@ -131,10 +134,15 @@
 
   /* People like decorating comments with '*', so check for '/'
      instead for efficiency.  */
-  while(! (*cur++ == '/' && cur[-2] == '*') )
-    ;
+  while (! (*cur++ == '/' && cur[-2] == '*'))
+    if (cur[-1] == '\n')
+      {
+	pfile->buffer->cur = cur - 1;
+	return true;
+      }
 
   pfile->buffer->cur = cur;
+  return false;
 }
 
 /* CUR points to the asterisk introducing a comment in the current
@@ -158,7 +166,7 @@
 
   buffer->cur = cur;
   if (pfile->context->prev)
-    unterminated = false, skip_macro_block_comment (pfile);
+    unterminated = skip_macro_block_comment (pfile);
   else
     unterminated = _cpp_skip_block_comment (pfile);
     
Index: libcpp/lex.c
===================================================================
diff --git a/libcpp/lex.c b/libcpp/lex.c
--- a/libcpp/lex.c	(revision 262353)
+++ b/libcpp/lex.c	(revision 262353)
@@ -568,7 +568,7 @@
     {
       vc m_nl, m_cr, m_bs, m_qm;
 
-      data = *((const vc *)s);
+      data = __builtin_vec_vsx_ld (0, s);
       s += 16;
 
       m_nl = (vc) __builtin_vec_cmpeq(data, repl_nl);
Index: fixincludes/configure
===================================================================
diff --git a/fixincludes/configure b/fixincludes/configure
--- a/fixincludes/configure	(revision 262353)
+++ b/fixincludes/configure	(revision 262353)
@@ -5401,7 +5401,7 @@
 # Check whether --with-gcc-major-version-only was given.
 if test "${with_gcc_major_version_only+set}" = set; then :
   withval=$with_gcc_major_version_only; if test x$with_gcc_major_version_only = xyes ; then
-        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*\$\$/\1/'"
+        get_gcc_base_ver="sed -e 's/^\([0-9]*\).*/\1/'"
       fi
 
 fi
Index: fixincludes/ChangeLog
===================================================================
diff --git a/fixincludes/ChangeLog b/fixincludes/ChangeLog
--- a/fixincludes/ChangeLog	(revision 262353)
+++ b/fixincludes/ChangeLog	(revision 262353)
@@ -1,3 +1,11 @@
+2018-06-22  Jakub Jelinek  <jakub@redhat.com>
+
+	Backported from mainline
+	2018-04-18  David Malcolm  <dmalcolm@redhat.com>
+
+	PR jit/85384
+	* configure: Regenerate.
+
 2018-01-25  Release Manager
 
 	* GCC 7.3.0 released.
Index: .
===================================================================
diff --git a/tags b/tags
--- a/tags	(revision 262353)
+++ b/tags	(revision 262353)

Property changes on: tags
___________________________________________________________________
Modified: svn:mergeinfo
## -0,0 +0,1 ##
   Merged /trunk:r262104
